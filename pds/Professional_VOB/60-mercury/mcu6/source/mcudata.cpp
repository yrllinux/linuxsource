/*****************************************************************************
   模块名      : mcu
   文件名      : mcudata.cpp
   相关文件    : mcudata.h
   文件实现功能: MCU数据模块应用类普通函数定义
   作者        : 李屹
   版本        : V0.9  Copyright(C) 2001-2002 KDC, All rights reserved.
-----------------------------------------------------------------------------
   修改记录:
   日  期      版本        修改人      修改内容
   2003/05/29  0.9         李屹        创建
   2005/02/19  3.6         万春雷      级联修改、与3.5版本合并
******************************************************************************/

#include "evmcumcs.h"
#include "evmcumt.h"
#include "evmcueqp.h"
#include "evmcu.h"
#include "evmp.h"
#include "mcuvc.h"
//#include "mcudata.h"
//#include "mcuerrcode.h"
//#include "mcuutility.h"
#include "mtadpssn.h"
#include "mcsssn.h"
#include "vcsssn.h"



//[liu lijiu][20100820]用户数据USBKEY授权校验功能仅限于8KE版本
#if defined(_8KE_) || defined(_8KH_)
#include "readlicense.h"
#include "usbkeyconst.h"
#include "licensekeyconst.h"
#endif//_8KE_ ends
#if defined(_8KI_)
#include "elitee.h"
#include "epc_elecrypt.h"
#endif
//[liu lijiu][20100820]end

// MPC2 支持
#ifdef _LINUX_
    #ifdef _LINUX12_
        #include "brdwrapper.h"
        #include "brdwrapperdef.h"
        #include "nipwrapper.h"
        #include "nipwrapperdef.h"
    #else
        #include "boardwrapper.h"
    #endif
#else
    #include "brddrvlib.h"
#endif

#define CHECK_CONFIDX(byConfIdx)                                    \
    if(byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX)          \
    {                                                               \
        StaticLog( "[CheckConfIdx] invalid confidx :%d\n", byConfIdx); \
        return FALSE;                                               \
    }

u32  g_dwVCUInterval;

// [7/22/2011 liuxu]
#define  PTR_CHECK( ptr, ret) if(!ptr) return ret


#define FREE_TABLE_MEM(pp, v)									\
do{																\
		if(NULL == pp) break;									\
		for (u32 nLoop = 0; nLoop < (u32)v; nLoop++ )			\
		{														\
			if( NULL != pp[nLoop] )								\
				delete []pp[nLoop];								\
				pp[nLoop] = NULL;								\
		}														\
		delete []pp;											\
		pp = NULL;												\
} while (0)

/*--------------------------------------------------------------------------*/
/*                                CMcuVcData                                */
/*--------------------------------------------------------------------------*/
/*lint -save -e1565*/
CMcuVcData::CMcuVcData() : m_tMcuDebugVal(),
						m_cUsrGrpInfo(),
						m_cVCSUsrGrpInfo(),
						m_cVCSUsrTaskInfo(),
						m_cMultiSpyMgr(),
						m_cBasChnListMgr()
{
	//清零
	ClearVcData();
    g_dwVCUInterval = 3*OspClkRateGet();    //3秒的tick数
	
	// 初始化m_atConfMapData
	for ( s32 nLoop = 0; nLoop < (MAXNUM_MCU_CONF + MAXNUM_MCU_TEMPLATE); nLoop++)
	{
		m_atConfMapData[nLoop].Clear();
	}

}

CMcuVcData::~CMcuVcData()
{
    MCU_SAFE_DELETE(m_ptTemplateInfo);
}

void CMcuVcData::ClearVcData()
{
	CPeriEqpChnnlMModeMgr::Clear();
	memset( m_apConfInst, 0, sizeof( m_apConfInst ) );
	memset( m_atPeriEqpTable, 0, sizeof( m_atPeriEqpTable ) );
	memset( m_atMcTable, 0, sizeof( m_atMcTable ) );
	memset( m_atMonitorTable, 0, sizeof(m_atMonitorTable));
	memset( m_atMpData, 0, sizeof(m_atMpData) );
	memset( m_atMtAdpData, 0, sizeof(m_atMtAdpData) );
	memset( m_atRecvMtPort, 0, sizeof(m_atRecvMtPort) );
	memset( m_atMulticastPort, 0, sizeof(m_atMulticastPort) );
	memset( m_abyConfStoreInfo, 0, sizeof(m_abyConfStoreInfo) );
	memset( m_abyConfRegState, 0, sizeof(m_abyConfRegState) );
	memset( (void*)&m_tGKID, 0, sizeof(m_tGKID) );
	memset( (void*)&m_tEPID, 0, sizeof(m_tEPID) );
	// memset( (void*)&m_tMcuDebugVal, 0, sizeof(m_tMcuDebugVal) ); // guzh 有构造函数,no memeset
	memset( m_atMtCallInterface, 0, sizeof(m_atMtCallInterface) );
	memset( m_atPeriDcsTable, 0, sizeof(m_atPeriDcsTable) );
	
	m_dwMakeConfIdTimes = 0;
	m_byRegGKDriId  = 0;
    m_byChargeRegOK = 0;
	m_dwMtCallInterfaceNum = 0;

	m_ptTemplateInfo = NULL;

	m_cVmpMemVidLmt.Init(); //VMP 各通道成员能力限制 
 	memset( m_adwEqpIp, 0, sizeof(m_adwEqpIp) );
	memset( m_abyTempEditer, 0, sizeof(m_abyTempEditer) );

	m_dwMcuStartTick = 0;

	//[liu lijiu][2010/10/28]8ke使用
	m_bUSBKEYFlag = FALSE;
	m_wUSBKEYErrorCode = 0;

	m_bRRQDriTransferred = FALSE;

	for(u8 byIdx = 0; byIdx < MAXNUM_PERIEQP; byIdx++ )
	{
		m_tNplusVmpModule[byIdx].Clear();
	}

	return;
}
/*lint -restore*/

u32 CMcuVcData::GetMcuStartTick(void)
{
    return m_dwMcuStartTick;
}

void CMcuVcData::SetMcuStartTick( u32 dwMcuStartTick )
{
    m_dwMcuStartTick = dwMcuStartTick;
}

/*====================================================================
    函数名      ：IsPeriEqpConnected
    功能        ：获取外设连接状态
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byEqpId, 外设 ID
    返回值说明  ：TRUE: connected FALSE: unnnected
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/04/06    1.0         杨昀         创建
====================================================================*/
BOOL32 CMcuVcData::IsPeriEqpConnected( u8 byEqpId )
{
	if( byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP )
	{
		return FALSE;
	}

	return( m_atPeriEqpTable[byEqpId - 1].m_tPeriEqpStatus.m_byOnline );
}

/*====================================================================
    函数名      ：GetPeriEqpLogicChnnl
    功能        ：获取外设的逻辑通道配置
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byEqpId, 外设 ID
				  u8 byMediaType, 媒体类型
				  TLogicalChannel * ptChnnl, 返回的逻辑通道配置
				  u8 * pbyChnnlNum, 返回的MCU至外设通道数
				  BOOL32 bForwardChnnl, 流向
    返回值说明  ：TRUE: success	FALSE: fail
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/04/06    1.0         杨昀         创建
====================================================================*/
BOOL32 CMcuVcData::GetPeriEqpLogicChnnl( u8 byEqpId, u8 byMediaType, u8 * pbyChnnlNum, TLogicalChannel * ptStartChnnl, BOOL32 bForwardChnnl )
{
	if( 0 == byEqpId || byEqpId > MAXNUM_MCU_PERIEQP || NULL == pbyChnnlNum || NULL == ptStartChnnl )
	{
		return FALSE;
	}

	switch( byMediaType )
	{
	case MODE_VIDEO:
		if( bForwardChnnl )
		{
			*pbyChnnlNum = m_atPeriEqpTable[byEqpId - 1].m_byFwdChannelNum;
			*ptStartChnnl = m_atPeriEqpTable[byEqpId - 1].m_tFwdVideoChannel;
		}
		else
		{
			*pbyChnnlNum = m_atPeriEqpTable[byEqpId - 1].m_byRvsChannelNum;
			*ptStartChnnl = m_atPeriEqpTable[byEqpId - 1].m_tRvsVideoChannel;
		}
		break;
	case MODE_AUDIO:
		if( bForwardChnnl )		
		{
			*pbyChnnlNum = m_atPeriEqpTable[byEqpId - 1].m_byFwdChannelNum;
			*ptStartChnnl = m_atPeriEqpTable[byEqpId - 1].m_tFwdAudioChannel;
		}
		else
		{
			*pbyChnnlNum = m_atPeriEqpTable[byEqpId - 1].m_byRvsChannelNum;
			*ptStartChnnl = m_atPeriEqpTable[byEqpId - 1].m_tRvsAudioChannel;
		}
		break;
	default:
		LogPrint(LOG_LVL_ERROR, MID_MCU_EQP, "Exception - CMcuVcData::GetPeriEqpLogicChnnl(): wrong Mode %u!\n", byMediaType );
		return( FALSE );
	}

	return( TRUE );
}

/*====================================================================
    函数名      ：SetEqpRtcpDstAddr
    功能        ：设置外设的通道目的Rtcp地址
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byEqpId, 外设 ID
				  u8 byChnnl, 通道号
				  u32 dwDstIp, 目的Ip
				  u16 wDstPort, 目的端口
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/10/19    3.0         胡昌威         创建
====================================================================*/
void CMcuVcData::SetEqpRtcpDstAddr(u8 byEqpId, u8 byChnnl, u32 dwDstIp, u16 wDstPort, u8 byMode)
{
    if (byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP || byChnnl >= MAXNUM_VMP_MEMBER)
    {
        return;
    }

    if (MODE_VIDEO == byMode)
    {
        m_atPeriEqpTable[byEqpId - 1].m_tVideoRtcpDstAddr[byChnnl].SetIpAddr(dwDstIp);
        m_atPeriEqpTable[byEqpId - 1].m_tVideoRtcpDstAddr[byChnnl].SetPort(wDstPort);
    }
    else if (MODE_AUDIO == byMode)
    {
        m_atPeriEqpTable[byEqpId - 1].m_tAudioRtcpDstAddr[byChnnl].SetIpAddr(dwDstIp);
        m_atPeriEqpTable[byEqpId - 1].m_tAudioRtcpDstAddr[byChnnl].SetPort(wDstPort);
    }
}

/*====================================================================
    函数名      ：GetEqpRtcpDstAddr
    功能        ：得到外设的通道目的Rtcp地址
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byEqpId, 外设 ID
				  u8 byChnnl, 通道号
				  u32 dwDstIp, 目的Ip
				  u16 wDstPort, 目的端口
    返回值说明  ：TRUE: success	FALSE: fail
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/10/19    3.0         胡昌威         创建
====================================================================*/
BOOL32 CMcuVcData::GetEqpRtcpDstAddr(u8 byEqpId, u8 byChnnl, u32 &dwDstIp, u16 &wDstPort, u8 byMode)
{
    if (byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP || byChnnl >= MAXNUM_VMP_MEMBER)
    {
        return FALSE;
    }

    if (MODE_VIDEO == byMode)
    {
        dwDstIp = m_atPeriEqpTable[byEqpId - 1].m_tVideoRtcpDstAddr[byChnnl].GetIpAddr();
        wDstPort = m_atPeriEqpTable[byEqpId - 1].m_tVideoRtcpDstAddr[byChnnl].GetPort();
    }
    else if (MODE_AUDIO == byMode)
    {
        dwDstIp = m_atPeriEqpTable[byEqpId - 1].m_tAudioRtcpDstAddr[byChnnl].GetIpAddr();
        wDstPort = m_atPeriEqpTable[byEqpId - 1].m_tAudioRtcpDstAddr[byChnnl].GetPort();
    }

    return ( dwDstIp == 0 || wDstPort == 0 ) ? FALSE : TRUE;
}

/*====================================================================
函数名      ：GetEqpIpAddr
功能        ：获得外设IP地址，已其接收数据IP作为其IP
算法实现    ：
引用全局变量：
输入参数说明：u8 byEqpId, 外设 ID				  
返回值说明  ：无
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
====================================================================*/
u32 CMcuVcData::GetEqpIpAddr(u8 byEqpId) const
{
    if (byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP)
    {
        return 0;
    }
	
    return m_atPeriEqpTable[byEqpId - 1].m_tFwdVideoChannel.m_tRcvMediaChannel.GetIpAddr();  
}

/*====================================================================
    函数名      ：GetPeriEqpStatus
    功能        ：获得外设状态
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byEqpId, 外设 ID
				  TPeriEqpStatus * ptStatus, 返回的外设状态
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/10    1.0         杨昀         创建
====================================================================*/
BOOL32 CMcuVcData::GetPeriEqpStatus( u8 byEqpId, TPeriEqpStatus * ptStatus )
{
	if( byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP || NULL == ptStatus )
	{
		return( FALSE );
	}

	*ptStatus = m_atPeriEqpTable[byEqpId - 1].m_tPeriEqpStatus;

	return( TRUE );
}
/*====================================================================
    函数名      ：SendPeriEqpStatusToMcs
    功能        ：发送指定外设状态给所有界面
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byEqpId:外设 ID
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    09/06/05                付秀华         创建
====================================================================*/
void CMcuVcData::SendPeriEqpStatusToMcs(u8 byEqpId)
{
	TPeriEqpStatus tEqpStatus;
	if (GetPeriEqpStatus(byEqpId, &tEqpStatus))
	{
		CServMsg cServMsg;
		cServMsg.SetMsgBody((u8 *)&tEqpStatus, sizeof(tEqpStatus));
		CMcsSsn::BroadcastToAllMcsSsn(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, 
			                          cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
	}

}
/*====================================================================
    函数名      ：IsMcConnected
    功能        ：获取MC连接状态
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wMcInstId, MC对应实例
    返回值说明  ：TRUE: connected FALSE: unnnected
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/04/06    1.0         杨昀         创建
====================================================================*/
BOOL32 CMcuVcData::IsMcConnected( u16 wMcInstId )
{
	if( 0 == wMcInstId || wMcInstId > (MAXNUM_MCU_MC + MAXNUM_MCU_VC) )
	{
		return FALSE;
	}

	return m_atMcTable[wMcInstId-1].m_bConnected;
}

/*====================================================================
    函数名      ：GetMcLogicChnnl
    功能        ：获取MC的逻辑通道配置
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wMcInstId, MC ID
				  u8 byMediaType, 媒体类型
				  TLogicalChannel * ptStartChnnl, 返回的逻辑通道配置
				   u8 * pbyChnnlNum, 返回的MCU至会控通道数
    返回值说明  ：TRUE: success FALSE: fail
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/04/06    1.0         杨昀         创建
====================================================================*/
BOOL32 CMcuVcData::GetMcLogicChnnl( u16 wMcInstId, u8 byMediaType, u8 * pbyChnnlNum, TLogicalChannel * ptStartChnnl )
{
	if( wMcInstId == 0 || wMcInstId > (MAXNUM_MCU_MC + MAXNUM_MCU_VC) || NULL == ptStartChnnl || NULL == pbyChnnlNum )
	{
		return FALSE;
	}

	*pbyChnnlNum = m_atMcTable[ wMcInstId-1 ].m_byFwdChannelNum;
	
	switch( byMediaType )
	{
	case MODE_VIDEO:
		*ptStartChnnl = m_atMcTable[ wMcInstId-1 ].m_tFwdVideoChannel;
		break;
	case MODE_AUDIO:
		*ptStartChnnl = m_atMcTable[ wMcInstId-1 ].m_tFwdAudioChannel;
		break;
	case MODE_SECVIDEO:
		*ptStartChnnl = m_atMcTable[ wMcInstId-1 ].m_tFwdDualChannel;
		break;
	default:
		LogPrint(LOG_LVL_ERROR, MID_MCU_MCS, "Exception - CMcuVcData::GetMcLogicChnnl(): wrong Mode %u!\n", byMediaType );
		return FALSE;
	}

	return TRUE;
}

/*====================================================================
    函数名      ：GetMcSrc
    功能        ：获取MC的发送/接收视频或音频源
    算法实现    ：
    引用全局变量：
    输入参数说明：uu16 wMcInstId, MC号
				  TMt * ptSrc, 返回的终端源
				  u8 byChnnlNo, 通道号
				  u8 byMode, 流模式MODE_VIDEO/MODE_AUDIO
    返回值说明  ：TRUE: success FALSE: fail
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/04/06    1.0         杨昀         创建
====================================================================*/
BOOL32 CMcuVcData::GetMcSrc( u16 wMcInstId, TMt * ptSrc, u8 byChnnlNo, u8 byMode )
{
	if( wMcInstId == 0 || wMcInstId > (MAXNUM_MCU_MC + MAXNUM_MCU_VC) || NULL == ptSrc || byChnnlNo >= MAXNUM_MC_CHANNL )
	{
		return FALSE;
	}

	switch( byMode )
	{
	case MODE_VIDEO:
		*ptSrc = m_atMcTable[ wMcInstId-1 ].m_atVidSrc[byChnnlNo];
		break;
	case MODE_AUDIO:
		*ptSrc = m_atMcTable[ wMcInstId-1 ].m_atAudSrc[byChnnlNo];
		break;
	case MODE_SECVIDEO:
		*ptSrc = m_atMcTable[ wMcInstId-1 ].m_atSecVidSrc[byChnnlNo];
		break;
	default:
		LogPrint(LOG_LVL_ERROR, MID_MCU_MCS, "Exception - CMcuVcData::GetMcSrc(): wrong Mode %u!\n", byMode );
		return FALSE;	
	}

	if (ptSrc->IsNull())
	{
		return FALSE;
	}

	return TRUE;
}

/*====================================================================
    函数名      ：GetPeriEqpSrc
    功能        ：获取外设的接收视频或音频源
    算法实现    ：
    引用全局变量：
    输入参数说明：u8  periEqp, 外设号
				  TMt * ptSrc, 返回的终端源
				  u8 byChnnlNo, 通道号
				  u8 byMode, 流模式MODE_VIDEO/MODE_AUDIO
    返回值说明  ：TRUE: success FALSE: fail
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/030   1.0         JQL         创建
====================================================================*/
BOOL32 CMcuVcData::GetPeriEqpSrc(u8 byEqpId, TMt * ptSrc, u8 byChnnlNo, u8 byMode )
{
	
	if( byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP 
		|| NULL == ptSrc || byChnnlNo >= MAXNUM_PERIEQP_CHNNL )
	{
		return FALSE;
	}

	switch( byMode )
	{
	case MODE_VIDEO:
	case MODE_SECVIDEO:
		*ptSrc = m_atPeriEqpTable[ byEqpId - 1 ].m_atVidSrc[byChnnlNo];
		break;
	case MODE_AUDIO:
		*ptSrc = m_atPeriEqpTable[ byEqpId - 1 ].m_atAudSrc[byChnnlNo];
		break;
	default:
		LogPrint(LOG_LVL_ERROR, MID_MCU_EQP, "Exception - CMcuVcData::GetMcSrc(): wrong Mode %u!\n", byMode );
		return FALSE;	
	}
	return TRUE;
}

/*====================================================================
    函数名      ：MsgPassCheck
    功能        ：检查消息是否可以发给会议
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wEvent, 事件号
				  u8 * const pbyMsg, 发送的消息指针
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/11/20    3.0         胡昌威         创建
====================================================================*/
BOOL32 CMcuVcData::MsgPassCheck(u16 wEvent, u8 * const pbyMsg, u16 wLen )
{
	BOOL32 bReturn = TRUE;
	CServMsg cServMsg( pbyMsg, wLen );
	u8 byConfIdx = 0, bySrcSsnId = 0;
	u8	byConfProtectMode = CONF_LOCKMODE_NONE;
	CMcuVcInst* pInst = NULL;
	CConfId cConfId;
	TConfProtectInfo tProtectInfo;
    TConfMapData tMapData;
 
    switch(wEvent)
	{
	//任何情况下都可通过的消息
    case MCS_MCU_GETMCUSTATUS_CMD:
	case MCS_MCU_GETMCUSTATUS_REQ:	        //查询MCU状态请求 
	case MCS_MCU_LISTALLCONF_REQ:	        //列出该MCU上所有会议信息
	case MCS_MCU_STOPSWITCHMC_REQ:	        //会议控制台停止播放请求
	case MCS_MCU_STOP_SWITCH_TW_REQ:	    //会议控制台向外设停止播放请求
	case MCS_MCU_GETMCUPERIEQPSTATUS_REQ:	//查询MCU外设状态
	case MCS_MCU_GETRECSTATUS_REQ:	        //查询录像机状态请求
	case MCS_MCU_GETMIXERSTATUS_REQ:	    //查询混音器状态请求
	case MCS_MCU_CONNECT_REQ:		        //控制台通知MCU请求准入
	case MCS_MCU_CURRTIME_REQ :		        //控制台查询mcu当前时间
	case MCS_MCU_CREATECONF_REQ:            //会议控制台在MCU上创建一个会议 
	case MCS_MCU_ENTERCONFPWD_ACK:          //会议控制台回应MCU的密码请求   
	case MCS_MCU_ENTERCONFPWD_NACK:         //会议控制台拒绝MCU的密码请求
	case MCU_MCSCONNECTED_NOTIF:            //会议控制台建链
	case MCU_MCSDISCONNECTED_NOTIF:         //会议控制台断链
    case MCU_CREATECONF_FROMFILE:           //从文件创建会议
	case MCS_MCU_GETMTLIST_REQ:             //会议控制台发给MCU的得到终端列表请求
	case MCS_MCU_REFRESHMCU_CMD:            //会议控制台发给MCU的刷新其他MCU的命令
	case MCS_MCU_GETCONFINFO_REQ:           //会议控制台向MCU查询会议信息  
    case MCS_MCU_GETMAUSTATUS_REQ:          //会议控制台向MCU查询MAU信息  
	case MCS_MCU_GETPOLLPARAM_REQ:          //会议控制台向MCU查询会议轮询参数
    case MCS_MCU_GETTWPOLLPARAM_REQ:
	case MCS_MCU_GETVMPPOLLPARAM_REQ:       //会议控制台向MCU查询Vmp单通道轮询参数
	//case MCS_MCU_GETDISCUSSPARAM_REQ:     //查询讨论参数请求
    case MCS_MCU_GETMIXPARAM_REQ:           //查询讨论参数请求
	case MCS_MCU_GETVMPPARAM_REQ:			//查询视频复合成员请求
	case MCS_MCU_GETCONFSTATUS_REQ:         //会议控制台向MCU查询会议状态
	case MCS_MCU_GETMTSTATUS_REQ:           //会控向MCU查询终端状态
	case MCS_MCU_GETMTVIDEOALIAS_REQ:       //会控获取终端视频源别名信息
	case MCS_MCU_GETALLMTSTATUS_REQ:		//会控向MCU查询所有终端状态
	case MCS_MCU_GETMTALIAS_REQ:            //会控向MCU查询终端别名
	case MCS_MCU_GETALLMTALIAS_REQ:			//会控向MCU查询所有终端别名
	case MCS_MCU_GETLOCKINFO_REQ:           //得到会议独享消息
	case MCS_MCU_MCUMEDIASRC_REQ:
	case MCS_MCU_GETMCULOCKSTATUS_REQ:        
    case MCS_MCU_SETCHAIRMODE_CMD:          //会议控制台设置会议的主席方式  // guzh [7/25/2006] 即使锁定或者需要密码等也允许直接操作，因为这只是一个内部操作，非用户操作
	case MCS_MCU_SAVECONFTOTEMPLATE_REQ:	//会议控制台请求保存当前会议为会议模板(预留)  FIXME: 权限保护未考虑, zgc, 2007/04/20
    case MCS_MCU_GETMTEXTINFO_REQ:          //获取终端的二次扩展信息
	case MCS_MCU_STOP_SWITCH_HDU_REQ:       //停止HDU交换   4.6.1 新加版本  jlb
	case MCS_MCU_VMPPRISEIZE_ACK:			// xliang [12/12/2008] 
	case MCS_MCU_VMPPRISEIZE_NACK:
		break;
		
    //需要判断的消息
	case MCS_MCU_SENDRUNMSG_CMD:            //会议控制台命令MCU向终端发送短消息，终端号为0表示发给所有终端
	case MCS_MCU_STARTPOLL_CMD:             //会议控制台命令该会议开始轮询广播
	case MCS_MCU_STOPPOLL_CMD:              //会议控制台命令该会议停止轮询广播  
	case MCS_MCU_PAUSEPOLL_CMD:             //会议控制台命令该会议暂停轮询广播   
	case MCS_MCU_RESUMEPOLL_CMD:            //会议控制台命令该会议继续轮询广播
    case MCS_MCU_CHANGEPOLLPARAM_CMD:       //会议控制台命令该会议更新轮询列表
	case MCS_MCU_SPECPOLLPOS_REQ:			//会议控制台指定轮询位置
    case MCS_MCU_STARTTWPOLL_CMD:           //开始电视墙轮询
    case MCS_MCU_STOPTWPOLL_CMD:
    case MCS_MCU_PAUSETWPOLL_CMD:
    case MCS_MCU_RESUMETWPOLL_CMD:

    case MCS_MCU_STARTHDUPOLL_CMD:           //开始hdu轮询
    case MCS_MCU_STOPHDUPOLL_CMD:
    case MCS_MCU_PAUSEHDUPOLL_CMD:
    case MCS_MCU_RESUMEHDUPOLL_CMD:
		
    case MCS_MCU_STARTVMPPOLL_CMD:           //vmp单通道轮询
    case MCS_MCU_STOPVMPPOLL_CMD:
    case MCS_MCU_PAUSEVMPPOLL_CMD:
    case MCS_MCU_RESUMEVMPPOLL_CMD:

	case MCS_MCU_SETMTBITRATE_CMD:          //会议控制台命令MCU调节终端码率
	case MCS_MCU_MTCAMERA_CTRL_CMD:         //会议控制台命令终端摄像机镜头运动
	case MCS_MCU_MTCAMERA_CTRL_STOP:        //会议控制台命令终端摄像机镜头停止运动
	case MCS_MCU_MTCAMERA_RCENABLE_CMD:     //会议控制台命令终端摄像机遥控使能	
	case MCS_MCU_MTCAMERA_SAVETOPOS_CMD:    //会议控制台命令终端摄像机将当前位置信息存入指定位置	
	case MCS_MCU_MTCAMERA_MOVETOPOS_CMD:    //会议控制台命令终端摄像机调整到指定位置
	
	case MCS_MCU_MTSEESPEAKER_CMD:          //强制广播发言人
    case MCS_MCU_ADDMIXMEMBER_CMD:          //改变混音成员
    case MCS_MCU_REMOVEMIXMEMBER_CMD:
	case MCS_MCU_SETMTVOLUME_CMD:			//会控实时设置终端音量,zgc,2006-12-26
	case MCS_MCU_REPLACEMIXMEMBER_CMD:      //替换混音成员
	case MCS_MCU_CHANGEMTSECVIDSEND_CMD:
        cConfId = cServMsg.GetConfId();
        byConfIdx = GetConfIdx( cConfId );
        if(byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX)
        {
            LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[MsgPassCheck] invalid cConfId :");
            cConfId.Print();
            return FALSE;
        }	    
        tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
        if(!tMapData.IsValidConf()) 
        {
            LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[MsgPassCheck] invalid instance id :%d\n", tMapData.GetInsId());
            return FALSE;
        }
        GetConfProtectInfo( byConfIdx, &tProtectInfo );
        bySrcSsnId = cServMsg.GetSrcSsnId();
		pInst = m_apConfInst[tMapData.GetInsId()-1];
		if (pInst == NULL)
		{
			LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS,"[MsgPassCheck] m_apConfInst[tMapData.GetInsId()-1] is NULL,Instid:%d\n",tMapData.GetInsId());
			return FALSE;
		}
		byConfProtectMode = pInst->m_tConf.m_tStatus.GetProtectMode();
		if( ( byConfProtectMode == CONF_LOCKMODE_LOCK && 
              (tProtectInfo.IsLockByMcs() && tProtectInfo.GetLockedMcSsnId() != bySrcSsnId || tProtectInfo.IsLockByMcu()) 
             ) || 
            ( byConfProtectMode == CONF_LOCKMODE_NEEDPWD && 
              !tProtectInfo.IsMcsPwdPassed(bySrcSsnId) 
            ) 
          )
		{         
            bReturn = FALSE;
			if(byConfProtectMode == CONF_LOCKMODE_NEEDPWD)
			{
				//问密码
				cServMsg.SetMsgBody();
                CMcsSsn::SendMsgToMcsSsn( bySrcSsnId, MCU_MCS_ENTERCONFPWD_REQ, 
					                          cServMsg.GetServMsg(), cServMsg.GetServMsgLen() );
			}
			else
			{
                if ( tProtectInfo.IsLockByMcu() )				
                {
                    u8 byLockedMcuId = tProtectInfo.GetLockedMcuId();
                    TMtAlias tMtAlias;
                    pInst->m_ptMtTable->GetMtAlias(byLockedMcuId, 
                        mtAliasTypeTransportAddress,
                        &tMtAlias);
                    
                    cServMsg.SetMsgBody( (u8*)&tMtAlias.m_tTransportAddr.m_dwIpAddr, sizeof(u32) );
                    if(!pInst->m_ptMtTable->GetMtAlias(byLockedMcuId, 
                        mtAliasTypeH323ID,
                        &tMtAlias))
                    {
                        if(!pInst->m_ptMtTable->GetMtAlias(byLockedMcuId, 
                            mtAliasTypeE164,
                            &tMtAlias))
                        {
                            strncpy( tMtAlias.m_achAlias, "mmcu", sizeof(tMtAlias.m_achAlias) );
                        }
                    }
                    tMtAlias.m_achAlias[MAXLEN_PWD-1] = 0;
                    cServMsg.CatMsgBody( (u8*)tMtAlias.m_achAlias, MAXLEN_PWD );										
				}
				else if( tProtectInfo.IsLockByMcs() && tProtectInfo.GetLockedMcSsnId() != bySrcSsnId )
                {
                    TMcsRegInfo tMcsRegInfo;
                    GetMcsRegInfo( tProtectInfo.GetLockedMcSsnId(), &tMcsRegInfo );
                    cServMsg.SetMsgBody( (u8*)&tMcsRegInfo.m_dwMcsIpAddr, sizeof(u32) );
                    cServMsg.CatMsgBody( (u8*)tMcsRegInfo.m_achUser, MAXLEN_PWD );
				}

				CMcsSsn::SendMsgToMcsSsn( bySrcSsnId, MCU_MCS_LOCKUSERINFO_NOTIFY, cServMsg.GetServMsg(), 
					            cServMsg.GetServMsgLen() );				
			}            
		}
        break;

	//需要判断并有可能要回应的消息
	case MCS_MCU_RELEASECONF_REQ:           //会议控制台请求MCU结束一个会议
	case MCS_MCU_CHANGECONFPWD_REQ:         //会议控制台请求MCU更改会议密码
	case MCS_MCU_SAVECONF_REQ:              //会议控制台请求MCU保存会议
	case MCS_MCU_MODIFYCONF_REQ:	        //会控修改预约会议
	case MCS_MCU_DELAYCONF_REQ:             //会议控制台请求MCU延长会议
	case MCS_MCU_CHANGEVACHOLDTIME_REQ:		//会议控制台请求MCU改变语音激励切换时间
	case MCS_MCU_CHANGECONFLOCKMODE_REQ:    //会议控制台请求MCU锁定会议
	case MCS_MCU_SPECCHAIRMAN_REQ:          //会议控制台指定一台终端为主席
	case MCS_MCU_CANCELCHAIRMAN_REQ:        //会议控制台取消当前会议主席
	case MCS_MCU_SPECSPEAKER_REQ:           //会议控制台指定一台终端发言
	case MCS_MCU_CANCELSPEAKER_REQ:         //会议控制台取消会议Speaker
    case MCS_MCU_SPECOUTVIEW_REQ:           //会议控制台指定回传通道
	case MCS_MCU_ADDMT_REQ:                 //会议控制台邀请终端入会	
	case MCS_MCU_DELMT_REQ:                 //会议控制台驱逐终端离会
	case MCS_MCU_STARTSWITCHMC_REQ:         //会控选看终端
	case MCS_MCU_STARTVAC_REQ:              //会议控制台请求MCU开始语音激励控制发言		
	case MCS_MCU_STOPVAC_REQ:               //会议控制台请求MCU停止语音激励控制发言
	case MCS_MCU_STARTDISCUSS_REQ:          //开始会议讨论请求 - 用于本级开始讨论操作
	case MCS_MCU_STOPDISCUSS_REQ:           //结束会议讨论请求 - 用于本级开始讨论操作
    case MCS_MCU_CHGSPEAKMODE_REQ:          //改变会议模式请求
	case MCS_MCU_GETAPPLYSPEAKLIST_REQ:		//查询当前申请发言的列表

    //会议控制---点名
    case MCS_MCU_STARTROLLCALL_REQ:
    case MCS_MCU_STOPROLLCALL_REQ:
    case MCS_MCU_CHANGEROLLCALL_REQ:

    //vmp
	case MCS_MCU_STARTVMP_REQ:              //开始视频复合请求
	case MCS_MCU_STOPVMP_REQ:               //结束视频复合请求
	case MCS_MCU_CHANGEVMPPARAM_REQ:        //会议控制台请求MCU改变视频复合参数
    //vmptw
	case MCS_MCU_STARTVMPTW_REQ:            //开始复合电视墙请求
	case MCS_MCU_STOPVMPTW_REQ:             //结束复合电视墙请求
	case MCS_MCU_CHANGEVMPTWPARAM_REQ:      //会议控制台请求MCU改变复合电视墙参数
    //
	case MCS_MCU_CALLMT_REQ:                //会议控制台请求MCU呼叫终端
	case MCS_MCU_SETCALLMTMODE_REQ:         //会议控制台设置MCU呼叫终端方式
	case MCS_MCU_DROPMT_REQ:                //会议控制台挂断终端请求
	case MCS_MCU_STARTSWITCHMT_REQ:         //会控强制目的终端选看源终端
	case MCS_MCU_STOPSWITCHMT_REQ:          //会控取消目的终端选看源终端
	case MCS_MCU_SETMTVIDSRC_CMD:           //会控要求MCU设置终端视频源
	case MCS_MCU_MTAUDMUTE_REQ:             //会控要求MCU设置终端静音
	case MCS_MCU_MATRIX_SAVESCHEME_CMD:     //保存矩阵方案请求        
    case MCS_MCU_MATRIX_GETALLSCHEMES_CMD:  //终端内置矩阵控制
    case MCS_MCU_MATRIX_GETONESCHEME_CMD:
    case MCS_MCU_MATRIX_SETCURSCHEME_CMD:
    case MCS_MCU_MATRIX_GETCURSCHEME_CMD:
    case MCS_MCU_EXMATRIX_GETINFO_CMD:      //获取终端外置矩阵类型
    case MCS_MCU_EXMATRIX_SETPORT_CMD:      //设置外置矩阵连接端口号
    case MCS_MCU_EXMATRIX_GETPORT_REQ:      //请求获取外置矩阵连接端口
    case MCS_MCU_EXMATRIX_SETPORTNAME_CMD:  //设置外置矩阵连接端口名
    case MCS_MCU_EXMATRIX_GETALLPORTNAME_CMD://请求获取外置矩阵的所有端口名        
    case MCS_MCU_GETVIDEOSOURCEINFO_CMD://终端扩展视频源
    case MCS_MCU_SETVIDEOSOURCEINFO_CMD:
    case MCS_MCU_SELECTEXVIDEOSRC_CMD:
	case MCS_MCU_STARTREC_REQ:              //会控向MCU请求录像
	case MCS_MCU_PAUSEREC_REQ:              //会控向MCU暂停录像
	case MCS_MCU_RESUMEREC_REQ:             //会控向MCU恢复录像
	case MCS_MCU_STOPREC_REQ:               //会控向MCU停止录像
	case MCS_MCU_STARTPLAY_REQ:             //会控开始放像请求
	case MCS_MCU_PAUSEPLAY_REQ:             //会控暂停放像请求
	case MCS_MCU_RESUMEPLAY_REQ:            //会控恢复放像请求
	case MCS_MCU_STOPPLAY_REQ:              //会控停止放像请求
	case MCS_MCU_FFPLAY_REQ:                //会控快进放像请求
	case MCS_MCU_FBPLAY_REQ:                //会控快退放像请求
	case MCS_MCU_SEEK_REQ:                  //会控调整放像进度请求
	case MCS_MCU_CLOSELISTRECORD_CMD:		//会控关闭文件列表（用于挂断vrs新录播实体）
    case MCS_MCU_GETRECPROG_CMD:            //会控查询录相进度
    case MCS_MCU_GETPLAYPROG_CMD:           //会控查询放相进度
	case MCS_MCU_START_SWITCH_TW_REQ:       //会议控制台请求将指定Mt的图像交换到指定外设的指定索引的通道上
	case MCS_MCU_STARTVMPBRDST_REQ:         //会议控制台命令MCU开始把画面合成图像广播到终端
	case MCS_MCU_STOPVMPBRDST_REQ:          //会议控制台命令MCU停止把画面合成图像广播到终端
	case MCS_MCU_LOCKSMCU_REQ:		
    case MCS_MCU_CHANGEMIXDELAY_REQ:
	case MCS_MCU_START_VMPBATCHPOLL_REQ:
	case MCS_MCU_PAUSE_VMPBATCHPOLL_CMD:
	case MCS_MCU_STOP_VMPBATCHPOLL_CMD:
	case MCS_MCU_STARTSWITCHVMPMT_REQ:
	case MCS_MCU_START_SWITCH_HDU_REQ:      //4.6.1  新加版本 jlb
	case MCS_MCU_CHGHDUVMPMODE_CMD:			//4.7.2  HDU多画面切换
	case MCS_MCU_STARTHDUBATCHPOLL_REQ:
		cConfId = cServMsg.GetConfId();
        byConfIdx = GetConfIdx( cConfId );
        if(byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX)
        {
            LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[MsgPassCheck] invalid cConfId :");
            cConfId.Print();
            return FALSE;
        }
        tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
        if(!tMapData.IsValidConf())
        {
            LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[MsgPassCheck] invalid instance id :%d\n", tMapData.GetInsId());
            return FALSE;
        }
	    GetConfProtectInfo( byConfIdx, &tProtectInfo );
        bySrcSsnId = cServMsg.GetSrcSsnId();
		pInst = m_apConfInst[tMapData.GetInsId()-1];
		if (pInst == NULL)
		{
			LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS,"[MsgPassCheck] m_apConfInst[tMapData.GetInsId()-1] is NULL,Instid:%d\n",tMapData.GetInsId());
			return FALSE;	
		}
		byConfProtectMode = pInst->m_tConf.m_tStatus.GetProtectMode();
		if( ( byConfProtectMode == CONF_LOCKMODE_LOCK && 
			  ( tProtectInfo.IsLockByMcs() && tProtectInfo.GetLockedMcSsnId() != bySrcSsnId || tProtectInfo.IsLockByMcu() ) 
             ) || 
		    ( byConfProtectMode == CONF_LOCKMODE_NEEDPWD && 
			  !tProtectInfo.IsMcsPwdPassed(bySrcSsnId)
            ) 
           )
        { 
            bReturn = FALSE;
			if( byConfProtectMode == CONF_LOCKMODE_NEEDPWD )
			{
				//问密码
				cServMsg.SetMsgBody();
                CMcsSsn::SendMsgToMcsSsn( bySrcSsnId, MCU_MCS_ENTERCONFPWD_REQ, 
					                          cServMsg.GetServMsg(), cServMsg.GetServMsgLen() );
			}
			else
			{
				//Nack, 不发给会议
                cServMsg.SetErrorCode( ERR_MCU_CTRLBYOTHER );
				CMcsSsn::SendMsgToMcsSsn( bySrcSsnId, wEvent+2, cServMsg.GetServMsg(), 
					                          cServMsg.GetServMsgLen() );

				 if (tProtectInfo.IsLockByMcu())
                 {
					TMtAlias tMtAlias;
                    u8 byLockedMcuId = tProtectInfo.GetLockedMcuId();
					pInst->m_ptMtTable->GetMtAlias(byLockedMcuId, 
																		mtAliasTypeTransportAddress,
																		&tMtAlias);

					cServMsg.SetMsgBody( (u8*)&tMtAlias.m_tTransportAddr.m_dwIpAddr, sizeof(u32) );
					if(!pInst->m_ptMtTable->GetMtAlias(byLockedMcuId, 
																			mtAliasTypeH323ID,
																			&tMtAlias))
					{
						if(!pInst->m_ptMtTable->GetMtAlias(byLockedMcuId, 
																				mtAliasTypeE164,
																				&tMtAlias))
						{
							strncpy( tMtAlias.m_achAlias, "mmcu", sizeof(tMtAlias.m_achAlias) );
						}
					}
					tMtAlias.m_achAlias[MAXLEN_PWD-1] = 0;
					cServMsg.CatMsgBody( (u8*)tMtAlias.m_achAlias, MAXLEN_PWD );										
                 }
                 else if(tProtectInfo.IsLockByMcs() && tProtectInfo.GetLockedMcSsnId() != bySrcSsnId )
                 {
                     TMcsRegInfo tMcsRegInfo;
                     GetMcsRegInfo( tProtectInfo.GetLockedMcSsnId(), &tMcsRegInfo );
                     cServMsg.SetMsgBody( (u8*)&tMcsRegInfo.m_dwMcsIpAddr, sizeof(u32) );
                     cServMsg.CatMsgBody( (u8*)tMcsRegInfo.m_achUser, MAXLEN_PWD );
                 }

				CMcsSsn::SendMsgToMcsSsn( bySrcSsnId, MCU_MCS_LOCKUSERINFO_NOTIFY, cServMsg.GetServMsg(), 
					                          cServMsg.GetServMsgLen() );
			}

		}
	 break;

	default:
		break;
	}
	return bReturn;
}

/*====================================================================
    函数名      ：BroadcastToAllConf
    功能        ：发消息给所有会议实例
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wEvent, 事件号
				  u8 * const pbyMsg, 发送的消息指针，缺省为NULL
				  u16 wLen, 消息长度，缺省为0
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/07/30    1.0         LI Yi         创建
	05/12/20	4.0			张宝卿		  增加T120消息
====================================================================*/
void CMcuVcData::BroadcastToAllConf( u16 wEvent, u8 * const pbyMsg, u16 wLen )
{
	//本端离线或者备用且未完全同步则丢弃(MTADP/MP/MC/外设 离线消息除外)，
	//否则允许向业务模块投递消息
	if ( MTADP_MCU_REGISTER_REQ != wEvent && 
		 MCU_MTADP_DISCONNECTED_NOTIFY != wEvent && 
		 MP_MCU_REG_REQ != wEvent && 
		 MCU_MP_DISCONNECTED_NOTIFY != wEvent && 
		 MCU_MCSCONNECTED_NOTIF != wEvent && 
		 MCU_MCSDISCONNECTED_NOTIF != wEvent && 
	 	 MCU_EQPCONNECTED_NOTIF != wEvent && 
 		 MCU_EQPDISCONNECTED_NOTIF != wEvent && 
		 MCU_RECCONNECTED_NOTIF != wEvent && 
		 MCU_RECDISCONNECTED_NOTIF != wEvent && 
		 MCU_BASCONNECTED_NOTIF != wEvent && 
		 MCU_BASDISCONNECTED_NOTIF != wEvent && 
		 MCU_MIXERCONNECTED_NOTIF != wEvent && 
		 MCU_MIXERDISCONNECTED_NOTIF != wEvent && 
		 MCU_VMPCONNECTED_NOTIF != wEvent && 
		 MCU_VMPDISCONNECTED_NOTIF != wEvent && 
		 MCU_VMPTWCONNECTED_NOTIF != wEvent && 
		 MCU_VMPTWDISCONNECTED_NOTIF != wEvent && 
		 MCU_PRSCONNECTED_NOTIF != wEvent && 
		 MCU_PRSDISCONNECTED_NOTIF != wEvent && 
		 MCU_TVWALLCONNECTED_NOTIF != wEvent && 
		 MCU_TVWALLDISCONNECTED_NOTIF != wEvent && 
		 MCU_DCSCONNCETED_NOTIF != wEvent &&
		 MCU_DCSDISCONNECTED_NOTIF != wEvent &&
		 MCU_HDUCONNECTED_NOTIF != wEvent &&         //4.6 新加  jlb
		 MCU_HDUDISCONNECTED_NOTIF!= wEvent &&      //4.6 新加  jlb
		 FALSE == g_cMSSsnApp.JudgeRcvMsgPass() )
	{
		return;
	}

	if (MsgPassCheck(wEvent, pbyMsg, wLen))
	{
		if (0 != ::OspPost(MAKEIID(AID_MCU_VC, CInstance::EACH), wEvent, pbyMsg, wLen))
		{
			LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[BroadcastToAllConf] msg.%d<%s> broad failed!\n", wEvent, OspEventDesc(wEvent));
		}
	}

	return;
}

/*====================================================================
    函数名      ：SendMsgToConf
    功能        ：发消息给指定的会议对应的会议实例
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx, 会议索引号
				  u16 wEvent, 事件号
				  u8 * const pbyMsg, 发送的消息指针，缺省为NULL
				  u16 wLen, 消息长度，缺省为0
    返回值说明  ：成功返回TRUE，若无该会议返回FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/07/28    1.0         LI Yi         创建
	05/12/20	4.0			张宝卿		  增加T120消息
====================================================================*/
BOOL32 CMcuVcData::SendMsgToConf( u8 byConfIdx, u16 wEvent, u8 * const pbyMsg, u16 wLen )
{
	//本端离线或者备用且未完全同步则丢弃(MTADP/MP/MC/外设 离线消息除外)，
	//否则允许向业务模块投递消息
	if (MTADP_MCU_REGISTER_REQ != wEvent && 
		MCU_MTADP_DISCONNECTED_NOTIFY != wEvent && 
		MP_MCU_REG_REQ != wEvent && 
		MCU_MP_DISCONNECTED_NOTIFY != wEvent && 
		MCU_MCSCONNECTED_NOTIF != wEvent && 
		MCU_MCSDISCONNECTED_NOTIF != wEvent && 
		MCU_EQPCONNECTED_NOTIF != wEvent && 
		MCU_EQPDISCONNECTED_NOTIF != wEvent && 
		MCU_RECCONNECTED_NOTIF != wEvent && 
		MCU_RECDISCONNECTED_NOTIF != wEvent && 
		MCU_BASCONNECTED_NOTIF != wEvent && 
		MCU_BASDISCONNECTED_NOTIF != wEvent && 
		MCU_MIXERCONNECTED_NOTIF != wEvent && 
		MCU_MIXERDISCONNECTED_NOTIF != wEvent && 
		MCU_VMPCONNECTED_NOTIF != wEvent && 
		MCU_VMPDISCONNECTED_NOTIF != wEvent && 
		MCU_VMPTWCONNECTED_NOTIF != wEvent && 
		MCU_VMPTWDISCONNECTED_NOTIF != wEvent && 
		MCU_PRSCONNECTED_NOTIF != wEvent && 
		MCU_PRSDISCONNECTED_NOTIF != wEvent && 
		MCU_TVWALLCONNECTED_NOTIF != wEvent && 
		MCU_TVWALLDISCONNECTED_NOTIF != wEvent && 
		MCU_DCSCONNCETED_NOTIF != wEvent &&
		MCU_DCSDISCONNECTED_NOTIF != wEvent &&
		MCU_HDUCONNECTED_NOTIF != wEvent &&          //4.6  新加  jlb 
		MCU_HDUDISCONNECTED_NOTIF != wEvent &&
		FALSE == g_cMSSsnApp.JudgeRcvMsgPass())
	{
		return TRUE;
	}
	
	if (0 != byConfIdx)
	{
		if (MsgPassCheck(wEvent, pbyMsg, wLen))
		{	
			u8 byInsId = GetConfMapInsId(byConfIdx);
            if (0 == byInsId || byInsId > MAXNUM_MCU_CONF)
            {
                LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "Send msg to conf fail, invalid confidx.%d!\n", byConfIdx);
            }
			else
			{
				::OspPost(MAKEIID(AID_MCU_VC, byInsId), wEvent, pbyMsg, wLen);
			}
		}
		return TRUE;
	}
	else
	{
		LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[SendMsgToConf] ConfIdx is 0! event:%u(%s)\n", wEvent, OspEventDesc(wEvent));
	}
	
    return FALSE;
}

/*====================================================================
    函数名      ：SendMsgToConf
    功能        ：发消息给指定的会议对应的会议实例
    算法实现    ：
    引用全局变量：
    输入参数说明：const CConfId & cConfId, 会议号，0表示任意IDLE实例
				  u16 wEvent, 事件号
				  u8 * const pbyMsg, 发送的消息指针，缺省为NULL
				  u16 wLen, 消息长度，缺省为0
    返回值说明  ：成功返回TRUE，若无该会议返回FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/07/28    1.0         LI Yi         创建
	05/12/20	4.0			张宝卿		  增加T120消息
====================================================================*/
BOOL32 CMcuVcData::SendMsgToConf( const CConfId & cConfId, u16 wEvent, u8 * const pbyMsg, u16 wLen )
{
	//本端离线或者备用且未完全同步则丢弃(MTADP/MP/MC/外设 离线消息除外)，
	//否则允许向业务模块投递消息
	if (MTADP_MCU_REGISTER_REQ != wEvent && 
		MCU_MTADP_DISCONNECTED_NOTIFY != wEvent && 
		MP_MCU_REG_REQ != wEvent && 
		MCU_MP_DISCONNECTED_NOTIFY != wEvent && 
		MCU_MCSCONNECTED_NOTIF != wEvent && 
		MCU_MCSDISCONNECTED_NOTIF != wEvent && 
		MCU_EQPCONNECTED_NOTIF != wEvent && 
		MCU_EQPDISCONNECTED_NOTIF != wEvent && 
		MCU_RECCONNECTED_NOTIF != wEvent && 
		MCU_RECDISCONNECTED_NOTIF != wEvent && 
		MCU_BASCONNECTED_NOTIF != wEvent && 
		MCU_BASDISCONNECTED_NOTIF != wEvent && 
		MCU_MIXERCONNECTED_NOTIF != wEvent && 
		MCU_MIXERDISCONNECTED_NOTIF != wEvent && 
		MCU_VMPCONNECTED_NOTIF != wEvent && 
		MCU_VMPDISCONNECTED_NOTIF != wEvent && 
		MCU_VMPTWCONNECTED_NOTIF != wEvent && 
		MCU_VMPTWDISCONNECTED_NOTIF != wEvent && 
		MCU_PRSCONNECTED_NOTIF != wEvent && 
		MCU_PRSDISCONNECTED_NOTIF != wEvent && 
		MCU_TVWALLCONNECTED_NOTIF != wEvent && 
		MCU_TVWALLDISCONNECTED_NOTIF != wEvent && 
		MCU_DCSCONNCETED_NOTIF != wEvent &&
		MCU_DCSDISCONNECTED_NOTIF != wEvent &&
		MCU_HDUCONNECTED_NOTIF != wEvent && 
		MCU_HDUDISCONNECTED_NOTIF != wEvent && 
		FALSE == g_cMSSsnApp.JudgeRcvMsgPass())
	{
		return TRUE;
	}

	if (cConfId.IsNull())
	{
//		if (MsgPassCheck(wEvent, pbyMsg, wLen))
//		{		
//		    ::OspPost(MAKEIID(AID_MCU_VC, CInstance::PENDING), wEvent, pbyMsg, wLen);
//		}

        LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[SendMsgToConf] ConfId is Null! event:%u(%s)\n", wEvent, OspEventDesc(wEvent));

		return TRUE;
	}
    
    if (MsgPassCheck(wEvent, pbyMsg, wLen))
	{
		u8 byConfIdx = GetConfIdx(cConfId);
		if (0 != byConfIdx)
		{
            u8 byInsId = GetConfMapInsId(byConfIdx);
            if (0 == byInsId || byInsId > MAXNUM_MCU_CONF)
            {
                LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "Send msg to conf fail, invalid confidx.%d!\n", byConfIdx);
            }
			else
			{
                if (OSP_OK != ::OspPost( MAKEIID( AID_MCU_VC, byInsId), wEvent, pbyMsg, wLen ))
                {
                    LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[SendMsgToConf] Send msg to conf by confIdx failure!\n");
                }
			}
		}
        else
        {
            s8 achBuf[MAXLEN_CONFID*2+1] = {0};
            cConfId.GetConfIdString( achBuf, sizeof(achBuf) );
             LogPrint(LOG_LVL_DETAIL, MID_PUB_ALWAYS, "[SendMsgToConf] cConfId %s invalid, Event = %s(%d)!\n", 
                      achBuf, 
                      OspEventDesc(wEvent),
                      wEvent);            
        }
	}
	
    return TRUE;
}

/*====================================================================
    函数名      ：SendMsgToDaemonConf
    功能        ：发消息给业务Daemon实例
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wEvent, 事件号
				  u8 * const pbyMsg, 发送的消息指针，缺省为NULL
				  u16 wLen, 消息长度，缺省为0
    返回值说明  ：成功返回TRUE，若无该会议返回FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/05/30    1.0         JQL           创建
	05/12/20	4.0			张宝卿		  增加T120消息
====================================================================*/
BOOL32 CMcuVcData::SendMsgToDaemonConf( u16 wEvent, u8 * const pbyMsg, u16 wLen )
{
	//本端离线或者备用且未完全同步则丢弃(MTADP/MP/MC/外设 离线消息除外)，
	//否则允许向业务模块投递消息
	if (MTADP_MCU_REGISTER_REQ != wEvent && 
		MCU_MTADP_DISCONNECTED_NOTIFY != wEvent && 
		MP_MCU_REG_REQ != wEvent && 
		MCU_MP_DISCONNECTED_NOTIFY != wEvent && 
		MCU_MCSCONNECTED_NOTIF != wEvent && 
		MCU_MCSDISCONNECTED_NOTIF != wEvent && 
		MCU_EQPCONNECTED_NOTIF != wEvent && 
		MCU_EQPDISCONNECTED_NOTIF != wEvent && 
		MCU_RECCONNECTED_NOTIF != wEvent && 
		MCU_RECDISCONNECTED_NOTIF != wEvent && 
		MCU_BASCONNECTED_NOTIF != wEvent && 
		MCU_BASDISCONNECTED_NOTIF != wEvent && 
		MCU_MIXERCONNECTED_NOTIF != wEvent && 
		MCU_MIXERDISCONNECTED_NOTIF != wEvent && 
		MCU_VMPCONNECTED_NOTIF != wEvent && 
		MCU_VMPDISCONNECTED_NOTIF != wEvent && 
		MCU_VMPTWCONNECTED_NOTIF != wEvent && 
		MCU_VMPTWDISCONNECTED_NOTIF != wEvent && 
		MCU_PRSCONNECTED_NOTIF != wEvent && 
		MCU_PRSDISCONNECTED_NOTIF != wEvent && 
		MCU_TVWALLCONNECTED_NOTIF != wEvent && 
		MCU_TVWALLDISCONNECTED_NOTIF != wEvent && 
		MCU_DCSCONNCETED_NOTIF != wEvent &&
		MCU_DCSDISCONNECTED_NOTIF != wEvent &&
		MCU_HDUCONNECTED_NOTIF != wEvent && 
		MCU_HDUDISCONNECTED_NOTIF != wEvent && 
		FALSE == g_cMSSsnApp.JudgeRcvMsgPass())
	{
		return TRUE;
	}

    if (MsgPassCheck( wEvent, pbyMsg, wLen ))
	{
        ::OspPost(MAKEIID( AID_MCU_VC, CInstance::DAEMON ), wEvent, pbyMsg, wLen);
	}

    return TRUE;
}

/*====================================================================
函数名      ：SendMsgToEqp
功能        ：发消息给外设实例
算法实现    ：
引用全局变量：
输入参数说明：u8 byEqpId: 发送外设id
              u16 wEvent： 事件号
              u8 * const pbyMsg： 发送的消息指针，缺省为NULL
			  u16 wLen: 消息长度，缺省为0
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
03/05/30    1.0         付秀华           创建
====================================================================*/
BOOL32 CMcuVcData::SendMsgToEqp( u8 byEqpId,  u16 wEvent, u8 * const pbyMsg, u16 wLen)
{
    ::OspPost(MAKEIID(AID_MCU_PERIEQPSSN, byEqpId ), wEvent, pbyMsg, wLen);
	return TRUE;	
}

/*====================================================================
    函数名      ：RefreshHtml
    功能        ：刷新Html页面
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/04/19    3.0         胡昌威        修改
    06/04/19    4.0         顾振华        NMS1写文件要求传入主机序地址
    08/06/27    5.0         周文          WriteHtml要求tStreamChannel包含AAC相关内容
====================================================================*/
void CMcuVcData::RefreshHtml( void )
{
	TStreamChannel tStreamChannel[64];
	memset( tStreamChannel, 0, sizeof(tStreamChannel) );
	u8  byChlNum = 0;
	TCapSupport tCapSupport;
    TMediaEncrypt tMediaEncrypt;
    u16 wMultiCastPort;

	for( u8 byLoop = 0; byLoop < MAXNUM_MCU_CONF; byLoop++ )
	{
		if( m_apConfInst[byLoop] != NULL && 
			m_apConfInst[byLoop]->m_tConf.GetConfAttrb().IsMulticastMode() && 
			m_apConfInst[byLoop]->m_tConf.m_tStatus.IsOngoing() )
		{
            tMediaEncrypt = m_apConfInst[byLoop]->m_tConf.GetMediaKey();
			tCapSupport = m_apConfInst[byLoop]->m_tConf.GetCapSupport();

			strncpy( tStreamChannel[byChlNum].m_aszChannelName, m_apConfInst[byLoop]->m_tConf.GetConfName(), 254 );
			strncpy( tStreamChannel[byChlNum].m_aszPassWord, m_apConfInst[byLoop]->m_tConf.GetConfPwd(), 32 );
            
            // 采用主机序地址
			tStreamChannel[byChlNum].m_dwIp  = AssignMulticastIp(m_apConfInst[byLoop]->m_byConfIdx);
            wMultiCastPort = AssignMulticastPort( (u8)m_apConfInst[byLoop]->m_byConfIdx, 0 );
            tStreamChannel[byChlNum].m_wPort[0] = wMultiCastPort;

            //设置加密密钥
            s32 nTmpLen;
            //视频
            tStreamChannel[byChlNum].m_tEncrypt[0].m_tEncryptKey[0].m_byMode = tMediaEncrypt.GetEncryptMode();
            tMediaEncrypt.GetEncryptKey(tStreamChannel[byChlNum].m_tEncrypt[0].m_tEncryptKey[0].m_abyKey, &nTmpLen);
            tStreamChannel[byChlNum].m_tEncrypt[0].m_tEncryptKey[0].m_byKeyLen = (u8)nTmpLen;

            //音频
            tStreamChannel[byChlNum].m_tEncrypt[0].m_tEncryptKey[1].m_byMode = tMediaEncrypt.GetEncryptMode();
            tMediaEncrypt.GetEncryptKey(tStreamChannel[byChlNum].m_tEncrypt[0].m_tEncryptKey[1].m_abyKey, &nTmpLen);
            tStreamChannel[byChlNum].m_tEncrypt[0].m_tEncryptKey[1].m_byKeyLen = (u8)nTmpLen;
            
            //默认写入双流信息
            tStreamChannel[byChlNum].m_wPort[1] = wMultiCastPort + 4;
            tStreamChannel[byChlNum].m_dwStreamNum = 2; 
            //视频
            tStreamChannel[byChlNum].m_tEncrypt[1].m_tEncryptKey[0].m_byMode = tMediaEncrypt.GetEncryptMode();
            tMediaEncrypt.GetEncryptKey(tStreamChannel[byChlNum].m_tEncrypt[1].m_tEncryptKey[0].m_abyKey, &nTmpLen);
            tStreamChannel[byChlNum].m_tEncrypt[1].m_tEncryptKey[0].m_byKeyLen = (u8)nTmpLen;

            //双流没有音频，不进行设置

			//第一路视频为H264时存在动态载荷支持，目前暂不支持加密流媒体
			if( MEDIA_TYPE_H264 == tCapSupport.GetMainVideoType() || 
				( !tCapSupport.GetSecondSimCapSet().IsNull() && 
				  MEDIA_TYPE_H264 == tCapSupport.GetSecVideoType() ) )
			{
                tStreamChannel[byChlNum].m_tEncrypt[0].m_byRealVideoPT = MEDIA_TYPE_H264;
				tStreamChannel[byChlNum].m_tEncrypt[0].m_byVideoEncType = 
                    GetActivePayload(m_apConfInst[byLoop]->m_tConf, MEDIA_TYPE_H264);
			}
			else
			{
				tStreamChannel[byChlNum].m_tEncrypt[0].m_byRealVideoPT  = tCapSupport.GetMainVideoType();
				tStreamChannel[byChlNum].m_tEncrypt[0].m_byVideoEncType = tCapSupport.GetMainVideoType();
			}
			tStreamChannel[byChlNum].m_tEncrypt[0].m_byRealAudioPT  = tCapSupport.GetMainAudioType();
			tStreamChannel[byChlNum].m_tEncrypt[0].m_byAudioEncType = tCapSupport.GetMainAudioType();

            //第二路视频
            tStreamChannel[byChlNum].m_tEncrypt[1].m_byRealVideoPT  = tCapSupport.GetDStreamMediaType();
            tStreamChannel[byChlNum].m_tEncrypt[1].m_byVideoEncType =
                GetActivePayload(m_apConfInst[byLoop]->m_tConf, tCapSupport.GetDStreamMediaType());

            tStreamChannel[byChlNum].m_tEncrypt[1].m_byRealAudioPT  = MEDIA_TYPE_NULL;
			tStreamChannel[byChlNum].m_tEncrypt[1].m_byAudioEncType = MEDIA_TYPE_NULL;

            // zw [06/27/2008] 如果是AAC会议，添加AAC需要的内容
            if ( MEDIA_TYPE_AACLC == m_apConfInst[byLoop]->m_tConf.GetMainAudioMediaType() )
            {
                tStreamChannel[byChlNum].m_tEncrypt[0].m_byAACSamplePerSecond = AAC_SAMPLE_FRQ_32;
				TAudioTypeDesc tAaclcAudio = m_apConfInst[byLoop]->m_tConfEx.GetMainAudioTypeDesc();
                tStreamChannel[byChlNum].m_tEncrypt[0].m_byAACChannels        = GetAACChnlTypeByAudioTrackNum(tAaclcAudio.GetAudioTrackNum()); 
            }
			//tianzhiyong 2010/04/02 如果是AAC会议，添加AAC需要的内容
			if ( MEDIA_TYPE_AACLD == m_apConfInst[byLoop]->m_tConf.GetMainAudioMediaType() )
            {
                tStreamChannel[byChlNum].m_tEncrypt[0].m_byAACSamplePerSecond = AAC_SAMPLE_FRQ_32;
				TAudioTypeDesc tAacldAudio = m_apConfInst[byLoop]->m_tConfEx.GetMainAudioTypeDesc();
                tStreamChannel[byChlNum].m_tEncrypt[0].m_byAACChannels        = GetAACChnlTypeByAudioTrackNum(tAacldAudio.GetAudioTrackNum()); 
            }

			byChlNum++;
		}
	}

	s8	   achWebFileName[KDV_MAX_PATH];
	sprintf( achWebFileName, "%s/%s", DIR_WEB, MCUHTMLFILENAME );
    LogPrint(LOG_LVL_DETAIL, MID_MCU_MCS, "[RefreshHtml] Writing VOD Channel info(%d chnl) into file %s.\n", byChlNum, achWebFileName);
	WriteHtml( achWebFileName, tStreamChannel, byChlNum );

	return;
}

/*====================================================================
    函数名      ：AddConf
    功能        ：向会议表中增加一个会议
    算法实现    ：
    引用全局变量：
    输入参数说明：TConfFullInfo	*ptConf, 会议完整信息
	              BOOL32 bRefreshHtml =TRUE 是否刷新流媒体文件
    返回值说明  ：成功返回TRUE，失败返回FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/07/30    1.0         LI Yi         创建
	03/05/29	1.2			Jiaql         修改
	03/11/08    3.0         胡昌威        修改
====================================================================*/
BOOL32 CMcuVcData::AddConf( CMcuVcInst *pConfInst, BOOL32 bRefreshHtml /*=TRUE*/ )
{
	if( pConfInst->GetInsID() > MAXNUM_MCU_CONF )
	{
		return FALSE;
	}

    m_apConfInst[(u8)pConfInst->GetInsID()-1] = pConfInst;

	if (bRefreshHtml)
	{
		RefreshHtml();
	}

	return TRUE;
}

/*====================================================================
    函数名      ：GetConfInstHandle
    功能        ：根据会议号索引号 查询会议实例指针
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx, 会议号索引号
    返回值说明  ：成功返回TRUE，失败返回FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/07/30    1.0         LI Yi         创建
	03/11/08    3.0         胡昌威        修改
====================================================================*/
CMcuVcInst *CMcuVcData::GetConfInstHandle( u8 byConfIdx )
{
	if (byConfIdx > MAX_CONFIDX || byConfIdx < MIN_CONFIDX)
	{
		return NULL;
	}
	
    TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
    if (!tMapData.IsValidConf() ||  NULL == m_apConfInst[tMapData.GetInsId()-1] )
    {
        return NULL;
    }

	return (CMcuVcInst *)m_apConfInst[tMapData.GetInsId()-1];

}

/*====================================================================
    函数名      ：RemoveConf
    功能        ：向会议表中删除一个会议
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx, 会议号索引号
	              BOOL32 bRefreshHtml =TRUE 是否刷新流媒体文件
    返回值说明  ：成功返回TRUE，失败返回FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/07/30    1.0         LI Yi         创建
	03/11/08    3.0         胡昌威        修改
====================================================================*/
BOOL32 CMcuVcData::RemoveConf( u8 byConfIdx, BOOL32 bRefreshHtml /*=TRUE*/ )
{
    CHECK_CONFIDX(byConfIdx)	
	
    TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
    if(!tMapData.IsValidConf())
    {
        return FALSE;
    }
    m_apConfInst[tMapData.GetInsId()-1] = NULL;

	if (bRefreshHtml)
	{
		RefreshHtml();
	}

	return TRUE;
}

/*====================================================================
    函数名      ：GetConfIdx
    功能        ：获得会议号在会议表中的序号
    算法实现    ：
    引用全局变量：
    输入参数说明：const CConfId& cConfId 会议号    
    返回值说明  ：0 没有找到会议号对应的序号，表示会议不存在
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/05/24    1.0         LI Yi         创建
	03/11/08    3.0         胡昌威        修改
====================================================================*/
u8 CMcuVcData::GetConfIdx( const CConfId& cConfId ) const
{	
	u8 byLoop;	    
    for( byLoop = 0; byLoop < MAXNUM_MCU_CONF; byLoop++ )
    {
        if( m_apConfInst[byLoop] != NULL &&
            m_apConfInst[byLoop]->m_tConf.GetConfId() == cConfId )
        {
            return m_apConfInst[byLoop]->m_byConfIdx;
        }
    }

	if( NULL != m_ptTemplateInfo )
	{
		for( byLoop = 0; byLoop < MAXNUM_MCU_TEMPLATE; byLoop++ )
		{
			if (!m_ptTemplateInfo[byLoop].IsEmpty() &&
				m_ptTemplateInfo[byLoop].m_tConfInfo.GetConfId() == cConfId)
			{
				return m_ptTemplateInfo[byLoop].m_byConfIdx;
			}
		}
	}

   return 0;
}

/*====================================================================
    函数名      ：GetConfId
    功能        ：根据在会议表中的序号获得会议号
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/05/24    1.0         LI Yi         创建
	03/11/08    3.0         胡昌威        修改
====================================================================*/
CConfId CMcuVcData::GetConfId(const u8 &byConfIdx) const
{
    CConfId cConfId;
    cConfId.SetNull();

    u8 byLoop;	    
    for( byLoop = 0; byLoop < MAXNUM_MCU_CONF; byLoop++ )
    {
        if( m_apConfInst[byLoop] != NULL &&
            m_apConfInst[byLoop]->m_byConfIdx == byConfIdx )
        {
            return m_apConfInst[byLoop]->m_tConf.GetConfId();
        }
    }
    return cConfId;
}

/*====================================================================
    函数名      ：MakeConfId
    功能        ：根据本MCU号/会议类型/会议索引值/会议号产生次数 产生会议号
                  支持用户组信息
				  支持会议创始者信息
    算法实现    ：
    引用全局变量：
    输入参数说明：无
    返回值说明  ：会议号
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/08/01    1.0         LI Yi         创建
    06/06/21    4.0         顾振华        支持用户组信息
====================================================================*/
CConfId CMcuVcData::MakeConfId(u8 byConfIdx, u8 byTemplate, u8 byUsrGrpId, u8 byConfSource /*= MCS_CONF*/ )
{
	CConfId	cConfId;
	u8	abyTConfId[8];
	u16	wTemp;

	//会议号产生次数进行累计,保证前后产生的会议号的唯一性
	m_dwMakeConfIdTimes++;

	//2 bytes
	wTemp = htons( LOCAL_MCUID );
	memcpy( abyTConfId, &wTemp, 2 );
	//2 bytes
	abyTConfId[2] = byTemplate;
	abyTConfId[3] = byConfIdx;
	//4 bytes
    u32 dwTimes = htonl(m_dwMakeConfIdTimes);
	memcpy(abyTConfId+4, &dwTimes, sizeof(dwTimes));
	
	cConfId.SetConfId(abyTConfId, sizeof(abyTConfId));
    cConfId.SetUsrGrpId( byUsrGrpId );
	cConfId.SetConfSource( byConfSource );

	return( cConfId );
}

/*====================================================================
    函数名      ：GetMakeTimesFromConfId
    功能        ：从CConfId取得已经进行了多少次的MakeConfId
    算法实现    ：
    引用全局变量：
    输入参数说明：无
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    07/04/10    4.0         顾振华          创建
====================================================================*/
u32 CMcuVcData::GetMakeTimesFromConfId(const CConfId& cConfId) const
{
    u32 dwTimes;
    u8	abyConfId[sizeof(CConfId)];
    cConfId.GetConfId( abyConfId, sizeof(abyConfId) );
    memcpy(&dwTimes, abyConfId+4, sizeof(u32));
    dwTimes = ntohl(dwTimes);
    return dwTimes;
}
/*====================================================================
    函数名      ：IsConfOnGoing
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：cConfId: conf id   
    返回值说明  ：TRUE:正在召开  FALSE:未召开
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/08    3.0         付秀华        创建
====================================================================*/
BOOL32 CMcuVcData::IsConfOnGoing(CConfId cConfId)
{
    for( u8 byLoop = 0; byLoop < MAXNUM_MCU_CONF; byLoop++ )
    {
        if( m_apConfInst[byLoop] != NULL &&
			m_apConfInst[byLoop]->m_tConf.GetConfId() == cConfId)
        {
	        return TRUE;
        }
    }

	return FALSE;
}

/*====================================================================
    函数名      ：IsConfNameRepeat
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：LPCSTR lpszConfName 新的会议名    
    返回值说明  ：TRUE-会议名重复 FALSE-不重复
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/08    3.0         胡昌威        创建
====================================================================*/
BOOL32 CMcuVcData::IsConfNameRepeat( LPCSTR lpszConfName, BOOL32 IsTemple ,BOOL32 bIsOngoingConf)
{
	if (!m_ptTemplateInfo)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[IsConfNameRepeat] m_ptTemplateInfo is null\n");
		printf("[IsConfNameRepeat] m_ptTemplateInfo is null\n");
		return TRUE;
	}

	u8 byLoop;
	
    if(IsTemple)
    {
        for(byLoop = 0; byLoop < MAXNUM_MCU_TEMPLATE; byLoop++)
        {
            if(!m_ptTemplateInfo[byLoop].IsEmpty() && 
                0 == memcmp(m_ptTemplateInfo[byLoop].m_tConfInfo.GetConfName(), lpszConfName, MAXLEN_CONFNAME ))
            {
                return TRUE;
            }
        }
    }
    else
    {
        for( byLoop = 0; byLoop < MAXNUM_MCU_CONF; byLoop++ )
        {
            if( m_apConfInst[byLoop] != NULL )
            {
                if ( m_apConfInst[byLoop]->m_tConf.m_tStatus.IsOngoing() == bIsOngoingConf &&
					0 == memcmp( m_apConfInst[byLoop]->m_tConf.GetConfName(), lpszConfName, MAXLEN_CONFNAME ) )                     
                {
                    return TRUE;
                }
            }
        }
    }	

	return FALSE;
}

/*====================================================================
    函数名      ：IsConfNameRepeat
    功能        ：是否会议E164号码重复
    算法实现    ：
    引用全局变量：
    输入参数说明：LPCSTR lpszConfE164 会议的E164号   
    返回值说明  ：TRUE-会议名重复 FALSE-不重复
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/07/25    3.0         胡昌威        创建
====================================================================*/
BOOL32 CMcuVcData::IsConfE164Repeat( LPCSTR lpszConfE164, BOOL32 IsTemple ,BOOL32 bIsOngoingConf)
{
	char abyMcuE164[MAXLEN_E164];
	g_cMcuAgent.GetE164Number( abyMcuE164, MAXLEN_E164 );
	if( memcmp( abyMcuE164, lpszConfE164, MAXLEN_E164 ) == 0 )
	{
		return TRUE;
	}
	
	return IsE164Repeated(lpszConfE164,IsTemple,bIsOngoingConf);
}

/*====================================================================
    函数名      ：IsE164Reapted
    功能        ：是否E164号码与会议或会议模板重复
    算法实现    ：
    引用全局变量：
    输入参数说明：LPCSTR lpszE164 E164号  
				  BOOL32 IsTemple 是模板或会议
    返回值说明  ：TRUE-重复 FALSE-不重复
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	12/04/05    4.7         chendaiwei        创建
====================================================================*/
BOOL32 CMcuVcData::IsE164Repeated( LPCSTR lpszE164, BOOL32 IsTemple ,BOOL32 bIsOngoingConf)
{
	u8 byLoop;

	if (!m_ptTemplateInfo)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[IsE164Reapted] m_ptTemplateInfo is null\n");
		printf("[IsE164Reapted] m_ptTemplateInfo is null\n");
		return TRUE;
	}

    if(IsTemple)
    {
        for(byLoop = 0; byLoop < MAXNUM_MCU_TEMPLATE; byLoop++)
        {
            if(!m_ptTemplateInfo[byLoop].IsEmpty() && 
               0 == memcmp(m_ptTemplateInfo[byLoop].m_tConfInfo.GetConfE164(), lpszE164, MAXLEN_E164 ))
            {
                return TRUE;
            }
        }
    }
    else
    {
        for( byLoop = 0; byLoop < MAXNUM_MCU_CONF; byLoop++ )
        {
            if ( m_apConfInst[byLoop] != NULL )
            {
                if(	m_apConfInst[byLoop]->m_tConf.m_tStatus.IsOngoing() == bIsOngoingConf &&
					0 == memcmp( m_apConfInst[byLoop]->m_tConf.GetConfE164(), lpszE164, MAXLEN_E164 ) )
                {
                    return TRUE;	
                }
            }
        }
	}
	
	return FALSE;	
}

/*====================================================================
    函数名      ：GetConfIdxByE164
    功能        ：从会议的E164号码得到会议的索引号
    算法实现    ：
    引用全局变量：
    输入参数说明：LPCSTR lpszConfE164 会议的E164号 
				  pbyOngoningConfIdx 返回的ongonig conf index
				  pbyTemplateConfIdx 返回的template conf idex

    返回值说明  ：TRUE-会议名重复 FALSE-不重复
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/07/25    3.0         胡昌威        创建
====================================================================*/
u8  CMcuVcData::GetOngoingConfIdxByE164( LPCSTR lpszConfE164 )
{
    if( NULL == lpszConfE164 )
    {
        return 0;
    }

	if (!m_apConfInst)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetOngoingConfIdxByE164] m_apConfInst is null\n");
		printf("[GetOngoingConfIdxByE164] m_apConfInst is null\n");
		return 0;
	}

    for (u8 byLoop = 0; byLoop < MAXNUM_MCU_CONF; byLoop++)
    {
        if (m_apConfInst[byLoop] == NULL)
        {
            continue;
        }
        
        if ( m_apConfInst[byLoop]->m_tConf.m_tStatus.IsOngoing() == TRUE &&
			0 == memcmp(m_apConfInst[byLoop]->m_tConf.GetConfE164(), lpszConfE164, MAXLEN_E164)) 
        {
            return m_apConfInst[byLoop]->m_byConfIdx;
        }
    }
    
    return 0;
}

u8  CMcuVcData::GetTemConfIdxByE164( LPCSTR lpszConfE164 )
{
    if( NULL == lpszConfE164 )
    {
        return 0;
    }

	if (!m_ptTemplateInfo)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetTemConfIdxByE164] m_ptTemplateInfo is null\n");
		printf("[GetTemConfIdxByE164] m_ptTemplateInfo is null\n");
		return 0;
	}

    for( u8 byLoop = 0; byLoop < MAXNUM_MCU_TEMPLATE; byLoop++)
    {
        if (m_ptTemplateInfo[byLoop].IsEmpty())
        {
            continue;
        }
        
        if (0 == memcmp(m_ptTemplateInfo[byLoop].m_tConfInfo.GetConfE164(), lpszConfE164, MAXLEN_E164))
        {
            return m_ptTemplateInfo[byLoop].m_byConfIdx;
        } 
    }

    return 0;
}

/*=============================================================================
  函 数 名： GetConfRateByConfIdx
  功    能： 由会议序号取会议速率
  算法实现： 
  全局变量： 
  参    数：  u16 wConfIdx
             u16& wFirstRate
             u16& wSecondRate
             BOOL32 bTemplate /* = FALSE  */
//  返 回 值： u16 
// =============================================================================*/
u16 CMcuVcData::GetConfRateByConfIdx( u16 wConfIdx, u16& wFirstRate, u16& wSecondRate, BOOL32 bTemplate /* = FALSE  */)
{
    if( 0 == wConfIdx)
    {
        return 0;
    }
    u16 wAudRate = 0;
    if( FALSE == bTemplate )
    {
		if (!m_apConfInst)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetConfRateByConfIdx] m_apConfInst is null\n");
			printf("[GetConfRateByConfIdx] m_apConfInst is null\n");
			return 0;
		}

        for (u8 byLoop = 0; byLoop < MAXNUM_MCU_CONF; byLoop++)
        {
            if (NULL == m_apConfInst[byLoop] )
            {
                continue;
            }
    
            if ( m_apConfInst[byLoop]->m_byConfIdx == (u8)wConfIdx ) 
            {
                wFirstRate = m_apConfInst[byLoop]->m_tConf.GetBitRate();
                wSecondRate = m_apConfInst[byLoop]->m_tConf.GetSecBitRate();
                TCapSupport m_tCapSupport = m_apConfInst[byLoop]->m_tConf.GetCapSupport();
                wAudRate = GetAudioBitrate(m_tCapSupport.GetMainAudioType() );
                wFirstRate += wAudRate;
                wSecondRate = ( 0 != wSecondRate ) ? (wSecondRate+wAudRate): 0;
                
                break;
            }
        }
    }
    else
    {
		if (!m_ptTemplateInfo)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetConfRateByConfIdx] m_ptTemplateInfo is null\n");
			printf("[GetConfRateByConfIdx] m_ptTemplateInfo is null\n");
			return 0;
		}

        for( u8 byLoop = 0; byLoop < MAXNUM_MCU_TEMPLATE; byLoop++)
        {
            if (m_ptTemplateInfo[byLoop].IsEmpty())
            {
                continue;
            }
    
            if ( m_ptTemplateInfo[byLoop].m_byConfIdx == wConfIdx )
            {
                wFirstRate = m_ptTemplateInfo[byLoop].m_tConfInfo.GetBitRate();
                wSecondRate = m_ptTemplateInfo[byLoop].m_tConfInfo.GetSecBitRate();
                wAudRate = GetAudioBitrate( m_ptTemplateInfo[byLoop].m_tConfInfo.GetMainAudioMediaType() );
                wFirstRate += wAudRate;
                wSecondRate = ( 0 != wSecondRate ) ? (wSecondRate+wAudRate): 0;
            } 
        }
    }
    return 0;
}

/*=============================================================================
  函 数 名： GetConfNameByConfId
  功    能： 根据会议ID取会议名称
  算法实现： 
  全局变量： 
  参    数：
  返 回 值： u8 ConfIdx, 0 - 没有找到
 =============================================================================*/
u8 CMcuVcData::GetConfNameByConfId( const CConfId cConfId, LPCSTR &lpszConfName )
{
	if (!m_apConfInst)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetConfNameByConfId] m_apConfInst is null\n");
		printf("[GetConfNameByConfId] m_apConfInst is null\n");
		return 0;
	}

    lpszConfName = NULL;
    for (u8 byLoop = 0; byLoop < MAXNUM_MCU_CONF; byLoop++)
    {
        if (NULL == m_apConfInst[byLoop] )
        {
            continue;
        }

        if ( m_apConfInst[byLoop]->m_tConf.GetConfId() == cConfId ) 
        {
            lpszConfName = m_apConfInst[byLoop]->m_tConf.GetConfName();
            return m_apConfInst[byLoop]->m_byConfIdx;
        }
    }    
    return 0;
}


/*=============================================================================
  函 数 名： GetConfIdByName
  功    能： 根据会议名称取CConfId
  算法实现： 
  全局变量： 
  参    数：  
  返 回 值： u8 ConfIdx, 0 - 没有找到
 =============================================================================*/
CConfId CMcuVcData::GetConfIdByName(LPCSTR lpszConfName, BOOL32 bTemplate ,BOOL32 bIsOngoingConf)
{	
    CConfId cConfId;
    cConfId.SetNull();
    u8 byLoop = 0;

    if (!bTemplate)
    {

		if (!m_apConfInst)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetConfIdByName] m_apConfInst is null\n");
			printf("[GetConfIdByName] m_apConfInst is null\n");
			return cConfId;
		}

        for (byLoop = 0; byLoop < MAXNUM_MCU_CONF; byLoop++)
        {
            if (NULL == m_apConfInst[byLoop] )
            {
                continue;
            }

            if ( m_apConfInst[byLoop]->m_tConf.m_tStatus.IsOngoing() == bIsOngoingConf &&
				strncmp(m_apConfInst[byLoop]->m_tConf.GetConfName(), lpszConfName, MAXLEN_CONFNAME) == 0 ) 
            {
                cConfId = m_apConfInst[byLoop]->m_tConf.GetConfId();
                break;
            }
        }  
    }
    else
    {
		if (!m_ptTemplateInfo)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetConfIdByName] m_ptTemplateInfo is null\n");
			printf("[GetConfIdByName] m_ptTemplateInfo is null\n");
			return cConfId;
		}

        for( byLoop = 0; byLoop < MAXNUM_MCU_TEMPLATE; byLoop++)
        {
            if (m_ptTemplateInfo[byLoop].IsEmpty())
            {
                continue;
            }
    
            if ( strncmp(m_ptTemplateInfo[byLoop].m_tConfInfo.GetConfName(), lpszConfName, MAXLEN_CONFNAME) == 0) 
            {
                cConfId = m_ptTemplateInfo[byLoop].m_tConfInfo.GetConfId();
                break;                
            } 
        }        
    }
    
    return cConfId;
}

/*=============================================================================
  函 数 名： GetConfIdByE164
  功    能： 根据会议名称取CConfId
  算法实现： 
  全局变量： 
  参    数：  
  返 回 值： u8 ConfIdx, 0 - 没有找到
 =============================================================================*/
CConfId CMcuVcData::GetConfIdByE164( LPCSTR lpszConfE164, BOOL32 bTemplate,BOOL32 bIsOngoingConf )
{
    CConfId cConfId;
    cConfId.SetNull();
    u8 byLoop = 0;

    if (!bTemplate)
    {
		if (!m_apConfInst)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetConfIdByE164] m_apConfInst is null\n");
			printf("[GetConfIdByE164] m_apConfInst is null\n");
			return cConfId;
		}

        for (byLoop = 0; byLoop < MAXNUM_MCU_CONF; byLoop++)
        {
            if (NULL == m_apConfInst[byLoop] )
            {
                continue;
            }

            if ( m_apConfInst[byLoop]->m_tConf.m_tStatus.IsOngoing() == bIsOngoingConf && 
				strncmp(m_apConfInst[byLoop]->m_tConf.GetConfE164(), lpszConfE164, MAXLEN_E164) == 0) 
            {
                cConfId = m_apConfInst[byLoop]->m_tConf.GetConfId();
                break;
            }
        }  
    }
    else
    {
		if (!m_ptTemplateInfo)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetConfIdByE164] m_ptTemplateInfo is null\n");
			printf("[GetConfIdByE164] m_ptTemplateInfo is null\n");
			return cConfId;
		}

        for( byLoop = 0; byLoop < MAXNUM_MCU_TEMPLATE; byLoop++)
        {
            if (m_ptTemplateInfo[byLoop].IsEmpty())
            {
                continue;
            }
    
            if ( strncmp(m_ptTemplateInfo[byLoop].m_tConfInfo.GetConfE164(), lpszConfE164, MAXLEN_E164) == 0) 
            {
                cConfId = m_ptTemplateInfo[byLoop].m_tConfInfo.GetConfId();
                break;                
            } 
        }        
    }
    
    return cConfId;
}

/*====================================================================
    函数名      ：GetConfNum
    功能        ：查询当前会议个数
    算法实现    ：
    引用全局变量：
    输入参数说明：BOOL32 bIncOngoing,           含即时会议
                  BOOL32 bIncSched,             含预约会议
                  BOOL32 bIncTempl,             含模板  
				  u8 byConfSource               针对某一发起方的信息统计
    返回值说明  ：实际返回的会议数目
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/03/19    1.0         Qzj           创建
	03/11/08    3.0         胡昌威        修改
    07/01/19    4.0         顾振华        修改
	08/11/28                付秀华        修改
====================================================================*/
u8 CMcuVcData::GetConfNum( BOOL32 bIncOngoing, BOOL32 bIncSched, BOOL32 bIncTempl, u8 byConfSource /*= MCS_CONF*/ ) const
{
	u8		byLoop;
	u8		byNum = 0;
	for( byLoop = 0; byLoop < MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE; byLoop++ )
	{
        TConfMapData tMapData = m_atConfMapData[byLoop];
        if ( (tMapData.IsValidConf() && m_apConfInst && NULL != m_apConfInst[tMapData.GetInsId()-1] ) )
        {
			if (byConfSource != ALL_CONF && m_apConfInst[tMapData.GetInsId()-1]->m_tConf.GetConfSource() != byConfSource)
			{
				break;
			}

            if ( bIncOngoing && m_apConfInst[tMapData.GetInsId()-1]->m_tConf.m_tStatus.IsOngoing() )
            {
                byNum ++;

				LogPrint(LOG_LVL_DETAIL, MID_MCU_CFG, "[GetConfNum]OnGoing Conf Index(%d), Name(%s)\n",
					byNum, m_apConfInst[tMapData.GetInsId()-1]->m_tConf.GetConfName());
            }
            if ( bIncSched && m_apConfInst[tMapData.GetInsId()-1]->m_tConf.m_tStatus.IsScheduled() )
            {
                byNum ++;

				LogPrint(LOG_LVL_DETAIL, MID_MCU_CFG, "[GetConfNum]Sched Conf Index(%d), Name(%s)\n",
					byNum, m_apConfInst[tMapData.GetInsId()-1]->m_tConf.GetConfName());
            }
        }
        if ( bIncTempl && tMapData.IsTemUsed() )
		{
			if (byConfSource != ALL_CONF 
				&& m_ptTemplateInfo 
				&& m_ptTemplateInfo[tMapData.GetTemIndex()].m_tConfInfo.GetConfSource() != byConfSource)
			{
				break;
			}

			byNum ++;
		}            
	}

	return( byNum );
}

/*====================================================================
    函数名      ：GetConfAllMtInfo
    功能        ：得到指定索引位置的一个完整会议信息
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx：索引位置
				  TConfAllMtInfo * pConfAllMtInfo：传入的数据空间
    返回值说明  ：TRUE - 成功 FALSE - 不存在
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/08/12    3.0         胡昌威        创建
====================================================================*/
BOOL32 CMcuVcData::GetConfAllMtInfo( u8 byConfIdx, TConfAllMtInfo * pConfAllMtInfo ) const
{
    CHECK_CONFIDX(byConfIdx)

	if(pConfAllMtInfo == NULL )
	{
		return FALSE;
	}

    TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
	if( tMapData.IsValidConf() && m_apConfInst && m_apConfInst[tMapData.GetInsId() - 1] != NULL )
	{
		memcpy( pConfAllMtInfo, &m_apConfInst[tMapData.GetInsId() - 1]->m_tConfAllMtInfo, sizeof( TConfAllMtInfo ) );
		return TRUE;
	}

	return FALSE;
}

/*====================================================================
    函数名      ：GetConfMtTable
    功能        ：得到指定索引位置的一个会议终端表
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx：索引位置
				  TConfMtTable * ptMtTable：传入的数据空间
    返回值说明  ：TRUE - 成功 FALSE - 不存在
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/08    3.0         胡昌威        创建
====================================================================*/
BOOL32 CMcuVcData::GetConfMtTable( u8 byConfIdx, TConfMtTable * ptMtTable ) const
{
    CHECK_CONFIDX(byConfIdx)

	if( ptMtTable == NULL )
	{
		return FALSE;
	}

    TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
	if( tMapData.IsValidConf() && m_apConfInst && m_apConfInst[tMapData.GetInsId() - 1] != NULL )
	{
		memcpy( ptMtTable, m_apConfInst[tMapData.GetInsId() - 1]->m_ptMtTable, sizeof( TConfMtTable ) );
		return TRUE;
	}

    return FALSE;
}

/*====================================================================
    函数名      ：GetConfProtectInfo
    功能        ：得到指定索引位置的一个会议保护信息
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx：索引位置，为避免操作失误
				  TConfProtectInfo *tConfProtectInfo：传入的数据空间
    返回值说明  ：TRUE - 成功 FALSE - 不存在
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/08    3.0         胡昌威        创建
====================================================================*/
BOOL32 CMcuVcData::GetConfProtectInfo( u8 byConfIdx, TConfProtectInfo *ptConfProtectInfo ) const
{
    CHECK_CONFIDX(byConfIdx)
	
	if(ptConfProtectInfo == NULL )
	{
		return FALSE;
	}

    TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
	if( tMapData.IsValidConf() && m_apConfInst && m_apConfInst[tMapData.GetInsId() - 1] != NULL )
	{
		memcpy( ptConfProtectInfo, &m_apConfInst[tMapData.GetInsId() - 1]->m_tConfProtectInfo , sizeof( TConfProtectInfo ) );
		return TRUE;
	}

    return FALSE;
}

/*====================================================================
    函数名      ：GetConfMtTable
    功能        ：得到指定索引位置的一个会议终端表
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx：索引位置
    返回值说明  ：会议存在 - 会议终端表指针 会议不存在 - NULL
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/03/19    1.0         Qzj           创建
	03/11/08    3.0         胡昌威        修改
====================================================================*/
TConfMtTable * CMcuVcData::GetConfMtTable( u8 byConfIdx ) const
{
	if ( byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[DATA]: serious error occur in GetConfMtTable(), ConfIdx: %d \n", byConfIdx );
		return NULL;
	}

    TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
	if( tMapData.IsValidConf() && m_apConfInst && NULL != m_apConfInst[tMapData.GetInsId() - 1] )
	{
		return m_apConfInst[tMapData.GetInsId() - 1]->m_ptMtTable;
	}
	
	return NULL;

}

/*====================================================================
    函数名      ：GetConfSwitchTable
    功能        ：得到指定索引位置的一个会议交换信息
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx：索引位置，为避免操作失误
    返回值说明  ：会议存在 - 会议交换表指针 会议不存在 - NULL
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/08    3.0         胡昌威        创建
====================================================================*/
TConfSwitchTable * CMcuVcData::GetConfSwitchTable( u8 byConfIdx ) const
{
	if( byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX )
	{
		return NULL;
	}

    TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
    if( tMapData.IsValidConf() && m_apConfInst && NULL != m_apConfInst[tMapData.GetInsId() - 1] )
    {
        return m_apConfInst[tMapData.GetInsId() - 1]->m_ptSwitchTable;        
    }

	return NULL;
}

/*====================================================================
    函数名      ：GetConfEqpModule
    功能        ：得到指定索引位置的一个会议设备模板
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx：索引位置，为避免操作失误
    返回值说明  ：会议存在 - 会议交换表指针 会议不存在 - NULL
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/08    3.0         胡昌威        创建
====================================================================*/
TConfEqpModule *CMcuVcData::GetConfEqpModule( u8 byConfIdx ) const
{
    CHECK_CONFIDX(byConfIdx)
	
    TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
    if( tMapData.IsValidConf() &&  m_apConfInst && m_apConfInst[tMapData.GetInsId() - 1]!=NULL )
	{
		return &m_apConfInst[tMapData.GetInsId() - 1]->m_tConfEqpModule;
	}

	return NULL;
}

/*====================================================================
    函数名      ：GetConfAllMtInfo
    功能        ：得到指定索引位置的一个会议所有终端信息
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx：索引位置，为避免操作失误
    返回值说明  ：会议存在 - 会议交换表指针 会议不存在 - NULL
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/08    3.0         胡昌威        创建
====================================================================*/
TConfAllMtInfo *CMcuVcData::GetConfAllMtInfo( u8 byConfIdx ) const
{
    CHECK_CONFIDX(byConfIdx)

    TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
	if( tMapData.IsValidConf() && m_apConfInst &&  m_apConfInst[tMapData.GetInsId() - 1]!=NULL )
	{
		return &m_apConfInst[tMapData.GetInsId() - 1]->m_tConfAllMtInfo;
	}

	return NULL;
}

/*====================================================================
    函数名      ：GetConfProtectInfo
    功能        ：得到指定索引位置的一个会议保护信息
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx：索引位置，为避免操作失误
    返回值说明  ：会议存在 - 会议交换表指针 会议不存在 - NULL
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/08    3.0         胡昌威        创建
====================================================================*/
TConfProtectInfo *CMcuVcData::GetConfProtectInfo( u8 byConfIdx ) const
{
    CHECK_CONFIDX(byConfIdx)

    TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
	if( tMapData.IsValidConf() && m_apConfInst && m_apConfInst[tMapData.GetInsId() - 1]!=NULL )
	{
		return &m_apConfInst[tMapData.GetInsId() - 1]->m_tConfProtectInfo;
	}

	return NULL;
}
	
/*====================================================================
    函数名      ：SaveConfToFile
    功能        ：把会议存储到文件 
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx：索引位置
				ptConfStore 如果是修改模板就不为空，新增模板时为空，为了区分是修改和新增，
					因为修改时要把会议信息文件中的动态增长的数据拿出来(现在仅仅是vcs会议中的预案)
    返回值说明  ：操作成功 - TRUE  操作失败 - FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/08    3.0         胡昌威        修改
	09/11/02	4.6.1		周晶晶			修改
====================================================================*/
BOOL32 CMcuVcData::SaveConfToFile( u8 byConfIdx, BOOL32 bTemplate, BOOL32 bDefaultConf,TConfStore *ptOldConfStore )
{
	CHECK_CONFIDX(byConfIdx)
		
	TConfStore tConfStore;
	
	if (!bTemplate)
	{        
		if (m_atConfMapData[byConfIdx-MIN_CONFIDX].IsValidConf())
		{
			//get tConfInfo
			if (NULL == GetConfInstHandle(byConfIdx))
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[CMcuVcData]: GetConfInstHandle NULL! -- %d\n", byConfIdx);
				return FALSE;
			}

			CMcuVcInst* pcVcInst = GetConfInstHandle(byConfIdx);
			if (pcVcInst)
			{
				tConfStore.m_tConfInfo = pcVcInst->m_tConf;
			}
			//tConfStore.m_tConfInfo = *ptConfFullInfo;
			if (CONF_LOCKMODE_LOCK == tConfStore.m_tConfInfo.m_tStatus.GetProtectMode())
			{
				tConfStore.m_tConfInfo.m_tStatus.SetProtectMode(CONF_LOCKMODE_NONE);
			}

            //保存即时会议时，清空当前会议状态中的外设状态
            tConfStore.m_tConfInfo.m_tStatus.SetNoMixing();
            tConfStore.m_tConfInfo.m_tStatus.SetVACing(FALSE);
            tConfStore.m_tConfInfo.m_tStatus.SetNoPlaying();
            tConfStore.m_tConfInfo.m_tStatus.SetNoRecording();
            //不清模板中画面合成模式
            tConfStore.m_tConfInfo.m_tStatus.SetVMPMode(CONF_VMPMODE_NONE);
            tConfStore.m_tConfInfo.m_tStatus.SetVmpTwMode(CONF_VMPTWMODE_NONE);
            tConfStore.m_tConfInfo.m_tStatus.SetPollMode(CONF_POLLMODE_NONE);
			//[03/04/2010] zjl add (电视墙多通道轮询代码合并)
            //tConfStore.m_tConfInfo.m_tStatus.SetTvWallPollState(POLL_STATE_NONE);
            
            //zbq [09/24/2007] 保存即时会议，清空当前的BAS状态
            if ( tConfStore.m_tConfInfo.m_tStatus.IsAudAdapting() )
            {
                tConfStore.m_tConfInfo.m_tStatus.SetAdaptMode(ADAPT_MODE_AUD, FALSE);
            }
            if ( tConfStore.m_tConfInfo.m_tStatus.IsVidAdapting() )
            {
                tConfStore.m_tConfInfo.m_tStatus.SetAdaptMode(ADAPT_MODE_VID, FALSE);
            }
			if ( tConfStore.m_tConfInfo.m_tStatus.IsDSAdapting())
			{
				tConfStore.m_tConfInfo.m_tStatus.SetAdaptMode(ADAPT_MODE_SECVID, FALSE);
			}
//             if ( tConfStore.m_tConfInfo.m_tStatus.IsBrAdapting() )
//             {
//                 tConfStore.m_tConfInfo.m_tStatus.SetAdaptMode(CONF_BASMODE_BR, FALSE);
//             }
//             if ( tConfStore.m_tConfInfo.m_tStatus.IsCasdAudAdapting() )
//             {
//                 tConfStore.m_tConfInfo.m_tStatus.SetAdaptMode(CONF_BASMODE_CASDAUD, FALSE);
//             }
//             if ( tConfStore.m_tConfInfo.m_tStatus.IsCasdVidAdapting() )
//             {
//                 tConfStore.m_tConfInfo.m_tStatus.SetAdaptMode(CONF_BASMODE_CASDVID, FALSE);
//             }
// 清除高清适配状态, zgc, 2008-08-09
//             if ( tConfStore.m_tConfInfo.m_tStatus.IsHdVidAdapting() )
//             {
//                 tConfStore.m_tConfInfo.m_tStatus.SetHDAdaptMode(CONF_HDBASMODE_VID, FALSE);
//             }
            

			TConfEqpModule tConfEqpModule = *GetConfEqpModule(byConfIdx);

			THduVmpModuleOrTHDTvWall tHduVmpModule = tConfEqpModule.m_tHduVmpModuleOrHDTvWall;
			tConfStore.m_tMultiTvWallModule = tConfEqpModule.m_tMultiTvWallModule; 

			if( pcVcInst != NULL )
			{
				tConfStore.m_atVmpModule = pcVcInst->GetVmpModule();
			}

            tConfStore.EmptyAllTvMember();
            tConfStore.EmptyAllVmpMember();

			TVmpModuleInfo tVmpModuleINfo;
			if( NULL != pcVcInst )
			{
				memcpy(&tVmpModuleINfo,&(pcVcInst->m_tConfEqpModule.m_tVmpModuleInfo),sizeof(tVmpModuleINfo));
			}
			
			tVmpModuleINfo.EmptyAllVmpMember();

			//get alias array
            u8 byMemberType = 0;
			TMt tMt;
			TMtAlias tMtAlias;
			TConfMtTable *ptMtTable = GetConfMtTable(byConfIdx);
            // guzh [5/31/2007] 当级联时有跳过终端，需要另外保存索引
            u8 byStoreIdx = 0;
			for (u8 byLoop = 0; ptMtTable && byLoop < ptMtTable->m_byMaxNumInUse; byLoop++)
			{
				tMt = ptMtTable->GetMt(byLoop+1);
				if (!tMt.IsNull())
				{
					if (MT_TYPE_MMCU == tMt.GetMtType())
					{
						continue;
					}

                    //zbq [08/09/2007] 优先保存终端的呼叫别名；然后依次保存E164/H323ID，IP.
                    if (ptMtTable->GetDialAlias((byLoop+1), &tMtAlias))
                    {
						//缺省会议特殊保存别名逻辑[12/14/2012 chendaiwei]
						//IP,E164,H323入会的终端都保存成Ip+别名的呼叫方式。以解决PU电话主动呼入保存到缺省会议后
						//由于保存方式不是PU呼叫，导致该缺省会议无法呼叫该电话终端的问题
						if(bDefaultConf)
						{
							if((tMtAlias.m_AliasType == puAliasTypeIPPlusAlias ||
								tMtAlias.m_AliasType == mtAliasTypeE164 ||
								tMtAlias.m_AliasType == mtAliasTypeH323ID)
								&& (ptMtTable->GetIPAddr(byLoop+1)!=0)) //避免IP为0,即不上线的终端被当作PU类型[12/29/2012 chendaiwei]避免
							{
								s8 *pszIPAddr = NULL;
								if(tMtAlias.m_AliasType == puAliasTypeIPPlusAlias)
								{
									//IPPlusAlias呼叫 m_achAlias别名组成方式：U32(字符串形式存储)+Alias[12/7/2012 chendaiwei]
									pszIPAddr = (s8*)&tMtAlias.m_tTransportAddr.m_dwIpAddr;	
								}
								else
								{
									u32 dwIpAddr = htonl(ptMtTable->GetIPAddr(byLoop+1));
									pszIPAddr = (s8*)&dwIpAddr;
								}
								
								u32 dwAliasMaxSize = sizeof(tMtAlias.m_achAlias)-sizeof(u32);
								u32 dwActualAliasSize = strlen(tMtAlias.m_achAlias);
								memcpy(tConfStore.m_atMtAlias[byStoreIdx].m_achAlias,pszIPAddr,sizeof(u32));
								memcpy(&tConfStore.m_atMtAlias[byStoreIdx].m_achAlias[sizeof(u32)],tMtAlias.m_achAlias,min(dwAliasMaxSize,dwActualAliasSize));
								tConfStore.m_atMtAlias[byStoreIdx].m_AliasType = puAliasTypeIPPlusAlias;
							}
							// 							else if( tMtAlias.m_AliasType == mtAliasTypeTransportAddress)
							// 							{
							// 								TMtAlias tTmpAlias;
							// 								if (ptMtTable->GetMtAlias((byLoop+1), mtAliasTypeE164, &tTmpAlias)
							// 									|| ptMtTable->GetMtAlias((byLoop+1), mtAliasTypeH323ID, &tTmpAlias))
							// 								{
							// 									s8 *pszIPAddr = (s8*)&tMtAlias.m_tTransportAddr.m_dwIpAddr;
							// 									memcpy(tConfStore.m_atMtAlias[byStoreIdx].m_achAlias,pszIPAddr,sizeof(u32));
							// 									memcpy(&tConfStore.m_atMtAlias[byStoreIdx].m_achAlias[sizeof(u32)],tTmpAlias.m_achAlias,min(sizeof(tTmpAlias.m_achAlias)-sizeof(u32),strlen(tTmpAlias.m_achAlias)));
							// 									tConfStore.m_atMtAlias[byStoreIdx].m_AliasType = puAliasTypeIPPlusAlias;
							// 								}
							// 								else
							// 								{
							// 									tConfStore.m_atMtAlias[byStoreIdx] = tMtAlias;
							// 								}
							// 							}
							else
							{
								tConfStore.m_atMtAlias[byStoreIdx] = tMtAlias;
							}
						}
						else if(tMtAlias.m_AliasType == puAliasTypeIPPlusAlias)
						{
							//IPPlusAlias呼叫 m_achAlias别名组成方式：U32(字符串形式存储)+Alias[12/7/2012 chendaiwei]
							s8 *pszIPAddr = (s8*)&tMtAlias.m_tTransportAddr.m_dwIpAddr;

							u32 dwAliasMaxSize = sizeof(tMtAlias.m_achAlias)-sizeof(u32);
							u32 dwActualAliasSize = strlen(tMtAlias.m_achAlias);
							memcpy(tConfStore.m_atMtAlias[byStoreIdx].m_achAlias,pszIPAddr,sizeof(tMtAlias.m_tTransportAddr.m_dwIpAddr));
							memcpy(&tConfStore.m_atMtAlias[byStoreIdx].m_achAlias[sizeof(tMtAlias.m_tTransportAddr.m_dwIpAddr)],tMtAlias.m_achAlias,min(dwAliasMaxSize,dwActualAliasSize));
							tConfStore.m_atMtAlias[byStoreIdx].m_AliasType = puAliasTypeIPPlusAlias;
						}
						else
						{
							tConfStore.m_atMtAlias[byStoreIdx] = tMtAlias;
						}
                    }
                    else
                    {
                        //由于mtAliasTypeH320Alias类型不能用作呼叫信息，所以不进行保存
					    if (ptMtTable->GetMtAlias((byLoop+1), mtAliasTypeH320ID, &tMtAlias))
					    {
						    tConfStore.m_atMtAlias[byStoreIdx] = tMtAlias;
					    }
					    else if (ptMtTable->GetMtAlias((byLoop+1), mtAliasTypeE164, &tMtAlias))
					    {
						    tConfStore.m_atMtAlias[byStoreIdx] = tMtAlias;			
					    }
					    else if (ptMtTable->GetMtAlias((byLoop+1), mtAliasTypeH323ID, &tMtAlias))
                        {
                            tConfStore.m_atMtAlias[byStoreIdx] = tMtAlias;
					    }
					    else if (ptMtTable->GetMtAlias((byLoop+1), mtAliasTypeTransportAddress, &tMtAlias))
					    {
						    tConfStore.m_atMtAlias[byStoreIdx] = tMtAlias;
					    }
                    }

                    tConfStore.m_awMtDialBitRate[byStoreIdx] = ptMtTable->GetDialBitrate(byLoop+1);
            
					//更新模板映射关系
					TConfAttrb tTempConfAttrb = tConfStore.m_tConfInfo.GetConfAttrb();
					if (tTempConfAttrb.IsHasTvWallModule())
					{
						for(u8 byTvLp = 0; byTvLp < MAXNUM_PERIEQP_CHNNL; byTvLp++)
                        {                            
                            u8 byTvId = tConfEqpModule.m_tTvWallInfo[byTvLp].m_tTvWallEqp.GetEqpId();
							//zjl[20091208]会议模板新增设置在hdu预案中设置终端成员，索引上限更改为56
                            for(u8 byTvChlLp = 0; byTvChlLp < MAXNUM_TVWALL_CHNNL_INSMOUDLE; byTvChlLp++)
                            {
                                if(TRUE == tConfEqpModule.IsMtInTvWallChannel(byTvId, byTvChlLp, tMt, byMemberType) )
                                {
                                    tConfStore.SetMtInTvChannel(byTvId, byTvChlLp, byStoreIdx+1, byMemberType);
                                }
                            }
                        }
					}

					//子通道member从mtId转换成mtalias数组下标+1[3/8/2013 chendaiwei]					
					for( u8 byLoopChIdx = 0; byLoopChIdx <(HDUID_MAX-HDUID_MIN+1)*MAXNUM_HDU_CHANNEL;byLoopChIdx++)
					{
						for(u8 byLoopSubIdx = 0; byLoopSubIdx <HDU_MODEFOUR_MAX_SUBCHNNUM; byLoopSubIdx++)
						{
							if(tConfEqpModule.IsMtInHduVmpChnnl(byLoopChIdx,byLoopSubIdx,tMt))
							{
								tHduVmpModule.SetHduVmpSubChnlMember(byLoopChIdx,byLoopSubIdx,byStoreIdx+1);
							}
						}
					}

					if (tTempConfAttrb.IsHasVmpModule())
					{
                        for (u8 byVmpIdx = 0; byVmpIdx < MAXNUM_MPU2VMP_MEMBER; byVmpIdx++)
                        {
                            if( tConfEqpModule.IsMtAtVmpChannel(byVmpIdx, tMt, byMemberType) )
						    {
								if( byVmpIdx < MAXNUM_MPUSVMP_MEMBER)
								{
									tConfStore.m_atVmpModule.SetVmpMember(byVmpIdx, byStoreIdx+1, byMemberType);
								}
								else
								{
									tVmpModuleINfo.m_abyMemberType[byVmpIdx] = byMemberType;
									tVmpModuleINfo.m_abyVmpMember[byVmpIdx] = byStoreIdx+1;
								}
						    }
                        }
					}            
                    byStoreIdx ++;
				}                
			}
            tConfStore.m_byMtNum = byStoreIdx;

			u16 wPackConfExInfoLength = 0;
#ifdef _UTF8			
			u8 byEncoding = emenCoding_Utf8;// lang:新版本直接把UTF8写进去 [pengguofeng 4/12/2013]
#endif
			if(pcVcInst)
			{
				// 多国语言:mcs模板则保存编码标志 [pengguofeng 4/12/2013]
#ifdef _UTF8
				if ( pcVcInst->m_tConf.GetConfSource() == MCS_CONF )
				{
					LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[SaveConfToFile]Mcs conf%d[non template] need to set UTF8 to file\n",
						byConfIdx);
					PackConfInfoEx(pcVcInst->m_tConfEx,(u8*)&tConfStore.m_byConInfoExBuf[0],wPackConfExInfoLength,
						&tHduVmpModule,&tVmpModuleINfo, &byEncoding);
				}
				else
#endif
				{
#ifdef _UTF8
					LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[SaveConfToFile]Vcs conf%d[non template] not need to set UTF8 to file\n",
						byConfIdx);
#endif
					PackConfInfoEx(pcVcInst->m_tConfEx,(u8*)&tConfStore.m_byConInfoExBuf[0],wPackConfExInfoLength,
						&tHduVmpModule,&tVmpModuleINfo);
				}
			}
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		if(!m_atConfMapData[byConfIdx-MIN_CONFIDX].IsTemUsed())
		{
			return FALSE;
		}
        // zbq [09/06/2007] 所有模板信息保存清空bFromFile
        u8 bySaveTmpIdx = m_atConfMapData[byConfIdx-MIN_CONFIDX].GetTemIndex();
		if(m_ptTemplateInfo)
		{
			m_ptTemplateInfo[bySaveTmpIdx].m_tConfInfo.m_tStatus.SetTakeFromFile(FALSE);
			// 待拷贝会议信息 [pengguofeng 4/12/2013]
			TConfStore tTempConfStore = (TConfStore)m_ptTemplateInfo[bySaveTmpIdx];
			// 多国语言:mcs模板则保存编码标志 [pengguofeng 4/12/2013]
#ifdef _UTF8
			if ( m_ptTemplateInfo[bySaveTmpIdx].m_tConfInfo.GetConfSource() == MCS_CONF )
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[SaveConfToFile]Mcs conf:%d[template] need to set UTF8 to file\n",
					byConfIdx);
				u8 byEncoding = 0;// lang:新版本直接把UTF8写进去 [pengguofeng 4/12/2013]
				TConfInfoEx tConfInfoEx;
				THduVmpModuleOrTHDTvWall tHduVmpModule;
				TVmpModuleInfo tVmpModule;
				u16 wPackConfExInfoLength = 0;
				BOOL32 bUnkownConfInfo;
				UnPackConfInfoEx(tConfInfoEx, tTempConfStore.m_byConInfoExBuf, wPackConfExInfoLength,
					bUnkownConfInfo, &tHduVmpModule, &tVmpModule, &byEncoding);
				if ( byEncoding != emenCoding_Utf8 )
				{
					// lang:非UTF8的值，再Pack成UTF8写到文件中去 [pengguofeng 4/12/2013]
					byEncoding = emenCoding_Utf8;
					PackConfInfoEx(tConfInfoEx, tTempConfStore.m_byConInfoExBuf, wPackConfExInfoLength,
						&tHduVmpModule, &tVmpModule, &byEncoding);
				}
			}
			else
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[SaveConfToFile]Vcs conf%d[template] not need to set UTF8 to file\n",
					byConfIdx);
			}
#endif
			memcpy(&tConfStore, &tTempConfStore, sizeof(TConfStore));
		}
	}

	return AddConfToFile(tConfStore, bDefaultConf,ptOldConfStore);
}

/*====================================================================
    函数名      ：RemoveConfFromFile
    功能        ：从文件删除会议
    算法实现    ：
    引用全局变量：
    输入参数说明：CConfId cConfId 要删除的会议号
    返回值说明  ：操作成功 - TRUE  操作失败 - FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/08    3.0         胡昌威        修改
====================================================================*/
BOOL32 CMcuVcData::RemoveConfFromFile( CConfId cConfId )
{
	if (cConfId.IsNull())
	{
		return FALSE;
	}

	return DeleteConfFromFile(cConfId);
}

/*====================================================================
    函数名      ：GetConfFullInfo
    功能        ：得到指定索引位置的一个完整会议信息
    算法实现    ：
    引用全局变量：
    输入参数说明：[IN]  u8 byConfIdx：索引位置
	              [IN]  TPackConfStore *ptPackConfStore 大小为预留的 sizeof(TConfStore)
    返回值说明  ：操作成功 - TRUE  操作失败 - FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/08    3.0         胡昌威        修改
====================================================================*/
BOOL32 CMcuVcData::GetConfFromFile( u8 byConfIdx, TPackConfStore *ptPackConfStore )
{
    return ::GetConfFromFile((byConfIdx-MIN_CONFIDX), ptPackConfStore);
}

/*=============================================================================
  函 数 名： InitPeriDcsList
  功    能： 初始化DCS列表：代理支持不够，目前直接构造初始结构
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： void 
  -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2005/12/15    4.0			张宝卿                  创建
=============================================================================*/
void CMcuVcData::InitPeriDcsList()
{
	u8  byDcsId = 0;
	memset( m_atPeriDcsTable, 0, sizeof(m_atPeriDcsTable) );
	
    for ( byDcsId = 1; byDcsId <= MAXNUM_MCU_DCS; byDcsId ++ )
    {
        if ( 0 != g_cMcuAgent.GetDcsIp() )
        {
            m_atPeriDcsTable[byDcsId-1].m_bIsValid = TRUE;
            m_atPeriDcsTable[byDcsId-1].m_tDcsStatus.SetType( TYPE_MCUPERI );
            m_atPeriDcsTable[byDcsId-1].m_tDcsStatus.SetEqpType( EQP_TYPE_DCS );
            m_atPeriDcsTable[byDcsId-1].m_tDcsStatus.SetEqpId(byDcsId);
            m_atPeriDcsTable[byDcsId-1].m_tDcsStatus.SetMcuId(LOCAL_MCUID);        
            m_atPeriDcsTable[byDcsId-1].m_tDcsStatus.m_byOnline = FALSE;
            
            //MCU给DCS主动构造别名
            g_cMcuVcApp.SetDcsAlias( byDcsId );
            m_atPeriDcsTable[byDcsId-1].m_tDcsStatus.SetDcsAlias(g_cMcuVcApp.GetDcsAlias(byDcsId));
        }        
    }
    return;
}

/*=============================================================================
  函 数 名： SetPeriDcsConnected
  功    能： 设置DCS的连接状态
  算法实现： 
  全局变量： 
  参    数：  u8 byDcsId
             BOOL32 bConnected
  返 回 值： void 
  -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2005/12/15    4.0			张宝卿                  创建
=============================================================================*/
void CMcuVcData::SetPeriDcsConnected( u8 byDcsId, BOOL32 bConnected )
{
	if( byDcsId == 0 || byDcsId > MAXNUM_MCU_DCS )
	{
		return;
	}	
	m_atPeriDcsTable[byDcsId-1].m_tDcsStatus.m_byOnline = bConnected;
	
	return;
}

/*=============================================================================
  函 数 名： IsPeriDcsConnected
  功    能： 判断DCS是否连接
  算法实现： 
  全局变量： 
  参    数： u8 byDcsId
  返 回 值： BOOL32 
  -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2005/12/15    4.0			张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsPeriDcsConnected( u8 byDcsId )
{
	if( byDcsId == 0 || byDcsId > MAXNUM_MCU_DCS )
	{
		return FALSE;
	}
	return( m_atPeriDcsTable[byDcsId - 1].m_tDcsStatus.m_byOnline );
}

/*=============================================================================
  函 数 名： SetPeriDcsValid
  功    能： 设置DCS配置状态
  算法实现： 
  全局变量： 
  参    数： u8 byDcsId
  返 回 值： void 
  -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2005/12/26    4.0			张宝卿                  创建
=============================================================================*/
void CMcuVcData::SetPeriDcsValid( u8 byDcsId )
{
    if( byDcsId == 0 || byDcsId > MAXNUM_MCU_DCS )
	{
		return;
	}

	m_atPeriDcsTable[byDcsId-1].m_bIsValid = TRUE;
}

/*=============================================================================
  函 数 名： IsPeriDcsValid
  功    能： 判断DCS是否配置
  算法实现： 
  全局变量： 
  参    数： u8 byDcsId
  返 回 值： BOOL32 
  -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2005/12/15    4.0			张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsPeriDcsValid( u8 byDcsId )
{
    if( byDcsId == 0 || byDcsId > MAXNUM_MCU_DCS )
	{
		return FALSE;
	}

	return m_atPeriDcsTable[byDcsId-1].m_bIsValid;
}

/*=============================================================================
  函 数 名： SetDcsAlias
  功    能： 设置DCS的别名
  算法实现： 
  全局变量： 
  参    数：  u8 byDcsId
             LPCSTR lpszDcsAlias
  返 回 值： void 
  -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2005/12/15    4.0			张宝卿                  创建
=============================================================================*/
void CMcuVcData::SetDcsAlias( u8 byDcsId )
{
	if( byDcsId == 0 || byDcsId > MAXNUM_MCU_DCS )
	{
		return;
	}
	s8 achDcsName[MAXLEN_EQP_ALIAS];
	sprintf( achDcsName, "%s%d", "dcs", byDcsId );
	m_atPeriDcsTable[byDcsId-1].m_tDcsStatus.SetDcsAlias( achDcsName );
}

/*=============================================================================
  函 数 名： GetDcsAlias
  功    能： 获得DCS的别名
  算法实现： 
  全局变量： 
  参    数： u8 byDcsId
  返 回 值： LPCSTR 
  -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2005/12/15    4.0			张宝卿                  创建
=============================================================================*/
LPCSTR CMcuVcData::GetDcsAlias( u8 byDcsId )
{
	if( byDcsId == 0 || byDcsId > MAXNUM_MCU_DCS )
	{
		return NULL;
	}
	return m_atPeriDcsTable[byDcsId-1].m_tDcsStatus.GetDcsAlias();
}

/*=============================================================================
  函 数 名： IsDcsConfiged
  功    能： DCS是否配置了
  算法实现： 目前代理只支持一个DCS
  全局变量： 
  参    数： u32 dwDcsIp
  返 回 值： BOOL32 
  -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2006/1/10    4.0			张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsPeriDcsConfiged( u32 dwDcsIp )
{
	for( s32 nIndex = 0; nIndex < MAXNUM_MCU_DCS; nIndex ++ )
	{
		if ( dwDcsIp ==  ntohl(g_cMcuAgent.GetDcsIp()) )
		{
			return TRUE;
		}
	}
	return FALSE;
}


/*=============================================================================
    函数名      ：GetPeriDcsStatus
    功能        ：获得DCS的状态
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byDcsId：DCS ID
				  TPeriDcsStatus * ptStatus, 返回的DCS状态
    返回值说明  ：无
-------------------------------------------------------------------------------
    修改记录    ：
    日  期       版本           修改人                修改内容
    2006/6/12    4.0			张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetPeriDcsStatus( u8 byDcsId, TPeriDcsStatus * ptStatus )
{
	if( byDcsId == 0 || byDcsId > MAXNUM_MCU_DCS || NULL == ptStatus )
	{
		return FALSE;
	}

	*ptStatus = m_atPeriDcsTable[byDcsId - 1].m_tDcsStatus;

	return TRUE;
}

/*=============================================================================
    函数名      ：SetPeriDcsStatus
    功能        ：设置DCS的状态
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byDcsId：DCS ID
				  TPeriDcsStatus * ptStatus
    返回值说明  ：无
-------------------------------------------------------------------------------
    修改记录    ：
    日  期       版本           修改人                修改内容
    2006/6/12    4.0			张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetPeriDcsStatus( u8 byDcsId, const TPeriDcsStatus * ptStatus )
{
	if( byDcsId == 0 || byDcsId > MAXNUM_MCU_DCS || NULL == ptStatus )
	{
		return FALSE;
	}

	m_atPeriDcsTable[byDcsId - 1].m_tDcsStatus = *ptStatus;
    return TRUE;
}

/*=============================================================================
    函数名      ：GetDcs
    功能        ：获得DCS结构体
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byDcsId：DCS ID
    返回值说明  ：TEqp
-------------------------------------------------------------------------------
    修改记录    ：
    日  期       版本           修改人                修改内容
    2006/6/12    4.0			张宝卿                  创建
=============================================================================*/
TEqp CMcuVcData::GetDcs( u8 byDcsId )
{
    TEqp tEqp;
    tEqp.SetNull();
    if( byDcsId == 0 || byDcsId > MAXNUM_MCU_DCS || !IsPeriDcsValid( byDcsId ) )
    {
        return tEqp;
    }
    
    return (TEqp)m_atPeriDcsTable[byDcsId-1].m_tDcsStatus;
}

/*====================================================================
    函数名      ：SetPeriEqpConnected
    功能        ：设置外设连接状态
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byEqpId, 外设 ID
				  BOOL32 bConnected, 是否连接
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/04/06    1.0         杨昀         创建
====================================================================*/
void CMcuVcData::SetPeriEqpConnected( u8 byEqpId, BOOL32 bConnected, BOOL32 bIsValid )
{
	if( byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP )
	{
		return;
	}

	m_atPeriEqpTable[byEqpId - 1].m_bIsValid = bIsValid;
	m_atPeriEqpTable[byEqpId - 1].m_tPeriEqpStatus.m_byOnline = bConnected;

	UpdateAgentEqpStat(m_atPeriEqpTable[byEqpId - 1].m_tPeriEqpStatus.GetEqpType());

	return;
}

/*====================================================================
    函数名      ：SetPeriEqpLogicChnnl
    功能        ：设置外设的逻辑通道
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byEqpId, 外设 ID
				  u8 byMediaType, 媒体类型
				  u8 byChnnlNum, MCU至外设通道数
				  TLogicalChannel * ptChnnl, 逻辑通道配置
				  BOOL32 bForwardChnnl, 流向
    输出参数说明：无
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/04/06    1.0         杨昀         创建
====================================================================*/
void CMcuVcData::SetPeriEqpLogicChnnl( u8 byEqpId, u8 byMediaType, u8 byChnnlNum, const TLogicalChannel * ptStartChnnl, BOOL32 bForwardChnnl )
{
	if( byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP || NULL == ptStartChnnl )
	{
		return ;
	}

	switch( byMediaType )
	{
	case MODE_VIDEO:
		if( bForwardChnnl )
		{
			m_atPeriEqpTable[byEqpId - 1].m_byFwdChannelNum = byChnnlNum;
			m_atPeriEqpTable[byEqpId - 1].m_tFwdVideoChannel = *ptStartChnnl;
		}
		else
		{
			m_atPeriEqpTable[byEqpId - 1].m_byRvsChannelNum = byChnnlNum;
			m_atPeriEqpTable[byEqpId - 1].m_tRvsVideoChannel = *ptStartChnnl;
		}
		break;
	case MODE_AUDIO:
		if( bForwardChnnl )		
		{
			m_atPeriEqpTable[byEqpId - 1].m_byFwdChannelNum = byChnnlNum;
			m_atPeriEqpTable[byEqpId - 1].m_tFwdAudioChannel = *ptStartChnnl;
		}
		else
		{
			m_atPeriEqpTable[byEqpId - 1].m_byRvsChannelNum = byChnnlNum;
			m_atPeriEqpTable[byEqpId - 1].m_tRvsAudioChannel = *ptStartChnnl;
		}
		break;
	default:
		LogPrint(LOG_LVL_ERROR, MID_MCU_EQP, "Exception - CMcuVcData::SetPeriEqpLogicChnnl(): wrong Mode %u!\n", byMediaType );
		break;
	}
	return;

}

/*====================================================================
    函数名      ：SetPeriEqpStatus
    功能        ：设置外设状态
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byEqpId, 外设 ID
				  const TPeriEqpStatus * ptStatus, 外设状态
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/10    1.0         杨昀         创建
====================================================================*/
void CMcuVcData::SetPeriEqpStatus( u8 byEqpId, const TPeriEqpStatus * ptStatus )
{
	if( byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP || NULL == ptStatus )
	{
		return ;
	}
	
	m_atPeriEqpTable[byEqpId - 1].m_tPeriEqpStatus = *ptStatus;
	UpdateAgentEqpStat(ptStatus->GetEqpType());
}

/************************************************************************/
/* 适配器状态信息的读写处理                                             */
/************************************************************************/
/*====================================================================
    函数名      ：SetBasChanStatus
    功能        ：设置BAS通道状态
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byEqpId, 外设 ID
				  u8 byChanNo, EBasStatus eStatus
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/09/07    4.0         libo          创建
====================================================================*/
//modify bas 2
void CMcuVcData::SetBasChanStatus(u8 byEqpId, u8 byChanNo, u8 byStatus)
{
	if (0 == byEqpId || byEqpId > MAXNUM_MCU_PERIEQP || byChanNo > MAXNUM_BAS_CHNNL)
	{
		return;
	}

    TBasStatus *ptBasStatus;
    ptBasStatus = &m_atPeriEqpTable[byEqpId - 1].m_tPeriEqpStatus.m_tStatus.tBas;
    ptBasStatus->tChnnl[byChanNo].SetStatus(byStatus);

	UpdateAgentEqpStat(EQP_TYPE_BAS);
}

/*====================================================================
    函数名      ：SetBasChanReserved
    功能        ：设置BAS通道预留情况
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byEqpId, 外设 ID
				  u8 byChanNo, EBasStatus eStatus
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/09/07    4.0         libo          创建
====================================================================*/
void CMcuVcData::SetBasChanReserved(u8 byEqpId, u8 byChanNo, BOOL32 bReserved)
{
    if (0 == byEqpId || byEqpId > MAXNUM_MCU_PERIEQP || byChanNo > MAXNUM_BAS_CHNNL)
	{
		return;
	}

    TBasStatus *ptBasStatus;
    ptBasStatus = &m_atPeriEqpTable[byEqpId - 1].m_tPeriEqpStatus.m_tStatus.tBas;
    ptBasStatus->tChnnl[byChanNo].SetReserved(bReserved);
	UpdateAgentEqpStat(EQP_TYPE_BAS);
}

/*====================================================================
    函数名      ：SetMcConnected
    功能        ：设置MC连接状态
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wMcInstId, 会议控制台实例号
				  BOOL32 bConnected, 是否连接
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/04/06    1.0         杨昀         创建
====================================================================*/
void CMcuVcData::SetMcConnected( u16 wMcInstId, BOOL32 bConnected )
{
	if( wMcInstId == 0 || wMcInstId > (MAXNUM_MCU_MC + MAXNUM_MCU_VC) )
	{
		return;
	}

	m_atMcTable[wMcInstId-1].m_bConnected = bConnected;

	return;
}

/*====================================================================
    函数名      ：SetMcConnected
    功能        ：设置MC连接状态
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wMcInstId, 会议控制台实例号
				  BOOL32 bConnected, 是否连接
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/04/06    1.0         杨昀         创建
====================================================================*/
void CMcuVcData::SetMcsRegInfo( u16 wMcInstId, TMcsRegInfo tMcsRegInfo )
{
	if( wMcInstId == 0 || wMcInstId > (MAXNUM_MCU_MC + MAXNUM_MCU_VC) )
	{
		return;
	}

	m_atMcTable[wMcInstId-1].m_tMcsRegInfo = tMcsRegInfo;
}

/*====================================================================
    函数名      ：SetMcConnected
    功能        ：设置MC连接状态
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wMcInstId, 会议控制台实例号
				  BOOL32 bConnected, 是否连接
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/04/06    1.0         杨昀         创建
====================================================================*/
BOOL32 CMcuVcData::GetMcsRegInfo( u16 wMcInstId, TMcsRegInfo *ptMcsRegInfo )
{
	if( wMcInstId == 0 || wMcInstId > (MAXNUM_MCU_MC + MAXNUM_MCU_VC) || ptMcsRegInfo == NULL )
	{
		return FALSE;
	}

	*ptMcsRegInfo = m_atMcTable[wMcInstId-1].m_tMcsRegInfo;
	return TRUE;
}

/*====================================================================
    函数名      ：SetMcLogicChnnl
    功能        ：设置MC的逻辑通道
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wMcInstId, MC号
				  u8 byMediaType, 媒体类型
				  u8 byChnnlNum, MCU至MC通道数
				  TLogicalChannel * ptStartChnnl, 逻辑通道配置
    输出参数说明:		无
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/04/06    1.0         杨昀         创建
====================================================================*/
void CMcuVcData::SetMcLogicChnnl( u16 wMcInstId, u8 byMediaType, u8 byChnnlNum, const TLogicalChannel * ptStartChnnl )
{
	if( wMcInstId == 0 || wMcInstId > (MAXNUM_MCU_MC + MAXNUM_MCU_VC) || NULL == ptStartChnnl )
	{
		return ;
	}

	switch( byMediaType )
	{
	case MODE_VIDEO:
		m_atMcTable[ wMcInstId-1 ].m_tFwdVideoChannel = *ptStartChnnl;
		break;
	case MODE_AUDIO:
		m_atMcTable[ wMcInstId-1 ].m_tFwdAudioChannel = *ptStartChnnl;
		break;
	case MODE_SECVIDEO:
		m_atMcTable[ wMcInstId-1 ].m_tFwdDualChannel = *ptStartChnnl;
		break;
	default:
		LogPrint(LOG_LVL_ERROR, MID_MCU_MCS, "Exception - CMcuVcData::SetMcLogicChnnl(): wrong Mode %u!\n", byMediaType );
		break;
	}
	m_atMcTable[ wMcInstId-1 ].m_byFwdChannelNum = byChnnlNum;

	return;	
}


/*====================================================================
    函数名      ：SetMcSrc
    功能        ：设置MC的发送/接收视频或音频源
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wMcInstId, MC号
				  TMt * ptSrc, 终端源
				  u8 byChnnlNo, 通道号
				  u8 byMode, 流模式MODE_VIDEO/MODE_AUDIO
    返回值说明  ：none
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/04/06    1.0         杨昀         创建
====================================================================*/
void CMcuVcData::SetMcSrc( u16 wMcInstId, const TMt * ptSrc, u8 byChnnlNo, u8 byMode )
{
	if( wMcInstId == 0 || wMcInstId > (MAXNUM_MCU_MC + MAXNUM_MCU_VC) || NULL == ptSrc || byChnnlNo >= MAXNUM_MC_CHANNL )
	{
		return ;
	}

	switch( byMode )
	{
	case MODE_VIDEO:
		m_atMcTable[ wMcInstId-1 ].m_atVidSrc[byChnnlNo] = *ptSrc;
		break;
	case MODE_AUDIO:
		m_atMcTable[ wMcInstId-1 ].m_atAudSrc[byChnnlNo] = *ptSrc;
		break;
	case MODE_BOTH:
		m_atMcTable[ wMcInstId-1 ].m_atVidSrc[byChnnlNo] = *ptSrc;	
		m_atMcTable[ wMcInstId-1 ].m_atAudSrc[byChnnlNo] = *ptSrc;
		break;
	case MODE_SECVIDEO:
		m_atMcTable[ wMcInstId-1 ].m_atSecVidSrc[byChnnlNo] = *ptSrc;
		break;
	default:
		LogPrint(LOG_LVL_ERROR, MID_MCU_MCS, "Exception - CMcuVcData::SetMcSrc(): wrong Mode %u!\n", byMode );
		break;
	}

	return;
}

/*====================================================================
    函数名      ：SetPeriEqpSrc
    功能        ：设置PeriEqp的发送/接收视频或音频源
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 periEqpId, Eqp号
				  TMt * ptSrc, 终端源
				  u8 byChnnlNo, 通道号
				  u8 byMode, 流模式MODE_VIDEO/MODE_AUDIO
    返回值说明  ：none
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/30    1.0         JQL           创建
====================================================================*/
void CMcuVcData::SetPeriEqpSrc( u8 byEqpId, const TMt * ptSrc, u8 byChnnlNo, u8 byMode )
{
	
	if( byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP 
		|| NULL == ptSrc || byChnnlNo >= MAXNUM_PERIEQP_CHNNL )
	{
		return ;
	}

	switch( byMode )
	{
	case MODE_VIDEO:
	case MODE_SECVIDEO:		//[2011/08/12/zhangli]外设接收双流源的信息放在video里，没有通道同时接收两种模式码流
		m_atPeriEqpTable[ byEqpId - 1 ].m_atVidSrc[byChnnlNo] = *ptSrc;
		break;
	case MODE_AUDIO:
		m_atPeriEqpTable[ byEqpId - 1 ].m_atAudSrc[byChnnlNo] = *ptSrc;
		break;
	case MODE_BOTH:
		m_atPeriEqpTable[ byEqpId - 1 ].m_atVidSrc[byChnnlNo] = *ptSrc;
		m_atPeriEqpTable[ byEqpId - 1 ].m_atAudSrc[byChnnlNo] = *ptSrc;
		break;
	default:
		LogPrint(LOG_LVL_ERROR, MID_MCU_EQP, "Exception - CMcuVcData::SetMcSrc(): wrong Mode %u!\n", byMode );
		break;
	}

	return;
}


/*====================================================================
    函数名      ：AddMp
    功能        ：增加一个Mp
    算法实现    ：
    引用全局变量：
    输入参数说明：tMp Mp信息
    返回值说明  ：成功TRUE,失败FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
====================================================================*/
BOOL32 CMcuVcData::AddMp( TMp tMp )
{
    if (0 == tMp.GetMpId() || tMp.GetMpId() > MAXNUM_DRI)
    {
        return FALSE;
    }

    m_atMpData[tMp.GetMpId() - 1].m_bConnected = TRUE;
	m_atMpData[tMp.GetMpId() - 1].m_tMp = tMp; 
    
    // guzh [1/17/2007] 根据MP类型确定其码流限制的能力
    u16 wMaxBand  = 0;
    u32 dwMaxPkNum = 0;
#ifdef _MINIMCU_
    // 对于8000B，要区分 MPC/MDSC/HDSC
    if ( tMp.GetAttachMode() == 1 )
    {
        wMaxBand = g_cMcuVcApp.GetPerfLimit().m_wMpcMaxMpAbility;
        dwMaxPkNum = g_cMcuVcApp.GetPerfLimit().m_dwMpcMaxPkNum;
    }
    else
    {
        // 为了防止用户配置错误，直接采用内部默认值
        u8 byType = g_cMcuAgent.GetRunBrdTypeByIdx( tMp.GetMpId() );
        if ( byType == 0xFF )
        {
            wMaxBand = 0;
            dwMaxPkNum = 0;
        }
        else if ( byType == BRD_TYPE_HDSC/*DSL8000_BRD_HDSC*/ )
        {
            wMaxBand = MAXLIMIT_CRI_MP_HDSC;
            dwMaxPkNum = MAXLIMIT_CRI_MP_HDSC_PMNUM * 1024;
        }
        else
        {
            wMaxBand = MAXLIMIT_CRI_MP_MDSC;
            dwMaxPkNum = MAXLIMIT_CRI_MP_MDSC_PMNUM * 1024;
        }
    }
#else
    if ( tMp.GetAttachMode() == 1 )
    {
        wMaxBand = g_cMcuVcApp.GetPerfLimit().m_wMpcMaxMpAbility;
        dwMaxPkNum = g_cMcuVcApp.GetPerfLimit().m_dwMpcMaxPkNum;
    }
    else
    {
        wMaxBand = g_cMcuVcApp.GetPerfLimit().m_wCriMaxMpAbility;
        dwMaxPkNum = g_cMcuVcApp.GetPerfLimit().m_dwCriMaxPkNum;
			//zhouyiliang 20101208 对于IS2.2，DRI2,CRI2板子支持256PM和512MB
		//CRI板还是保持60PM和120MB
	#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)//8000G转发板都是内置
		u8 byType = g_cMcuAgent.GetRunBrdTypeByIdx( tMp.GetMpId() );

		u8 byBrdId = g_cMcuAgent.GetBrdIdbyIpAddr(tMp.GetIpAddr());
		TBoardInfo tBrdInfo;
		g_cMcuAgent.GetBrdCfgById(byBrdId,&tBrdInfo);

		switch( byType ) 
		{
			case BRD_TYPE_IS22:
				wMaxBand = MAXLIMIT_CRI_MP_EX ;
				dwMaxPkNum = MAXLIMIT_CRI_MP_PMNUM_EX*1024;
				break;

			case BRD_TYPE_CRI2:     
			//case BRD_TYPE_DRI2:
				//如果不是默认值（通过配置文件来的）,不处理
				if( tBrdInfo.GetPortChoice() == 0 )
				{
					wMaxBand = MAXLIMIT_CRI_MP_EX ;
					dwMaxPkNum = MAXLIMIT_CRI_MP_PMNUM_EX*1024;
				}
				break;
			case BRD_TYPE_CRI:
			case BRD_TYPE_DRI:
				//保持 do nothing 
				break;
			//  [1/21/2011 chendaiwei] Fix me: CRI2,DRI2的处理
			default:
				break;
		}
	#endif

    }
#endif
    m_atMpData[tMp.GetMpId()-1].m_wNetBandAllowed = wMaxBand;
    m_atMpData[tMp.GetMpId()-1].m_dwPkNumAllowed = dwMaxPkNum;

	return TRUE;
}

/*====================================================================
    函数名      ：RemoveMp
    功能        ：移除Mp
    算法实现    ：
    引用全局变量：
    输入参数说明：byMpId Mp编号	          
    返回值说明  ：成功TRUE,失败FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
====================================================================*/
BOOL32 CMcuVcData::RemoveMp( u8 byMpId )
{
	if(!IsMpConnected(byMpId))
	{
		return FALSE;
	}

    m_atMpData[byMpId - 1].m_bConnected = FALSE;
	memset( &m_atMpData[byMpId - 1].m_tMp, 0, sizeof(TMp) );
    m_atMpData[byMpId - 1].m_wMtNum = 0;
    memset( m_atMpData[byMpId - 1].m_abyMtId, 0, sizeof(m_atMpData[byMpId - 1].m_abyMtId) );
    m_atMpData[byMpId - 1].m_wNetBandAllowed = 0;

	return TRUE;
}

/*====================================================================
    函数名      ：ReAssignMpForEqp
    功能        ：为指定外设重新配置转发板
    算法实现    ：1)为保证外设使用期间无需重新建桥，采取直接分配当前转发板
	              的下一跳在线转发板为新的转发板
				  2)该外设所用新转发板信息告知外设端立刻启用，mpc侧内存对应
				  信息也同步更新，告知界面，但不保存配置文件,仅为运行时灵活
				  应变转发板掉线，重启后仍遵从用户选择，手动负载均衡
    引用全局变量：
    输入参数说明：          
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/10/15    3.0         付秀华        创建
====================================================================*/
void CMcuVcData::ReAssignMpForEqp(u8 byEqpId)
{
	TPeriEqpStatus tPeriEqpStatus;
	if( !GetPeriEqpStatus(byEqpId , &tPeriEqpStatus) )
	{
		return;
	}
	u8 byBasType = 0;
	if ( GetEqpType(byEqpId) == EQP_TYPE_BAS)
	{
		if (  g_cMcuAgent.IsEqpBasAud(byEqpId) )
		{
			byBasType = tPeriEqpStatus.m_tStatus.tAudBas.GetEqpType();
		}
		else if (  g_cMcuAgent.IsEqpBasHD(byEqpId) )
		{
			byBasType =  tPeriEqpStatus.m_tStatus.tHdBas.GetEqpType();
		}
	}
	// 目前只对MPU VMP进行支持,追加MPU2的vmp支持
	if ((GetEqpType(byEqpId) == EQP_TYPE_VMP && (MPU_SVMP == tPeriEqpStatus.m_tStatus.tVmp.m_bySubType ||
												 MPU2_VMP_BASIC == tPeriEqpStatus.m_tStatus.tVmp.m_bySubType ||
												 MPU2_VMP_ENHACED == tPeriEqpStatus.m_tStatus.tVmp.m_bySubType))
	  	|| (GetEqpType(byEqpId) == EQP_TYPE_BAS && (TYPE_MPU == byBasType ||
		                                            TYPE_MPU_H == byBasType||
													TYPE_MPU2_BASIC == byBasType ||
		                                            TYPE_MPU2_ENHANCED == byBasType ||
													TYPE_APU2_BAS == byBasType
													)
			)
	 	|| (GetEqpType(byEqpId) == EQP_TYPE_MIXER))
	{
		u8  byOldMpId = g_cMcuAgent.GetEqpSwitchBrdId(byEqpId);
		u8  byNewMpId   = GetNextValidMp(byOldMpId);
		u32 dwNewIpAddr = GetMpIpAddr(byNewMpId);
		if (byNewMpId <= MAXNUM_DRI)
		{
			LogPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ReAssignMpForEqp]Assign new mp(id:%d), ip%s, for eqp(id:%d)\n",
				   byNewMpId, StrOfIP(dwNewIpAddr), byEqpId);
			g_cMcuAgent.SetEqpSwitchBrdId(byEqpId, byNewMpId);
			
			m_atPeriEqpTable[byEqpId - 1].m_tRvsVideoChannel.SetRcvMediaChnnelIp(dwNewIpAddr);
			m_atPeriEqpTable[byEqpId - 1].m_tRvsAudioChannel.SetRcvMediaChnnelIp(dwNewIpAddr);

			//[2011/08/29/zhangli]
			//fwd video
			m_atPeriEqpTable[byEqpId - 1].m_tFwdVideoChannel.m_tSndMediaCtrlChannel.SetIpAddr(dwNewIpAddr);
			//fwd audio
			m_atPeriEqpTable[byEqpId - 1].m_tFwdAudioChannel.m_tSndMediaCtrlChannel.SetIpAddr(dwNewIpAddr);
			
			// 通知外设修改发送配置信息
			if (m_atPeriEqpTable[byEqpId - 1].m_tPeriEqpStatus.m_byOnline)
			{
				dwNewIpAddr = htonl(dwNewIpAddr);
				SendMsgToEqp(byEqpId, MCU_EQP_MODSENDADDR_CMD, (u8*)&dwNewIpAddr, sizeof(u32));
			}
			
			//模拟界面请求，通知界面更新后的单板配置信息
			::OspPost(MAKEIID(AID_MCU_CONFIG, 1), MCS_MCU_GETBRDCFG_REQ);
		}
	}
}
/*====================================================================
    函数名      ：AssignNewMpToReplace
    功能        ：为指定的转发板寻找新的在线转发板进行替代工作
    算法实现    ：
    引用全局变量：
    输入参数说明：byOldMpId：老转发板id号	          
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/10/15    3.0         付秀华        创建
====================================================================*/
void CMcuVcData::AssignNewMpToReplace(u8 byOldMpId)
{
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	// 轮询所有外设，为分配到指定转发板的外设分配新的转发板
	u8 byEqpId = 0;
	for (u8 byEqpIdx = 0; byEqpIdx < MAXNUM_MCU_PERIEQP; byEqpIdx++)
	{
		byEqpId = m_atPeriEqpTable[byEqpIdx].m_tPeriEqpStatus.GetEqpId();
		if (g_cMcuAgent.GetEqpSwitchBrdId(byEqpId) == byOldMpId)
		{
			ReAssignMpForEqp(byEqpId);
		}	
	}
#endif
}
/*====================================================================
    函数名      ：GetNextValidMp
    功能        ：获取空闲的转发板
    算法实现    ：
    引用全局变量：
    输入参数说明：          
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/10/15    3.0         付秀华        创建
====================================================================*/
u8 CMcuVcData::GetNextValidMp(u8 byMpId)
{
	u8 byTempMpIdx = byMpId;
	for (u8 byMpIdx = 0; byMpIdx < MAXNUM_DRI; byMpIdx++)
	{
		if (byTempMpIdx >= MAXNUM_DRI)
		{
			byTempMpIdx = 0;
		}

		if (!m_atMpData[byTempMpIdx].m_bConnected)
		{
			byTempMpIdx++;
			continue;			
		}
		else
		{
			return (byTempMpIdx + 1);
		}
	}
	return (MAXNUM_DRI + 1);

}

/*====================================================================
    函数名      ：ChkAndRefreshMpForEqp
    功能        ：为指定的外设检测其所配置的接入板的有效性
	              并对无效配置自动进行更新替换
    算法实现    ：
    引用全局变量：
    输入参数说明：byEqpId：外设id号	          
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/10/15    3.0         付秀华        创建
====================================================================*/
void CMcuVcData::ChkAndRefreshMpForEqp(u8 byEqpId)
{
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	u8 byMpId = g_cMcuAgent.GetEqpSwitchBrdId(byEqpId);
	if (byMpId != (MAXNUM_DRI + 1) &&
		!IsMpConnected(byMpId))
	{
		ReAssignMpForEqp(byEqpId);
	}
#endif
	return ;
}

/*====================================================================
    函数名      ：IsMpConnected
    功能        ：判断Mp是否已连接
    算法实现    ：
    引用全局变量：
    输入参数说明：byMpId Mp编号
    返回值说明  ：TRUE - 连接, FALSE - 未连接
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
====================================================================*/
BOOL32 CMcuVcData::IsMpConnected( u8 byMpId )
{
    if (0 == byMpId || byMpId > MAXNUM_DRI)
    {
        return FALSE;
    }

    return m_atMpData[byMpId - 1].m_bConnected;
}

/*====================================================================
    函数名      ：GetMpIpAddr
    功能        ：得到Mp的Ip地址 
    算法实现    ：
    引用全局变量：
    输入参数说明：byMpId Mp编号
	              byIpNO 第几个IP
    返回值说明  ：成功返回IP地址, 失败0
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
====================================================================*/
u32  CMcuVcData::GetMpIpAddr( u8 byMpId )
{
    if(!IsMpConnected(byMpId))
	{
		return 0;
	}

	return m_atMpData[byMpId - 1].m_tMp.GetIpAddr( );
}

/*====================================================================
    函数名      ：GetMpNum
    功能        ：得到Mp的数目
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：Mp的数量
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
====================================================================*/
u8   CMcuVcData::GetMpNum( void )
{
	u8 byMpNum = 0;
    for(u8 byLoop = 0; byLoop < MAXNUM_DRI; byLoop++ )
	{
        if(m_atMpData[byLoop].m_bConnected)
		{
		    byMpNum++;
		}
	}
	return byMpNum;
}

/*====================================================================
    函数名      ：FindMp
    功能        ：查找Mp
    算法实现    ：
    引用全局变量：
    输入参数说明：u32 dwIp   ip地址，主机序
    返回值说明  ：查找Mp的Id
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
====================================================================*/
u8  CMcuVcData::FindMp( u32 dwIp )
{
	u8 byMpId = 0;
	int nMpId = 0;
	while( nMpId < MAXNUM_DRI && byMpId == 0)
	{
		//跳过未连接的
		if(!m_atMpData[nMpId].m_bConnected)
		{
			nMpId++;
			continue;
		}
		
#if defined(_8KH_) || defined(_8KE_) || defined(_8KI_)
		TMultiManuNetAccess tMultiManuNetAccess;
		g_cMcuAgent.GetMultiManuNetAccess(tMultiManuNetAccess);
		TGKProxyCfgInfo tGKProxyCfgInfo;
		g_cMcuAgent.GetGkProxyCfgInfo(tGKProxyCfgInfo);
		if( tGKProxyCfgInfo.IsProxyUsed())
		{
			for( u8 byIdx = 0; byIdx < tMultiManuNetAccess.GetIpSecNum(); byIdx++ )
			{
				u32 dwProyIp = tMultiManuNetAccess.GetIpAddr(byIdx);
				if(dwProyIp == dwIp)
				{
					LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"8KE/H/I in dwIp:%x is Multi Proxy Ip\n",dwIp);

					return 16;
				}
			}
		}
#endif

		//查找是否是此Mp
		if( m_atMpData[nMpId].m_tMp.GetIpAddr( ) == dwIp )
		{
			byMpId = nMpId+1;
			break;
		}
		nMpId++;
	}

	return byMpId;
}

/*====================================================================
    函数名      ：GetValidMp
    功能        ：得到一个Mp
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：查找Mp的Id
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/10/21    3.0         胡昌威        创建
====================================================================*/
u32  CMcuVcData::GetAnyValidMp( void )
{
	int nMpId = 0;
	while( nMpId < MAXNUM_DRI )
	{
		//跳过未连接的
		if(!m_atMpData[nMpId].m_bConnected)
		{
			nMpId++;
			continue;
		}

		return m_atMpData[nMpId].m_tMp.GetIpAddr( );

	}

	return 0;	
}

u8   CMcuVcData::GetMpMulticast(u8 byMpId)
{
    if (byMpId == 0 || byMpId > MAXNUM_DRI || !m_atMpData[byMpId - 1].m_bConnected)
    {
        return 0;
    }

    return m_atMpData[byMpId - 1].m_tMp.GetMulticast();
}

/*====================================================================
    函数名      ：ShowDri
    功能        ：显示DRI信息
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：u8 byDriId DRI编号
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/04/02    3.0         胡昌威        创建
    06/11/09    4.0         许世林        修改
====================================================================*/
void  CMcuVcData::ShowDri( u8 byDriId )
{	
	if( byDriId == 0 )
	{
		for( u8 byLoop = 1; byLoop <= MAXNUM_DRI; byLoop++ )
		{	        
			if( m_atMpData[byLoop-1].m_bConnected )
			{
				StaticLog("\n============= MP%d: TotalMtNum:%d ===========\n", 
                    byLoop, m_atMpData[byLoop-1].m_wMtNum );

                for( u8 byConfIdx = MIN_CONFIDX; byConfIdx <= MAX_CONFIDX; byConfIdx++ )
	            { 		
		            if( NULL != g_cMcuVcApp.GetConfInstHandle( byConfIdx ))
		            { 
                        TConfInfo  *ptConfFullInfo = &g_cMcuVcApp.GetConfInstHandle( byConfIdx )->m_tConf;
			            StaticLog("Conf: %s \n", ptConfFullInfo->GetConfName( ) );

                        for(u8 byIdx = 0; byIdx < MAXNUM_CONF_MT; byIdx++)
                        {
                            if (m_atMpData[byLoop-1].m_abyMtId[byConfIdx-1][byIdx] > 0)
                            {
                                StaticLog("Mt.%d ", m_atMpData[byLoop-1].m_abyMtId[byConfIdx-1][byIdx]);
                            }
                        }
                       StaticLog("\n");
                    }
                }                
			}
			else if( m_atMpData[byLoop-1].m_wMtNum )
			{
				StaticLog( "MP%d: %d TotalMtNum:%d (Not Online)\n", byLoop, m_atMpData[byLoop-1].m_wMtNum );
			}
			
			if( m_atMtAdpData[byLoop-1].m_bConnected )
			{
				StaticLog("============== MtAdp%d: TotalMtNum:%d  ProtocolID:%d ==========\n", 
                            byLoop, m_atMtAdpData[byLoop-1].m_wMtNum, 
						    m_atMtAdpData[byLoop-1].m_byProtocolType );	

                for( u8 byConfIdx = MIN_CONFIDX; byConfIdx < MAX_CONFIDX; byConfIdx++ )
	            { 		
		            if( NULL != g_cMcuVcApp.GetConfInstHandle( byConfIdx ))
		            { 
                        TConfInfo  *ptConfFullInfo = &g_cMcuVcApp.GetConfInstHandle( byConfIdx )->m_tConf;
			            StaticLog("Conf: %s \n", ptConfFullInfo->GetConfName( ) );

                        for(u8 byIdx = 0; byIdx < MAXNUM_CONF_MT; byIdx++)
                        {
                            if (m_atMtAdpData[byLoop-1].m_abyMtId[byConfIdx-1][byIdx] > 0)
                            {
                                StaticLog("Mt.%d ", m_atMtAdpData[byLoop-1].m_abyMtId[byConfIdx-1][byIdx]);
                            }
                        }
                        StaticLog("\n");
                    }
                }                
			}
			else if( m_atMtAdpData[byLoop-1].m_wMtNum )
			{
				StaticLog("MtAdp%d: TotalMtNum:%d ProtocolID:%d (Not Online)\n", byLoop, 
						   m_atMtAdpData[byLoop-1].m_wMtNum, 
						   m_atMtAdpData[byLoop-1].m_byProtocolType );	
			}
		}
	}
	else if (byDriId <= MAXNUM_DRI)
	{
		if( m_atMpData[byDriId-1].m_bConnected )
		{
			StaticLog("\n\n=========== MP%d: TotalMtNum:%d =============\n", 
                        byDriId, m_atMpData[byDriId-1].m_wMtNum );
            
            for( u8 byConfIdx = MIN_CONFIDX; byConfIdx < MAX_CONFIDX; byConfIdx++ )
	        { 		
		        if( NULL != g_cMcuVcApp.GetConfInstHandle( byConfIdx ))
		        { 
                    TConfInfo  *ptConfFullInfo = &g_cMcuVcApp.GetConfInstHandle( byConfIdx )->m_tConf;
			        StaticLog("Conf: %s \n", ptConfFullInfo->GetConfName( ) );

                    for(u8 byIdx = 0; byIdx < MAXNUM_CONF_MT; byIdx++)
                    {
                        if (m_atMpData[byDriId-1].m_abyMtId[byConfIdx-1][byIdx] > 0)
                        {
                            StaticLog("Mt.%d ", m_atMpData[byDriId-1].m_abyMtId[byConfIdx-1][byIdx]);
                        }
                    }
                    StaticLog("\n");
                }
            }            
		}
		else if( m_atMpData[byDriId-1].m_wMtNum )
		{
			StaticLog("MP%d: TotalMtNum:%d (Not Online)\n", byDriId, m_atMpData[byDriId-1].m_wMtNum );
		}
		
		if( m_atMtAdpData[byDriId-1].m_bConnected )
		{
			StaticLog("============ MtAdp%d: TotalMtNum:%d ProtocolID:%d ============\n", 
                        byDriId, m_atMtAdpData[byDriId-1].m_wMtNum, 
					    m_atMtAdpData[byDriId-1].m_byProtocolType );	

            for( u8 byConfIdx = MIN_CONFIDX; byConfIdx < MAX_CONFIDX; byConfIdx++ )
	        { 		
		        if( NULL != g_cMcuVcApp.GetConfInstHandle( byConfIdx ))
		        { 
                    TConfInfo  *ptConfFullInfo = &g_cMcuVcApp.GetConfInstHandle( byConfIdx )->m_tConf;
			        StaticLog("Conf: %s \n", ptConfFullInfo->GetConfName( ) );

                    for(u8 byIdx = 0; byIdx < MAXNUM_CONF_MT; byIdx++)
                    {
                        if (m_atMtAdpData[byDriId-1].m_abyMtId[byConfIdx-1][byIdx] > 0)
                        {
                            StaticLog("Mt.%d ", m_atMtAdpData[byDriId-1].m_abyMtId[byConfIdx-1][byIdx]);
                        }
                    }
                    StaticLog("\n");
                }
            }            
		}
		else if( m_atMtAdpData[byDriId-1].m_wMtNum )
		{
			StaticLog("MtAdp%d: TotalMtNum:%d ProtocolID:%d (Not Online)\n", byDriId, 
					   m_atMtAdpData[byDriId-1].m_wMtNum, 
					   m_atMtAdpData[byDriId-1].m_byProtocolType );	
		}
	}
}

/*====================================================================
    函数名      ：IncMtAdpMtNum
    功能        ：增加DRI终端数
    算法实现    ：
    引用全局变量：
    输入参数说明：u16  wIncExtraNum		[i] 需要额外增加的计数
    返回值说明  ：u8 byDriId DRI编号
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/04/02    3.0         胡昌威        创建
	20110916    4.6         pengjie       修改
====================================================================*/
void CMcuVcData::IncMtAdpMtNum( u8 byDriId, u8 byConfIdx, u8 byMtId , u8 byMtType )
{
    LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[IncMtAdpMtNum] DriId.%d, ConfIdx.%d, MtId.%d, MtType.%d, CurMtNum = %d\n", \
		byDriId, byConfIdx, byMtId, byMtType, m_atMtAdpData[byDriId-1].m_wMtNum );
    
	if( 0 == byDriId || byDriId > MAXNUM_DRI || 0 == byMtId || 0 == byConfIdx || byConfIdx > MAX_CONFIDX )	
	{
        return;		
	}

	// reset
	if( byMtType == TYPE_MCU )
	{
		byMtType = 2;
	}
	else if( byMtType == TYPE_MT )
	{
		byMtType = 1;
	}
	else
	{
        LogPrint( LOG_LVL_ERROR, MID_MCU_CALL, "[IncMtAdpMtNum]byConfIdx: %d,Mt:%d Type is %d,wrong type!", byConfIdx, byMtId, byMtType);
		return;
	}
	// xliang [1/4/2009] 上限非定值 MAXNUM_CONF_MT
	u8 byDriMaxNum = m_atMtAdpData[byDriId-1].m_byMaxMtNum;

    //先查找是否已经存在，并记录空位置
    u8 byEmptyIdx = byDriMaxNum/*MAXNUM_CONF_MT*/;

	for( u8 byIdx = 0; byIdx < byDriMaxNum; byIdx++ )
	{
		if( m_atMtAdpData[byDriId-1].m_abyMtId[byConfIdx-1][byIdx] == byMtId )
		{
			if( m_atMtAdpData[byDriId-1].m_abyMtType[byConfIdx-1][byIdx] == byMtType )
			{
                LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[IncMtAdpMtNum]has existed!\n");
				return;
			}
			else
			{
                LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[IncMtAdpMtNum]update Dri:%d MtNum, conf:%d mt:%d current type:%d new type:%d!\n",
                    byDriId, byConfIdx, byMtId, m_atMtAdpData[byDriId-1].m_abyMtType[byConfIdx-1][byIdx], byMtType);

				m_atMtAdpData[byDriId-1].m_wMtNum -= m_atMtAdpData[byDriId-1].m_abyMtType[byConfIdx-1][byIdx];
				m_atMtAdpData[byDriId-1].m_wMtNum += byMtType;
                m_atMtAdpData[byDriId-1].m_abyMtType[byConfIdx-1][byIdx] = byMtType;
				return;
			}
		}

		if (0 == m_atMtAdpData[byDriId-1].m_abyMtId[byConfIdx-1][byIdx] && byDriMaxNum == byEmptyIdx)
        {
            byEmptyIdx = byIdx;
        }
	}

	//不存在, 增加mtid记录并增加计数
	if( byEmptyIdx < byDriMaxNum )
	{
        LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[IncMtAdpMtNum]inc Dri:%d MtMum, conf:%d mt:%d type:%d!\n",
            byDriId, byConfIdx, byMtId, byMtType);
		m_atMtAdpData[byDriId-1].m_abyMtId[byConfIdx-1][byEmptyIdx] = byMtId;
		m_atMtAdpData[byDriId-1].m_wMtNum += byMtType;
        m_atMtAdpData[byDriId-1].m_abyMtType[byConfIdx-1][byEmptyIdx] = byMtType;  
	}
	else
    {
        LogPrint(LOG_LVL_ERROR, MID_MCULIB_MTADP, "[IncMtAdpMtNum] ConfIdx.%d MtNum.%d is full.\n", 
            byConfIdx, m_atMtAdpData[byDriId-1].m_wMtNum);
    }

    return;
}

/*====================================================================
    函数名      ：DecMtAdpMtNum
    功能        ：减少DRI终端数
    算法实现    ：
    引用全局变量：
    输入参数说明：BOOL32 bHDMt			[in] 是HD终端 
				  
    返回值说明  ：u8 byDriId DRI编号
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/04/02    3.0         胡昌威        创建
	1/4/2009				薛亮		  修改	 
	20110916    4.6         pengjie       修改
====================================================================*/
void CMcuVcData::DecMtAdpMtNum( u8 byDriId, u8 byConfIdx, u8 byMtId, BOOL32 bHDMt)
{
    LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[DecMtAdpMtNum] DriId.%d, ConfIdx.%d, MtId.%d, bHDMt.%d, CurMtNum = %d\n", \
		byDriId, byConfIdx, byMtId, bHDMt, m_atMtAdpData[byDriId-1].m_wMtNum );

    if( 0 == byDriId || byDriId > MAXNUM_DRI || 0 == byMtId || 0 == byConfIdx || byConfIdx > MAX_CONFIDX ||
        0 == m_atMtAdpData[byDriId-1].m_wMtNum)	
	{
        return;		
	}    
   
    //先查找是否已经存在
    for(u8 byIdx = 0; byIdx < MAXNUM_CONF_MT; byIdx++)
    {      
        if ( m_atMtAdpData[byDriId-1].m_abyMtId[byConfIdx-1][byIdx] == byMtId )
        {
            LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[DecMtAdpMtNum]release conf:%d mt:%d type:%d count at Dri:%d!\n",
                byConfIdx, byMtId, m_atMtAdpData[byDriId-1].m_abyMtType[byConfIdx-1][byIdx], byDriId);
            m_atMtAdpData[byDriId-1].m_abyMtId[byConfIdx-1][byIdx] = 0;
			if( m_atMtAdpData[byDriId-1].m_wMtNum >= m_atMtAdpData[byDriId-1].m_abyMtType[byConfIdx-1][byIdx] )
			{
				m_atMtAdpData[byDriId-1].m_wMtNum -= m_atMtAdpData[byDriId-1].m_abyMtType[byConfIdx-1][byIdx];
			}
			else
			{
                LogPrint( LOG_LVL_WARNING, MID_MCU_CALL, "[DecMtAdpMtNum]Dri:%d count:%d is not enough, be clear!\n",
                    byDriId, m_atMtAdpData[byDriId-1].m_wMtNum);
				m_atMtAdpData[byDriId-1].m_wMtNum = 0;
                
			}
            m_atMtAdpData[byDriId-1].m_abyMtType[byConfIdx-1][byIdx] = 0;

#if (defined(_8KE_) || defined(_8KH_) || defined(_8KI_) ) || defined(_LINUX_) 
			// xliang [10/27/2008] 如果是HD的MT，且mcu内置接入板
			if(bHDMt)
			{
				TMtAdpHDChnnlInfo tHdChnnlInfo;
				tHdChnnlInfo.SetConfIdx(byConfIdx);
				tHdChnnlInfo.SetHDMtId(byMtId);

				for(u8 byIndex=0; byIndex<MAXHDLIMIT_MPC_MTADP; byIndex ++)
				{
					if(m_atMtAdpData[byDriId-1].m_atHdChnnlInfo[byIndex] == tHdChnnlInfo)
					{
						m_atMtAdpData[byDriId-1].m_atHdChnnlInfo[byIndex].SetNull();
						break;
					}
				}
			}
#endif
            return;
        }        
    }   
    return;	
}

/*====================================================================
    函数名      ：IncAudMtAdpNum
    功能        ：增加语音终端接入数
    算法实现    ：
    引用全局变量：
    输入参数说明：
				  u8 byConfIdx					    会议号
				  u8 byMtId					    	终端ID
				  u8 byIsAudMt						是否语音终端
				  u16& wErrorCode					错误码
    返回值说明  ：BOOL32
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	20120814    4.7         周嘉麟        创建
====================================================================*/
/*lint -save -e527*/
BOOL32 CMcuVcData::IncAudMtAdpNum(u8 byConfIdx, u8 byMtId, u8 byMtHasVidCap, u16& wErrorCode)
{
	LogPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[IncAudMtAdpNum] Conf.%d's MT.%d hasvidCap.%d!\n",
												   byConfIdx, byMtId,byMtHasVidCap);


	if( byConfIdx > MAX_CONFIDX || byConfIdx == 0 || byMtId > MAXNUM_CONF_MT || byMtId == 0)
	{
		LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS,  "[IncAudMtAdpNum] invalid conf Index or mt id!\n");
		
		return FALSE;
	}
	
	if (byMtHasVidCap)
	{
		return TRUE;
	}

	u16 wMcuMaxAudMtLicenseNum = GetAudMtLicenseNum();
	if (0 == wMcuMaxAudMtLicenseNum)
	{
		LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS,  "[IncAudMtAdpNum] GetAudMtLicenseNum is 0!\n");
		return FALSE;
	}

	//当前终端是否已经计入语音接入数
	if (IsOccupyAudAccessPoint(byConfIdx, byMtId))
	{  
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[IncAudMtAdpNum] Conf.%d's MT.%d Has been in AudAccessPoint!\n",
												   byConfIdx, byMtId);
		return TRUE;
	}

	u16 wMcuAudMtLicenseNum = 0;
#ifdef _8KH_
	if( g_cMcuAgent.Is8000HmMcu() )
	{
		wMcuAudMtLicenseNum = GetMpcCurrentAudMtAdpNum();
	}
	else
	{
		wMcuAudMtLicenseNum = wMcuMaxAudMtLicenseNum;
	}
#else
	wMcuAudMtLicenseNum = wMcuMaxAudMtLicenseNum;
#endif

	if( wMcuMaxAudMtLicenseNum <  wMcuAudMtLicenseNum )
	{
		wMcuAudMtLicenseNum = wMcuMaxAudMtLicenseNum;
	}
	
	if (m_wCurrentAudMtNum >= wMcuAudMtLicenseNum/*min(GetMpcCurrentAudMtAdpNum(), wMcuMaxAudMtLicenseNum)*/)
	{
		wErrorCode = ERR_MCU_CALLAUDMTFAIL;
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[IncAudMtAdpNum] m_wCurrentAudMtNum.%d >= McuAudLIcense.%d!\n",
													m_wCurrentAudMtNum, GetAudMtLicenseNum());
		return FALSE;
	}
	
	m_wCurrentAudMtNum ++;
	
	m_abyAudMtData[byConfIdx-1][(byMtId-1)/8] |= 1 << ((byMtId-1)%8);
	LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[IncAudMtAdpNum] Conf.%d's MT.%d inc AudAccessPoint!\n",byConfIdx, byMtId);
	
	return TRUE;
}

/*====================================================================
    函数名      ：DecAudMtAdpNum
    功能        ：删除语音终端接入数
    算法实现    ：
    引用全局变量：
    输入参数说明：
				  u8 byConfIdx					    会议号
				  u8 byMtId					    	终端ID
				  const TCapSupport& tCapSupport	终端能力
    返回值说明  ：BOOL32
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	20120814    4.7         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcData::DecAudMtAdpNum(u8 byConfIdx, u8 byMtId)
{

	if( byConfIdx > MAX_CONFIDX || byConfIdx == 0 )
	{
		LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS,  "[DecMpcCurrentHDMtNum] unexpected byConfIdx.%d!\n", byConfIdx);
		
		return FALSE;
	}
	
	if (byMtId > MAXNUM_CONF_MT || byMtId == 0)
	{
		LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS,  "[DecMpcCurrentHDMtNum] unexpected byMtId.%d!\n", byMtId);
	}

	if (IsOccupyAudAccessPoint(byConfIdx, byMtId))
	{
		if( m_wCurrentAudMtNum >= 1)
		{
			m_wCurrentAudMtNum--;
		}
		else
		{
			m_wCurrentAudMtNum = 0;
		}
		
		/*lint -save -e502*/ 
		m_abyAudMtData[byConfIdx-1][(byMtId-1)/8] &= (u8)(~((u8)1 << ((u8)(byMtId-1) % 8)));
		/*lint -restore*/
	}	

	return TRUE;

}
/*lint -restore*/

/*====================================================================
    函数名      ：IncMpMtNum
    功能        ：增加MP终端数
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wConfBR: 会议码率
    返回值说明  ：BOOL32
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/04/02    3.0         胡昌威        创建
    07/02/09    4.0         张宝卿        增加MP的Pk限制策略  
====================================================================*/
BOOL32 CMcuVcData::IncMpMtNum( u8 byMpId, u8 byConfIdx, u8 byMtId, u16 wConfBR )
{
    // guzh [6/14/2007] 纯音频会议会议码率为0，也应该能分配
    if( 0 == byMpId || byMpId > MAXNUM_DRI || 0 == byMtId || 0 == byConfIdx || byConfIdx > MAX_CONFIDX )	
	{
        LogPrint(LOG_LVL_ERROR, MID_MCU_MPMGR, "[IncMpMtNum] param err: byMpId.%d, byMtId.%d, byConfIdx.%d, wConfBR.%d !\n",
                                 byMpId, byMtId, byConfIdx, wConfBR );
        return FALSE;		
	}

    //先查找是否已经存在，并记录空位置
    u8 byEmptyIdx = MAXNUM_CONF_MT;
    for(u8 byIdx = 0; byIdx < MAXNUM_CONF_MT; byIdx++)
    {      
        if ( m_atMpData[byMpId-1].m_abyMtId[byConfIdx-1][byIdx] == byMtId )
        {
			//zbq[09/11/2008]对已经存在的重复添加，应该认为OK
            //return FALSE;
			return TRUE;
        }

        if (0 == m_atMpData[byMpId-1].m_abyMtId[byConfIdx-1][byIdx] && MAXNUM_CONF_MT == byEmptyIdx)
        {
            byEmptyIdx = byIdx;
        }
    }

    //不存在, 增加mtid记录并增加计数
    if (byEmptyIdx < MAXNUM_CONF_MT)
    {
        // 增加该MP上负载的Pk数, 1M以下负载按1M计算 [07/02/09-zbq]
        m_atMpData[byMpId-1].m_dwPkNumReal += wConfBR >= 1024 ? wConfBR : 1024;
        m_atMpData[byMpId-1].m_abyMtId[byConfIdx-1][byEmptyIdx] = byMtId;
        m_atMpData[byMpId-1].m_wMtNum++;
    }
    else
    {
        LogPrint(LOG_LVL_ERROR, MID_MCULIB_MTADP, "[IncMpMtNum] ConfIdx.%d MtNum.%d is full.\n", 
                                byConfIdx, m_atMpData[byMpId-1].m_wMtNum);
        return FALSE;
    }    
    return TRUE;
}


/*====================================================================
    函数名      ：DecMpMtNum
    功能        ：减少MP终端数
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：u8 byMpId MP编号
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/04/02    3.0         胡昌威        创建
====================================================================*/
void CMcuVcData::DecMpMtNum( u8 byMpId, u8 byConfIdx, u8 byMtId, u16 wConfBR )
{
	if( 0 == byMpId || byMpId > MAXNUM_DRI || 0 == byMtId || 0 == byConfIdx || byConfIdx > MAX_CONFIDX ||
        0 == m_atMpData[byMpId-1].m_wMtNum)	
	{
        return;		
	}

    //先查找是否已经存在
    for(u8 byIdx = 0; byIdx < MAXNUM_CONF_MT; byIdx++)
    {      
        if ( m_atMpData[byMpId-1].m_abyMtId[byConfIdx-1][byIdx] == byMtId )
        {
            m_atMpData[byMpId-1].m_abyMtId[byConfIdx-1][byIdx] = 0;
            m_atMpData[byMpId-1].m_wMtNum--;
            m_atMpData[byMpId-1].m_dwPkNumReal -= wConfBR >= 1024 ? wConfBR : 1024;
            return;
        }        
    }   
    return;	
}

/*====================================================================
    函数名      ：AssignMpIdByBurden
    功能        ：根据负载分配MpId，首先查指定配置表
    算法实现    ：
    引用全局变量：
    输入参数说明：u8        byConfIdx:
                  TMtAlias &tMtAlias : 别名可能是IP或E164+IP
                  u8        byMtId   :
                  u16       wConfBR : 会议码率
    返回值说明  ：Mp的Id 
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
    06/12/29    4.0         guzh          增加别名传入，别名可能是IP或E164+IP
    07/02/12    4.0         张宝卿        用 繁忙指数 重新规划负载均衡
====================================================================*/
u8 CMcuVcData::AssignMpIdByBurden( u8 byConfIdx, TMtAlias &tMtAlias, u8 byMtId, u16 wConfBR )
{
    // guzh [12/29/2006] 首先尝试从配置文件里面读取
    u32 dwMtadpIpAddr = 0;
    u32 dwMpIpAddr = 0;
    
    u8 byMpId = 0;

    BOOL32 bFoundInTable = FALSE;
    if ( tMtAlias.m_AliasType == mtAliasTypeE164 ) 
    {
        // 首先匹配E164
        if ( g_cMcuVcApp.GetMpIdAndH323MtDriIdFromMtAlias(tMtAlias, dwMtadpIpAddr, dwMpIpAddr) )
        {
            bFoundInTable = TRUE;

            byMpId = g_cMcuVcApp.FindMp( dwMpIpAddr );             
        }
        else
        {
            // 用IP尝试
            tMtAlias.m_AliasType = mtAliasTypeTransportAddress;
        }
    }
    if (!bFoundInTable)
    {
        // 再匹配IP        
        if ( g_cMcuVcApp.GetMpIdAndH323MtDriIdFromMtAlias(tMtAlias, dwMtadpIpAddr, dwMpIpAddr) )
        {
            bFoundInTable = TRUE;

            byMpId = g_cMcuVcApp.FindMp( dwMpIpAddr );             
        }
    }   
    
	//step 1: search from those only support one IP type
	u8 byLoop = 0;
	u8  byLeastBusyPercent = 200;
	BOOL32 bIsIpV6 = IsMtIpV6(tMtAlias.m_tTransportAddr.GetIpAddr());
	u8 byIpType = bIsIpV6? IP_V6 : IP_V4;
	if ( !bFoundInTable)
	{
		for ( byLoop = 1; byLoop <= MAXNUM_DRI; byLoop++)
		{
			if ( !m_atMpData[byLoop-1].m_bConnected
				|| GetMpIpType(byLoop) != byIpType)
			{
				continue;
			}

			if ( m_atMpData[byLoop-1].GetCurBusyPercent() < byLeastBusyPercent
				&& m_atMpData[byLoop-1].IsThePkSupport(wConfBR))
			{
				byMpId = byLoop;
				byLeastBusyPercent = m_atMpData[byLoop-1].GetCurBusyPercent();
				bFoundInTable = TRUE;
			}
		}
		
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[AssignMp] assign MP(type:%d) for MT:%d: MpId:%d bFound:%d\n",
			byIpType, byMtId, byMpId, bFoundInTable);
	}

	//step 2: search from those Supporting Both IPV4 and IpV6
	if ( !bFoundInTable)
	{
		for ( byLoop = 1; byLoop <= MAXNUM_DRI; byLoop++)
		{
			if ( !m_atMpData[byLoop-1].m_bConnected
				|| GetMpIpType(byLoop) != IP_V4V6)
			{
				continue;
			}
			
			if ( m_atMpData[byLoop-1].GetCurBusyPercent() < byLeastBusyPercent
				&& m_atMpData[byLoop-1].IsThePkSupport(wConfBR))
			{
				byMpId = byLoop;
				byLeastBusyPercent = m_atMpData[byLoop-1].GetCurBusyPercent();
				bFoundInTable = TRUE;
			}
		}

		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[AssignMp] assign MP(type:IP_V4V6) for MT:%d: MpId:%d bFound:%d\n",
			byMtId, byMpId, bFoundInTable);
	}
	// 用户没有指定, 寻找 当前最轻闲的MP
//     if (!bFoundInTable)
//     {
//         // 繁忙指数可能超过100%(超负荷运转)，这里给一个安全上限
//         u8  byLeastBusyPercent = 200;
//         u8  byMaxPkLeftNO = 0;
//         
//         for(u8 byLoop = 0; byLoop < MAXNUM_DRI; byLoop++ )
//         {
//             if(m_atMpData[byLoop].m_bConnected)
//             {
//                 // 繁忙指数最小 且 在Pk承受范围之内者 居之
//                 if ( m_atMpData[byLoop].GetCurBusyPercent() < byLeastBusyPercent &&
//                      m_atMpData[byLoop].IsThePkSupport( wConfBR ) ) 
//                 {
//                     byMaxPkLeftNO = byLoop;
//                     byLeastBusyPercent = m_atMpData[byLoop].GetCurBusyPercent();
//                 }
//             }
//         }
//         byMpId = byMaxPkLeftNO+1;
//     }	

    if ( byMpId != 0 && m_atMpData[byMpId-1].m_bConnected )
    {
        if ( !IncMpMtNum(byMpId, byConfIdx, byMtId, wConfBR) ) 
        {
            byMpId = 0;
        }
    }
    else
    {
        byMpId = 0;
    }

	return byMpId;
}

#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
/*====================================================================
    函数名      ：AssignH323MtDriIdFor8KE
    功能        ：根据终端地址分配H323适配用的接入板 
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx, TMtAlias &tMtAlias, u8 byMtId
    返回值说明  ：返回的适配用的DRI板ID 
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	10/03/11	4.6			薛亮		   create
====================================================================*/
u8 CMcuVcData::AssignH323MtDriIdFor8KE(u8 byConfIdx, TMtAlias &tMtAlias, u8 byMtId)
{

	u8 byDriId = 0;	
    
    u32 dwMtadpIpAddr = 0;
    u32 dwMpIpAddr = 0;

    if( 0 == byMtId || 0 == byConfIdx || byConfIdx > MAX_CONFIDX )
    {
        byDriId = 0;
        LogPrint(LOG_LVL_ERROR, MID_MCU_MT, "[AssignH323MtDriId] assign mtadp id, param byConfIdx.%d error! \n", byConfIdx );
        return byDriId;
    }

    // find the conf
    TConfInfo *ptConf = NULL;
    if(byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX)
    {
        return FALSE;
    }
    TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
    if(tMapData.IsValidConf())
    {            
        ptConf = &m_apConfInst[tMapData.GetInsId()-1]->m_tConf;
    }
    else
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_MT, "[AssignH323MtDriId] can't get confinfo.%d\n", byConfIdx);
        return FALSE;
    }

// 接入板自身的限制一律不考虑。
//     u8 byMtNum = 0;
//     u8 bySMcuNum = 0;

    if (GetMpIdAndH323MtDriIdFromMtAlias(tMtAlias, dwMtadpIpAddr, dwMpIpAddr))
    {
        byDriId = FindMtAdp( dwMtadpIpAddr, PROTOCOL_TYPE_H323 );

        // 分配时,检测所有终端,不区分是否在线.
//         if ( //GetPerfLimit().IsLimitMtNum() &&
//              //zbq[01/09/2008]优先判断终端分布
//              GetMtNumOnDri(byDriId, FALSE, byMtNum, bySMcuNum) &&
//              GetPerfLimit().IsLimitMtNum() )
//         {
//             byDriId = 0;
//         }
    }
    else
    {
        byDriId = MCU_BOARD_MPC;
    }
    

    if ( byDriId > 0 )
    {
        IncMtAdpMtNum(byDriId, byConfIdx, byMtId); //对于终端重复，接口内部有过滤
    }
   
	return byDriId;
}
#endif	//8000E
/*====================================================================
    函数名      ：AssignH323MtDriId
    功能        ：根据终端地址分配H323适配用的DRI板 
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx, TMtAlias &tMtAlias, u8 byMtId
    返回值说明  ：返回的适配用的DRI板ID 
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
	07/01/08    4.0         周广程		  修改
====================================================================*/
u8 CMcuVcData::AssignH323MtDriId(u8 byConfIdx, TMtAlias &tMtAlias, u8 byMtId)
{
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
	return AssignH323MtDriIdFor8KE(byConfIdx, tMtAlias, byMtId);
#endif
	u8 byDriId = 0;	
    
    u32 dwMtadpIpAddr = 0;
    u32 dwMpIpAddr = 0;

    if( 0 == byMtId || 0 == byConfIdx || byConfIdx > MAX_CONFIDX )
    {
        byDriId = 0;
        LogPrint( LOG_LVL_ERROR, MID_MCU_CALL, "[AssignH323MtDriId] assign mtadp id, param byConfIdx.%d error! \n", byConfIdx);
        return byDriId;
    }

    // find the conf
    TConfInfo *ptConf = NULL;
    if(byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX)
    {
        return FALSE;
    }
    TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
    if(tMapData.IsValidConf())
    {            
        ptConf = &m_apConfInst[tMapData.GetInsId()-1]->m_tConf;
    }
    else
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_CALL, "[AssignH323MtDriId] can't get confinfo.%d ptConf =%d\n", byConfIdx,ptConf);
        return FALSE;
    }

    u8 byMtNum = 0;
    u8 bySMcuNum = 0;

    if (GetMpIdAndH323MtDriIdFromMtAlias(tMtAlias, dwMtadpIpAddr, dwMpIpAddr))
    {
        byDriId = FindMtAdp( dwMtadpIpAddr, PROTOCOL_TYPE_H323 );
		
        // 分配时,检测所有终端,不区分是否在线.
        if ( //GetPerfLimit().IsLimitMtNum() &&
			//zbq[01/09/2008]优先判断终端分布
			GetMtNumOnDri(byDriId, FALSE, byMtNum, bySMcuNum) &&
			GetPerfLimit().IsLimitMtNum() )
        {
            byDriId = 0;
        }
		
        if ((byDriId == MCU_BOARD_MPC ||
			byDriId == MCU_BOARD_MPCD) )
        {
            LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[AssignH323MtDriId] User specified dri.%d is mpc!\n", byDriId);
        }		
    }
    else
    {
//         u8 byMinDriNO = 0;
// 		s32 nMaxMtNumLeft = (s32)0x80000000 ;	// xliang [2/16/2009] 接入能力最大剩余数,因为这里有可能为负，所以这里取个最小值
		//[pengguofeng 5/10/2012]IPV6 
		byDriId = GetH323MtDriId( tMtAlias );
/*        for(u8 byLoop2 = 0; byLoop2 < MAXNUM_DRI; byLoop2++ )
        {
			//             [pengjie 2010/1/21] Mofiy VCS抢占支持，这里不再进行容量过滤，在终端入会通知时有相应限制
			//             if ( //GetPerfLimit().IsLimitMtNum() &&
			//                  //zbq[01/09/2008]优先判断终端分布
//                  GetMtNumOnDri(byLoop2+1, FALSE, byMtNum, bySMcuNum) &&
//                  GetPerfLimit().IsLimitMtNum() )
//             {
//                 // 跳过超容量的
//                 continue;
//             }
			
			// [5/21/2010 xliang] 不做过滤，仅获取mt负载数
			GetMtNumOnDri(byLoop2+1, FALSE, byMtNum, bySMcuNum);

            if( m_atMtAdpData[byLoop2].m_bConnected && 
                PROTOCOL_TYPE_H323 == m_atMtAdpData[byLoop2].m_byProtocolType )
            {
				// xliang [2/16/2009] 选剩余接入能力最多的一个
				s32 nMtNumLeft = m_atMtAdpData[byLoop2].m_byMaxMtNum - m_atMtAdpData[byLoop2].m_wMtNum;
				LogPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[AssignH323MtDriId]DRI.%d - MtNumLeft: %d\n", (byLoop2+1), nMtNumLeft);
				if( nMtNumLeft > nMaxMtNumLeft)
				{
					nMaxMtNumLeft = nMtNumLeft;
					byMinDriNO = byLoop2;
				}
            }
        }
		byDriId = byMinDriNO + 1;
		*/

    }
    
	
    if ( byDriId > 0 && byDriId <= MAXNUM_DRI )
    {
        IncMtAdpMtNum(byDriId, byConfIdx, byMtId);
    }
   
	LogPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[AssignH323MtDriId] return DRI.%d\n", byDriId);
	return byDriId;
}

/*====================================================================
    函数名      ：AssignMpIdAndH320MtDriId
    功能        ：根据终端Ip地址分配交换数据的mp板以及H320适配用的DRI板 
    算法实现    ：
    引用全局变量：
    输入参数说明：byMpId 返回的mp板ID
    返回值说明  ：返回的适配用的DRI板ID 
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
====================================================================*/
u8 CMcuVcData::AssignH320MtDriId( u8 byConfIdx, TMtAlias &tMtAlias, u8 byMtId )
{
	u8 byDriId = 0;    
	u8 byLayer   = 0; 
	u8 bySlot    = 0;
	u8 byChannel = 0;
	u32 dwDriNo  = 0;
	tMtAlias.GetH320Alias( byLayer, bySlot, byChannel );
	dwDriNo  = byLayer << 4;
	dwDriNo += bySlot;
	if( dwDriNo <= MAXNUM_DRI_MT )
	{
		byDriId = (u8)(dwDriNo+1);
		if( byDriId <= MAXNUM_DRI
			&& byDriId >= 1
			&& m_atMtAdpData[byDriId-1].m_bConnected 
			&& PROTOCOL_TYPE_H320 == m_atMtAdpData[byDriId-1].m_byProtocolType)
		{
			if( (byChannel+1) > m_atMtAdpData[byDriId-1].m_byMaxMtNum )
			{
				byDriId = 0;
				LogPrint(LOG_LVL_ERROR, MID_MCU_MT, "[AssignMpIdAndH320MtDriId] invalid Channel! \n" );	
			}
			else
			{
				IncMtAdpMtNum(byDriId, byConfIdx, byMtId);
			}
		}
	}
	else
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_MT, "[AssignH320MtDriId] invalid dri! \n" );
	}	
    
	return byDriId;
}

/*=============================================================================
函 数 名： IsMtAssignInDri
功    能： 终端是否已经分配在此mtadp上
算法实现： 
全局变量： 
参    数：  u8 byDriId
           u8 byConfIdx
           u8 byMtId
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/11/13  4.0			许世林                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsMtAssignInDri( u8 byDriId, u8 byConfIdx, u8 byMtId )
{
    if (0 == byDriId || byDriId > MAXNUM_DRI || byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX)
    {
        return FALSE;
    }

    for(u8 byIdx = 0; byIdx < MAXNUM_CONF_MT; byIdx++)
    {
        if (m_atMtAdpData[byDriId-1].m_abyMtId[byConfIdx-1][byIdx] == byMtId)
        {
            return TRUE;
        }
    }
    return FALSE;
}

/*=============================================================================
函 数 名： GetMpcHDAccessNum
功    能： 得到MPC的高清接入点数
算法实现： 
全局变量： 
参    数：  
 
返 回 值： u16 返回MPC的高清接入点总数  
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2011/07/28  4.0			陈代伟                  创建
=============================================================================*/
u16 CMcuVcData::GetMpcHDAccessNum()
{
	u16 wMpcHDAccessNum = 0;

	for( u8 byIndx = 0; byIndx < MAXNUM_DRI; byIndx ++ )
	{
		if( m_atMtAdpData[byIndx].m_bConnected)
		{
			wMpcHDAccessNum += m_atMtAdpData[byIndx].m_byMaxHDMtNum;
		}
	}

	return wMpcHDAccessNum;
}

/*=============================================================================
函 数 名： IncMpcCurrentHDMtNum
功    能： 增加MPC当前已占用的高清终端接入数目,置终端占用高清接入点标志位为TRUE
终端增加已占用高清接入数目一，MCU增加高清接入数目二
算法实现： 
全局变量： 
参    数： u8 byConIdx表明会议下标; u8 byMtId 终端Id;BOOL32 bIsMcu 是否是MCU

  返 回 值： BOOL32 增加成功，返回TRUE; 否则返回FALSE
  ----------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2011/07/28  4.0			陈代伟                  创建
=============================================================================*/
BOOL32  CMcuVcData::IncMpcCurrentHDMtNum (u8 byConIdx, u8 byMtId, BOOL32 bIsMcu )
{
	if( byConIdx > MAX_CONFIDX || byConIdx == 0 || byMtId > MAXNUM_CONF_MT || byMtId == 0)
	{
		LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS,  "[IncMpcCurrentHDMtNum] invalid conf Index or mt id!\n");
		
		return FALSE;
	}
	
	if(!bIsMcu)
	{
		if( m_wCurrentHDMtNum >= GetMpcHDAccessNum())
		{
			return FALSE;
		}
		
		m_wCurrentHDMtNum ++;
	}
	else
	{
		if( m_wCurrentHDMtNum >= GetMpcHDAccessNum()-1)
		{
			return FALSE;
		}
		
		m_wCurrentHDMtNum = m_wCurrentHDMtNum + 2;
	}
	
	m_abyHDMtData[byConIdx-1][(byMtId-1)/8] |= 1 << ((byMtId-1)%8);
	
	return TRUE;
}

/*=============================================================================
函 数 名： DecMpcCurrentHDMtNum
功    能： 减少MPC当前已占用的高清终端接入数目,同时置终端占用高清接入点标志位为FALSE
终端减少已占用高清接入数目一，MCU减少已占用高清接入数目二
算法实现： 
全局变量： 
参    数：  u8 byConIdx表明会议下标; u8 byMtId 终端Id;BOOL32 bIsMcu 是否是MCU

  返 回 值： BOOL32 减少成功，返回TRUE; 否则返回FALSE
  ----------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2011/07/28  4.0			陈代伟                  创建
=============================================================================*/
BOOL32  CMcuVcData::DecMpcCurrentHDMtNum (u8 byConIdx, u8 byMtId, BOOL32 bIsMcu )
{
	if( byConIdx > MAX_CONFIDX || byConIdx == 0 || byMtId > MAXNUM_CONF_MT || byMtId == 0)
	{
		LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS,  "[DecMpcCurrentHDMtNum] invalid conf Index or mt id!\n");
		
		return FALSE;
	}
	
	if(bIsMcu)
	{
		if( m_wCurrentHDMtNum >=2 )
		{
			m_wCurrentHDMtNum = m_wCurrentHDMtNum - 2;
		}
		else
		{
			m_wCurrentHDMtNum = 0;
		}
	}
	else
	{	
		if( m_wCurrentHDMtNum >= 1)
		{
			m_wCurrentHDMtNum --;
		}
		else
		{
			m_wCurrentHDMtNum = 0;
		}
	}
	
	/*lint -save -e502*/        //Warning -- Expected unsigned type)
	m_abyHDMtData[byConIdx-1][(byMtId-1)/8] &= (u8)(~((u8)1 << ((u8)(byMtId-1) % 8)));
	/*lint -restore*/

	return TRUE;
}


/*=============================================================================
函 数 名： IsOccupyHDAccessPoint
功    能： 判断终端是否占用高清接入点
算法实现： 
全局变量： 
参    数： u8 byConIdx表明会议下标；u8 byMtId表明终端Id 

  返 回 值： 该终端占用高清接入点返回TRUE; 否则返回FALSE;
  ----------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2011/07/28  4.0			陈代伟                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsOccupyHDAccessPoint (u8 byConIdx, u8 byMtId)
{
	BOOL32 bResult = FALSE;
	
	if( byConIdx > MAX_CONFIDX || byConIdx == 0 || byMtId > MAXNUM_CONF_MT || byMtId == 0)
	{
		return bResult;
	}
	
	if ( m_abyHDMtData[byConIdx - 1][(byMtId - 1)/8] & (1 << ((byMtId - 1)%8)) )
	{
		bResult = TRUE;
	}
	
	return bResult;
}

/*=============================================================================
函 数 名： IsOccupyAudAccessPoint
功    能： 判断终端是否占用语音接入点
算法实现： 
全局变量： 
参    数： u8 byConIdx
		   u8 byMtId

  返 回 值： 该终端占用语音接入点返回TRUE; 否则返回FALSE;
  ----------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2012/09/18  4.0			周嘉麟                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsOccupyAudAccessPoint(u8 byConIdx, u8 byMtId)
{
	BOOL32 bResult = FALSE;
	
	if( byConIdx > MAX_CONFIDX || byConIdx == 0 || byMtId > MAXNUM_CONF_MT || byMtId == 0)
	{
		return bResult;
	}
	
	if ( m_abyAudMtData[byConIdx - 1][(byMtId - 1)/8] & (1 << ((byMtId - 1)%8)) )
	{
		bResult = TRUE;
	}
	
	return bResult;
}
/*=============================================================================
函 数 名： IsMtAssignInMp
功    能： 终端是否已经分配在此mp上
算法实现： 
全局变量： 
参    数：  u8 byMpId
           u8 byConfIdx
           u8 byMtId
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/11/13  4.0			许世林                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsMtAssignInMp( u8 byMpId, u8 byConfIdx, u8 byMtId )
{
    if (0 == byMpId || byMpId > MAXNUM_DRI || byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX)
    {
        return FALSE;
    }

    for(u8 byIdx = 0; byIdx < MAXNUM_CONF_MT; byIdx++)
    {
        if (m_atMpData[byMpId-1].m_abyMtId[byConfIdx-1][byIdx] == byMtId)
        {
            return TRUE;
        }
    }
    return FALSE;
}

/*====================================================================
    函数名      ：GetRegConfDriId
    功能        ：得到注册会议的MtAdp号
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：MtAdpId ID
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
====================================================================*/
u8 CMcuVcData::GetRegConfDriId( void )
{
	u8  byDriId  = 0;
	int nMtAdpId = 0;
	u8  byRegNum = MAXNUM_MCU_CONF;
	while( nMtAdpId < MAXNUM_DRI )
	{
		//跳过未连接的
		if( !m_atMtAdpData[nMtAdpId].m_bConnected || 
			PROTOCOL_TYPE_H323 == m_atMtAdpData[nMtAdpId].m_byProtocolType )
		{
			++nMtAdpId;
		}
		else
		{
			if( m_atMtAdpData[nMtAdpId].m_byRegGKConfNum < byRegNum )
			{
				byRegNum  = m_atMtAdpData[nMtAdpId].m_byRegGKConfNum;
				byDriId = nMtAdpId+1;
			}
			++nMtAdpId;
		}
	}

	return byDriId<=MAXNUM_DRI ? byDriId : 0;	
}

/*====================================================================
    函数名      ChangeDriRegConfNum
    功能        ：改变Dri上注册GK的会议数
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：Mp的数量
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
====================================================================*/
void CMcuVcData::ChangeDriRegConfNum( u8 byDriId, BOOL32 bInc  )
{
    if( byDriId >= MAXNUM_DRI )
	{
		return;
	}

	if( bInc )
	{
		m_atMtAdpData[byDriId].m_byRegGKConfNum++;
	}
	else
	{
		m_atMtAdpData[byDriId].m_byRegGKConfNum--;
	}
}

/*=============================================================================
    函 数 名： RegisterConfToGK
    功    能： 把MCU或者会议实体注册到GK上
    算法实现： 
    全局变量： 
    参    数： u8 byConfIdx
               u8 byDriId
    返 回 值： void 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/7/6    3.6			万春雷                  创建
=============================================================================*/
void CMcuVcData::RegisterConfToGK(u8 byConfIdx, u8 byDriId, BOOL32 bTemplate, BOOL32 bUnReg)
{
    TMtAlias tMcuH323Id;
    TMtAlias tMcuE164;
    CServMsg cServMsg;

    if (0 == g_cMcuAgent.GetGkIpAddr() || 
        0 == byDriId || 
        byDriId > MAXNUM_DRI)
    {
        return;
    }
    if (0 == byConfIdx)
    {
        s8 achMcuE164[MAXLEN_ALIAS];
        s8 achMcuH323Id[MAXLEN_ALIAS];
        memset(achMcuE164, 0, MAXLEN_ALIAS);
        memset(achMcuH323Id, 0, MAXLEN_ALIAS);
        g_cMcuAgent.GetE164Number(achMcuE164, MAXLEN_ALIAS);
        g_cMcuAgent.GetMcuAlias(achMcuH323Id, MAXLEN_ALIAS);
        tMcuE164.SetE164Alias(achMcuE164);
        tMcuH323Id.SetH323Alias(achMcuH323Id);
        cServMsg.SetMcuId(LOCAL_MCUID);
        cServMsg.SetConfIdx(0);
        cServMsg.SetDstDriId(byDriId);
        cServMsg.SetMsgBody((u8*)&tMcuE164, sizeof(TMtAlias));
        cServMsg.CatMsgBody((u8*)&tMcuH323Id, sizeof(TMtAlias));
    }
    else
    {		
        TConfInfo *ptConf = NULL;
        if(byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX)
        {
            return;
        }
        TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
        if(bTemplate && tMapData.IsTemUsed() && m_ptTemplateInfo)
        {           
            ptConf = &m_ptTemplateInfo[tMapData.GetTemIndex()].m_tConfInfo;
        }
        else if(tMapData.IsValidConf())
        {            
            ptConf = &m_apConfInst[tMapData.GetInsId()-1]->m_tConf;
        }
        else
        {
            LogPrint(LOG_LVL_ERROR, MID_MCU_CALL, "[RegisterConfToGK] can't get confinfo for register\n");
            return;
        }
        
        tMcuE164.SetE164Alias(ptConf->GetConfE164());
        cServMsg.SetConfId(ptConf->GetConfId());
        cServMsg.SetConfIdx(byConfIdx);
        cServMsg.SetDstDriId(byDriId);
        cServMsg.SetMsgBody((u8*)&tMcuE164, sizeof(TMtAlias));
        cServMsg.CatMsgBody((u8*)&tMcuH323Id, sizeof(TMtAlias));
    }

    //协议接入板地址
    BOOL32 bHasMtadp = FALSE;
    TTransportAddr tMtadpAddr;
    for (u8 byIdx = 0; byIdx < MAXNUM_DRI; byIdx++)
    {
        if (m_atMtAdpData[byIdx].m_bConnected && m_atMtAdpData[byIdx].m_dwIpAddr != 0)
        {
            tMtadpAddr.SetNetSeqIpAddr(m_atMtAdpData[byIdx].m_dwIpAddr);            
            tMtadpAddr.SetPort(m_atMtAdpData[byIdx].m_wQ931Port);
            cServMsg.CatMsgBody((u8*)&tMtadpAddr, sizeof(tMtadpAddr));
            bHasMtadp = TRUE;
        }
    }
    if (!bHasMtadp)
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_CALL, "[RegisterConfToGK] no online mtadp for register\n");
        return;
    }
    
    if(bUnReg)
    {
        g_cMtAdpSsnApp.SendMsgToMtAdpSsn(byDriId, MCU_MT_UNREGISTERGK_REQ, cServMsg);
    }
    else
    {
        g_cMtAdpSsnApp.SendMsgToMtAdpSsn(byDriId, MCU_MT_REGISTERGK_REQ, cServMsg);
    }    

    return;
}


/*=============================================================================
    函 数 名： ConfChargeByGK
    功    能： 会议计费请求
    算法实现： 
    全局变量： 
    参    数： u8 byConfIdx
               u8 byDriId
               BOOL32 bStopCharge = FALSE
               u8 byCreateBy = CONF_CREATE_MCS
               u8 byMtNum
    返 回 值： void 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2006/11/09  4.0			张宝卿                  创建
=============================================================================*/
void CMcuVcData::ConfChargeByGK( u8 byConfIdx, u8 byDriId, BOOL32 bStopCharge, u8 byCreateBy, u8 byMtNum )
{
    TConfInfo *ptConf = NULL;
    if(byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX)
    {
        return;
    }
    TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
    if(tMapData.IsValidConf())
    {            
        ptConf = &m_apConfInst[tMapData.GetInsId()-1]->m_tConf;
    }
    else
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_CALL, "[ConfChargeByGK] can't get confinfo for charge\n");
        return;
    }

    CServMsg cServMsg;
    cServMsg.SetConfId(ptConf->GetConfId());
    cServMsg.SetConfIdx(byConfIdx);
    cServMsg.SetDstDriId(byDriId);

    if ( !bStopCharge )
    {
        TNetWorkInfo tNetInfo;
        g_cMcuAgent.GetNetWorkInfo( &tNetInfo );

        TConfChargeInfo tChargeInfo;
        tChargeInfo.SetGKUsrName( ptConf->GetConfAttrbEx().GetGKUsrName() );
        tChargeInfo.SetGKPwd( ptConf->GetConfAttrbEx().GetGKPwd() );

        if ( CONF_CREATE_NPLUS == byCreateBy )
        {
            tChargeInfo.SetConfName( ptConf->GetConfName() );
            tChargeInfo.SetConfE164( ptConf->GetConfE164() );
            // GK计费依照会议全码率（VID+AUD）, zgc, 2008-09-23
            //tChargeInfo.SetBitRate( ptConf->GetBitRate() );
            tChargeInfo.SetBitRate( ptConf->GetBitRate() + GetAudioBitrate(ptConf->GetMainAudioMediaType()) );
            
			TConfAttrb tTempConfAttrb = ptConf->GetConfAttrb();
            BOOL32 bDiscussConf = tTempConfAttrb.IsDiscussConf();
            tChargeInfo.SetMixerNum( bDiscussConf ? 1 : 0 );
            
            tChargeInfo.SetTerNum( byMtNum );
            
            BOOL32 bVMPAuto = ptConf->m_tStatus.GetVmpParam().IsVMPAuto();
            tChargeInfo.SetVMPNum( bVMPAuto ? 1 : min(16, byMtNum) );
            tChargeInfo.SetBasNum( 0 != ptConf->GetSecBitRate() ? 1 : 0 );  //码率适配数
            
            BOOL32 bDataConf = FALSE;
            u8 byMode = ptConf->GetConfAttrb().GetDataMode();
            if ( CONF_DATAMODE_VAANDDATA == byMode ||
                CONF_DATAMODE_DATAONLY  == byMode )
            {
                bDataConf = TRUE;
            }
            tChargeInfo.SetIsUseDataConf( bDataConf );
            
            BOOL32 bDualVideo = FALSE;
            byMode = ptConf->GetConfAttrb().GetDualMode();
            if ( CONF_DUALMODE_SPEAKERONLY  == byMode ||
                CONF_DUALMODE_EACHMTATWILL == byMode )
            {
                bDualVideo = TRUE;
            }
            tChargeInfo.SetIsUseDualVideo( bDualVideo );
            
            BOOL32 bEncrypt = FALSE;
            byMode = ptConf->GetConfAttrb().GetEncryptMode();
            if ( CONF_ENCRYPTMODE_NONE != byMode )
            {
                bEncrypt = TRUE;
            }
            tChargeInfo.SetIsUseEncrypt( bEncrypt );
            tChargeInfo.SetIsUseCascade( ptConf->GetConfAttrb().IsSupportCascade() );
            tChargeInfo.SetIsUseStreamBroadCast( ptConf->GetConfAttrb().IsMulticastMode() );
        }
        else
        {            
            TTemplateInfo tTemInfo;
            GetTemplate( byConfIdx, tTemInfo );
       
            tChargeInfo.SetConfName( tTemInfo.m_tConfInfo.GetConfName() );
            tChargeInfo.SetConfE164( tTemInfo.m_tConfInfo.GetConfE164() );
            // GK计费依照会议全码率（VID+AUD）, zgc, 2008-09-23
            //tChargeInfo.SetBitRate( tTemInfo.m_tConfInfo.GetBitRate() );
            tChargeInfo.SetBitRate( tTemInfo.m_tConfInfo.GetBitRate() + GetAudioBitrate(tTemInfo.m_tConfInfo.GetMainAudioMediaType()) );
            
            BOOL32 bDiscussConf = FALSE;
			TConfAttrb tTempConfAttrb = tTemInfo.m_tConfInfo.GetConfAttrb();
            bDiscussConf = tTempConfAttrb.IsDiscussConf();
            tChargeInfo.SetMixerNum( bDiscussConf ? 1 : 0 );
            
            tChargeInfo.SetTerNum( tTemInfo.m_byMtNum );
            
            BOOL32 bVMPAuto = tTemInfo.m_atVmpModule.GetVmpParam().IsVMPAuto();
            tChargeInfo.SetVMPNum( bVMPAuto ? 1 : min(16, tTemInfo.m_byMtNum) );
            tChargeInfo.SetBasNum( 0 != tTemInfo.m_tConfInfo.GetSecBitRate() ? 1 : 0 );  //码率适配数
            
            BOOL32 bDataConf = FALSE;
            u8 byMode = tTemInfo.m_tConfInfo.GetConfAttrb().GetDataMode();
            if ( CONF_DATAMODE_VAANDDATA == byMode ||
                CONF_DATAMODE_DATAONLY  == byMode )
            {
                bDataConf = TRUE;
            }
            tChargeInfo.SetIsUseDataConf( bDataConf );
            
            BOOL32 bDualVideo = FALSE;
            byMode = tTemInfo.m_tConfInfo.GetConfAttrb().GetDualMode();
            if ( CONF_DUALMODE_SPEAKERONLY  == byMode ||
                CONF_DUALMODE_EACHMTATWILL == byMode )
            {
                bDualVideo = TRUE;
            }
            tChargeInfo.SetIsUseDualVideo( bDualVideo );
            
            BOOL32 bEncrypt = FALSE;
            byMode = tTemInfo.m_tConfInfo.GetConfAttrb().GetEncryptMode();
            if ( CONF_ENCRYPTMODE_NONE != byMode )
            {
                bEncrypt = TRUE;
            }
            tChargeInfo.SetIsUseEncrypt( bEncrypt );
            tChargeInfo.SetIsUseCascade( tTemInfo.m_tConfInfo.GetConfAttrb().IsSupportCascade() );
            tChargeInfo.SetIsUseStreamBroadCast( tTemInfo.m_tConfInfo.GetConfAttrb().IsMulticastMode() );
        }
        cServMsg.SetMsgBody( (u8*)&tChargeInfo, sizeof(tChargeInfo) );
        g_cMtAdpSsnApp.SendMsgToMtAdpSsn(byDriId, MCU_MT_CONF_STARTCHARGE_REQ, cServMsg);
    }
    else
    {
        g_cMtAdpSsnApp.SendMsgToMtAdpSsn(byDriId, MCU_MT_CONF_STOPCHARGE_REQ, cServMsg);
    }

    return;
}

/*====================================================================
    函数名      ：AddMtAdp
    功能        ：增加一个MtAdp
    算法实现    ：
    引用全局变量：
    输入参数说明：tMtAdpReg MtAdp信息
    返回值说明  ：成功TRUE,失败FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
    08/03/27    4.5         顾振华        高清HDI支持
====================================================================*/
void CMcuVcData::AddMtAdp( TMtAdpReg &tMtAdpReg )
{
    m_atMtAdpData[tMtAdpReg.GetDriId() - 1].m_bConnected     = TRUE;
	m_atMtAdpData[tMtAdpReg.GetDriId() - 1].m_byMtAdpId      = tMtAdpReg.GetDriId(); 
	m_atMtAdpData[tMtAdpReg.GetDriId() - 1].m_dwIpAddr       = htonl( tMtAdpReg.GetIpAddr() );
	m_atMtAdpData[tMtAdpReg.GetDriId() - 1].m_byProtocolType = tMtAdpReg.GetProtocolType(); 	
    m_atMtAdpData[tMtAdpReg.GetDriId() - 1].m_wQ931Port      = tMtAdpReg.GetQ931Port();
    m_atMtAdpData[tMtAdpReg.GetDriId() - 1].m_wRasPort       = tMtAdpReg.GetRasPort();

    // guzh [1/17/2007] 综合考量MtAdp能力与业务限制
    u8 byMaxMtNum = tMtAdpReg.GetMaxMtNum();
    u8 byMaxSMcuNum = MAXLIMIT_CRI_MTADP_SMCU;
	u8 byMaxHDMtNum = tMtAdpReg.GetMaxHDMtNum();
	u16 wMaxAudMTNum = tMtAdpReg.GetMaxAudMtNum();
    TMcuPerfLimit tLimit = GetPerfLimit ();
    if ( tLimit.IsLimitMtNum() )
    {
        if ( tMtAdpReg.GetAttachMode() == 1)
        {
            byMaxMtNum = min ( byMaxMtNum, tLimit.m_byMpcMaxMtAdpConnMtAbility );
            byMaxSMcuNum = tLimit.m_byMpcMaxMtAdpConnSMcuAbility;
        }
        else
        {
#ifndef _MINIMCU_
//             if (tMtAdpReg.IsSupportHD())
//             {
//                 byMaxMtNum = min ( byMaxMtNum, tLimit.m_byHdiMaxMtAdpConnMtAbility );
//             }
//             else
//             {
//                 byMaxMtNum = min ( byMaxMtNum, tLimit.m_byTuiMaxMtAdpConnMtAbility );
//             }
			byMaxMtNum = min ( byMaxMtNum, MAXNUM_DRI_MT);
#else
            byMaxMtNum = min ( byMaxMtNum, tLimit.m_byTuiMaxMtAdpConnMtAbility );
#endif            
            byMaxSMcuNum = tLimit.m_byTuiMaxMtAdpConnSMcuAbility;
        }
    }
	
	byMaxHDMtNum = min ( byMaxHDMtNum, byMaxMtNum );
	wMaxAudMTNum = min(wMaxAudMTNum, byMaxMtNum);
	m_atMtAdpData[tMtAdpReg.GetDriId() - 1].m_byMaxHDMtNum	 = byMaxHDMtNum;
    m_atMtAdpData[tMtAdpReg.GetDriId() - 1].m_byMaxMtNum     = byMaxMtNum;
    m_atMtAdpData[tMtAdpReg.GetDriId() - 1].m_byMaxSMcuNum   = byMaxSMcuNum;
	m_atMtAdpData[tMtAdpReg.GetDriId() - 1].m_wMaxAudMtNum   = wMaxAudMTNum;

	//保存Mtadp所属单板MAC地址信息[5/16/2012 chendaiwei]
	tMtAdpReg.GetMacAddr(m_atMtAdpData[tMtAdpReg.GetDriId() - 1].m_abyMacAddr);
}

/*====================================================================
    函数名      ：RemoveMtAdp
    功能        ：移除MtAdp
    算法实现    ：
    引用全局变量：
    输入参数说明：byMtAdpId MtAdp编号	          
    返回值说明  ：成功TRUE,失败FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
====================================================================*/
void CMcuVcData::RemoveMtAdp( u8 byMtAdpId )
{
    if (!IsMtAdpConnected(byMtAdpId))
    {
        return;
    }
    
    m_atMtAdpData[byMtAdpId - 1].m_bConnected     = FALSE;
	m_atMtAdpData[byMtAdpId - 1].m_byMtAdpId      = 0;
	m_atMtAdpData[byMtAdpId - 1].m_dwIpAddr       = 0;
	m_atMtAdpData[byMtAdpId - 1].m_byProtocolType = 0;
	m_atMtAdpData[byMtAdpId - 1].m_byMaxMtNum     = 0;
    m_atMtAdpData[byMtAdpId - 1].m_byMaxSMcuNum   = 0;
    m_atMtAdpData[byMtAdpId - 1].m_wQ931Port      = 0;
    m_atMtAdpData[byMtAdpId - 1].m_wRasPort       = 0;
    m_atMtAdpData[byMtAdpId - 1].m_byRegGKConfNum = 0;
    m_atMtAdpData[byMtAdpId - 1].m_wMtNum         = 0;
	m_atMtAdpData[byMtAdpId - 1].m_byMaxHDMtNum   = 0;
    memset(m_atMtAdpData[byMtAdpId - 1].m_abyMtId, 0, sizeof(m_atMtAdpData[byMtAdpId - 1].m_abyMtId));
	memset(m_atMtAdpData[byMtAdpId-1].m_abyMacAddr,0,sizeof(m_atMtAdpData[byMtAdpId-1].m_abyMacAddr));
}

/*====================================================================
    函数名      ：IsMtAdpConnected
    功能        ：判断MtAdp是否已连接
    算法实现    ：
    引用全局变量：
    输入参数说明：byMtAdpId MtAdp编号
    返回值说明  ：TRUE - 连接, FALSE - 未连接
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
====================================================================*/
BOOL32 CMcuVcData::IsMtAdpConnected( u8 byMtAdpId )
{
    if (0 == byMtAdpId || byMtAdpId > MAXNUM_DRI)
    {
        return FALSE;
    }

    return m_atMtAdpData[byMtAdpId - 1].m_bConnected;
}

/*=============================================================================
    函 数 名： GetMtAdpProtocalType
    功    能： 获取适配板支持的协议类型
    算法实现： 
    全局变量： 
    参    数： u8 byMtAdpId
    返 回 值： u8 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/7/1    3.5			万春雷                  创建
=============================================================================*/
u8 CMcuVcData::GetMtAdpProtocalType( u8 byMtAdpId )
{
    if (!IsMtAdpConnected(byMtAdpId))
    {
        return 0;
    }

    return m_atMtAdpData[byMtAdpId - 1].m_byProtocolType;
}

/*=============================================================================
    函 数 名： GetMtAdpSupportMtNum
    功    能： 获取适配板支持的最大呼叫通道数
    算法实现： 
    全局变量： 
    参    数： u8 byMtAdpId
    返 回 值： u8 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/7/1    3.5			万春雷                  创建
=============================================================================*/
u8 CMcuVcData::GetMtAdpSupportMtNum( u8 byMtAdpId )
{
    if (!IsMtAdpConnected(byMtAdpId))
    {
        return 0;
    }

    return m_atMtAdpData[byMtAdpId - 1].m_byMaxMtNum;
}

/*=============================================================================
    函 数 名： GetMtAdpSupportSMcuNum
    功    能： 获取适配板支持的最大下级MCU数
    算法实现： 
    全局变量： 
    参    数： u8 byMtAdpId
    返 回 值： u8 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2007/1/17   4.0			顾振华                  创建
=============================================================================*/
u8 CMcuVcData::GetMtAdpSupportSMcuNum( u8 byMtAdpId )
{
    if (!IsMtAdpConnected(byMtAdpId))
    {
        return 0;
    }

    return m_atMtAdpData[byMtAdpId - 1].m_byMaxSMcuNum;
}

/*====================================================================
    函数名      ：GetMtAdpIpAddr
    功能        ：得到MtAdp的Ip地址 
    算法实现    ：
    引用全局变量：
    输入参数说明：byMtAdpId MtAdp编号
    返回值说明  ：成功返回IP地址, 失败0
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
====================================================================*/
u32 CMcuVcData::GetMtAdpIpAddr( u8 byMtAdpId )
{
    if (!IsMtAdpConnected(byMtAdpId))
    {
        return 0;
    }

	return ntohl( m_atMtAdpData[byMtAdpId - 1].m_dwIpAddr );
}

/*====================================================================
    函数名      ：GetMtAdpNum
    功能        ：得到MtAdp的数目
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byProtocolType = PROTOCOL_TYPE_H323 协议类型
    返回值说明  ：MtAdp的数量
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
====================================================================*/
u8 CMcuVcData::GetMtAdpNum( u8 byProtocolType )
{
	u8 byMpNum = 0;
    for( u8 byLoop = 0; byLoop < MAXNUM_DRI; byLoop++ )
	{
        if( m_atMtAdpData[byLoop].m_bConnected && 
			m_atMtAdpData[byLoop].m_byProtocolType == byProtocolType )
		{
		    byMpNum++;
		}
	}
	return byMpNum;
}

/*====================================================================
    函数名      ：FindMtAdp
    功能        ：查找MtAdp
    算法实现    ：
    引用全局变量：
    输入参数说明：u32 dwIp ip地址，主机序
	              u8 byProtocolType = PROTOCOL_TYPE_H323 协议类型
    返回值说明  ：查找MtAdp的Id
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/07    3.0         胡昌威        创建
====================================================================*/
u8 CMcuVcData::FindMtAdp( u32 dwIp, u8 byProtocolType )
{
	u8 byMtAdpId = 0;
	int nMtAdpId = 0;
	while( nMtAdpId < MAXNUM_DRI && byMtAdpId == 0)
	{
		//跳过未连接的
		if(!m_atMtAdpData[nMtAdpId].m_bConnected)
		{
			++nMtAdpId;
			continue;
		}
		
		//查找是否是此MtAdp
		if( m_atMtAdpData[nMtAdpId].m_dwIpAddr == htonl(dwIp) && 
			m_atMtAdpData[nMtAdpId].m_byProtocolType == byProtocolType )
		{
			byMtAdpId = nMtAdpId+1;
			break;
		}
		
		++nMtAdpId;
	}
	
	return byMtAdpId;
}

/*====================================================================
    函数名      ：InitPeriEqpList
    功能        ：初始化外设列表
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/21    3.0         zmy           创建
	10/03/01	4.6			xl			  modify for 8000E
====================================================================*/
void CMcuVcData::InitPeriEqpList()
{

    memset(m_atPeriEqpTable, 0, sizeof(m_atPeriEqpTable));

/*#ifndef _8KE_*/
	u8  byEqpId;
    u32 dwIP;
    u8  byType;

    for (byEqpId = 1; byEqpId <= MAXNUM_MCU_PERIEQP; byEqpId++)
    {
        m_atPeriEqpTable[byEqpId-1].m_bIsValid = (SUCCESS_AGENT == g_cMcuAgent.GetPeriInfo(byEqpId, &dwIP, &byType));
        m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.SetMcuId(LOCAL_MCUID);
        m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.SetEqpId(byEqpId);
        m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.SetEqpType(byType);
		m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_byOnline = FALSE;
		if (byEqpId >= HDUID_MIN && byEqpId <= HDUID_MAX)
		{
			for ( u8 byHduChnIdx = 0;byHduChnIdx < MAXNUM_HDU_CHANNEL;byHduChnIdx++)
			{
				m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdu.atHduChnStatus[byHduChnIdx].SetVolume(HDU_VOLUME_DEFAULT);
			}
		}
    }
/*#endif*/

}

/*====================================================================
    函数名      ：IsPeriEqpValid
    功能        ：外设是否在配置中
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/21    3.0         zmy           创建
====================================================================*/
BOOL32 CMcuVcData::IsPeriEqpValid( u8   byEqpId )
{
	if (byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP )
    {
        return FALSE;
    }
	return m_atPeriEqpTable[byEqpId-1].m_bIsValid;
}

/*=============================================================================
函 数 名： SetPeriEqpIsValid
功    能： 设置指定外设有效
算法实现： 
全局变量： 
参    数： u8 byEqpId
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2007/10/29   4.0		周广程                  创建
=============================================================================*/
void CMcuVcData::SetPeriEqpIsValid( u8 byEqpId )
{
	if (byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP )
    {
        return;
    }
	m_atPeriEqpTable[byEqpId-1].m_bIsValid = TRUE;
}

/*====================================================================
    函数名      ：GetEqp
    功能        ：得到外设结构
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/12/04    3.0         胡昌威           创建
====================================================================*/
TEqp CMcuVcData::GetEqp( u8 byEqpId )
{
	TEqp tEqp;
	tEqp.SetNull();
	if( byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP || !IsPeriEqpValid( byEqpId ) )
	{
		return tEqp;
	}

	return (TEqp)m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus;
}

/*====================================================================
    函数名      ：GetEqpType
    功能        ：得到外设类型
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/12/04    3.0         胡昌威           创建
====================================================================*/
u8   CMcuVcData::GetEqpType( u8 byEqpId )
{
	if( byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP || !IsPeriEqpValid( byEqpId ) )
	{
		return 0;
	}

	return m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.GetEqpType();
}
/*====================================================================
    函数名      :GetEqpData
    功能        :得到外设数据
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/12/04    3.0         zhangsh           创建
====================================================================*/
TPeriEqpData *CMcuVcData::GetEqpData( u8 byEqpId )
{
	/*lint -save -e1536*/
	if( byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP || !IsPeriEqpValid( byEqpId ) )
	{
		return NULL;
	}
	return &m_atPeriEqpTable[byEqpId-1];
	/*lint -restore*/
}

/*====================================================================
    函数名      ：GetIdleVMP
    功能        ：得到空闲的画面合成器
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 * pbyVMPBuf IN OUT : IDLE VMP id buf
                  u8 & byNum    OUT : IDLE VMP num
                  u8   byVMPLen IN  : buf len
    返回值说明  ：BOOL32
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/12/03    3.0         胡昌威        创建
    06/12/27    4.0         张宝卿        获取所有的空闲VMP  
====================================================================*/
BOOL32 CMcuVcData::GetIdleVMP( u8 * pbyVMPBuf, u8 &byNum, u8 byVMPLen )
{
    if ( NULL == pbyVMPBuf || byVMPLen < MAXNUM_PERIEQP )
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[GetIdleVMP] param err: pbyBuf.0x%x, byVMPLen.%d !\n", pbyVMPBuf, byVMPLen );
        return FALSE;
    }
    byNum = 0;
	u8    byEqpId = VMPID_MIN;
    while( byEqpId <= VMPID_MAX )
	{
		if( IsPeriEqpValid( byEqpId ) &&
			m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_byOnline && 
			m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tVmp.m_byUseState == TVmpStatus::IDLE)
		{
            pbyVMPBuf[byNum] = byEqpId;
            byNum ++;
		}
        byEqpId++;
	}

	if (g_bPrintEqpMsg)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[GetIdleVMP]idle vmp:\n");
		for (u8 byIdx = 0; byIdx < byNum; byIdx++)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "eqpid.%d\n", pbyVMPBuf[byIdx]);
		}
		if (0 == byNum)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[GetIdleVMP]no other idle vmp\n");
		}

	}

	return TRUE;
}

/*====================================================================
    函数名      ：GetIdleVmpTw
    功能        ：得到空闲的复合电视墙
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 * pbyMPWBuf IN OUT : IDLE VMP id buf
                  u8 & byNum    OUT : IDLE VMP num
                  u8   byMPWLen IN  : buf len
    返回值说明  ：BOOL32
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	05/10/08    4.0         libo          创建
    06/12/27    4.0         张宝卿        获取所有的空闲MPW
====================================================================*/
BOOL32 CMcuVcData::GetIdleVmpTw( u8 * pbyMPWBuf, u8 &byNum, u8 byMPWLen )
{
    if ( NULL == pbyMPWBuf || byMPWLen < MAXNUM_PERIEQP )
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[GetIdleVMP] param err: pbyBuf.0x%x, byVMPLen.%d !\n", pbyMPWBuf, byMPWLen );
        return FALSE;
    }
    byNum = 0;
    u8    byEqpId = VMPTWID_MIN;
    while( byEqpId <= VMPTWID_MAX )
    {
        if( IsPeriEqpValid( byEqpId ) &&
            m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_byOnline && 
            m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tVmp.m_byUseState == TVmpStatus::IDLE)
        {
            pbyMPWBuf[byNum] = byEqpId;
            byNum ++;
        }
        byEqpId++;
    }
    return TRUE;
}

/*====================================================================
    函数名      ：GetIdlePrsChl
    功能        ：得到空闲的包重传通道
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：0-未找到 非0-EqpId
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/03/26    3.0         胡昌威           创建
====================================================================*/
// u8   CMcuVcData::GetIdlePrsChl(u8 &byEqpId, u8 &byChlId, u8 &byChlId2, u8 &byChlIdAud)
// {
//     u8  byLoopEqpId = 1;
//     u8  byLoopChlId = 0; 
//     TPrsStatus tPrsStatus;
// 
//     while (byLoopEqpId <= MAXNUM_MCU_PERIEQP)
//     {
//         if (IsPeriEqpValid(byLoopEqpId))
//         {
//             if (EQP_TYPE_PRS == GetEqpType(byLoopEqpId))
//             {			
//                 if (m_atPeriEqpTable[byLoopEqpId-1].m_tPeriEqpStatus.m_byOnline)
//                 {
//                     byLoopChlId = 0;
//                     tPrsStatus = m_atPeriEqpTable[byLoopEqpId - 1].m_tPeriEqpStatus.m_tStatus.tPrs;
//                     while (byLoopChlId < MAXNUM_PRS_CHNNL)
//                     {
//                         if (!tPrsStatus.m_tPerChStatus[byLoopChlId].IsReserved() &&
//                             !tPrsStatus.m_tPerChStatus[byLoopChlId + 1].IsReserved() &&
//                             !tPrsStatus.m_tPerChStatus[byLoopChlId + 2].IsReserved())
//                         {
//                             byEqpId = byLoopEqpId;
//                             byChlId = byLoopChlId;
//                             byChlId2 = byLoopChlId + 1;
//                             byChlIdAud = byLoopChlId + 2;
//                             return byEqpId;
//                         }
//                         byLoopChlId++;
//                     }
//                 }
//             }
//         }
//         byLoopEqpId++;
//     }
// 
//     LogPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[GetIdlePrsChl]: No Idle prs chl can get!\n");
// 
//     return 0;
// }

/*=============================================================================
  函 数 名： GetIdlePrsChl
  功    能： 获取一个空闲的包重传通道
  算法实现： 
  全局变量： 
  参    数： u8 byEqpId
  返 回 值： u8  
=============================================================================*/
u8   CMcuVcData::GetIdlePrsChl(u8 &byEqpId, u8 &byChlId)
{
    u8  byLoopEqpId = 1;
    u8  byLoopChlId = 0; 
    TPrsStatus tPrsStatus;
    
    while (byLoopEqpId <= MAXNUM_MCU_PERIEQP)
    {
        if (IsPeriEqpValid(byLoopEqpId))
        {
            if (EQP_TYPE_PRS == GetEqpType(byLoopEqpId))
            {			
                if (m_atPeriEqpTable[byLoopEqpId-1].m_tPeriEqpStatus.m_byOnline)
                {
                    byLoopChlId = 0;
                    tPrsStatus = m_atPeriEqpTable[byLoopEqpId - 1].m_tPeriEqpStatus.m_tStatus.tPrs;
                    while (byLoopChlId < MAXNUM_PRS_CHNNL)
                    {
                        if (!tPrsStatus.m_tPerChStatus[byLoopChlId].IsReserved())                            
                        {
                            byEqpId = byLoopEqpId;
                            byChlId = byLoopChlId;                            
                            return byEqpId;
                        }
                        byLoopChlId++;
                    }
                }
            }
        }
        byLoopEqpId++;
    }
    
    LogPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[GetIdlePrsChl]: No Idle prs chl can get!\n");
    
    return 0;
}

/*====================================================================
    函数名      : GetAllIdlePrsChnsNum
    功能        ：获取所有空闲prs通道总数
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：空闲prs通道总数
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	11/04/18    4.6         周嘉麟          创建
====================================================================*/
u8 CMcuVcData::GetAllIdlePrsChnsNum()
{
	u8 byAllIdlePrsChnNum = 0;
	TPrsStatus tPrsStatus;
	for (u8 byPrsId = PRSID_MIN; byPrsId <= PRSID_MAX; byPrsId++)
	{		
		if ( 1 == m_atPeriEqpTable[byPrsId-1].m_tPeriEqpStatus.m_byOnline ) 
		{
			tPrsStatus = m_atPeriEqpTable[byPrsId - 1].m_tPeriEqpStatus.m_tStatus.tPrs;
			for(u8 byChnId = 0; byChnId < MAXNUM_PRS_CHNNL; byChnId++)
			{
				if (!tPrsStatus.m_tPerChStatus[byChnId].IsReserved())
				{
					byAllIdlePrsChnNum++;
				}
			}
		}
	}
    return byAllIdlePrsChnNum;
}
/*====================================================================
    函数名      : GetIdlePrsChls
    功能        ：获取空闲prs通道
    算法实现    ：逐一获取当前prs单板中通道数最多的资源
    引用全局变量：
    输入参数说明：u8 byNeedChnNum 需要的通道数
				  u8 *pbyPrsId    获取的单板ID
				  u8 *pbyPrsChnId 获取的通道ID
    返回值说明  ：FALSE-未找到 TRUE-找到
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	11/04/18    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuVcData::GetIdlePrsChls(u8 byNeedChnNum, u8 *pbyPrsId /* = NULL */, u8 *pbyPrsChnId /* = NULL */)
{
	if (0 == byNeedChnNum || NULL == pbyPrsId || NULL == pbyPrsChnId)
	{
		return FALSE;
	}
	
	u8 byMaxIdlePrsChnNum = GetAllIdlePrsChnsNum();
	if (byMaxIdlePrsChnNum < byNeedChnNum)
	{
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_PRS, "[GetIdlePrsChls] NeedPrsChnNum:%d, IdleChnNum:%d!\n", 
			byNeedChnNum, byMaxIdlePrsChnNum);
		return FALSE;
	}

	//上一个Prs单板的空闲通道数
	u8 byLastMaxChls  = 0;
	//当前所有Prs单板上最多空闲通道数
	u8 byCurMaxChls   = 0;
	//当前所有Prs单板上最多空闲通道的单板Id
	u8 byMaxIdlePrsId = 0;
	//当前获取空闲通道索引
	u8 byIdleIdx      = 0;
	TPrsStatus tPrsStatus;
	//记录预占空闲通道
	u8 abyChnReserved[PRSID_MAX + 1][MAXNUM_PRS_CHNNL] = {0};

	for (u8 byIdx = 0; byIdx < byNeedChnNum; byIdx++)
	{
		//初始化
		byMaxIdlePrsId = 0;
		byCurMaxChls   = 0;

		for (u8 byPrsId = PRSID_MIN; byPrsId <= PRSID_MAX; byPrsId++)
		{
			//初始化
			byLastMaxChls = 0;

			if ( 1 == m_atPeriEqpTable[byPrsId-1].m_tPeriEqpStatus.m_byOnline &&
				 IsPeriEqpValid(byPrsId) && EQP_TYPE_PRS == GetEqpType(byPrsId)) 
			{
				tPrsStatus = m_atPeriEqpTable[byPrsId - 1].m_tPeriEqpStatus.m_tStatus.tPrs;
				for (u8 byPrsChnIdx = 0; byPrsChnIdx < MAXNUM_PRS_CHNNL; byPrsChnIdx++)
				{
					if (!tPrsStatus.m_tPerChStatus[byPrsChnIdx].IsReserved() &&
						1 != abyChnReserved[byPrsId][byPrsChnIdx])
					{
						byLastMaxChls ++;
					}
				}
				if( byCurMaxChls <= byLastMaxChls ) // 相同空闲数时先取后面的。
				{
					byMaxIdlePrsId  = byPrsId;
					byCurMaxChls    = byLastMaxChls;
				}
			}
		}
		
		if (byMaxIdlePrsId < PRSID_MIN || byMaxIdlePrsId > PRSID_MAX ||
			0 == m_atPeriEqpTable[byMaxIdlePrsId-1].m_tPeriEqpStatus.m_byOnline ) 
		{
			return FALSE;
		}

		tPrsStatus = m_atPeriEqpTable[byMaxIdlePrsId - 1].m_tPeriEqpStatus.m_tStatus.tPrs;
		for (u8 byChnIdx = 0; byChnIdx < MAXNUM_PRS_CHNNL; byChnIdx++)
		{
			//未实际占用和预占
			if (!tPrsStatus.m_tPerChStatus[byChnIdx].IsReserved() &&
				1 != abyChnReserved[byMaxIdlePrsId][byChnIdx])
			{
				pbyPrsId[byIdleIdx]    = byMaxIdlePrsId;
				pbyPrsChnId[byIdleIdx] = byChnIdx;
				byIdleIdx ++;
				//标识预占通道
				abyChnReserved[byMaxIdlePrsId][byChnIdx] = 1;
				break;
			}
		}
	}
	return TRUE;
}
/*====================================================================
    函数名      : GetIdlePrsChls
    功能        ：从所有在线Prs中得到空闲的通道数
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byChannelNum 需要的通道数
				  TPrsChannel& tPrsChannel 通道结构
    返回值说明  ：FALSE-未找到 TRUE-找到
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/02/22    4.0         john           创建
====================================================================*/
// BOOL32 CMcuVcData::GetIdlePrsChls(u8 byChannelNum, TPrsChannel& tPrsChannel)
// {
// 	u8  byEqpPrsId;
//     TPrsStatus tPrsStatus;
//     BOOL32 bRet = FALSE;
// 	u8 byIdleNum = GetMaxIdleChlsPrsId( byEqpPrsId ); // 得到在线Prs中最大空闲通道数
// 	if( byChannelNum <= byIdleNum ) // 有足够的通道数并且在线
// 	{
// 		u8 byChlIdx = 0;
// 		tPrsStatus = m_atPeriEqpTable[byEqpPrsId - 1].m_tPeriEqpStatus.m_tStatus.tPrs;
// 		for(u8 byChlLp = 0; byChlLp < MAXNUM_PRS_CHNNL; byChlLp++)
// 		{
// 			if (!tPrsStatus.m_tPerChStatus[byChlLp].IsReserved())
// 			{
// 				tPrsChannel.m_abyPrsChannels[byChlIdx++] = byChlLp;
// 				if ( byChlIdx == byChannelNum ) // 得到足够的通道数
// 				{
// 					break;
// 				}
// 			}
// 		}
// 		tPrsChannel.SetChannelNum( byChannelNum );
// 		tPrsChannel.SetPrsId( byEqpPrsId );
// 		bRet = TRUE;
// 	}
// 	return bRet;
// }
/*====================================================================
    函数名      : GetIdlePrsChls
    功能        ：得到空闲的混音组
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byPrsId      指定PrsId
				  u8 byChannelNum 需要的通道数
				  TPrsChannel& tPrsChannel 通道结构
    返回值说明  ：FALSE-未找到 TRUE-找到
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/02/22    4.0         john           创建
====================================================================*/
// BOOL32 CMcuVcData::GetIdlePrsChls(u8 byPrsId, u8 byChannelNum, TPrsChannel& tPrsChannel)
// {
// 	BOOL32 bRet = FALSE;
// 	TPrsStatus tPrsStatus = m_atPeriEqpTable[byPrsId - 1].m_tPeriEqpStatus.m_tStatus.tPrs;
// 	if ( 1 == m_atPeriEqpTable[byPrsId-1].m_tPeriEqpStatus.m_byOnline ) // 在线
// 	{
// 		if( byChannelNum <= tPrsStatus.GetIdleChlNum() )
// 		{
// 			u8 byChlIdx = 0;
// 			for(u8 byChlLp = 0; byChlLp < MAXNUM_PRS_CHNNL; byChlLp++)
// 			{
// 				if (!tPrsStatus.m_tPerChStatus[byChlLp].IsReserved())
// 				{
// 					tPrsChannel.m_abyPrsChannels[byChlIdx++] = byChlLp;
// 					if ( byChlIdx == byChannelNum ) // 得到足够的通道数
// 					{
// 						break;
// 					}
// 				}
// 			}
// 			bRet = TRUE;
// 		}
// 	}
// 	return bRet;
// }
/*====================================================================
    函数名      GetMaxIdleChlsPrsId
    功能        ：得到所有Prs中空闲通道数最多的PrsId
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byEqpPrsId PrsId
    返回值说明  ：空闲通道数
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/02/22    4.0         john           创建
====================================================================*/
u8 CMcuVcData::GetMaxIdleChlsPrsId(u8& byEqpPrsId )
{
    u8  byMaxChls = 0; 
    TPrsStatus tPrsStatus;
    u8  byLoopEqpId = PRSID_MIN;
    while (byLoopEqpId >= PRSID_MIN && byLoopEqpId <= PRSID_MAX)
    {
        if ( 1 == m_atPeriEqpTable[byLoopEqpId-1].m_tPeriEqpStatus.m_byOnline ) // 在线
		{
			if (IsPeriEqpValid(byLoopEqpId) 
				&& EQP_TYPE_PRS == GetEqpType(byLoopEqpId) ) // 合法性检测
			{
				tPrsStatus = m_atPeriEqpTable[byLoopEqpId - 1].m_tPeriEqpStatus.m_tStatus.tPrs;
				if( byMaxChls <= tPrsStatus.GetIdleChlNum() ) // 相同空闲数时先取后面的。
				{
					byEqpPrsId = byLoopEqpId;
					byMaxChls = tPrsStatus.GetIdleChlNum();
				}
            }
        }
		byLoopEqpId++;
    }
	return byMaxChls;
}
/*====================================================================
    函数名      ：GetIdleEapuMixer
    功能        ：得到空闲的且混音容量最大的EAPU类型板混音器
    算法实现    ：
    引用全局变量：
    输入参数说明：增加最小能力限制,即获取一个能力比该参数大的混音器
    返回值说明  ：0-未找到 非0-EqpId
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/17/10    3.0         田志勇           创建
====================================================================*/
u8   CMcuVcData::GetIdleEapuMixer(u8 byMinMemberNum,u8 *pbyMixMemberNum)
{
	if (pbyMixMemberNum != NULL)
	{
		*pbyMixMemberNum = 0;
	}
	u8  byMixerIdx = 0;/*MIXERID_MIN - 1*/
	u8  byEqpId = 0;
	u8  byRetMixerId = 0;
    TMixerStatus tMixerStatus;
	u8  byMixerChnNum = 0;                                                       //记录找到的已遍历的混音器中混音成员数最大值
	u8 byMixerSubtype = UNKONW_MIXER;
	for ( ; byMixerIdx < MIXERID_MAX ; byMixerIdx++ )//遍历EAPU，是否有符合条件
	{
		tMixerStatus = m_atPeriEqpTable[byMixerIdx].m_tPeriEqpStatus.m_tStatus.tMixer;
		byEqpId = m_atPeriEqpTable[byMixerIdx].m_tPeriEqpStatus.GetEqpId();
		if (g_cMcuAgent.GetMixerSubTypeByEqpId(byEqpId,byMixerSubtype)
			&& IsPeriEqpValid( byEqpId ) && byMixerSubtype == EAPU_MIXER 
			&& m_atPeriEqpTable[byMixerIdx].m_tPeriEqpStatus.m_byOnline 
			&& tMixerStatus.m_atGrpStatus[0].m_byGrpState == TMixerGrpStatus::READY
			&& tMixerStatus.m_atGrpStatus[0].m_byMixGrpChnNum >= byMinMemberNum
			&& tMixerStatus.m_atGrpStatus[0].m_byMixGrpChnNum > byMixerChnNum)
		{
			byMixerChnNum = tMixerStatus.m_atGrpStatus[0].m_byMixGrpChnNum;
			byRetMixerId = byEqpId;
		}
	}
	if (byRetMixerId < MIXERID_MIN || byRetMixerId > MIXERID_MAX)
	{
		return 0;
	}
	if (pbyMixMemberNum != NULL)
	{
		*pbyMixMemberNum = byMixerChnNum;
	}
	return byRetMixerId;
}
/*====================================================================
    函数名      ：GetIdleEapuMixer
    功能        ：得到空闲的混音组
    算法实现    ：
    引用全局变量：
    输入参数说明：增加最小能力限制,即获取一个能力不小于该参数的混音器
    返回值说明  ：0-未找到 非0-EqpId
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/17/10    3.0         田志勇           创建
====================================================================*/
u8   CMcuVcData::GetIdleApuMixer(u8 byMinMemberNum,u8 *pbyMixMemberNum)
{
	if (pbyMixMemberNum != NULL)
	{
		*pbyMixMemberNum = 0;
	}
	u8  byMixerIdx = 0;/*MIXERID_MIN - 1*/
	u8  byEqpId = 0;
	u8  byRetMixerId = 0;
	TMixerStatus tMixerStatus;
	u8 byMixerSubtype = UNKONW_MIXER;
	for ( ; byMixerIdx < MIXERID_MAX ; byMixerIdx++ )//遍历APU，是否有符合条件
	{
		tMixerStatus = m_atPeriEqpTable[byMixerIdx].m_tPeriEqpStatus.m_tStatus.tMixer;
		byEqpId = m_atPeriEqpTable[byMixerIdx].m_tPeriEqpStatus.GetEqpId();
		if (g_cMcuAgent.GetMixerSubTypeByEqpId(byEqpId,byMixerSubtype)
			&& IsPeriEqpValid( byEqpId ) && byMixerSubtype == APU_MIXER 
			&& m_atPeriEqpTable[byMixerIdx].m_tPeriEqpStatus.m_byOnline 
			&& tMixerStatus.m_atGrpStatus[0].m_byGrpState == TMixerGrpStatus::READY
			&& MAXNUM_APU_MIXING_MEMBER >= byMinMemberNum)
		{
			byRetMixerId = byEqpId;
			break;
		}
	}
	if (byRetMixerId < MIXERID_MIN || byRetMixerId > MIXERID_MAX)
	{
		return 0;
	}
	if (pbyMixMemberNum != NULL)
	{
		*pbyMixMemberNum = MAXNUM_APU_MIXING_MEMBER;
	}
	return byRetMixerId;
}
/*====================================================================
    函数名      GetIdleApu2Mixer
    功能        ：得到空闲的混音组
    算法实现    ：
    引用全局变量：
    输入参数说明：增加最小能力限制,即获取一个能力不小于该参数的混音器
    返回值说明  ：0-未找到 非0-EqpId
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	01/31/12    3.0         田志勇           创建
====================================================================*/
u8   CMcuVcData::GetIdleApu2Mixer(u8 byMinMemberNum,u8 *pbyMixMemberNum)
{
	if (pbyMixMemberNum != NULL)
	{
		*pbyMixMemberNum = 0;
	}
	u8  byMixerIdx = 0;/*MIXERID_MIN - 1*/
	u8  byEqpId = 0;
	u8  byRetMixerId = 0;
    TMixerStatus tMixerStatus;
	u8  byMixerChnNum = 0;                                                       //记录找到的已遍历的混音器中混音成员数最大值
	u8 byMixerSubtype = UNKONW_MIXER;
	for ( ; byMixerIdx < MIXERID_MAX ; byMixerIdx++ )//遍历APU2，是否有符合条件
	{
		tMixerStatus = m_atPeriEqpTable[byMixerIdx].m_tPeriEqpStatus.m_tStatus.tMixer;
		byEqpId = m_atPeriEqpTable[byMixerIdx].m_tPeriEqpStatus.GetEqpId();
		if (g_cMcuAgent.GetMixerSubTypeByEqpId(byEqpId,byMixerSubtype)
			&& IsPeriEqpValid( byEqpId ) && byMixerSubtype == APU2_MIXER 
			&& m_atPeriEqpTable[byMixerIdx].m_tPeriEqpStatus.m_byOnline 
			&& tMixerStatus.m_atGrpStatus[0].m_byGrpState == TMixerGrpStatus::READY
			&& tMixerStatus.m_atGrpStatus[0].m_byMixGrpChnNum >= byMinMemberNum
			&& tMixerStatus.m_atGrpStatus[0].m_byMixGrpChnNum > byMixerChnNum)
		{
			byMixerChnNum = tMixerStatus.m_atGrpStatus[0].m_byMixGrpChnNum;
			byRetMixerId = byEqpId;
		}
	}
	if (byRetMixerId < MIXERID_MIN || byRetMixerId > MIXERID_MAX)
	{
		return 0;
	}
	if (pbyMixMemberNum != NULL)
	{
		*pbyMixMemberNum = byMixerChnNum;
	}
	return byRetMixerId;
}
/*====================================================================
函数名      GetIdle8kxMixer
功能        ：得到空闲的混音组
算法实现    ：
引用全局变量：
输入参数说明：增加最小能力限制,即获取一个能力不小于该参数的混音器
返回值说明  ：0-未找到 非0-EqpId
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
01/31/12    3.0         田志勇           创建
====================================================================*/
u8   CMcuVcData::GetIdle8kxMixer(u8 byMinMemberNum)
{
	u8  byMixerIdx = 0;/*MIXERID_MIN - 1*/
	u8  byEqpId = 0;
	u8  byRetMixerId = 0;
    TMixerStatus tMixerStatus;
	u8  byMixerChnNum = 0;                                                       //记录找到的已遍历的混音器中混音成员数最大值
	u8 byMixerSubtype = UNKONW_MIXER;
	for ( ; byMixerIdx < MIXERID_MAX ; byMixerIdx++ )//遍历，是否有符合条件
	{
		tMixerStatus = m_atPeriEqpTable[byMixerIdx].m_tPeriEqpStatus.m_tStatus.tMixer;
		byEqpId = m_atPeriEqpTable[byMixerIdx].m_tPeriEqpStatus.GetEqpId();
		if (g_cMcuAgent.GetMixerSubTypeByEqpId(byEqpId,byMixerSubtype)
			&& IsPeriEqpValid( byEqpId )
#ifdef _8KE_
			&& byMixerSubtype == MIXER_8KG
#elif defined(_8KH_)
			&& byMixerSubtype == MIXER_8KH
#elif defined(_8KI_)
			&& byMixerSubtype == MIXER_8KI
#endif
			&& m_atPeriEqpTable[byMixerIdx].m_tPeriEqpStatus.m_byOnline 
			&& tMixerStatus.m_atGrpStatus[0].m_byGrpState == TMixerGrpStatus::READY
			&& tMixerStatus.m_atGrpStatus[0].m_byMixGrpChnNum >= byMinMemberNum
			&& tMixerStatus.m_atGrpStatus[0].m_byMixGrpChnNum > byMixerChnNum
			)
		{
			byMixerChnNum = tMixerStatus.m_atGrpStatus[0].m_byMixGrpChnNum;
			byRetMixerId = byEqpId;
		}
	}
	if (byRetMixerId < MIXERID_MIN || byRetMixerId > MIXERID_MAX)
	{
		return 0;
	}
	return byRetMixerId;
}
/*====================================================================
    函数名      ：GetIdleMixer
    功能        ：得到空闲的混音组
    算法实现    ：
    引用全局变量：
    输入参数说明：增加最小能力限制,即获取一个能力不小于该参数的混音器

    返回值说明  ：0-未找到 非0-EqpId
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/12/03    3.0         胡昌威           创建
	03/17/10    3.0         田志勇           修改（去掉混音组，增加音频类型）
	13/03/18	4.7			国大卫			 修改(支持多格式)
====================================================================*/
/*lint -save -e527*/
u8 CMcuVcData::GetIdleMixer(u8 byMinMemberNum, u8 byAudCapNum, TAudioTypeDesc *ptAudioTypeDesc)
{
	TAudioTypeDesc tAudioDescInfo[MAXNUM_CONF_AUDIOTYPE];
	memcpy(&tAudioDescInfo[0], ptAudioTypeDesc, sizeof(TAudioTypeDesc) * byAudCapNum);
	
	LogPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[GetIdleMixer] AudCapNum: %d, MediaType_TrackNum: [1]%d_%d [2]%d_%d [3]%d_%d [4]%d_%d \n", 
		byAudCapNum, 
		tAudioDescInfo[0].GetAudioMediaType(), tAudioDescInfo[0].GetAudioTrackNum(),
		tAudioDescInfo[1].GetAudioMediaType(), tAudioDescInfo[1].GetAudioTrackNum(),
		tAudioDescInfo[2].GetAudioMediaType(), tAudioDescInfo[2].GetAudioTrackNum(),
		tAudioDescInfo[3].GetAudioMediaType(), tAudioDescInfo[3].GetAudioTrackNum() );

	if (tAudioDescInfo[0].GetAudioMediaType() == MEDIA_TYPE_NULL)
	{
		LogPrint(LOG_LVL_WARNING, MID_MCU_MIXER, "[GetIdleMixer] Main Conf AudType is MEDIA_TYPE_NULL\n");
		return 0;
	}
	u8 byCurMixerId = 0;
	u8 byReturnMixerId = 0;
	u8 byCurMixerMemberNum = 0;
	u8 byReturnMixerMemberNum = 0;
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
	//查找8K系列类型混音器
	byReturnMixerId = GetIdle8kxMixer(byMinMemberNum);
	if ( byReturnMixerId != 0 )
	{
		return byReturnMixerId;
	} 
#else
	//查找APU2类型混音器
	byReturnMixerId = GetIdleApu2Mixer(byMinMemberNum,&byReturnMixerMemberNum);
	if (byAudCapNum > 1 || /* 多格式*/
		(tAudioDescInfo[0].GetAudioMediaType() == MEDIA_TYPE_AACLC && tAudioDescInfo[0].GetAudioTrackNum() > 1) ||
		(tAudioDescInfo[0].GetAudioMediaType() == MEDIA_TYPE_AACLD && tAudioDescInfo[0].GetAudioTrackNum() > 1) /*多声道*/)
	{	
		return byReturnMixerId;		
	}

	//查找EAPU类型混音器
	byCurMixerId = GetIdleEapuMixer(byMinMemberNum,&byCurMixerMemberNum);	
	if (0 == byMinMemberNum && byCurMixerMemberNum > byReturnMixerMemberNum)
	{
		byReturnMixerId = byCurMixerId;
		byReturnMixerMemberNum = byCurMixerMemberNum;
	}
	if( 0 == byReturnMixerId )
	{
		byReturnMixerId = byCurMixerId;
	}

	if (tAudioDescInfo[0].GetAudioMediaType() == MEDIA_TYPE_G719 || 
		tAudioDescInfo[0].GetAudioMediaType() == MEDIA_TYPE_AACLD||
		tAudioDescInfo[0].GetAudioMediaType() == MEDIA_TYPE_G729 )
	{
		return byReturnMixerId;
	}

	//查找APU类型混音器
	byCurMixerId = GetIdleApuMixer(byMinMemberNum,&byCurMixerMemberNum);	
	if (0 == byMinMemberNum && byCurMixerMemberNum > byReturnMixerMemberNum)
	{
		byReturnMixerId = byCurMixerId;
	}
	if( 0 == byReturnMixerId )
	{
		byReturnMixerId = byCurMixerId;
	}
	return byReturnMixerId;
#endif
	return 0;
}



void CMcuVcData::UpdateAgentEqpStat(u8 byEqpType)
{
	u8  byLoopEqpId = 1;
	u8  byLoopGrpId = 0;

	u8 byEqpTotal = 0;
	u8 byEqpUsed = 0;
	u8 byEqpIdle = 0;

	u8 bySmStatEqpType = 0;

	BOOL32 bUpdate = TRUE;

	switch(byEqpType)
	{
	case EQP_TYPE_MIXER:
		{
			bySmStatEqpType = SM_STAT_EQP_TYPE_MIXER;
			TMixerStatus* ptMixerStatus = NULL;
			while( byLoopEqpId <= MAXNUM_MCU_PERIEQP )
			{
				if(IsPeriEqpValid(byLoopEqpId) && (GetEqpType(byLoopEqpId) == byEqpType))
				{
					if(m_atPeriEqpTable[byLoopEqpId-1].m_tPeriEqpStatus.m_byOnline == 1)
					{
						byLoopGrpId = 0;
						ptMixerStatus = &m_atPeriEqpTable[byLoopEqpId-1].m_tPeriEqpStatus.m_tStatus.tMixer;
						byEqpTotal += ptMixerStatus->m_byGrpNum;
						while( byLoopGrpId < ptMixerStatus->m_byGrpNum )
						{
							if( ptMixerStatus->m_atGrpStatus[byLoopGrpId].m_byGrpState != TMixerGrpStatus::READY )
							{
								++byEqpUsed;
							}
							
							byLoopGrpId++;
						}
					}	
				}

				byLoopEqpId++;
			}
		}
		break;

	case EQP_TYPE_BAS:
		{
			bySmStatEqpType = SM_STAT_EQP_TYPE_BAS;
			TBasStatus* ptBasStatus = NULL;
			TMpuBasStatus* ptMpuBasStatus = NULL;
			TMpu2BasStatus* ptMpu2BasStatus = NULL;
			TMauBasStatus* ptMauBasStatus = NULL;
			TApu2BasStatus	*pApu2BasStatus = NULL;

			THDBasVidChnStatus* ptVidChn = NULL;
			TAudBasChnStatus	*pAudChn =NULL;
			
			TPeriEqpStatus* ptPeriEqpStatus = NULL;

			while( byLoopEqpId <= MAXNUM_MCU_PERIEQP )
			{
				if(IsPeriEqpValid(byLoopEqpId) && (GetEqpType(byLoopEqpId) == byEqpType))
				{
					ptPeriEqpStatus = &m_atPeriEqpTable[byLoopEqpId-1].m_tPeriEqpStatus;

					if(ptPeriEqpStatus->m_byOnline == 1)
					{
						byLoopGrpId = 0;

						if (g_cMcuAgent.IsEqpBasHD(byLoopEqpId))
						{
							u8 bySubEqpType = ptPeriEqpStatus->m_tStatus.tHdBas.GetEqpType();

							if (bySubEqpType == TYPE_MPU)
							{
								ptMpuBasStatus = &ptPeriEqpStatus->m_tStatus.tHdBas.tStatus.tMpuBas;
								byEqpTotal += MAXNUM_MPU_CHN;

								byEqpIdle = 0;

								while( byLoopGrpId < MAXNUM_MPU_CHN )
								{
									ptVidChn = ptMpuBasStatus->GetVidChnStatus(byLoopGrpId);
										
									if ( ptVidChn == NULL )
									{
										continue;
									}

									if (!ptVidChn->IsReserved() &&
										!ptVidChn->IsTempReserved() &&
										ptVidChn->GetStatus() != TBasBaseChnStatus::IDLE )
									{
										++byEqpIdle;
									}
									
									byLoopGrpId++;				
								}

								byEqpUsed += MAXNUM_MPU_CHN - byEqpIdle;
							}
							else if (bySubEqpType == TYPE_MAU_NORMAL)
							{
								ptMauBasStatus = &ptPeriEqpStatus->m_tStatus.tHdBas.tStatus.tMauBas;
								byEqpTotal += MAXNUM_MAU_VCHN;
								byEqpIdle = 0;
								while( byLoopGrpId < MAXNUM_MAU_VCHN )
								{
									ptVidChn = ptMauBasStatus->GetVidChnStatus(byLoopGrpId);
									if ( ptVidChn == NULL )
									{
										continue;
									}

									if (!ptVidChn->IsReserved() &&
										!ptVidChn->IsTempReserved() &&
										ptVidChn->GetStatus() != TBasBaseChnStatus::IDLE )
									{
										++byEqpIdle;
									}
									
									byLoopGrpId++;				
								}
								byEqpUsed += MAXNUM_MAU_VCHN - byEqpIdle;
							}
							else if(bySubEqpType == TYPE_MPU_H)
							{
								ptMpuBasStatus = &ptPeriEqpStatus->m_tStatus.tHdBas.tStatus.tMpuBas;
								byEqpTotal += MAXNUM_MPU_H_CHN;
								
								byEqpIdle = 0;
								
								while( byLoopGrpId < MAXNUM_MPU_H_CHN )
								{
									ptVidChn = ptMpuBasStatus->GetVidChnStatus(byLoopGrpId);
									
									if ( ptVidChn == NULL )
									{
										continue;
									}

									if (!ptVidChn->IsReserved() &&
										!ptVidChn->IsTempReserved() &&
										ptVidChn->GetStatus() != TBasBaseChnStatus::IDLE )
									{
										++byEqpIdle;
									}
									
									byLoopGrpId++;				
								}								
								byEqpUsed += MAXNUM_MPU_H_CHN - byEqpIdle;
							}
							else if(bySubEqpType == TYPE_MPU2_BASIC)
							{
								ptMpu2BasStatus = &ptPeriEqpStatus->m_tStatus.tHdBas.tStatus.tMpu2Bas;
								byEqpTotal += MAXNUM_MPU2_BASIC_CHN;
								
								byEqpIdle = 0;
								
								while( byLoopGrpId < MAXNUM_MPU2_BASIC_CHN )
								{
									ptVidChn = ptMpu2BasStatus->GetVidChnStatus(byLoopGrpId);
									
									if ( ptVidChn == NULL )
									{
										continue;
									}

									if (!ptVidChn->IsReserved() &&
										!ptVidChn->IsTempReserved() &&
										ptVidChn->GetStatus() != TBasBaseChnStatus::IDLE )
									{
										++byEqpIdle;
									}
									
									byLoopGrpId++;				
								}								
								byEqpUsed += MAXNUM_MPU2_BASIC_CHN - byEqpIdle;
							}
							else if(bySubEqpType == TYPE_MPU2_ENHANCED)
							{
								ptMpu2BasStatus = &ptPeriEqpStatus->m_tStatus.tHdBas.tStatus.tMpu2Bas;
								byEqpTotal += MAXNUM_MPU2_EHANCED_CHN;
								
								byEqpIdle = 0;
								
								while( byLoopGrpId < MAXNUM_MPU2_EHANCED_CHN )
								{
									ptVidChn = ptMpu2BasStatus->GetVidChnStatus(byLoopGrpId);
									
									if ( ptVidChn == NULL )
									{
										continue;
									}

									if (!ptVidChn->IsReserved() &&
										!ptVidChn->IsTempReserved() &&
										ptVidChn->GetStatus() != TBasBaseChnStatus::IDLE )
									{
										++byEqpIdle;
									}
									
									byLoopGrpId++;				
								}								
								byEqpUsed += MAXNUM_MPU2_EHANCED_CHN - byEqpIdle;
							}
						}
						else if ( g_cMcuAgent.IsEqpBasAud(byLoopEqpId) )
						{
							u8 bySubAudType = ptPeriEqpStatus->m_tStatus.tAudBas.GetEqpType();
							if(bySubAudType == TYPE_APU2_BAS)
							{
								pApu2BasStatus = &ptPeriEqpStatus->m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus;
								byEqpTotal += MAXNUM_APU2_BASCHN;
								
								byEqpIdle = 0;
								
								while( byLoopGrpId < MAXNUM_APU2_BASCHN )
								{
									pAudChn = pApu2BasStatus->GetAudChnStatus(byLoopGrpId);
									
									if ( pAudChn == NULL )
									{
										continue;
									}
									
									if (!pAudChn->IsReserved() &&
										!pAudChn->IsTempReserved() &&
										pAudChn->GetStatus() != TBasBaseChnStatus::IDLE )
									{
										++byEqpIdle;
									}
									
									byLoopGrpId++;				
								}								
								byEqpUsed += MAXNUM_APU2_BASCHN - byEqpIdle;
							}
						}
						else
						{
							ptBasStatus = &ptPeriEqpStatus->m_tStatus.tBas;
							byEqpTotal += ptBasStatus->byChnNum;
							while( byLoopGrpId < ptBasStatus->byChnNum )
							{
								if( ptBasStatus->tChnnl[byLoopGrpId].GetStatus() != TBasChnStatus::READY )
								{
									++byEqpUsed;
								}
								byLoopGrpId++;	
							}
						}
					}	
				}

				byLoopEqpId++;
			}
		}
		break;

	case EQP_TYPE_PRS:
		{
			bySmStatEqpType = SM_STAT_EQP_TYPE_PRS;
			TPrsStatus* ptPrsStatus = NULL;
			while( byLoopEqpId <= MAXNUM_MCU_PERIEQP )
			{
				if(IsPeriEqpValid(byLoopEqpId) && (GetEqpType(byLoopEqpId) == byEqpType))
				{
					if(m_atPeriEqpTable[byLoopEqpId-1].m_tPeriEqpStatus.m_byOnline == 1)
					{
						ptPrsStatus = &m_atPeriEqpTable[byLoopEqpId-1].m_tPeriEqpStatus.m_tStatus.tPrs;
						byEqpTotal += MAXNUM_PRS_CHNNL;
						byEqpUsed += MAXNUM_PRS_CHNNL - ptPrsStatus->GetIdleChlNum();

					}	
				}

				byLoopEqpId++;
			}
		}
		break;

	case EQP_TYPE_VMP:
		{
			bySmStatEqpType = SM_STAT_EQP_TYPE_VMP;
			TVmpStatus* ptVmpStatus;
			byLoopEqpId = VMPID_MIN;

			while( byLoopEqpId <= VMPID_MAX )
			{
				if(IsPeriEqpValid(byLoopEqpId) && (GetEqpType(byLoopEqpId) == byEqpType))
				{
					if(m_atPeriEqpTable[byLoopEqpId-1].m_tPeriEqpStatus.m_byOnline == 1)
					{
						++byEqpTotal;
						ptVmpStatus = &m_atPeriEqpTable[byLoopEqpId-1].m_tPeriEqpStatus.m_tStatus.tVmp;

						if (ptVmpStatus->m_byUseState != TVmpStatus::IDLE)
						{
							++byEqpUsed;
						}				
					}	
				}

				byLoopEqpId++;
			}
		}
		break;

	case EQP_TYPE_HDU:
// 	case EQP_TYPE_HDU_H:
// 	case EQP_TYPE_HDU_L:
// 	case EQP_TYPE_HDU2:
// 	case EQP_TYPE_HDU2_L:
		{
			bySmStatEqpType = SM_STAT_EQP_TYPE_HDU;
			THduStatus* ptHduStatus = NULL;
			byLoopEqpId = HDUID_MIN;
			while( byLoopEqpId <= HDUID_MAX )
			{
				if( IsPeriEqpValid(byLoopEqpId) )
				{
					if(m_atPeriEqpTable[byLoopEqpId-1].m_tPeriEqpStatus.m_byOnline == 1)
					{
						ptHduStatus = &m_atPeriEqpTable[byLoopEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdu;

						u8 bySubEqpType = HDU_SUBTYPE_HDU_M;
						if( g_cMcuAgent.GetHduSubTypeByEqpId(byLoopEqpId,bySubEqpType) )
						{
							if( HDU_SUBTYPE_HDU_M == bySubEqpType || 
								HDU_SUBTYPE_HDU_L == bySubEqpType || 
								HDU_SUBTYPE_HDU2 == bySubEqpType ||
								HDU_SUBTYPE_HDU2_L == bySubEqpType ||
								HDU_SUBTYPE_HDU2_S == bySubEqpType
								)
							{
								byEqpTotal += MAXNUM_HDU_CHANNEL;
								
								for ( byLoopGrpId = 0; byLoopGrpId < MAXNUM_HDU_CHANNEL; byLoopGrpId++ )
								{
									if( ptHduStatus->atHduChnStatus[byLoopGrpId].GetStatus() == THduChnStatus::eRUNNING ) 	
									{
										++byEqpUsed;
									}
								}
							} 
							else if( HDU_SUBTYPE_HDU_H == bySubEqpType )
							{
								byEqpTotal += MAXNUM_HDU_H_CHANNEL;
								
								for ( byLoopGrpId = 0; byLoopGrpId < MAXNUM_HDU_H_CHANNEL; byLoopGrpId++ )
								{
									if ( ptHduStatus->atHduChnStatus[byLoopGrpId].GetStatus() == THduChnStatus::eRUNNING )
									{
										++byEqpUsed;
									}
								}
							}
						}
					}	
				}
				
				byLoopEqpId++;
			}
		}
		break;

	default:
		{
			bUpdate = FALSE;
		}
		break;
	}

	if (bUpdate)
	{
		g_cMcuAgent.SetEqpStat(bySmStatEqpType, byEqpUsed, byEqpTotal);
		
		LogPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "UpdateAgentEqpStat EqpType:%d, EqpUsed:%d, EqpTotal:%d\n", byEqpType, byEqpUsed, byEqpTotal);
	}
}

/*====================================================================
    函数名      ：GetIdleBasChl
    功能        ：得到空闲的适配器通道
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 &byEqpId 返回的外设号
	              u8 &byChlId 返回的通道ID
    返回值说明  ：0-未找到 非0-EqpId
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/03/20    3.0         胡昌威           创建
====================================================================*/
// u8 CMcuVcData::GetIdleBasChl(u8 byAdaptType, u8 &byEqpId, u8 &byChlId)
// {
//     u8 byLoopGrpId = 0;
//     u8 byMinChnl;
//     u8 byMaxChnl;
//     TPeriEqpStatus *ptStatus;
// 
//     for (u8 byLoopEqpId = 1; byLoopEqpId < MAXNUM_MCU_PERIEQP; byLoopEqpId++)
//     {
//         if (!IsPeriEqpValid(byLoopEqpId))
//         {
//             continue;
//         }
//         if (EQP_TYPE_BAS != GetEqpType(byLoopEqpId))
//         {
//             continue;
//         }
// 
//         if ( g_cMcuAgent.IsEqpBasHD(byLoopEqpId) )
//         {
//             continue;   
//         }
// 
//         ptStatus = &(m_atPeriEqpTable[byLoopEqpId-1].m_tPeriEqpStatus);
//         if (!ISTRUE(ptStatus->m_byOnline))
//         {
//             continue;
//         }
// 
//         byMinChnl = 0;
//         byMaxChnl = ptStatus->m_tStatus.tBas.byChnNum;
//         
//         //查找空闲通道
//         for (u8 byChnIdx =byMinChnl; byChnIdx < byMaxChnl; byChnIdx++)
//         {            
//             if (!ptStatus->m_tStatus.tBas.tChnnl[byChnIdx].IsReserved())
//             {                
//                 BOOL32 bFlag = FALSE;
//                 u8 byBasChnnlType = ptStatus->m_tStatus.tBas.tChnnl[byChnIdx].GetChannelType();
//                 if (BAS_CHAN_AUDIO == byBasChnnlType)
//                 {
//                     if (ADAPT_TYPE_AUD == byAdaptType)
//                     {
//                         bFlag = TRUE;
//                     }                    
//                 }
//                 else if (BAS_CHAN_VIDEO == byBasChnnlType)
//                 {
//                     if (ADAPT_TYPE_VID == byAdaptType || ADAPT_TYPE_BR == byAdaptType)
//                     {
//                         bFlag = TRUE;
//                     }                    
//                 }
// 
//                 if (bFlag)
//                 {                    
//                     ptStatus->m_tStatus.tBas.tChnnl[byChnIdx].SetReserved(TRUE);
//                     byEqpId = byLoopEqpId;
//                     byChlId = byChnIdx;
//                     return byEqpId;
//                 }
//             }
//         }			
//     }
// 
// 	return 0;
// }
/*=============================================================================
函 数 名： IsIdleHDBasVidChlExist
功    能： 查找是否有空闲的MAU主视频适配通道
算法实现： 
全局变量： 
参    数：
返 回 值： BOOL32
----------------------------------------------------------------------
修改记录    ：
日  期		版本		创建人		走读人    修改内容
09/06/03                付秀华             
=============================================================================*/
// BOOL32 CMcuVcData::IsIdleHDBasVidChlExist(u8* pbyEqpId /*= NULL*/, u8* pbyChlIdx /*= NULL*/)
// {
//     TPeriEqpStatus *ptStatus;
//     for (u8 byLoopEqpId = BASID_MIN; byLoopEqpId <= BASID_MAX; byLoopEqpId++)
//     {
//         if (!IsPeriEqpValid(byLoopEqpId))
//         {
//             continue;
//         }
//         if ( !g_cMcuAgent.IsEqpBasHD(byLoopEqpId) )
//         {
//             continue;   
//         }
// 
//         ptStatus = &(m_atPeriEqpTable[byLoopEqpId-1].m_tPeriEqpStatus);
//         if (!ISTRUE(ptStatus->m_byOnline))
//         {
//             continue;
//         }
// 
//         u8 byEqpType = ptStatus->m_tStatus.tHdBas.GetEqpType();
//         if (TYPE_MAU_H263PLUS == byEqpType)
//         {
//             continue;
// 		}
// 
//         u8 byChnIdx = 0;
//         THDBasVidChnStatus tVidChn;
// 
//         //查找空闲通道
//         switch (byEqpType)
//         {
//         case TYPE_MPU:
// 		case TYPE_MPU_H:
// 			{
// 				u8 byOutNum = 0;
// 				if (TYPE_MPU == byEqpType)
// 				{
// 					byOutNum = MAXNUM_MPU_CHN;
// 				}
// 				else if(TYPE_MPU_H == byEqpType)
// 				{
// 					byOutNum = MAXNUM_MPU_H_VOUTPUT;
// 				}
// 				for (byChnIdx = 0; byChnIdx < byOutNum/*MAXNUM_MPU_CHN*/; byChnIdx++)
// 				{            
// 					memset( &tVidChn, 0, sizeof(tVidChn) );
// 					memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnIdx), sizeof(tVidChn) );
// 					if (!tVidChn.IsReserved() &&
// 						!tVidChn.IsTempReserved() &&
// 						tVidChn.GetStatus() != THDBasChnStatus::IDLE )
// 					{
// 						if (pbyEqpId != NULL)
// 						{
// 							*pbyEqpId = byLoopEqpId;
// 						}
// 						if (pbyChlIdx != NULL)
// 						{
// 							*pbyChlIdx = byChnIdx;
// 						}
// 						return TRUE;
// 					}
// 				}
// 			}
// 
//         	break;
// 
//         case TYPE_MAU_NORMAL:
//             for (byChnIdx = 0; byChnIdx < MAXNUM_MAU_VCHN; byChnIdx++)
//             {            
//                 memset( &tVidChn, 0, sizeof(tVidChn) );
//                 memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnIdx), sizeof(tVidChn) );
//                 if (!tVidChn.IsReserved() &&
//                     !tVidChn.IsTempReserved() &&
//                     tVidChn.GetStatus() != THDBasChnStatus::IDLE )
//                 {
//                     if (pbyEqpId != NULL)
//                     {
//                         *pbyEqpId = byLoopEqpId;
//                     }
//                     if (pbyChlIdx != NULL)
//                     {
//                         *pbyChlIdx = byChnIdx;
//                     }
//                     return TRUE;
//                 }
//             }
// 
//             break;
//         default:
//             LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsIdleHDBasVidChlExist] unexpected type.%d for eqp.%d!\n", byEqpType, byLoopEqpId);
//             break;
//         }		
// 	}
// 	return FALSE;
// }
/*=============================================================================
函 数 名： GetIdleHDBasVidChl
功    能： 为第一路高清主视频获取空闲的MAU适配通道
算法实现： 
全局变量： 
参    数： 
           u8 &byEqpId
           u8 &byChlIdx
           BOOL32 bIsTemp
返 回 值： BOOL32
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2008/8/4   4.0		    周广程                  创建
=============================================================================*/
// BOOL32 CMcuVcData::GetIdleHDBasVidChl( u8 &byEqpId, u8 &byChlIdx )
// {
//     TPeriEqpStatus *ptStatus;
//     
//     for (u8 byLoopEqpId = BASID_MIN; byLoopEqpId <= BASID_MAX; byLoopEqpId++)
//     {
//         if (!IsPeriEqpValid(byLoopEqpId))
//         {
//             continue;
//         }
//         if ( !g_cMcuAgent.IsEqpBasHD(byLoopEqpId) )
//         {
//             continue;   
//         }
//        
//         ptStatus = &(m_atPeriEqpTable[byLoopEqpId-1].m_tPeriEqpStatus);
// 		if (TYPE_MAU_H263PLUS == ptStatus->m_tStatus.tHdBas.GetEqpType())
// 		{
// 			continue;
// 		}
// 
//         if (!ISTRUE(ptStatus->m_byOnline))
//         {
//             continue;
//         }
//         
//         u8 byEqpType = ptStatus->m_tStatus.tHdBas.GetEqpType();
// 
//         u8 byChnIdx = 0;
//         THDBasVidChnStatus tVidChn;
// 
//         //查找空闲通道
//         switch (byEqpType)
//         {
//         case TYPE_MPU:
// 		case TYPE_MPU_H:
// 			{
// 				u8 byChnNum = 0;
// 				if (TYPE_MPU == byEqpType)
// 				{
// 					byChnNum = MAXNUM_MPU_CHN;
// 				}
// 				else 
// 				{
// 					byChnNum = MAXNUM_MPU_H_CHN;
// 				}
// 				for (byChnIdx = 0; byChnIdx < byChnNum/*MAXNUM_MPU_CHN*/; byChnIdx++)
// 				{            
// 					memset( &tVidChn, 0, sizeof(tVidChn) );
// 					memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnIdx), sizeof(tVidChn) );
// 					if (!tVidChn.IsReserved() &&
// 						!tVidChn.IsTempReserved() &&
// 						tVidChn.GetStatus() != THDBasChnStatus::IDLE )
// 					{          
// 						tVidChn.SetIsReserved( TRUE );
// 						ptStatus->m_tStatus.tHdBas.tStatus.tMpuBas.SetVidChnStatus( tVidChn, byChnIdx );
// 						byEqpId = byLoopEqpId;
// 						byChlIdx = byChnIdx;
// 						return TRUE;
// 					}
// 				}	
// 			}
//         	break;
// 
//         case TYPE_MAU_NORMAL:
// 
//             for (byChnIdx = 0; byChnIdx < MAXNUM_MAU_VCHN; byChnIdx++)
//             {            
//                 memset( &tVidChn, 0, sizeof(tVidChn) );
//                 memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(), sizeof(tVidChn) );
//                 if (!tVidChn.IsReserved() &&
//                     !tVidChn.IsTempReserved() &&
//                     tVidChn.GetStatus() != THDBasChnStatus::IDLE )
//                 {          
//                     tVidChn.SetIsReserved( TRUE );
//                     ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.SetVidChnStatus( tVidChn );
//                     byEqpId = byLoopEqpId;
//                     byChlIdx = byChnIdx;
//                     return TRUE;
//                 }
//             }	
//             break;
//         default:
//             LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetIdleHDBasVidChl] unexpected eqp type.%d for eqp.%d!\n", byEqpType, byLoopEqpId);
//             break;
//         }
//     }
//     
// 	return FALSE;
// }

/*====================================================================
    函数名      ：GetIdleMauChn
    功能        ：获取空闲的MAU通道
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	08/11/09    4.5         张宝卿        创建
====================================================================*/
// BOOL32 CMcuVcData::GetIdleMauChn(u8 byChnType, u8 &byMauId, u8 &byChnId)
// {
//     byMauId = 0xff;
//     byChnId = 0xff;
// 
//     TPeriEqpStatus *ptStatus;
// 
//     BOOL32 bMVChn = FALSE;
//     BOOL32 bDSChn = FALSE;
// 
//     switch (byChnType)
//     {
//     case MAU_CHN_NORMAL:
//     case MAU_CHN_263TO264:
//         bMVChn = TRUE;
//         break;
//     case MAU_CHN_VGA:
//     case MAU_CHN_264TO263:
//         bDSChn = TRUE;
//     	break;
//     default:
//         LogPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[GetIdleMauChn] unexpected chn type.%d\n", byChnType);
//         return FALSE;
//     }
// 
//     for (u8 byEqpId = BASID_MIN; byEqpId <= BASID_MAX; byEqpId++)
//     {
//         if (!IsPeriEqpValid(byEqpId))
//         {
//             continue;
//         }
//         if ( !g_cMcuAgent.IsEqpBasHD(byEqpId) )
//         {
//             continue;   
//         }
//         
//         ptStatus = &(m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus);
//         if (!ISTRUE(ptStatus->m_byOnline))
//         {
//             continue;
//         }
//         
//         if ((MAU_CHN_VGA == byChnType || MAU_CHN_NORMAL == byChnType) &&
//             ptStatus->m_tStatus.tHdBas.GetEqpType() != TYPE_MAU_NORMAL)
//         {
//             continue;
//         }
//         if ((MAU_CHN_263TO264 == byChnType || MAU_CHN_264TO263 == byChnType) &&
//             ptStatus->m_tStatus.tHdBas.GetEqpType() != TYPE_MAU_H263PLUS)
//         {
//             continue;
//         }
// 
//         if (bMVChn)
//         {
//             THDBasVidChnStatus tVidChn;
//             u8 byChnIdx = 0;
//             for (; byChnIdx < MAXNUM_MAU_VCHN; byChnIdx++)
//             {            
//                 memset( &tVidChn, 0, sizeof(tVidChn) );
//                 memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnIdx), sizeof(tVidChn) );
//                 if (!tVidChn.IsReserved() &&
//                     !tVidChn.IsTempReserved() &&
//                     tVidChn.GetStatus() == THDBasChnStatus::READY )
//                 {
//                     tVidChn.SetIsReserved(TRUE);
//                     ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.SetVidChnStatus(tVidChn, byChnIdx );
//                     byMauId = byEqpId;
//                     byChnId = 0;
//                     break;
//                 }
//                 else
//                 {
//                     LogPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[GetIdleMau] Eqp.%d mv failed due to<ChnIdx.%d, Res.%d, Status.%d>\n",
//                         byEqpId, byChnIdx, tVidChn.IsReserved(), tVidChn.GetStatus());
//                     continue;
//                 }
//             }
//         }
//         else if (bDSChn)
//         {
//             THDBasDVidChnStatus tDVidChn;
//             u8 byChnIdx = 0;
//             for (; byChnIdx < MAXNUM_MAU_VCHN; byChnIdx++)
//             {            
//                 memset( &tDVidChn, 0, sizeof(tDVidChn) );
//                 memcpy( &tDVidChn, ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(byChnIdx), sizeof(tDVidChn) );
//                 if (!tDVidChn.IsReserved() &&
//                     !tDVidChn.IsTempReserved() &&
//                     tDVidChn.GetStatus() == THDBasChnStatus::READY )
//                 {
//                     tDVidChn.SetIsReserved(TRUE);
//                     ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.SetDVidChnStatus(tDVidChn, byChnIdx );
//                     byMauId = byEqpId;
//                     byChnId = 1;
//                     break;
//                 }
//                 else
//                 {
//                     LogPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[GetIdleMau] Eqp.%d mv failed due to<ChnIdx.%d, Res.%d, Status.%d>\n",
//                         byEqpId, byChnIdx, tDVidChn.IsReserved(), tDVidChn.GetStatus());
//                     continue;
//                 }
//             }
//         }
// 
//         if (0xff != byMauId)
//         {
//             break;
//         }
//     }
// 
//     if (0xff != byMauId && 0xff != byChnId)
//     {
//         return TRUE;
//     }
//     return FALSE;
// }

/*====================================================================
    函数名      ：GetIdleMpuChn
    功能        ：获取空闲的Mpu通道
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/05/19    4.6         张宝卿        创建
====================================================================*/
// BOOL32 CMcuVcData::GetIdleMpuChn(u8 &byEqpId, u8 &byChnId)
// {
//     byEqpId = 0xff;
//     byChnId = 0xff;
// 
//     TPeriEqpStatus *ptStatus;
// 
//     for (u8 byIdx = BASID_MIN; byIdx <= BASID_MAX; byIdx++)
//     {
//         if (!IsPeriEqpValid(byIdx))
//         {
//             continue;
//         }
//         if ( !g_cMcuAgent.IsEqpBasHD(byIdx) )
//         {
//             continue;   
//         }
//         
//         ptStatus = &(m_atPeriEqpTable[byIdx-1].m_tPeriEqpStatus);
//         if (!ISTRUE(ptStatus->m_byOnline))
//         {
//             continue;
//         }
//         if (ptStatus->m_tStatus.tHdBas.GetEqpType() != TYPE_MPU)
//         {
//             continue;
//         }
// 
//         THDBasVidChnStatus tVidChn;
//         u8 byChnIdx = 0;
//         for (; byChnIdx < MAXNUM_MPU_CHN; byChnIdx++)
//         {
//             memset( &tVidChn, 0, sizeof(tVidChn) );
//             memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnIdx), sizeof(tVidChn) );
//             if (!tVidChn.IsReserved() &&
//                 !tVidChn.IsTempReserved() &&
//                 tVidChn.GetStatus() == THDBasChnStatus::READY )
//             {
//                 tVidChn.SetIsReserved(TRUE);
//                 ptStatus->m_tStatus.tHdBas.tStatus.tMpuBas.SetVidChnStatus(tVidChn, byChnIdx );
//                 byEqpId = byIdx;
//                 byChnId = byChnIdx;
//                 break;
//             }
//             else
//             {
//                 LogPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[GetIdleMpuChn] Eqp.%d failed due to<ChnIdx.%d, Res.%d, Status.%d>\n",
//                     byIdx, byChnIdx, tVidChn.IsReserved(), tVidChn.GetStatus());
//                 continue;
//             }
//         }
//         if (0xff != byEqpId && 0xff != byChnId)
//         {
//             break;
//         }
//     }
// 
//     if (0xff != byEqpId && 0xff != byChnId)
//     {
//         return TRUE;
//     }
//     return FALSE;
// }

/*====================================================================
函数名      GetIdle8keBasChn
功能        ：获取空闲的8kebas通道
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
03/01/2010   4.6        周嘉麟        创建
====================================================================*/
// BOOL32 CMcuVcData::GetIdle8keBasChn(u8 byChnType ,u8 &byEqpId, u8 &byChnId) 
// {
// 	byEqpId = 0xff;
//     byChnId = 0xff;
// 	
//     TPeriEqpStatus *ptStatus;
// 	
//     for (u8 byIdx = BASID_MIN; byIdx <= BASID_MAX; byIdx++)
//     {
//         if (!IsPeriEqpValid(byIdx))
//         {
//             continue;
//         }
//         
//         ptStatus = &(m_atPeriEqpTable[byIdx-1].m_tPeriEqpStatus);
//         if (!ISTRUE(ptStatus->m_byOnline))
//         {
//             continue;
//         }
//         if (ptStatus->m_tStatus.tHdBas.GetEqpType() != TYPE_8KE_BAS)
//         {
//             continue;
//         }
// 		
//         THDBasVidChnStatus tVidChn;
//         u8 byChnIdx = 0;
// 		
//         for (; byChnIdx < MAXNUM_8KEBAS_VCHN; byChnIdx++)
//         {
// 			memset( &tVidChn, 0, sizeof(tVidChn) );
// 			memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(byChnIdx), sizeof(tVidChn) );
// 			if (!tVidChn.IsReserved() &&
// 				!tVidChn.IsTempReserved() &&
// 				tVidChn.GetStatus() == THDBasChnStatus::READY &&
// 				byChnType == tVidChn.GetType())
// 			{
// 				tVidChn.SetIsReserved(TRUE);
// 				ptStatus->m_tStatus.tHdBas.tStatus.t8keBas.SetVidChnStatus(tVidChn, byChnIdx );
// 				byEqpId = byIdx;
// 				byChnId = byChnIdx;
// 				break;
// 			}
// 			else
// 			{
// 				LogPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[GetIdleMpuChn] Eqp.%d failed due to<ChnIdx.%d, Res.%d, Status.%d>\n",
// 					byIdx, byChnIdx, tVidChn.IsReserved(), tVidChn.GetStatus());
// 				continue;
// 			}
//         }
// 		
//         if (0xff != byEqpId && 0xff != byChnId)
//         {
//             break;
//         }
//     }
// 	
//     if (0xff != byEqpId && 0xff != byChnId)
//     {
//         return TRUE;
//     }
//     return FALSE;	
// }
/*====================================================================
    函数名      ：ReleaseHDBasChn
    功能        ：释放占用的HD-BAS通道
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	08/11/09    4.5         张宝卿        创建
====================================================================*/
// void CMcuVcData::ReleaseHDBasChn(u8 byEqpId, u8 byChnId)
// {
//     TPeriEqpStatus *ptStatus;
//     
//     if (!IsPeriEqpValid(byEqpId))
//     {
//         return;
//     }
// #ifdef	_8KE_								//[03/01/2010] zjl add 8kebas 不区分高标清
// #else
// 	if ( !g_cMcuAgent.IsEqpBasHD(byEqpId) )
//     {
//         return;   
//     }
// #endif
//     
//     ptStatus = &(m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus);
//     
//     //zbq[11/27/2008] 不在线的EQP也要清理数据区
//     //if (!ISTRUE(ptStatus->m_byOnline))
//     //{
//     //    return;
//     //}
// 
//     u8 byAdpType = ptStatus->m_tStatus.tHdBas.GetEqpType();
// 
//     switch (byAdpType)
//     {
//     case TYPE_MAU_NORMAL:
//     case TYPE_MAU_H263PLUS:
//         {
//             if (byChnId >= MAXNUM_MAU_VCHN + MAXNUM_MAU_DVCHN)
//             {
//                 LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseHDBasChn] unexpected mau chnId.%d\n", byChnId);
//                 return;
//             }
//             BOOL32 bReleaseMV = byChnId == 0 ? TRUE : FALSE;
//          
//             if (bReleaseMV)
//             {
//                 THDBasVidChnStatus tVidChn;
//                 memset( &tVidChn, 0, sizeof(tVidChn) );
//                 memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(), sizeof(tVidChn) );          
// 
//                 tVidChn.SetIsReserved(FALSE);
//                 tVidChn.SetStatus(THDBasChnStatus::READY);
// 				tVidChn.ClrOutputVidParam();
//                 ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.SetVidChnStatus(tVidChn);
//             }
//             else
//             {
//                 THDBasVidChnStatus tVidChn;
//                 memset( &tVidChn, 0, sizeof(tVidChn) );
//                 memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(), sizeof(tVidChn) );
//                 
//                 tVidChn.SetIsReserved(FALSE);
//                 tVidChn.SetStatus(THDBasChnStatus::READY);
// 				tVidChn.ClrOutputVidParam();
//                 ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.SetDVidChnStatus(tVidChn);
//             }
//         }
//         break;
// 
//     case TYPE_MPU:
//         {
//             if (byChnId >= MAXNUM_MPU_VCHN)
//             {
//                 LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseHDBasChn] unexpected mpu chnId.%d\n", byChnId);
//                 return;
//             }
//             THDBasVidChnStatus tVidChn;
//             memset( &tVidChn, 0, sizeof(tVidChn) );
//             memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId), sizeof(tVidChn) );
//             
//             tVidChn.SetIsReserved(FALSE);
//             tVidChn.SetStatus(THDBasChnStatus::READY);
// 			tVidChn.ClrOutputVidParam();
//             ptStatus->m_tStatus.tHdBas.tStatus.tMpuBas.SetVidChnStatus(tVidChn, byChnId );  
//         }
// 	case TYPE_8KE_BAS:
// 		{
// 			if (byChnId >= MAXNUM_8KEBAS_VCHN)
// 			{
// 				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseHDBasChn] unexpected 8kebas chnId.%d\n", byChnId);
//                 return;
// 			}
// 			THDBasVidChnStatus tVidChn;
//             memset( &tVidChn, 0, sizeof(tVidChn) );
//             memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(byChnId), sizeof(tVidChn) );
//             
//             tVidChn.SetIsReserved(FALSE);
//             tVidChn.SetStatus(THDBasChnStatus::READY);
// 			tVidChn.ClrOutputVidParam();
//             ptStatus->m_tStatus.tHdBas.tStatus.t8keBas.SetVidChnStatus(tVidChn, byChnId );  
// 		}
//     	break;
//     default:
//         LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseHDBasChn] unexpected EqpType.%d!\n", byAdpType);
//         break;
//     }
// 	SendPeriEqpStatusToMcs(byEqpId);
// 	UpdateAgentEqpStat(m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.GetEqpType());
//     return;
// }

/*====================================================================
    函数名      ：ResetHDBasChn
    功能        ：清空通道内适配参数：防止残留
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/05/20    4.6         张宝卿        创建
====================================================================*/
// void CMcuVcData::ResetHDBasChn(u8 byEqpId, u8 byChnId)
// {
//     TPeriEqpStatus tEqpStatus;
//     if (!g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tEqpStatus))
//     {
//         LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ResetHDBasChn] get Eqp.%d status failed!\n", byEqpId);
//         return;
//     }
//     
//     THDBasVidChnStatus tVidChn;
//     memset(&tVidChn, 0, sizeof(tVidChn));
//     
//     u8 byBasType = tEqpStatus.m_tStatus.tHdBas.GetEqpType();
//     switch (byBasType)
//     {
//     case TYPE_MAU_NORMAL:
//     case TYPE_MAU_H263PLUS:
//         {
//             if (byChnId >= MAXNUM_MAU_VCHN + MAXNUM_MAU_DVCHN)
//             {
//                 LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ResetHDBasChn] unexpected mau chnId.%d!\n", byChnId);
//                 return;
//             }
//             
//             BOOL32 bChnMV = byChnId == 0 ? TRUE : FALSE;
//             
//             if (bChnMV)
//             {
//                 tVidChn = *tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus();
//                 
//                 for(u8 byIdx = 0; byIdx < MAXNUM_VOUTPUT; byIdx++)
//                 {
//                     THDAdaptParam tParam = *tVidChn.GetOutputVidParam(byIdx);
//                     tParam.Reset();
//                     tVidChn.SetOutputVidParam(tParam, byIdx);
//                 }
//                 tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.SetVidChnStatus(tVidChn);
//                 g_cMcuVcApp.SetPeriEqpStatus(byEqpId, &tEqpStatus);
//             }
//             else
//             {
//                 tVidChn = *tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus();
//                 
//                 for(u8 byIdx = 0; byIdx < MAXNUM_VOUTPUT; byIdx++)
//                 {
//                     THDAdaptParam tParam = *tVidChn.GetOutputVidParam(byIdx);
//                     tParam.Reset();
//                     tVidChn.SetOutputVidParam(tParam, byIdx,TYPE_MAU_H263PLUS == byBasType);
//                 }
//                 tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.SetDVidChnStatus(tVidChn);
//                 g_cMcuVcApp.SetPeriEqpStatus(byEqpId, &tEqpStatus);
//             }
//         }
//         break;
//         
//     case TYPE_MPU:
// 	case TYPE_MPU_H:
//         {
//             tVidChn = *tEqpStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId);
//             
//             for(u8 byIdx = 0; byIdx < MAXNUM_MPU_H_VOUTPUT; byIdx++)
//             {
//                 THDAdaptParam tParam = *tVidChn.GetOutputVidParam(byIdx);
//                 tParam.Reset();
//                 tVidChn.SetOutputVidParam(tParam, byIdx, byBasType);
//             }
//             tEqpStatus.m_tStatus.tHdBas.tStatus.tMpuBas.SetVidChnStatus(tVidChn, byChnId);
//             g_cMcuVcApp.SetPeriEqpStatus(byEqpId, &tEqpStatus);
//         }
// 		break;
// 	case TYPE_8KE_BAS:
// 		{
// 			if (byChnId >= MAXNUM_8KEBAS_VCHN)
// 			{	
// 				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ResetHDBasChn] unexpected mpu chnId.%d!\n", byChnId);
//                 return;
// 			}
// 			tVidChn = *tEqpStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(byChnId);
// 			for(u8 byIdx = 0; byIdx < MAXNUM_8KEBAS_VOUTPUT; byIdx++)
//             {
//                 THDAdaptParam tParam = *tVidChn.GetOutputVidParam(byIdx);
//                 tParam.Reset();
//                 tVidChn.SetOutputVidParam(tParam, byIdx, tVidChn.GetType());
//             }
// 			tEqpStatus.m_tStatus.tHdBas.tStatus.t8keBas.SetVidChnStatus(tVidChn, byChnId);
//             g_cMcuVcApp.SetPeriEqpStatus(byEqpId, &tEqpStatus);
// 		}
//         break;
//         
//     default:
//         break;
//     }
// 
//     g_cMcuVcApp.SetPeriEqpStatus(byEqpId, &tEqpStatus);
//     
//     return;
// }

/*====================================================================
    函数名      ：GetIdleRecorder
    功能        ：查找是否有可用的录像机
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/07/18    4.0         顾振华        创建
====================================================================*/
BOOL32 CMcuVcData::IsRecorderOnline (u8 byEqpId)
{
	if (byEqpId == 0)
    {
        return FALSE;
    }	
    if( byEqpId <= MAXNUM_MCU_PERIEQP )
	{
		if( GetEqpType( byEqpId ) == EQP_TYPE_RECORDER &&
            m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_byOnline )
		{
            // 目前就简单了事
			return TRUE;
		}
	}    
    return FALSE;
}

/*====================================================================
    函数名      ：SetEqpAlias
    功能        ：设置外设别名
    算法实现    ：
    引用全局变量：
    输入参数说明：LPCSTR strAlias 外设别名	           
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/02/25    3.0         胡昌威           创建
====================================================================*/
void   CMcuVcData::SetEqpAlias( u8 byEqpId, LPCSTR lpszAlias )
{
	if( byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP )
	{
		return;
	}

	if( lpszAlias != NULL )
	{
		strncpy( m_atPeriEqpTable[byEqpId-1].m_achAliase, lpszAlias, MAXLEN_EQP_ALIAS );
		m_atPeriEqpTable[byEqpId-1].m_achAliase[MAXLEN_EQP_ALIAS - 1] = '\0';
	}
	else
	{
		memset( m_atPeriEqpTable[byEqpId-1].m_achAliase, 0, MAXLEN_EQP_ALIAS );
	}
}

/*====================================================================
    函数名      ：GetEqpAlias
    功能        ：得到外设别名
    算法实现    ：
    引用全局变量：
    输入参数说明：LPCSTR strAlias 外设别名	           
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/02/25    3.0         胡昌威           创建
====================================================================*/
LPCSTR CMcuVcData::GetEqpAlias( u8 byEqpId )
{
	if( byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP )
	{
		return NULL;
	}

	return m_atPeriEqpTable[byEqpId-1].m_achAliase;
}

/*====================================================================
    函数名      ：IsEqpH263pMau
    功能        ：得到mau 是否为H263p
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/01/08    4.5         张宝卿           创建
====================================================================*/
// BOOL32 CMcuVcData::IsEqpH263pMau(u8 byEqpId)
// {
//     if (!g_cMcuAgent.IsEqpBasHD(byEqpId))
//     {
//         return FALSE;
//     }
// 
//     TPeriEqpStatus tStatus;
//     GetPeriEqpStatus(byEqpId, &tStatus);
// 
//     if (TYPE_MAU_H263PLUS == tStatus.m_tStatus.tHdBas.GetEqpType())
//     {
//         return TRUE;
//     }
//     return FALSE;
// }

/*====================================================================
    函数名      ：GetIdleMau
    功能        ：得到mau 是否为H263p
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/01/08    4.5         张宝卿           创建
====================================================================*/
// void CMcuVcData::GetIdleMau(u8 &byNVChn, u8 &byVGAChn, u8 &byH263pChn)
// {
//     BOOL32 bNVReserved = FALSE;
//     BOOL32 bVGAReserved = FALSE;
//     BOOL32 bH263p = FALSE;
// 
//     for(u8 byEqpId = BASID_MIN; byEqpId <= BASID_MAX; byEqpId++)
//     {
//         TPeriEqpStatus tStatus;
//         if (GetPeriEqpStatus(byEqpId, &tStatus))
//         {
//             //hd only
//             if (g_cMcuVcApp.IsPeriEqpConnected(byEqpId) &&
//                 g_cMcuAgent.IsEqpBasHD(byEqpId) &&
//                 !tStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus()->IsNull() &&
//                 !tStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus()->IsNull())
//             {
//                 u8 byEqpType = tStatus.m_tStatus.tHdBas.GetEqpType();
//                 if (TYPE_MPU == byEqpType)
//                 {
//                     continue;
//                 }
// 
//                 u8 byConfIdx = tStatus.GetConfIdx();
//                 
//                 //one chnnl only
//                 bNVReserved = tStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus()->IsReserved();
//                 bVGAReserved = tStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus()->IsReserved();
//                 
//                 //h263p
//                 bH263p = byEqpType == TYPE_MAU_H263PLUS ? TRUE : FALSE;
//                 
//                 if (bH263p)
//                 {
//                     if (!bNVReserved)
//                     {
//                         byH263pChn++;
//                     }
//                 }
//                 else
//                 {
//                     if (!bNVReserved)
//                     {
//                         byNVChn ++;
//                     }
//                     if (!bVGAReserved)
//                     {
//                         byVGAChn++;
//                     }
//                 }
//             }
//         }
//     }
// 
//     return;
// }

/*====================================================================
    函数名      ：GetIdleMpu
    功能        ：得到空闲的mpu通道
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/05/19    4.6         张宝卿           创建
====================================================================*/
// void CMcuVcData::GetIdleMpu(u8 &byChnNum)
// {
//     byChnNum = 0;
//     BOOL32 bReserved = FALSE;
//     
//     for(u8 byEqpId = BASID_MIN; byEqpId <= BASID_MAX; byEqpId++)
//     {
//         TPeriEqpStatus tStatus;
//         memset(&tStatus, 0, sizeof(tStatus));
//         
//         if (!GetPeriEqpStatus(byEqpId, &tStatus))
//         {
//             continue;
//         }
// 
//         if (!g_cMcuVcApp.IsPeriEqpConnected(byEqpId) ||
//             !g_cMcuAgent.IsEqpBasHD(byEqpId))
//         {
//             continue;
//         }
//         u8 byEqpType = tStatus.m_tStatus.tHdBas.GetEqpType();
//         if (TYPE_MPU != byEqpType)
//         {
//             continue;
//         }
// 
//         for(u8 byChnIdx = 0; byChnIdx < MAXNUM_MPU_CHN; byChnIdx ++)
//         {
//             THDBasVidChnStatus tVidChn;
//             memset(&tVidChn, 0, sizeof(tVidChn));
//             tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnIdx);
//             bReserved = tVidChn.IsReserved();
//             
//             if (!bReserved)
//             {
//                 byChnNum ++;
//             }
//         }
//     }
//     
//     return;
// }

/*====================================================================
函数名      ：GetIdle8kebas
功能        ：得到空闲的8ke_bas数
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
02/25/2010  4.6         周嘉麟          创建
====================================================================*/
// void CMcuVcData::GetIdle8keBas(u8 &byMvChnNum, u8 &byDsChnNum)
// {
//     byMvChnNum = 0;
// 	byDsChnNum = 0;
// 
//     BOOL32 bReserved = FALSE;
//     
//     for(u8 byEqpId = BASID_MIN; byEqpId <= BASID_MAX; byEqpId++)
//     {
//         TPeriEqpStatus tStatus;
//         memset(&tStatus, 0, sizeof(tStatus));
//         
//         if (!GetPeriEqpStatus(byEqpId, &tStatus))
//         {
//             continue;
//         }
// 		
//         if (!g_cMcuVcApp.IsPeriEqpConnected(byEqpId) 
// 			)
//         {
//             continue;
//         }
//         u8 byEqpType = tStatus.m_tStatus.tHdBas.GetEqpType();
//         if (TYPE_8KE_BAS != byEqpType)
//         {
//             continue;
//         }
//         
//         for(u8 byChnIdx = 0; byChnIdx < MAXNUM_8KEBAS_VCHN; byChnIdx ++)
//         {
//             THDBasVidChnStatus tVidChn;
//             memset(&tVidChn, 0, sizeof(tVidChn));
//             tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(byChnIdx);
// 			u8 byChnType = tVidChn.GetType();
//             bReserved = tVidChn.IsReserved();
//             LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetIdle8keBas] chnStatus for chIdx.%d IsReserved: %d\n", byChnIdx, bReserved);
// 			
//             if (!bReserved)
//             {
// 				if (BAS_8KECHN_MV == byChnType)
// 				{
// 					byMvChnNum ++;
// 				}
// 				else if (BAS_8KECHN_DS == byChnType)
// 				{
// 					byDsChnNum ++;
// 				}
//             }
//         }		
//     }
// 	return;
// }


/*====================================================================
函数名      IsInHduVmp
功能        ：HDU是否支持多画面
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/11   4.7.2       陈兵         修改(HDU多画面支持)
====================================================================*/
BOOL32 CMcuVcData::IsMultiModeHdu(const u8 byHduId)
{
	TPeriEqpStatus tHduStatus;

	u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byHduId));
    g_cMcuVcApp.GetPeriEqpStatus(byHduId, &tHduStatus);

    for(u8 byHduChnId = 0; byHduChnId < min(byHduChnNum, MAXNUM_HDU_CHANNEL); byHduChnId++)
    {
		if( HDU_MODEFOUR_MAX_SUBCHNNUM == tHduStatus.m_tStatus.tHdu.GetChnMaxVmpMode(byHduChnId) )
		{					
			return TRUE;
		}
	}

	return FALSE;
}

/*====================================================================
函数名      ：GetEqpCodeFormat
功能        ：获取字符编码类型
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
20130517	4.7.2		国大卫		  创建
====================================================================*/
u8 CMcuVcData::GetEqpCodeFormat(const u8 byEqpId)
{
	if (byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP )
    {
        return emenCoding_Start;
    }
	return m_atPeriEqpTable[byEqpId - 1].m_byEqpCodeFormat;
}

/*====================================================================
函数名      ：SetEqpCodeFormat
功能        ：设置字符编码类型
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
20130517	4.7.2		国大卫		  创建
====================================================================*/
BOOL32 CMcuVcData::SetEqpCodeFormat(u8 byEqpId, u8 byCodeFormat)
{
	if (byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP )
    {
        return emenCoding_Start;
    }
	m_atPeriEqpTable[byEqpId - 1].m_byEqpCodeFormat = byCodeFormat;
	return TRUE;
}

/*====================================================================
    函数名      ：GetMpuChn
    功能        ：得到mpu所有通道
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/05/19    4.6         张宝卿           创建
====================================================================*/
void CMcuVcData::GetMpuNum(u8 &byMpuNum)
{
    byMpuNum = 0;
    //BOOL32 bReserved = FALSE;
    
    for(u8 byEqpId = BASID_MIN; byEqpId <= BASID_MAX; byEqpId++)
    {
        TPeriEqpStatus tStatus;
        memset(&tStatus, 0, sizeof(tStatus));
        
        if (!GetPeriEqpStatus(byEqpId, &tStatus))
        {
            continue;
        }
        
        if (!g_cMcuVcApp.IsPeriEqpConnected(byEqpId) ||
            !g_cMcuAgent.IsEqpBasHD(byEqpId))
        {
            continue;
        }
        u8 byEqpType = tStatus.m_tStatus.tHdBas.GetEqpType();
        if (TYPE_MPU != byEqpType)
        {
            continue;
        }
        byMpuNum += 1;
    }

    return;
}
/*====================================================================
    函数名      ShowPrsInfo
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/04/11    4.5         周嘉麟           创建
====================================================================*/
void CMcuVcData::ShowPrsInfo()
{
	StaticLog("PrsInfo as follows\n");

	for(u8 byEqpId = PRSID_MIN; byEqpId < PRSID_MAX; byEqpId++)
	{
		if (!IsPeriEqpValid(byEqpId))
        {
            continue;
        }
		if (0 == m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_byOnline )
		{
			continue;
		}
		StaticLog("PrsId:%d\n", byEqpId);
		for (u8 byPrsChnId = 0; byPrsChnId < MAXNUM_PRS_CHNNL; byPrsChnId++)
		{
			StaticLog("ChnId:%d, Reserved:%d, ConfIdx:%d\n", 
				      byPrsChnId, 
					  m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tPrs.m_tPerChStatus[byPrsChnId].byChlReserved,
					  m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tPrs.m_tPerChStatus[byPrsChnId].GetConfIdx());
		}
	}
}
/*====================================================================
    函数名      ：ShowBasInfo
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/04/11    4.5         张宝卿           创建
====================================================================*/
void CMcuVcData::ShowBasInfo()
{
    for(u8 byEqpId = BASID_MIN; byEqpId < BASID_MAX; byEqpId++)
    {
        if (!IsPeriEqpValid(byEqpId))
        {
            continue;
        }
        if (!IsPeriEqpConnected(byEqpId))
        {
            continue;
        }
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
		if (g_cMcuAgent.IsEqpBasHD(byEqpId))
#endif              
        {     
			u8 byBasType = m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdBas.GetEqpType();

			if (TYPE_MPU == byBasType || TYPE_MPU_H == byBasType)
			{
				StaticLog("\n---- MPU-BAS.%d info is as follows: ----\n\n", byEqpId);
				m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdBas.tStatus.tMpuBas.Print();
				StaticLog("\n---- MPU-BAS.%d info is end         ----\n", byEqpId);
			}
			else if ( TYPE_MPU2_BASIC == byBasType || TYPE_MPU2_ENHANCED == byBasType )
			{
				StaticLog("\n---- MPU2-BAS.%d info is as follows: ----\n\n", byEqpId);
				m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.Print();
				StaticLog("\n---- MPU2-BAS.%d info is end         ----\n", byEqpId);
			}
			else if(byBasType == TYPE_8KE_BAS)
			{				
				StaticLog("\n---- 8KE-BAS.%d info is as follows: ----\n\n", byEqpId);
				m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdBas.tStatus.t8keBas.Print();
				StaticLog("\n---- 8KE-BAS.%d info is end         ----\n", byEqpId);
			}
			else if(byBasType == TYPE_8KH_BAS)
			{				
				StaticLog("\n---- 8KH-BAS.%d info is as follows: ----\n\n", byEqpId);
				m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdBas.tStatus.t8khBas.Print();
				StaticLog("\n---- 8KH-BAS.%d info is end         ----\n", byEqpId);
			}
			else if(byBasType == TYPE_8KI_VID_BAS)
			{				
				StaticLog("\n---- 8KI-BAS.%d info is as follows: ----\n\n", byEqpId);
				m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdBas.tStatus.t8kiBas.Print();
				StaticLog("\n---- 8KI-BAS.%d info is end         ----\n", byEqpId);
			}
			else
			{
				StaticLog("\n---- MAU-BAS.%d info is as follows: ----\n\n", byEqpId);
				m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.Print();
				StaticLog("\n---- MAU-BAS.%d info is end         ----\n", byEqpId);
			}
		}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
		else if ( g_cMcuAgent.IsEqpBasAud(byEqpId)  )
#endif
		{
			u8 byAudType = m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tAudBas.GetEqpType();
			if (byAudType == TYPE_APU2_BAS)
			{
				StaticLog("\n---- APU2-BAS.%d info is as follows: ----\n\n", byEqpId);
				m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.Print();
				StaticLog("\n---- APU2-BAS.%d info is end         ----\n", byEqpId);
			}
			else if(TYPE_8KI_AUD_BAS == byAudType)
			{
				StaticLog("\n---- 8KIAUD-BAS.%d info is as follows: ----\n\n", byEqpId);
				m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.Print();
				StaticLog("\n---- 8KIAUD-BAS.%d info is end         ----\n", byEqpId);
			}
		}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
		else
		{
			StaticLog("\n---- VPU-BAS.%d info is as follows: ----\n\n", byEqpId);
			for(u8 byChnIdx = 0; byChnIdx < MAXNUM_VPU_OUTPUT; byChnIdx++)
			{
				m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tBas.tChnnl[byChnIdx].Print();
			}			
		}
#endif
    }
}

/*====================================================================
    函数名      ShowBasList
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010-6-30   4.6         周嘉麟           创建
====================================================================*/
void CMcuVcData::ShowBasList()
{
	m_cBasChnListMgr.Print();
}

/*====================================================================
    函数名      ShowTW
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010-6-30   4.6         周嘉麟          创建
	2011-10-24  4.6         刘旭            修改
====================================================================*/
void CMcuVcData::ShowTW(u8 byHduId)
{
	TPeriEqpStatus tTwStatus;
	u8 byTWId;
	TTvwMember tMember;
	TMt  tMt;

	StaticLog("------------------------------------------------------------------------------------------------------\n");
	StaticLog("%30s |             Tvw Member                    |\n", " ");
	StaticLog("%7s %5s %5s %5s|-------------------------------------------| %6s %5s %6s %6s\n", "TvwType", "EqpId", "ChIdx", "HduSubChnId", "Status", "Mute", "Volume", "Scheme");
	StaticLog("%30s | %5s %5s %5s %5s %4s %7s %4s |\n", 
		" ", "MType", "SType", "McuId", "MtId", "Conf", "MmbType", "Mode");
	StaticLog("------------------------------------------------------------------------------------------------------\n");

	if ( 0 != byHduId )
	{
		if ( byHduId >= TVWALLID_MIN && byHduId <= TVWALLID_MAX )
		{
			if (!GetPeriEqpStatus(byHduId, &tTwStatus))
			{
				StaticLog("EqpId is not Valid!");
				return;
			}
			
			for (u8 byChnId = 0; byChnId < 5; byChnId++)
			{	
				tMember = tTwStatus.m_tStatus.tTvWall.atVideoMt[byChnId];
				StaticLog("%5s %6d %4d       NO     | %3d %5d %5d %5d %4d %5d %6d   | \n", 
					"tvw", byHduId, byChnId, 
					tMember.GetType(),
					tMember.GetMtType(),
					tMember.GetMcuIdx(),
					tMember.GetMtId(),
					tMember.GetConfIdx(),
					tMember.byMemberType,
					GetChnnlMMode(byHduId, byChnId));
			}
		}

		if ( byHduId >= HDUID_MIN && byHduId <= HDUID_MAX )
		{
			if (!GetPeriEqpStatus(byHduId, &tTwStatus))
			{
				StaticLog("EqpId is not Valid!");
				return;
			}
			
			u8 byChnnlNum = GetHduChnNumAcd2Eqp(GetEqp(byHduId));
			for (u8 byChnId = 0; byChnId < byChnnlNum; byChnId++)
			{		
				// [2013/03/11 chenbing] 添加四风格处理 
				if ( HDUCHN_MODE_FOUR == tTwStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnId) )
				{
					for (u8 bySubChnId = 0; bySubChnId < HDU_MODEFOUR_MAX_SUBCHNNUM; bySubChnId++)
					{
						tMt = tTwStatus.m_tStatus.tHdu.GetChnMt(byChnId, bySubChnId);
						StaticLog("%5s %6d %4d %8d     | %3d %5d %5d %5d %4d %5d %6d   | %4d %5d %5d %6d\n", 
							GetHduTypeStr( *(TEqp*)&tTwStatus ),
							/*"hdu", */byHduId, byChnId, bySubChnId,
							tMt.GetType(),
							tMt.GetMtType(),
							tMt.GetMcuIdx(),
							tMt.GetMtId(),
							tMt.GetConfIdx(),
							tTwStatus.m_tStatus.tHdu.GetMemberType(byChnId, bySubChnId),
							GetChnnlMMode(byHduId, byChnId),
							tTwStatus.m_tStatus.tHdu.GetChnStatus(byChnId, bySubChnId),
							tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetIsMute(),
							tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetVolume(),
							tTwStatus.m_tStatus.tHdu.GetSchemeIdx(byChnId, bySubChnId));
					}
					continue;
				}
				tMember = tTwStatus.m_tStatus.tHdu.atVideoMt[byChnId];
				if ( HDUCHN_MODE_ONE == tTwStatus.m_tStatus.tHdu.GetChnMaxVmpMode(byChnId) )
				{
					StaticLog("%5s %6d %4d       NO     | %3d %5d %5d %5d %4d %5d %6d   | %4d %5d %5d %6d\n", 
						GetHduTypeStr( *(TEqp*)&tTwStatus ),
						/*"hdu", */byHduId, byChnId, 
						tMember.GetType(),
						tMember.GetMtType(),
						tMember.GetMcuIdx(),
						tMember.GetMtId(),
						tMember.GetConfIdx(),
						tMember.byMemberType,
						GetChnnlMMode(byHduId, byChnId),
						tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetStatus(),
						tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetIsMute(),
						tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetVolume(),
						tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetSchemeIdx()
					);
				}
				else
				{
					StaticLog("%5s %6d %4d      YES     | %3d %5d %5d %5d %4d %5d %6d   | %4d %5d %5d %6d\n", 
						GetHduTypeStr( *(TEqp*)&tTwStatus ),
						/*"hdu", */byHduId, byChnId, 
						tMember.GetType(),
						tMember.GetMtType(),
						tMember.GetMcuIdx(),
						tMember.GetMtId(),
						tMember.GetConfIdx(),
						tMember.byMemberType,
						GetChnnlMMode(byHduId, byChnId),
						tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetStatus(),
						tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetIsMute(),
						tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetVolume(),
						tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetSchemeIdx()
					);
				}
			}
		}
		StaticLog("\n");
		return;
	}

	for (byTWId = TVWALLID_MIN; byTWId <=  TVWALLID_MAX; byTWId++)
	{
		if (!GetPeriEqpStatus(byTWId, &tTwStatus))
		{
			continue;
		}
		if (tTwStatus.m_byOnline == 0)
		{
			continue;
		}
		
		for (u8 byChnId = 0; byChnId < 5; byChnId++)
		{	
			tMember = tTwStatus.m_tStatus.tTvWall.atVideoMt[byChnId];
			StaticLog("%5s %6d %4d       NO     | %3d %5d %5d %5d %4d %5d %6d   | \n", 
				"tvw", byTWId, byChnId, 
				tMember.GetType(),
				tMember.GetMtType(),
				tMember.GetMcuIdx(),
				tMember.GetMtId(),
				tMember.GetConfIdx(),
				tMember.byMemberType,
				GetChnnlMMode(byTWId, byChnId));
		}
		StaticLog("\n");
		
	}
	
	for (byTWId = HDUID_MIN; byTWId <= HDUID_MAX; byTWId++)
	{
		if (!GetPeriEqpStatus(byTWId, &tTwStatus))
		{
			continue;
		}
		if (tTwStatus.m_byOnline == 0)
		{
			continue;
		}
		
		u8 byChnnlNum = GetHduChnNumAcd2Eqp(GetEqp(byTWId));
		for (u8 byChnId = 0; byChnId < byChnnlNum; byChnId++)
		{		
			// [2013/03/11 chenbing] 添加四风格处理 
			if ( HDUCHN_MODE_FOUR == tTwStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnId) )
			{
				for (u8 bySubChnId = 0; bySubChnId < HDU_MODEFOUR_MAX_SUBCHNNUM; bySubChnId++)
				{
					tMt = tTwStatus.m_tStatus.tHdu.GetChnMt(byChnId, bySubChnId);
					StaticLog("%5s %6d %4d %8d     | %3d %5d %5d %5d %4d %5d %6d   | %4d %5d %5d %6d\n", 
						GetHduTypeStr( *(TEqp*)&tTwStatus ),
						/*"hdu", */byTWId, byChnId, bySubChnId,
						tMt.GetType(),
						tMt.GetMtType(),
						tMt.GetMcuIdx(),
						tMt.GetMtId(),
						tMt.GetConfIdx(),
						tTwStatus.m_tStatus.tHdu.GetMemberType(byChnId, bySubChnId),
						GetChnnlMMode(byTWId, byChnId),
						tTwStatus.m_tStatus.tHdu.GetChnStatus(byChnId, bySubChnId),
						tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetIsMute(),
						tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetVolume(),
						tTwStatus.m_tStatus.tHdu.GetSchemeIdx(byChnId, bySubChnId));
				}
				continue;
			}
			tMember = tTwStatus.m_tStatus.tHdu.atVideoMt[byChnId];
			if ( HDUCHN_MODE_ONE == tTwStatus.m_tStatus.tHdu.GetChnMaxVmpMode(byChnId) )
			{
				StaticLog("%5s %6d %4d       NO     | %3d %5d %5d %5d %4d %5d %6d   | %4d %5d %5d %6d\n", 
					GetHduTypeStr( *(TEqp*)&tTwStatus ),
					/*"hdu", */byTWId, byChnId, 
					tMember.GetType(),
					tMember.GetMtType(),
					tMember.GetMcuIdx(),
					tMember.GetMtId(),
					tMember.GetConfIdx(),
					tMember.byMemberType,
					GetChnnlMMode(byTWId, byChnId),
					tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetStatus(),
					tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetIsMute(),
					tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetVolume(),
					tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetSchemeIdx()
				);
			}
			else
			{
				StaticLog("%5s %6d %4d      YES     | %3d %5d %5d %5d %4d %5d %6d   | %4d %5d %5d %6d\n", 
					GetHduTypeStr( *(TEqp*)&tTwStatus ),
					/*"hdu", */byTWId, byChnId, 
					tMember.GetType(),
					tMember.GetMtType(),
					tMember.GetMcuIdx(),
					tMember.GetMtId(),
					tMember.GetConfIdx(),
					tMember.byMemberType,
					GetChnnlMMode(byTWId, byChnId),
					tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetStatus(),
					tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetIsMute(),
					tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetVolume(),
					tTwStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].GetSchemeIdx()
				);
			}
		}
		StaticLog("\n");
	}
}


/*====================================================================
    函数名      ：GetTvWallOutputMode
    功能        ：得到电视墙输出模式
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byEqpId 外设号	           
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	05/10/18    3.6         libo           创建
====================================================================*/
u8 CMcuVcData::GetTvWallOutputMode(u8 byEqpId)
{
    if (byEqpId == 0 || byEqpId > MAXNUM_MCU_PERIEQP)
    {
        return TW_OUTPUTMODE_NONE;
    }

    if (EQP_TYPE_TVWALL != m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.GetEqpType())
    {
        return TW_OUTPUTMODE_NONE;
    }

    return m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tTvWall.byOutputMode;
}

//4.6.1  新加  jlb
/*====================================================================
    函数名      : GetHduOutputMode
    功能        : 得到Hdu输出模式
    算法实现    :
    引用全局变量:
    输入参数说明: u8 byEqpId 外设号	           
    返回值说明  :
----------------------------------------------------------------------
    修改记录    :
    日  期      版本        修改人        修改内容
	09/01/19    4.6         江乐斌           创建
====================================================================*/
u8 CMcuVcData::GetHduOutputMode( u8 byEqpId )    
{
	//lx,封装了hdu的判断
	if (!IsValidHduEqp(GetEqp(byEqpId)))
	{
		return HDU_OUTPUTMODE_NONE;
	}

    return m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdu.byOutputMode;
}

/*====================================================================
    函数名      ：EqpStatusShow
    功能        ：显示外设的状态信息
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byEqpId 返回的外设号
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/01/09    3.0         zmy            创建
====================================================================*/
void CMcuVcData::EqpStatusShow( u8   byEqpId )
{
    s8  achEqpType[][14]={"UNKNOW","MIXER","VMP","RECORDER","BAS","TVWALL","DCS","PRS","FILEENC","VMPTW","HDU","","EMIXER","HDU_H","HDU_L","HDU2" };
    StaticLog("_____________________________________________________________\n");
    if (byEqpId < 1) 
    {
        StaticLog("Eqp Id must from 1 - 140\n");
        StaticLog("Dcs Id must from 1 - 16 ( support only one now )\n");
        StaticLog("<<<<<<<<<<<<<                   当前配置外设信息                  >>>>>>>>>>>>>\n");

		/*lint -save -e661*/
        for(s32 nIdx =1; nIdx <= MAXNUM_MCU_PERIEQP; nIdx++)
        {
            if (m_atPeriEqpTable[nIdx-1].m_bIsValid)
            {
				const u8 byEqpType = GetEqpType(nIdx);
				const u8 byElemNum = sizeof(achEqpType)/sizeof(achEqpType[0]);
				const s8* pszOnline = m_atPeriEqpTable[nIdx-1].m_tPeriEqpStatus.m_byOnline ? "在线":"掉线";
				const s8* pszIp = GetEqpIpAddr(nIdx) > 0 ? StrOfIP(GetEqpIpAddr(nIdx)) : "";

                StaticLog(" %s (Eqp.%3d) %10s %8s \t%-15s \t%s\n",
                          m_atPeriEqpTable[nIdx-1].m_tPeriEqpStatus.m_byOnline ? "√":"×",
                          nIdx,
                          achEqpType[min(byEqpType, byElemNum)],
                          pszOnline,
						  pszIp,
						  m_atPeriEqpTable[nIdx-1].m_tPeriEqpStatus.GetAlias());
            }
        }
		/*lint -restore*/

        u8 byDcsNum = 0;
        for(u8 byIdx = 1; byIdx <= MAXNUM_MCU_DCS; byIdx ++ )
        {            
            if (m_atPeriDcsTable[byIdx-1].m_bIsValid) 
            {
                byDcsNum ++ ;
                if ( 1 == byDcsNum )
                {
                    StaticLog("\n" );
                }
                StaticLog(" %s (Dcs.%2d) %10s %s \n",
                          m_atPeriDcsTable[byIdx-1].m_tDcsStatus.m_byOnline ? "√":"×",
                          byIdx,
                          achEqpType[EQP_TYPE_DCS],
                          m_atPeriDcsTable[byIdx-1].m_tDcsStatus.m_byOnline ? "在线":"掉线");
            }
        }
        StaticLog( "_____________________________________________________________\n\n");
        return;
    }

	StaticLog("\nEqpId = %d    ", byEqpId);
	if (!m_atPeriEqpTable[byEqpId-1].m_bIsValid)
	{
		StaticLog("NOT CONFIG\n");
		return;
	}

	if( !m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_byOnline )
	{
		StaticLog("    Offline\n");
		return;
	}
    
	StaticLog("\n");
	switch( GetEqpType( byEqpId) ) 
	{
	case EQP_TYPE_BAS://码流适配器
		{
//             if ( !g_cMcuAgent.IsEqpBasHD(byEqpId) )
//             {
// 			    nChnnlNum = m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tBas.byChnNum;
// 			    LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, " Status:  IDLE(0),READY(1),RUNING(2)\n");
// 			    LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, " BAS.%d has %d channels\n\n", byEqpId, nChnnlNum);
// 			    LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "%3s%7s%10s%14s%10s\n","CH","Status","Type A/V","  Resolution","Bitrate");
// 			    for(nChnIdx =0 ;nChnIdx <  min(MAXNUM_BAS_CHNNL,nChnnlNum);nChnIdx++)
// 			    {
// 				    LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "%3d %6d   %2d/%2d   %5d X %-5d%10d\n",nChnIdx,
// 					    m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tBas.tChnnl[nChnIdx].GetStatus(),
// 					    m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tBas.tChnnl[nChnIdx].GetAudType(),
// 					    m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tBas.tChnnl[nChnIdx].GetVidType(),
// 					    m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tBas.tChnnl[nChnIdx].GetWidth(),
// 					    m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tBas.tChnnl[nChnIdx].GetHeight(),
// 					    m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tBas.tChnnl[nChnIdx].GetBitrate());
// 			    }
//             }
//             else
//             {
//                 LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, " Status:  IDLE(0),READY(1),RUNING(2)\n");
//                 LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, " Reserve type:  IDLE(0),Reserved(1),Temp reserved(2)\n");
//                 LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, " %-6s %-3s %-5s %-10s %-14s%\n","EQPID","CH","Type","Status","Reservetype");
//                 for ( nChnIdx = 0; nChnIdx < MAXNUM_MAU_VCHN; nChnIdx++ )
//                 {
//                     LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, " %-6d %-3d %-5s %-10d %-4d\n",
//                     m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(nChnIdx)->GetEqpId(),
//                     m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(nChnIdx)->GetChnIdx(),
//                     "VID",
//                     m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(nChnIdx)->GetStatus(),
//                     m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(nChnIdx)->GetReservedType());
//                 }
//                 for ( nChnIdx = 0; nChnIdx < MAXNUM_MAU_DVCHN; nChnIdx++ )
//                 {
//                     LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, " %-6d %-3d %-5s %-10d %-4d\n",
//                     m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(nChnIdx)->GetEqpId(),
//                     m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(nChnIdx)->GetChnIdx(),
//                     "DVID",
//                     m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(nChnIdx)->GetStatus(),
//                     m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(nChnIdx)->GetReservedType());
//                 }
//             }
		}
		break;
	case EQP_TYPE_MIXER://混音器
		{
			u8   byIdx;
			u8   byMmbNum;
			u8   abyActiveMmb[MAXNUM_MIXER_DEPTH];
			u8   abyMixMmb[256];
			static char status[3][7]={"  IDLE"," READY","MIXING"};
			static char acharSubMixer[6][7]={"UNKONW","APU2","APU","EAPU","8KG","8KH"};
			u8 byMixerSubtype = UNKONW_MIXER;
			g_cMcuAgent.GetMixerSubTypeByEqpId(byEqpId,byMixerSubtype);
			StaticLog("\n------[ MIXER(%s)(%s).%d  Format[%s]  MIXEROFFID[%d]-----\n",acharSubMixer[byMixerSubtype],
				m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.GetAlias(),byEqpId,
				(m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tMixer.m_bIsMultiFormat?"多格式":"单格式"),
				m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tMixer.m_byGrpNum);
			StaticLog("Status(%d) : %s          MemNum  : %d   ChnOff : %d \n",
				m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[0].m_byGrpState,
				status[m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[0].m_byGrpState],
				m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[0].m_byMixGrpChnNum,
				m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tMixer.m_byMixOffChnNum);
			StaticLog("Active Mmb:");
			
			byMmbNum =m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[0].GetActiveMmb( abyActiveMmb ,MAXNUM_MIXER_DEPTH);
			for( byIdx=0 ;byIdx< byMmbNum ;byIdx++)
			{
				StaticLog(" %d",abyActiveMmb[byIdx]);		
			}
			StaticLog("\n");
			StaticLog("Mixing Member Id\n");
			
			byMmbNum = m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[0].GetMixMmb( abyMixMmb ,200);
			for( byIdx=0 ;byIdx< byMmbNum ;byIdx++)
			{
				StaticLog(" %3d",abyMixMmb[byIdx]);
				if( ((byIdx+1)%10)==0 )
					StaticLog("\n");
			}
		}
		break;
	case EQP_TYPE_RECORDER://录像机
		{
			TRecChnnlStatus tChnStatus;
			u8 byRecChnNum  ,byChnIdx;
			TRecStatus * ptRecStatus = &m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tRecorder;
			byRecChnNum  = ptRecStatus->GetRecChnnlNum();
			
			StaticLog("_____________________ Recorder.%d ___________________\n",byEqpId);
			StaticLog("%-6s %-12s %-10s %6s/%-6s %s\n","  CH","    Status","    Mode","Cur(S)","Tot(S)","Recording Name ");
			for( byChnIdx = 0 ;byChnIdx < byRecChnNum ;byChnIdx++ )
			{
				ptRecStatus->GetChnnlStatus( byChnIdx ,TRecChnnlStatus::TYPE_RECORD ,&tChnStatus);
				StaticLog("CH.%2d  %12s %10s %6d/%-6d %s\n",byChnIdx 
					,tChnStatus.GetStatusStr( tChnStatus.m_byState)
					,tChnStatus.m_byRecMode == TRecChnnlStatus::MODE_REALTIME ?"NORMAL":"SKIP"
					,tChnStatus.m_tProg.GetCurProg(),tChnStatus.m_tProg.GetTotalTime() 
					,tChnStatus.GetRecordName());
			}
			
			StaticLog("\t__________________________________________\n");
			StaticLog("%-6s %-12s %6s/%-6s %s\n","  CH","    Status","Cur(S)","Tot(S)","Playing Name ");
			for( byChnIdx = 0 ;byChnIdx < byRecChnNum ;byChnIdx++ )
			{
				ptRecStatus->GetChnnlStatus( byChnIdx ,TRecChnnlStatus::TYPE_PLAY ,&tChnStatus);
				StaticLog("CH.%2d  %12s %6d/%-6d %s\n",byChnIdx 
					,tChnStatus.GetStatusStr( tChnStatus.m_byState) 
					,tChnStatus.m_tProg.GetCurProg(),tChnStatus.m_tProg.GetTotalTime()
					,tChnStatus.GetRecordName());
			}
		}
		break;
	case EQP_TYPE_TVWALL:
		{
			TTvWallStatus *ptTWStatus;
			ptTWStatus = &m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tTvWall;
			StaticLog("_________________%d channels TV Wall ________________\n",ptTWStatus->byChnnlNum);
			for( u8 byChnIdx=0 ;byChnIdx < ptTWStatus->byChnnlNum ;byChnIdx++)
			{
				StaticLog("Chn.%d Playing Mcu.%d MT.%d\n",byChnIdx
					,ptTWStatus->atVideoMt[byChnIdx].GetMcuId()
					,ptTWStatus->atVideoMt[byChnIdx].GetMtId());
			}
		}
		break;

	case EQP_TYPE_HDU:
// 	case EQP_TYPE_HDU_L:
// 	case EQP_TYPE_HDU_H:
// 	case EQP_TYPE_HDU2:
// 	case EQP_TYPE_HDU2_L:
		{
			THduStatus *ptHduStatus;
			ptHduStatus = &m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tHdu;
			StaticLog("_________________%d channels HDU ________________\n",ptHduStatus->GetChnnlNum());
			for( u8 byChnIdx=0 ;byChnIdx < ptHduStatus->GetChnnlNum() ;byChnIdx++)
			{
				StaticLog("Chn.%d Playing Mcu.%d MT.%d\n",byChnIdx
					,ptHduStatus->atVideoMt[byChnIdx].GetMcuId()
					,ptHduStatus->atVideoMt[byChnIdx].GetMtId());
			}
		}
		break;

	case EQP_TYPE_VMP:
		{
			TVmpStatus *ptVmpStatus;
			ptVmpStatus = &m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.m_tStatus.tVmp;
			StaticLog("___ UseState:%d, SubType:%d, BoardVer:%d, ConfIdx:%d. _______\n",
				ptVmpStatus->m_byUseState, ptVmpStatus->m_bySubType, ptVmpStatus->m_byBoardVer, m_atPeriEqpTable[byEqpId-1].m_tPeriEqpStatus.GetConfIdx());
			StaticLog("_________________%d channels Vmp ________________\n",ptVmpStatus->m_byChlNum);
			TVMPParam_25Mem tPeriVmpParam = ptVmpStatus->GetVmpParam();
			TVMPMember *ptVmpMember = NULL;
			StaticLog("VMPAuto.%d VMPBrdst.%d VMPStyle.%d VMPSchemeId.%d VMPMode.%d\n",tPeriVmpParam.IsVMPAuto(), tPeriVmpParam.IsVMPBrdst(), tPeriVmpParam.GetVMPStyle(), tPeriVmpParam.GetVMPSchemeId(), tPeriVmpParam.GetVMPMode());
			for( u8 byChnIdx=0 ;byChnIdx < ptVmpStatus->m_byChlNum ;byChnIdx++)
			{
				ptVmpMember = tPeriVmpParam.GetVmpMember(byChnIdx);

				if (ptVmpMember == NULL)
				{
					continue;
				}
				StaticLog("Chn.%d Playing Mcu.%d MT.%d\n",byChnIdx
					,ptVmpMember->GetMcuId()
					,ptVmpMember->GetMtId());
			}
		}
		break;

	default:
		break;
	};

}

/*====================================================================
    函数名      ：AssignMtPort
    功能        ：分配终端端口
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx 会议索引号
				  u8 byMtId 终端号
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/03/02    3.0         胡昌威          创建
====================================================================*/
u16  CMcuVcData::AssignMtPort( u8 byConfIdx, u8 byMtId )
{
	u16 wPort = 0;
	u16 wPortIndex = 0;
	while( wPortIndex < MAXNUM_MCU_MT + 1 )
	{
		if( m_atRecvMtPort[wPortIndex].m_byPortInUse )
		{
			wPortIndex++;
		}
		else
		{
			break;
		}
	}
	
	if( wPortIndex < MAXNUM_MCU_MT + 1 )
	{
		wPort = g_cMcuAgent.GetRecvStartPort() + PORTSPAN * wPortIndex;
		m_atRecvMtPort[wPortIndex].m_byPortInUse = TRUE;
		m_atRecvMtPort[wPortIndex].m_byConfIdx = byConfIdx;
		m_atRecvMtPort[wPortIndex].m_byMtId = byMtId;
	}
	else
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_MT, "[AssignMtPort] all Ports have been occupied, so wPort is 0 !!!!\n");
		wPort = 0;
	}

	return wPort;
}

/*====================================================================
    函数名      ：ReleaseMtPort
    功能        ：释放终端端口
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx 会议索引号
				  u8 byMtId 终端号
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/03/02    3.0         胡昌威          创建
====================================================================*/
void CMcuVcData::ReleaseMtPort( u8 byConfIdx, u8 byMtId )
{
	u16 wPortIndex = 0;
	while( wPortIndex < MAXNUM_MCU_MT + 1 )
	{
		if( m_atRecvMtPort[wPortIndex].m_byConfIdx == byConfIdx 
			&& m_atRecvMtPort[wPortIndex].m_byMtId == byMtId )
		{
			m_atRecvMtPort[wPortIndex].m_byPortInUse = FALSE;
			m_atRecvMtPort[wPortIndex].m_byConfIdx = 0;
			m_atRecvMtPort[wPortIndex].m_byMtId = 0;
			break;
		}
		else
		{
			wPortIndex++;
		}
	}
}

/*====================================================================
    函数名      ：AssignMulticastIp
    功能        ：分配组播Ip地址
    算法实现    ：231.255.255.255 --- 233.0.0.0为保留范围
    引用全局变量：
    输入参数说明：无
    返回值说明  ：分配的组播Ip地址 - 主机序
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	05/09/27    4.0         libo          创建
    06/04/06    4.0         顾振华        根据会议模版，而不再自动生成
====================================================================*/
u32  CMcuVcData::AssignMulticastIp(u8 byConfIdx)
{
    u32 dwMultiCastAddr = 0;
    CMcuVcInst* pVcInst = GetConfInstHandle(byConfIdx);
    if ( NULL != pVcInst )
    {
        // 顾振华@2006.4.8 直接从会议里面获取
        dwMultiCastAddr = pVcInst->m_tConf.GetConfAttrb().GetMulticastIp();
    }
    else
    {
        // Fatal error!
        LogPrint(LOG_LVL_ERROR, MID_MCU_MT, "Cannot get VC Instance(conf idx: %d) while AssignMulticastIp!\n", 
                            byConfIdx);
    }

    return dwMultiCastAddr;
}

/*====================================================================
    函数名      ：AssignMulticastPort
    功能        ：分配组播端口
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx 会议索引号
				  u8 byMtId 终端号
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/03/02    3.0         胡昌威        创建
    06/04/06    4.0         顾振华        根据会议模版，而不再自动生成
====================================================================*/
u16  CMcuVcData::AssignMulticastPort( u8 byConfIdx, u8 byMtId )
{
	u16 wMultiCastPort;
	u16 wPort = 0;
	u16 wPortIndex = 0;

    CMcuVcInst* pVcInst = GetConfInstHandle(byConfIdx);
    if ( NULL == pVcInst )
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_MT, "Cannot get VC Instance(conf idx: %d) while AssignMulticastPort!\n", 
                            byConfIdx);
        return 0;
    }

    // 顾振华@2006.4.8 直接从会议里面获取
    wMultiCastPort = pVcInst->m_tConf.GetConfAttrb().GetMulticastPort();    
    
    // xsl [9/25/2006] 会议组播不分配port
    if (0 == byMtId)
    {
        return wMultiCastPort;
    }
    
	//该端口是否已分配好
	while( wPortIndex < MAXNUM_MCU_MT + 1 )
	{
		if( m_atMulticastPort[wPortIndex].m_byConfIdx == byConfIdx 
			&& m_atMulticastPort[wPortIndex].m_byMtId == byMtId )
		{           
			wPort = wMultiCastPort + 4 * wPortIndex;
			return wPort;
		}
		else
		{
			wPortIndex++;
		}
	}

    //查找空闲端口
	wPortIndex = 0;
	while( wPortIndex < MAXNUM_MCU_MT + 1 )
	{
		if( m_atMulticastPort[wPortIndex].m_byPortInUse )
		{
			wPortIndex++;
		}
		else
		{
			break;
		}
	}
	
	//分配端口
	if( wPortIndex < MAXNUM_MCU_MT + 1 )
	{
		wPort = wMultiCastPort + 4 * wPortIndex;
		m_atMulticastPort[wPortIndex].m_byPortInUse = TRUE;
		m_atMulticastPort[wPortIndex].m_byConfIdx = byConfIdx;
		m_atMulticastPort[wPortIndex].m_byMtId = byMtId;
	}
	else
	{
		wPort = 0;
	}

	return wPort;
}

/*====================================================================
    函数名      ：IsMulticastAddrOccupied
    功能        ：查找所有的即时会议，是否启用了相应的地址
    算法实现    ：暂时一个会议占用一个IP地址，不允许多会议占用1个
    引用全局变量：
    输入参数说明：
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    06/04/06    4.0         顾振华        创建
====================================================================*/
BOOL32 CMcuVcData::IsMulticastAddrOccupied(u32 dwCastIp, u16 wCastPort)
{
	LogPrint(LOG_LVL_DETAIL,MID_MCU_CONF,"[IsMulticastAddrOccupied] dwCastIp:0x%x wCastPort:%d\n",dwCastIp,wCastPort);
    // 暂时不考虑端口
	CMcuVcInst* pcVcInst = NULL;
	for (u8 byInstID = 1; byInstID <= MAXNUM_MCU_CONF; byInstID++)
	{
		pcVcInst = m_apConfInst[byInstID-1];
		if (NULL != pcVcInst)
		{
            //组播地址与卫星组播地址也不能冲突
            //会议为卫星分散会议或组播会议才对比地址和端口
            if ( pcVcInst->m_tConf.m_tStatus.IsOngoing() &&
                 ( ( pcVcInst->m_tConf.GetConfAttrb().IsMulticastMode() && 
                     pcVcInst->m_tConf.GetConfAttrb().GetMulticastIp() == dwCastIp) || 
                   ( pcVcInst->m_tConf.GetConfAttrb().IsSatDCastMode() && 
                     pcVcInst->m_tConf.GetConfAttrb().GetSatDCastIp() == dwCastIp ) ) )
            {
                // 发现已经被占用
                return TRUE;
            }
		}	
	}    
    return FALSE;
}

/*====================================================================
    函数名      ：ReleaseMulticastPort
    功能        ：释放组播端口
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byConfIdx 会议索引号
				  u8 byMtId 终端号
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/03/02    3.0         胡昌威          创建
====================================================================*/
void CMcuVcData::ReleaseMulticastPort( u8 byConfIdx, u8 byMtId )
{
	u16 wPortIndex = 0;
	while( wPortIndex < MAXNUM_MCU_MT + 1 )
	{
		if( m_atMulticastPort[wPortIndex].m_byConfIdx == byConfIdx 
			&& m_atMulticastPort[wPortIndex].m_byMtId == byMtId )
		{
			m_atMulticastPort[wPortIndex].m_byPortInUse = FALSE;
			m_atMulticastPort[wPortIndex].m_byConfIdx = 0;
			m_atMulticastPort[wPortIndex].m_byMtId = 0;
			break;
		}
		else
		{
			wPortIndex++;
		}
	}
}

/*====================================================================
    函数名      ：IsDistrConfCastAddrOccupied
    功能        ：查找所有的即时会议，是否启用了相应的分散会议组播地址
    算法实现    ：只有当地址和端口都被占用才认为被占用
    引用全局变量：
    输入参数说明：
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/04/12    4.0         顾振华        创建
====================================================================*/
BOOL32 CMcuVcData::IsDistrConfCastAddrOccupied( u32 dwCastIp, u16 wCastPort) 
{
	CMcuVcInst* pcVcInst = NULL;
	for (u8 byInstID = 1; byInstID <= MAXNUM_MCU_CONF; byInstID++)
	{
		pcVcInst = m_apConfInst[byInstID-1];
		if (NULL != pcVcInst)
		{
            //卫星组播地址与组播地址不能冲突
            //会议为卫星分散会议或组播会议才对比地址和端口
            if (pcVcInst->m_tConf.m_tStatus.IsOngoing() &&                
                ( ( pcVcInst->m_tConf.GetConfAttrb().IsSatDCastMode() &&
                    pcVcInst->m_tConf.GetConfAttrb().GetSatDCastIp() == dwCastIp &&
                    pcVcInst->m_tConf.GetConfAttrb().GetSatDCastPort() == wCastPort ) ||
                  ( pcVcInst->m_tConf.GetConfAttrb().IsMulticastMode() &&
                    pcVcInst->m_tConf.GetConfAttrb().GetMulticastIp() == dwCastIp &&
                    pcVcInst->m_tConf.GetConfAttrb().GetMulticastPort() == wCastPort ) ) )
            {
                // 发现已经被占用
                return TRUE;
            }
		}	
	}    
    return FALSE;
}

/*=============================================================================
    函 数 名： GetBaseInfoFromDebugFile
    功    能： 获取指定MCU Debug文件中基本调试信息设置
    算法实现： 
    全局变量： 
    参    数： 
    返 回 值： void 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/22  4.0			万春雷                  创建
=============================================================================*/
void CMcuVcData::GetBaseInfoFromDebugFile( )
{
	McuGetDebugKeyValue(m_tMcuDebugVal);

	return;
}

/*=============================================================================
    函 数 名： GetMcuTelnetPort
    功    能： 获取指定MCU Debug文件中MCU_TELNET端口设置
    算法实现： 
    全局变量： 
    参    数： 
    返 回 值： u16 主机序 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/22  4.0			万春雷                  创建
=============================================================================*/
u16 CMcuVcData::GetMcuTelnetPort( )
{
	return m_tMcuDebugVal.m_wMcuTelnetPort;
}

BOOL32 CMcuVcData::IsTelnetEnable()
{
	return (m_tMcuDebugVal.m_byTelnetEn == 1);
}

/*=============================================================================
    函 数 名： GetBaseInfoFromDebugFile
    功    能： 获取指定MCU Debug文件中MCU_LISTEN端口设置
    算法实现： 
    全局变量： 
    参    数： 
    返 回 值： u16 主机序 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/22  4.0			万春雷                  创建
=============================================================================*/
u16 CMcuVcData::GetMcuListenPort( )
{
	return m_tMcuDebugVal.m_wMcuListenPort;
}

/*=============================================================================
    函 数 名： GetMcsRefreshInterval
    功    能： 获取指定MCU Debug文件中MCS的终端转台刷新间隔设置
    算法实现： 
    全局变量： 
    参    数： 
    返 回 值： u32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/22  4.0			万春雷                  创建
=============================================================================*/
u32 CMcuVcData::GetMcsRefreshInterval( )
{
	return m_tMcuDebugVal.m_dwMcsRefreshInterval;
}

/*=============================================================================
    函 数 名： IsWatchDogEnable
    功    能： 获取指定MCU Debug文件中看门狗是否激活设置
    算法实现： 
    全局变量： 
    参    数： 
    返 回 值： BOOL32
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/22  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsWatchDogEnable( )
{
	return m_tMcuDebugVal.m_bWDEnable;
}

/*=============================================================================
    函 数 名： IsHDMt
    功    能： 是否高清终端类型
    算法实现： 
    全局变量： 
    参    数： 
    返 回 值： BOOL32
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2010/02/09  4.0			周晶晶                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsHDMt( s8* pachProductID )
{
	if( !IsCanConfCapabilityCheat() )
	{
		return FALSE;
	}
	
	if( NULL == pachProductID )
	{
		return FALSE;
	}

	u8 byProductStrLen = strlen(pachProductID);

	if( 0 == byProductStrLen )
	{
		return FALSE;
	}

	u8 byIndex = 0;
	u8 byCharIndex = 0;

	while( byIndex < m_tMcuDebugVal.m_byConfHDMtBoardTypeNum )
	{
		if( strlen( (char*)&m_tMcuDebugVal.m_pachHDMtBoardType[byIndex][0] ) != byProductStrLen )
		{
			byIndex++;
			continue;
		}
		for( byCharIndex = 0;byCharIndex < byProductStrLen;byCharIndex++ )
		{
			if( pachProductID[byCharIndex] != 
				m_tMcuDebugVal.m_pachHDMtBoardType[byIndex][byCharIndex] )
			{
				if( m_tMcuDebugVal.m_pachHDMtBoardType[byIndex][byCharIndex] >= 'A' &&
					m_tMcuDebugVal.m_pachHDMtBoardType[byIndex][byCharIndex] <= 'Z' &&
					pachProductID[byCharIndex] >= 'a' &&
					pachProductID[byCharIndex] <= 'z'
					)
				{
					//转大写后比较
					pachProductID[byCharIndex] = pachProductID[byCharIndex] - ( 'a' - 'A' );
				}

				if( m_tMcuDebugVal.m_pachHDMtBoardType[byIndex][byCharIndex] >= 'a' &&
					m_tMcuDebugVal.m_pachHDMtBoardType[byIndex][byCharIndex] <= 'z' &&
					pachProductID[byCharIndex] >= 'A' &&
					pachProductID[byCharIndex] <= 'Z'
					)
				{
					//转小写后比较
					pachProductID[byCharIndex] = pachProductID[byCharIndex] + ( 'a' - 'A' );
				}
				
			}
			if( pachProductID[byCharIndex] != 
				m_tMcuDebugVal.m_pachHDMtBoardType[byIndex][byCharIndex]
				)
			{
				break;
			}
		}
		if( byCharIndex == byProductStrLen )
		{
			return TRUE;
		}
		
		byIndex++;		
	}
	
	return FALSE;
	
}


/*=============================================================================
    函 数 名： GetConfCapabilityCheatMtBoardType
    功    能： 获取指定MCU Debug文件中可以会议能力欺骗的终端类型数组
    算法实现： 
    全局变量： 
    参    数： 
    返 回 值： BOOL32
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2010/02/04  4.0			周晶晶                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsMtBoardTypeCanCapabilityCheat( s8* pachProductID )
{
	if( !IsCanConfCapabilityCheat() )
	{
		return FALSE;
	}	
	
	u8 byIndex = 0;
	u8 byCharIndex = 0;
	u8 byProductStrLen = strlen(pachProductID);

	if( 0 == byProductStrLen )
	{
		return FALSE;
	}

	while( byIndex < m_tMcuDebugVal.m_byConfCapCheatMtBoardTypeNum )
	{
		if( strlen( (char*)&m_tMcuDebugVal.m_pachCheatMtBoardType[byIndex][0] ) != byProductStrLen )
		{
			byIndex++;
			continue;
		}
		for( byCharIndex = 0;byCharIndex < byProductStrLen;byCharIndex++ )
		{
			if( pachProductID[byCharIndex] != 
				m_tMcuDebugVal.m_pachCheatMtBoardType[byIndex][byCharIndex] )
			{
				if( m_tMcuDebugVal.m_pachCheatMtBoardType[byIndex][byCharIndex] >= 'A' &&
					m_tMcuDebugVal.m_pachCheatMtBoardType[byIndex][byCharIndex] <= 'Z' &&
					pachProductID[byCharIndex] >= 'a' &&
					pachProductID[byCharIndex] <= 'z'
					)
				{
					//转大写后比较
					pachProductID[byCharIndex] = pachProductID[byCharIndex] - ( 'a' - 'A' );
				}

				if( m_tMcuDebugVal.m_pachCheatMtBoardType[byIndex][byCharIndex] >= 'a' &&
					m_tMcuDebugVal.m_pachCheatMtBoardType[byIndex][byCharIndex] <= 'z' &&
					pachProductID[byCharIndex] >= 'A' &&
					pachProductID[byCharIndex] <= 'Z'
					)
				{
					//转小写后比较
					pachProductID[byCharIndex] = pachProductID[byCharIndex] + ( 'a' - 'A' );
				}
				
			}
			if( pachProductID[byCharIndex] != 
				m_tMcuDebugVal.m_pachCheatMtBoardType[byIndex][byCharIndex]
				)
			{
				break;
			}
		}
		if( byCharIndex == byProductStrLen )
		{
			return TRUE;
		}
		//if( strcmp((char*)&m_tMcuDebugVal.m_pachCheatMtBoardType[byIndex][0],pachProductID) == 0 )
		//{
			
		//}
		byIndex++;		
	}
	
	return FALSE;
		
}

BOOL32 CMcuVcData::IsCanConfCapabilityCheat( void )
{
	return ( 0 != m_tMcuDebugVal.m_byIsCanConfCapabilityCheat );
}

/*=============================================================================
函 数 名： GetMsSynTime
功    能： 获得主备同步时间
算法实现： 
全局变量： 
参    数： void
返 回 值： 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2007/4/2  4.0			周广程                  创建
=============================================================================*/
u16	 CMcuVcData::GetMsSynTime(void)
{
	return m_tMcuDebugVal.m_wMsSynTime;
}

/*=============================================================================
  函 数 名： GetDri2E1CfgTable
  功    能： 读DRI2板E1级联配置
  算法实现： 
  全局变量： 
  参    数： const s8* lpszProfileName
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::GetDri2E1CfgTableFromFile()
{
    
    s8 lpszProfileName[MAX_PATH];
    sprintf(lpszProfileName, "%s/%s", DIR_CONFIG, MCUDEBUGFILENAME);

    s8*   *ppszTable = NULL;
    s8    achSeps[] = " ,\t";       /* space or tab as seperators */
    s8    *pchToken = NULL;
	//u32	  dwBrdLoop;
    u32   dwLoop;
    BOOL32  bResult = TRUE;
    s32   nMemEntryNum;

    //  get the number of entry 
    bResult = GetRegKeyInt( lpszProfileName, (const s8*)"mcudri2E1cfgTable", 
                                  STR_ENTRY_NUM, 0, &nMemEntryNum );
	if( !bResult ) 
	{
		printf("[AgentGetDri2E1CfgTable] Wrong profile while reading %s %s!\n", 
			                     (const s8*)"mcudri2E1cfgTable", STR_ENTRY_NUM );
		return FALSE;
	}

    // 没有配置
    if(0 == nMemEntryNum)
    {
        return TRUE;
    }

    //最多有MAXNUM_SUB_MCU组配置
    if(nMemEntryNum > MAXNUM_SUB_MCU)
    {
        nMemEntryNum = MAXNUM_SUB_MCU;
    }

	// alloc memory
    ppszTable = new s8*[(u32)nMemEntryNum];
    if(NULL == ppszTable )
    {
       printf("[AgentGetDri2E1CfgTable] Fail to malloc memory for dri2 E1 table\n");
       return FALSE;
    }

    for( dwLoop = 0; dwLoop < (u32)nMemEntryNum; dwLoop++ )
    {
        ppszTable[dwLoop] = new s8[MAX_VALUE_LEN + 1];
        if(NULL == ppszTable[dwLoop] )
        {
            printf("[AgentGetDri2E1CfgTable] Fail to malloc memory for dri2 E1 table1\n");
			FREE_TABLE_MEM(ppszTable, dwLoop);

			return FALSE;
        }
    }

	// get the dri2 E1 table
    //m_dwMpwEntryNum = (u32)nMemEntryNum;

    bResult = GetRegKeyStringTable( lpszProfileName, (const s8*)"mcudri2E1cfgTable",
                "fail", ppszTable, (u32*)&nMemEntryNum, MAX_VALUE_LEN + 1 );
    if( !bResult )
    {
		printf("[AgentGetDri2E1CfgTable] Wrong profile while reading %s table!\n", 
			                                        (const s8*)"mcudri2E1cfgTable");
        FREE_TABLE_MEM(ppszTable, nMemEntryNum);

		return FALSE;
    }

    for( dwLoop = 0; dwLoop < (u32)nMemEntryNum; dwLoop++ )
    {
        // Dri Ip
        pchToken = strtok( ppszTable[dwLoop], achSeps );
        if( NULL == pchToken )
        {
            printf("[GetDri2E1CfgTable] Wrong profile while reading Dri Id!\n");
            bResult = FALSE;
            continue;
        }
        else
        {
            m_atDri2E1CfgTable[dwLoop].SetDriIp( ntohl(INET_ADDR(pchToken)) );
        }

		// PortNO
        pchToken = strtok( NULL, achSeps );
        if( NULL == pchToken )
        {
            printf("[GetDri2E1CfgTable] Wrong profile while reading PortNO!\n");
            bResult = FALSE;
            continue; 
        }
        else
        {
            m_atDri2E1CfgTable[dwLoop].SetPortNO( atoi(pchToken) );
        }

		// IPAddr
        pchToken = strtok( NULL, achSeps );
        if( NULL == pchToken )
        {
            printf("[GetDri2E1CfgTable] Wrong profile while reading ip!\n" );
            bResult = FALSE;
            continue;
        }
        else
        {
            m_atDri2E1CfgTable[dwLoop].SetIpAddr( ntohl(INET_ADDR(pchToken)) );
            
        }

        //Ajust Rate,初始值为1不需要从配置文件读入
        //m_atDri2E1CfgTable[dwLoop].SetAjtRate( (double)1 );
//         pchToken = strtok( NULL, achSeps );
//         if( NULL == pchToken )
//         {
//             printf("[GetDri2E1CfgTable] Wrong profile while reading Ajust Rate!\n" );
//             bResult = FALSE;
//             continue;
//         }
//         else
//         {
//             m_atDri2E1CfgTable[dwLoop].SetAjtRate( atof(pchToken) );
//             
//         }
	} 

	// free memory 
    FREE_TABLE_MEM(ppszTable, nMemEntryNum );
    
	return bResult;
}

BOOL32 CMcuVcData::GetDri2E1CfgTable( TDri2E1Cfg* tDri2E1CfgTable )
{
    if ( tDri2E1CfgTable == NULL)
    {
        return FALSE;
    }
    
    memcpy( tDri2E1CfgTable, m_atDri2E1CfgTable, sizeof(m_atDri2E1CfgTable) );
	
    return TRUE;
}

void CMcuVcData::SaveRealBandwidth( u16 wBandWidth, u8 byIndx, u8 byE1Num )
{
    m_atDri2E1CfgTable[byIndx].SetRealBandWidth(wBandWidth);
    m_atDri2E1CfgTable[byIndx].SetCfgE1Num(byE1Num);
    return;
}

u32 CMcuVcData::GetCfgIpByIdx( u8 byIndx )
{
    return m_atDri2E1CfgTable[byIndx].GetIpAddr();
}

BOOL32 CMcuVcData::GetRealBandwidthByIp(u32 dwIp, u16 &wRealBandwidth)
{
    BOOL32 bRet = FALSE;
    for ( u8 byIndx = 0; byIndx < MAXNUM_SUB_MCU; byIndx++)
    {
        if (dwIp == m_atDri2E1CfgTable[byIndx].GetIpAddr())
        {
            wRealBandwidth = m_atDri2E1CfgTable[byIndx].GetRealBandWidth();
            bRet = TRUE;
        }
        else
        {
            continue;
        }
    }
	
    return bRet;
}

/*=============================================================================
函 数 名： GetFakeCapParamByMtInfo
功    能： 根据指定IP地址读取对应能力集[包括主能力集和双流能力集]
注　　意： 此函数会设置RES, FPS, BR;其他的由会议设定
算法实现：
全局变量：
参    数： u32 dwIp:    主机序[in]
 	 	    TSimCapSet &tMainCapSet:    主能力集
 	 	    TDStreamCap &tDSCapSet:　    双流能力集
			TAudioTypeDesc& tAudioDesc   音频能力集
			u8 byFakeMask                 作假的mask，第0，1，2位分别表示主，双，音频能力集是否设置（1表示设置，0:没设置）
返 回 值： BOOL32 : TRUE/FALSE
----------------------------------------------------------------------
修改记录    ：
日  期        版本        修改人        走读人    修改内容
12/07/24    4.0            pengguofeng           创建
=============================================================================*/
BOOL32 CMcuVcData::GetFakeCapParamByMtInfo(u32 dwIp, s8* pszProductId,u8 byManuId,TSimCapSet &tMainCapSet, TDStreamCap &tDSCapSet,TAudioTypeDesc& tAudioDesc,u8& byFakeMask)
{
	u8 byMainCapId = 0xff;
	u8 byDualCapId = 0xff;
	u8 byAudioCapId = 0xff;
	byFakeMask = 0;
	if ( !GetFakeCapIdByMtInfo(dwIp,pszProductId,byManuId, byMainCapId, byDualCapId,byAudioCapId))
	{
		return FALSE;
	}
	
	if ( byMainCapId == 0xff && byDualCapId == 0xff && byAudioCapId == 0xFF)
	{
		return FALSE;
	}
	
	TVideoStreamCap tMainVidCap = tMainCapSet.GetVideoCap();
	
	//主能力
	if ( byMainCapId != 0xff)
	{
		u16 wConfBitRate = 0;
		if( m_tMcuDebugVal.m_tCheatVideoCapSet[byMainCapId].GetMaxBitRate() == 0 )
		{
			wConfBitRate = tMainCapSet.GetVideoMaxBitRate() + GetAudioBitrate(tMainCapSet.GetAudioMediaType());
		}

		tMainCapSet.SetVideoCap(m_tMcuDebugVal.m_tCheatVideoCapSet[byMainCapId]);
		if( tMainCapSet.GetVideoMaxBitRate() == 0 )
		{
			tMainCapSet.SetVideoMaxBitRate(wConfBitRate);
		}
		SET_MAINSTREAM_FAKED(byFakeMask);
	}
	
	//双流能力
	if ( byDualCapId != 0xff )
	{   
		 //        tDSCapSet->SetSupportH239(TRUE);
		tDSCapSet.SetMediaType(m_tMcuDebugVal.m_tCheatVideoCapSet[byDualCapId].GetMediaType());
		tDSCapSet.SetResolution(m_tMcuDebugVal.m_tCheatVideoCapSet[byDualCapId].GetResolution());
		if( tDSCapSet.GetMediaType() == MEDIA_TYPE_H264 )
		{
			tDSCapSet.SetUserDefFrameRate(m_tMcuDebugVal.m_tCheatVideoCapSet[byDualCapId].GetUserDefFrameRate());
		}
		else
		{
			tDSCapSet.SetFrameRate(m_tMcuDebugVal.m_tCheatVideoCapSet[byDualCapId].GetFrameRate());
		}
		
		if( m_tMcuDebugVal.m_tCheatVideoCapSet[byDualCapId].GetMaxBitRate() != 0 )
		{
			tDSCapSet.SetMaxBitRate(m_tMcuDebugVal.m_tCheatVideoCapSet[byDualCapId].GetMaxBitRate());
		}

		tDSCapSet.SetH264ProfileAttrb(m_tMcuDebugVal.m_tCheatVideoCapSet[byDualCapId].GetH264ProfileAttrb());
		tDSCapSet.SetSupportH239(m_tMcuDebugVal.m_tCheatVideoCapSet[byDualCapId].IsSupportH239());
		SET_DOUBLESTREAM_FAKED(byFakeMask);
	}
	if (byAudioCapId != 0xff)
	{
		tAudioDesc.SetAudioMediaType(m_tMcuDebugVal.m_tCheatAudioCapSet[byAudioCapId].GetAudioMediaType());
		tAudioDesc.SetAudioTrackNum(m_tMcuDebugVal.m_tCheatAudioCapSet[byAudioCapId].GetAudioTrackNum());
		SET_AUDIODESC_FAKED(byFakeMask);
	}

 	return TRUE;
}

/*================================================================
函 数 名： GetFakeCapIdByMtInfo
功    能： 根据指定IP地址读取对应能力集编号
算法实现：
全局变量：
参    数： u32 dwIp: 主机序[in]
 	 	    u8 byMainCapId: 主流能力集id
 	 	    u8 byDualCapId: 双流能力集id
返 回 值： u8  :正常情况下返回0~191 ,异常返回0xFF
----------------------------------------------------------------------
修改记录    ：
日  期        版本        修改人        走读人    修改内容
12/07/24    4.0            pengguofeng           创建
=============================================================================*/
BOOL32 CMcuVcData::GetFakeCapIdByMtInfo(u32 dwIp, s8* pszProductId,u8 byManuId, u8 &byMainCapId, u8 &byDualCapId,u8& byAudioCapId)
{	
	byMainCapId = byDualCapId = byAudioCapId = 0xff;
	u8 byIdx = 0;
	for ( ; byIdx < m_tMcuDebugVal.m_byCheatMtNum; byIdx++)
	{
		if( dwIp == 0)
			break;

		if( m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_byMtIdType == 1 
			&& dwIp == ntohl(INET_ADDR(m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_aszMtAlias)))
		{
			byMainCapId = m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_byMainCapId;
			byDualCapId = m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_byDualCapId;
			byAudioCapId = m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_byAudioCapId;
			return TRUE;			
		}
	}

	for ( byIdx = 0 ; byIdx < m_tMcuDebugVal.m_byCheatMtNum; byIdx++)
	{
		if( pszProductId == NULL )
			break;
		
		if( m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_byMtIdType == 2 
			&& 0 == memcmp(m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_aszMtAlias,pszProductId,sizeof(m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_aszMtAlias)))
		{
			byMainCapId = m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_byMainCapId;
			byDualCapId = m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_byDualCapId;
			byAudioCapId = m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_byAudioCapId;
			return TRUE;			
		}
	}

	for ( byIdx = 0 ; byIdx < m_tMcuDebugVal.m_byCheatMtNum; byIdx++)
	{
		if( byManuId == 0 )
			break;
		
		if( m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_byMtIdType == 3 
			&& byManuId == atoi(m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_aszMtAlias))
		{
			byMainCapId = m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_byMainCapId;
			byDualCapId = m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_byDualCapId;
			byAudioCapId = m_tMcuDebugVal.m_tCheatMtParam[byIdx].m_byAudioCapId;
			return TRUE;			
		}
	}
	
 	return FALSE;
}
 	 	 
/*=============================================================================
    函 数 名： GetMtCallInterfaceInfoFromDebugFile
    功    能： 获取指定MCU Debug文件关于指定终端的协议适配板资源及码流转发板资源的设置
    算法实现： 
    全局变量： 
    参    数： 
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/7/25   3.6			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetMtCallInterfaceInfoFromDebugFile( )
{
	m_dwMtCallInterfaceNum = MAXNUM_MCU_MT;
	if( FALSE == McuGetMtCallInterfaceInfo(m_atMtCallInterface, m_dwMtCallInterfaceNum) )
	{
		memset(m_atMtCallInterface, 0, sizeof(m_atMtCallInterface));
		m_dwMtCallInterfaceNum = 0;

		return FALSE;
	}

	return TRUE;	
}

/*=============================================================================
    函 数 名： GetMpIdAndH323MtDriIdFromMtAlias
    功    能： 根据终端别名 获取 该终端的协议适配板资源及码流转发板资源的设置
    算法实现： 
    全局变量： 
    参    数： u32      [in] tMtAlias       //终端的别名
	           u32      [out]&dwMtadpIpAddr //协议适配板IP地址, 网络序
	           u32      [out]&dwMpIpAddr    //码流转发板IP地址, 网络序
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/7/25   3.6			万春雷                  创建
    2006/12/20  4.0-R4      王亮                    增加E164号码段支持
=============================================================================*/
BOOL32 CMcuVcData::GetMpIdAndH323MtDriIdFromMtAlias( TMtAlias &tMtAlias, u32 &dwMtadpIpAddr, u32 &dwMpIpAddr )
{
	for( u32 dwLoop = 0; dwLoop < m_dwMtCallInterfaceNum; dwLoop++ )
	{
        switch (m_atMtCallInterface[dwLoop].m_byAliasType)
        {
        case mtAliasTypeTransportAddress:
            if( tMtAlias.m_AliasType == mtAliasTypeTransportAddress &&
                 m_atMtCallInterface[dwLoop].m_tIpSeg.IsIpIn( tMtAlias.m_tTransportAddr.GetNetSeqIpAddr() ) )
            {
			    dwMtadpIpAddr = m_atMtCallInterface[dwLoop].m_dwMtadpIpAddr;
			    dwMpIpAddr    = m_atMtCallInterface[dwLoop].m_dwMpIpAddr;
                return TRUE;
            }
            break;
        case mtAliasTypeE164:
            //判断E164号码是否在号码段内
            if( tMtAlias.m_AliasType == mtAliasTypeE164 &&
                m_atMtCallInterface[dwLoop].IsE164Same( tMtAlias.m_achAlias ) )
             {
                LogPrint(LOG_LVL_DETAIL, MID_MCU_MT, "[GetMpIdAndH323MtDriIdFromMtAlias]: E164=%s in E164 seg=%s.\n", tMtAlias.m_achAlias, m_atMtCallInterface[dwLoop].m_szE164);
			    dwMtadpIpAddr = m_atMtCallInterface[dwLoop].m_dwMtadpIpAddr;
			    dwMpIpAddr    = m_atMtCallInterface[dwLoop].m_dwMpIpAddr;
                return TRUE;
            }
            break;
        default:
            break;
        }
	}
	return FALSE;
}

/*=============================================================================
    函 数 名： GetMSDetermineType
    功    能： 获取指定MCU Debug文件中 主备用结果提取方式 设置
	           vxworks下硬件平台支持主备用功能，则直接由os获取主备用结果，默认不支持
    算法实现： 
    全局变量： 
    参    数： 
    返 回 值： BOOL32
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/12/26  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetMSDetermineType( )
{
	return m_tMcuDebugVal.m_bMSDetermineType;
}


/*=============================================================================
函 数 名： GetBitrateScale
功    能： 获取适配码率比例
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/4/11  4.0			许世林                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetBitrateScale()
{
    return m_tMcuDebugVal.m_byBitrateScale;
}


/*=============================================================================
函 数 名： IsMMcuSpeaker
功    能： 是否指定上级作发言人
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/4/11  4.0			许世林                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsMMcuSpeaker() const
{    
	TLocalInfo tLocalInfo;
    if(SUCCESS_AGENT != g_cMcuAgent.GetLocalInfo(&tLocalInfo))
    {
		return TRUE;        
    }
	return ( 0 != tLocalInfo.GetIsMMcuSpeaker() );
}

/*=============================================================================
函 数 名： IsShowMMcuMtList
功    能： 级联时是否显示上级MCU的终端列表
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2007/04/30  4.0			顾振华                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsShowMMcuMtList() const
{
	TLocalInfo tLocalInfo;
    if(SUCCESS_AGENT != g_cMcuAgent.GetLocalInfo(&tLocalInfo))
    {
		//[nizhijun 2011/02/14] 读取tLocalInfo失败，默认返回TRUE，显示上级MCU所挂终端列表
		return TRUE;        
    }
    
    return ( 0 != tLocalInfo.GetIsShowMMcuMtList() );     
}

/*=============================================================================
函 数 名： GetMtFastUpdateInterval
功    能： 忽略关键帧请求轮回时间
算法实现： 
全局变量： 
参    数： 
返 回 值： u8 单位(秒) 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2012/03/09  4.7			周晶晶                 创建
=============================================================================*/
u8 CMcuVcData::GetMtFastUpdateInterval() const
{
	return m_tMcuDebugVal.m_byMtFastUpdateInterval;
}

/*=============================================================================
函 数 名： GetMtFastUpdateNeglectNum
功    能： 轮回时间内忽略关键帧请求次数
算法实现： 
全局变量： 
参    数： 
返 回 值： u8 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2012/03/09  4.7			周晶晶                  创建
=============================================================================*/
u8 CMcuVcData::GetMtFastUpdateNeglectNum( void ) const
{
	return m_tMcuDebugVal.m_byMtFastUpdateNeglectNum;
}

/*=============================================================================
函 数 名： IsPolyComMtCanSendDoubleStream
功    能： 是否限制polycom终端发双流
算法实现： 
全局变量： 
参    数： 
返 回 值： u8 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2012/06/13  4.7			周晶晶                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsPolyComMtCanSendDoubleStream( void ) const
{
	return ( 1 == m_tMcuDebugVal.m_byIsPolyComMtSendDoubleStream );
}

/*=============================================================================
函 数 名： IsSendStaticText
功    能： 会议轮询时是否发送短消息"您马上要被轮询"
算法实现： 
全局变量： 
参    数： 
返 回 值： u8 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2012/06/13  4.7			周晶晶                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsSendStaticText( void ) const
{
	return ( 1 == m_tMcuDebugVal.m_byIsSendStaticText );
}

/*=============================================================================
函 数 名： IsChaoRanMtAllowInVmpChnnl
功    能： 超然终端是否允许进vmp通道
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2012/07/09  4.7			杨怀志                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsChaoRanMtAllowInVmpChnnl( void ) const
{
	return ( 1 == m_tMcuDebugVal.m_byIsChaoRanMtAllowInVmpChnnl );
}

/*=============================================================================
函 数 名： IsNeedMapDstIpAddr
功    能： 判断dwDstIpAddr是否需要作假源ip和端口
算法实现： 
全局变量： 
参    数： u32 dwDstIpaddr （网络序）
返 回 值： BOOL32 TRUE：需要作假
				  FALSE 不需要
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2012/09/07  4.7			周翼亮                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsNeedMapDstIpAddr( u32 dwDstIpAddr ) const
{
	BOOL32 bRet = FALSE;
	for (u8 byLoop = 0 ; byLoop < m_tMcuDebugVal.m_byNeedMapIpNum ; byLoop++)
	{
		if (dwDstIpAddr == m_tMcuDebugVal.m_adwNeedMappedIp[byLoop])
		{
			return TRUE;
		}
	}
	return bRet;
}



/*=============================================================================
函 数 名： IsRcvH264DependInMark
功    能： 对应的manuid和productid是否要按特殊方式解码
算法实现： 
全局变量： 
参    数： u32 byManuId 厂商，const s8* pProductId ：对应的productid
返 回 值： BOOL32 TRUE：需要
				  FALSE 不需要
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/07/23  4.7			yanghuaizhi             创建
=============================================================================*/
BOOL32 CMcuVcData::IsRcvH264DependInMark( u8 byManuId,const s8* pProductId ) 
{
	BOOL32 bRet = FALSE;
	
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
	if(MT_MANU_KDC == byManuId || MT_MANU_KDCMCU == byManuId)
	{
		return bRet;
	}
	for (u8 byLoop = 0 ; byLoop < m_tMcuDebugVal.m_byRcvH264DependInMarkNum ; byLoop++)
	{
		if (m_tMcuDebugVal.m_atRcvH264DependInMarkMt[byLoop].m_byManuId == byManuId && 
			strcmp(pProductId,m_tMcuDebugVal.m_atRcvH264DependInMarkMt[byLoop].m_achProductId) == 0
			)
		{
			bRet = TRUE;
			break;
		}
	}
#endif

	return bRet;
}

/*=============================================================================
函 数 名： GetCurrentAudMtNum
功    能： 获取当前占用音频接入点数
算法实现： 
全局变量： 
参    数： 
返 回 值： u16 返回当前占用音频接入点数
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2012/12/10  4.7			chendaiwei                 创建
=============================================================================*/
u16 CMcuVcData::GetCurrentAudMtNum(void)
{
	return m_wCurrentAudMtNum;
}

/*=============================================================================
函 数 名： IsShowMMcuMtList
功    能： 级联时是否显示上级MCU的终端列表
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2007/04/30  4.0			顾振华                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsLowCalledMtChlOpenMp4( void )
{
	return ( 1 == m_tMcuDebugVal.m_byLowBrCalledMtChlOpenMode );
}
/*=============================================================================
函 数 名： IsShowMMcuMtList
功    能： 级联时是否显示上级MCU的终端列表
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2007/04/30  4.0			顾振华                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsLowCalledMtChlOpenH264( void )
{
	return ( 2 == m_tMcuDebugVal.m_byLowBrCalledMtChlOpenMode );
}

/*=============================================================================
函 数 名： IsStartSwitchToMMcuWithOutCaseBas
功    能： 下级交换码流到上级是否可以不过适配
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2007/04/30  4.0			周嘉麟                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsStartSwitchToMMcuWithOutCasBas() const
{
	//[03/04/2010] zjl modify (武警需求代码合并)
	return m_tMcuDebugVal.m_byIsStartSwitchToMMcuWithoutCasBas;
}
/*=============================================================================
函 数 名： SetSMcuCasPort
功    能： 设置欲连接的下级MCU的侦听端口。
算法实现： 
全局变量： 
参    数： 
返 回 值： 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/6/15  4.0			顾振华                  创建
=============================================================================*/
void CMcuVcData::SetSMcuCasPort(u16 wPort)
{
    m_tMcuDebugVal.m_wSMcuCasPort = wPort;
}

/*=============================================================================
函 数 名： GetSMcuCasPort
功    能： 返回欲连接的下级MCU的侦听端口。本值在telnet里面通过SetSMcuCasPort设置
算法实现： 
全局变量： 
参    数： 
返 回 值： u16 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/6/15  4.0			顾振华                  创建
=============================================================================*/
u16 CMcuVcData::GetSMcuCasPort() const
{
    return m_tMcuDebugVal.m_wSMcuCasPort;
}

/*=============================================================================
函 数 名： IsAutoDetectMMcuDupCall
功    能： 当上级MCU重新呼叫时，是否检测是否是同一个上级MCU
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/6/22  4.0			顾振华                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsAutoDetectMMcuDupCall() const
{
    return (0 != m_tMcuDebugVal.m_byIsAutoDetectMMcuDupCall);
}

/*=============================================================================
函 数 名： GetCascadeAliasType
功    能： 获取级联时MCU在会议中别名的显示方式
算法实现： 
全局变量： 
参    数： 
返 回 值： 0 - MCU Alias+Conf H.323ID,  1 - Mcu Alias Only, 2 - Conf H.323ID Only
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2007/4/30   4.0			顾振华                  创建
=============================================================================*/
u8 CMcuVcData::GetCascadeAliasType() const
{
	TLocalInfo tLocalInfo;
    g_cMcuAgent.GetLocalInfo(&tLocalInfo);
    
	//这里加1时因为要兼容以前的代码，以前代码2是会议名称，3是mcu名称＋会议名称
    return tLocalInfo.GetConfNameShowType() + 1;    
}

u8 CMcuVcData::GetCascadeAdminLevel( ) const
{
	TLocalInfo tLocalInfo;
    g_cMcuAgent.GetLocalInfo(&tLocalInfo);   
	
    return tLocalInfo.GetAdminLevel();   
}
/*=============================================================================
函 数 名： GetMaxOngoingConfNum
功    能： 
算法实现： 
全局变量： 
参    数： 
返 回 值： u8 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2007/04/17  4.0			顾振华                  创建
=============================================================================*/
u8 CMcuVcData::GetMaxMcsOngoingConfNum(void) const
{
	TLocalInfo tLocalInfo;
    if(SUCCESS_AGENT != g_cMcuAgent.GetLocalInfo(&tLocalInfo))
    {
        return 1;
    }

    return tLocalInfo.GetMaxMcsOnGoingConfNum();

	//return m_tMcuDebugVal.m_byMaxOngoingConf;
}
/*=============================================================================
函 数 名： IsApplyChairToZxMcu
功    能： 是否向中兴mcu申请主席
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/6/22  4.0			许世林                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsApplyChairToZxMcu() const
{
	return (0 != m_tMcuDebugVal.m_byIsApplyChairToZxMcu);
}

/*=============================================================================
函 数 名： IsTransmitMtShortMsg
功    能： 是否转发终端短消息
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/11/3  4.0			许世林                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsTransmitMtShortMsg() const
{
    return (0 != m_tMcuDebugVal.m_byIsTransmitMtShortMsg);
}

/*=============================================================================
函 数 名： IsChairDisplayMtApplyInfo
功    能： 是否将终端申请主席或发言人的提示信息告诉主席终端
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/11/3  4.0			许世林                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsChairDisplayMtApplyInfo() const
{
    return (0 != m_tMcuDebugVal.m_byIsChairDisplayMtApplyInfo);
}

/*=============================================================================
函 数 名： IsSelInDoubleMediaConf
功    能： 是否允许双格式会议选看，只针对标清会议，允许不同格式码流直接交换，
           由接收端自适应解码
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/11/10  4.0			许世林                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsSelInDoubleMediaConf() const
{
    return (0 != m_tMcuDebugVal.m_byIsSelInDoubleMediaConf);
}

/*=============================================================================
函 数 名： IsLimitAccessByMtModal
功    能： 是否根据终端和MCU的类型限制终端呼入
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2007/05/14  4.0			张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsLimitAccessByMtModal() const
{
    return (0 == m_tMcuDebugVal.m_byIsNotLimitAccessByMtModal);
}

/*=============================================================================
函 数 名： IsSupportSecDSCap
功    能： 是否根据支持第二双流能力
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2008/11/15  4.5			张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsSupportSecDSCap() const
{
    return (0 != m_tMcuDebugVal.m_byIsSupportSecDSCap);
}

/*=============================================================================
函 数 名： GetDbgConfFPS
功    能： Get Conf FPS
算法实现： 
全局变量： 
参    数： 
返 回 值： u8 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2009/11/11  4.6			薛亮                  创建
=============================================================================*/
u8 CMcuVcData::GetDbgConfFPS() const
{
	return m_tMcuDebugVal.m_byConfFPS;
}

/*=============================================================================
函 数 名： IsAllowVmpMemRepeated
功    能： 是否允许单通道下VMP成员重复
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：  
日  期		版本		修改人		走读人    修改内容
2009/03/21  4.5			张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsAllowVmpMemRepeated() const
{
	//zhouyiliang 20110425 8kh有前适配通道，所以也不允许同一终端进不同通道。
#if defined(_8KE_)
	return TRUE;	// [9/14/2010 xliang] 8000G 不受该限制。
#endif

    return (0 != m_tMcuDebugVal.m_byIsAllowVmpMemRepeated);
}
/*=============================================================================
函 数 名： IsSendFakeCap2Polycom
功    能： 是否约束面向polycom的能力集
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2007/05/14  4.0			张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsSendFakeCap2Polycom() const
{
    return (1 == m_tMcuDebugVal.m_byIsSendFakeCap2Polycom);
}
/*=============================================================================
函 数 名： IsSendFakeCap2Taide
功    能： 是否约束面向polycom的能力集
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2007/05/14  4.0			张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsSendFakeCap2Taide() const
{
    return (1 == m_tMcuDebugVal.m_byIsSendFakeCap2Taide);
}

/*=============================================================================
函 数 名： IsSendFakeCap2TaideHD
功    能： 是否手动提升面向polycom的能力集
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2009/08/31  4.0			张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsSendFakeCap2TaideHD() const
{
    return (1 == m_tMcuDebugVal.m_byIsSendFakeCap2TaideHD);
}

/*=============================================================================
 函 数 名： IsAdpResourceCompact
 功    能： 是否紧凑使用当前视频资源
 算法实现： 
 全局变量： 
 参    数： 
 返 回 值： BOOL32 
 ----------------------------------------------------------------------
 修改记录    ：
 日  期		版本		修改人		走读人    修改内容
 2009/05/22  4.5		张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsAdpResourceCompact() const
{
    return (0 != m_tMcuDebugVal.m_byIsAdpResourceCompact);
}

/*=============================================================================
 函 数 名： IsVASimultaneous
 功    能： 是否支持唇音同步
 算法实现： 
 全局变量： 
 参    数： 
 返 回 值： BOOL32 
 ----------------------------------------------------------------------
 修改记录    ：
 日  期		版本		修改人		走读人    修改内容
 2010/10/28  4.5		周嘉麟                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsVASimultaneous() const
{
    return (0 != m_tMcuDebugVal.m_byIsVASimultaneous);
}

/*=============================================================================
 函 数 名： IsSVmpOutput1080i
 功    能： 是否强制SVMP编码输出1080i，即同时放弃720p
 算法实现： 
 全局变量： 
 参    数： 
 返 回 值： BOOL32 
 ----------------------------------------------------------------------
 修改记录    ：
 日  期		    版本		修改人		走读人    修改内容
 2009/07/26     4.5		    张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsSVmpOutput1080i() const
{
    return (0 != m_tMcuDebugVal.m_byIsSVmpOutput1080i);
}

/*=============================================================================
 函 数 名： GetBandWidthReserved4HdBas
 功    能： 获取为HD-BAS预留的带宽
 算法实现： 
 全局变量： 
 参    数： 
 返 回 值： BOOL32 
 ----------------------------------------------------------------------
 修改记录    ：
 日  期		    版本		修改人		走读人    修改内容
 2009/07/26     4.6		    张宝卿                  创建
=============================================================================*/
u8 CMcuVcData::GetBandWidthReserved4HdBas() const
{
    return m_tMcuDebugVal.m_byBandWidthReserved4HdBas;
}

/*=============================================================================
 函 数 名： GetBandWidthReserved4HdVmp
 功    能： 获取为HD-VMP预留的带宽
 算法实现： 
 全局变量： 
 参    数： 
 返 回 值： BOOL32 
 ----------------------------------------------------------------------
 修改记录    ：
 日  期		    版本		修改人		走读人    修改内容
 2009/07/26     4.6		    张宝卿                  创建
=============================================================================*/
u8 CMcuVcData::GetBandWidthReserved4HdVmp() const
{
    return m_tMcuDebugVal.m_byBandWidthReserved4HdVmp;
}


BOOL32 CMcuVcData::IsDistinguishHDSDMt() const
{
	return (1 == m_tMcuDebugVal.m_byIsDistingtishSDHDMt);
}

BOOL32 CMcuVcData::IsVidAdjustless4Polycom() const
{
	return (1 == m_tMcuDebugVal.m_byIsVidAdjustless4Polycom);
}

BOOL32 CMcuVcData::IsSelAccord2Adp() const
{
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)// [10/22/2010 xliang] 8000G 
	return TRUE;
#endif 
    return (1 == m_tMcuDebugVal.m_byIsSelAccord2Adp);
}

BOOL32 CMcuVcData::GetFakeCap2HuaweiSDEp( const u32 dwMtIp,u8 &byVideoFormat ) const
{
    //return (1 == m_tMcuDebugVal.m_bIsSendFakeCap2HuaweiSDMcu);
	for( u8 byIdx = 0;byIdx < m_tMcuDebugVal.m_byNoneKedaMtAbilityCheatNum;++byIdx )
	{
		if( m_tMcuDebugVal.m_arrdwNoneKedaMtIp[byIdx] == dwMtIp )
		{
			byVideoFormat = m_tMcuDebugVal.m_arrbyNoneKedaMtAbility[byIdx];
			return VIDEO_FORMAT_INVALID != byVideoFormat;			
		}
	}
	return FALSE;
}

/*=============================================================================
函 数 名： IsSupportChgLGCResAcdBR
功    能： 是否支持根据终端呼叫码率降终端逻辑通道分辨率
算法实现： 
全局变量： 
参    数： 
返 回 值： u16
----------------------------------------------------------------------
修改记录    ：
日  期		    版本		修改人		走读人    修改内容
2010/04/13      4.6		    周嘉麟                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsSupportChgLGCResAcdBR() const
{
    return m_tMcuDebugVal.m_byIsSupportChgLGCResAcdBR;
}

/*=============================================================================
函 数 名： Get1080P6050FpsLeastBR
功    能： 获取1080p/60/50帧的最低呼叫码率
算法实现： 
全局变量： 
参    数： 
返 回 值： u16
----------------------------------------------------------------------
修改记录    ：
日  期		    版本		修改人		走读人    修改内容
2011/03/31     4.6		    陈代伟                  创建
=============================================================================*/
u16 CMcuVcData::Get1080P6050FpsBpLeastBR() const
{
    return m_tMcuDebugVal.m_w1080p6050FPSBpLeastBR;
}

/*=============================================================================
函 数 名： Get1080P6050FpsLeastBR
功    能： 获取1080p/60/50帧的最低呼叫码率
算法实现： 
全局变量： 
参    数： 
返 回 值： u16
----------------------------------------------------------------------
修改记录    ：
日  期		    版本		修改人		走读人    修改内容
2011/03/31     4.6		    陈代伟                  创建
=============================================================================*/
u16 CMcuVcData::Get1080P6050FpsHpLeastBR() const
{
    return m_tMcuDebugVal.m_w1080p6050FPSHpLeastBR;
}

/*=============================================================================
函 数 名： Get1080P3025FpsLeastBR
功    能： 获取1080p/30/25帧的最低呼叫码率
算法实现： 
全局变量： 
参    数： 
返 回 值： u16
----------------------------------------------------------------------
修改记录    ：
日  期		    版本		修改人		走读人    修改内容
2011/03/31     4.6		    陈代伟                  创建
=============================================================================*/
u16 CMcuVcData::Get1080P3025FpsBpLeastBR() const
{
    return m_tMcuDebugVal.m_w1080p3025FPSBpLeastBR;
}


/*=============================================================================
函 数 名： Get1080P3025FpsLeastBR
功    能： 获取1080p/30/25帧的最低呼叫码率
算法实现： 
全局变量： 
参    数： 
返 回 值： u16
----------------------------------------------------------------------
修改记录    ：
日  期		    版本		修改人		走读人    修改内容
2011/03/31     4.6		    陈代伟                  创建
=============================================================================*/
u16 CMcuVcData::Get1080P3025FpsHpLeastBR() const
{
    return m_tMcuDebugVal.m_w1080p3025FPSHpLeastBR;
}

/*=============================================================================
函 数 名： Get720pLeastBR
功    能： 获取720p的最低呼叫码率
算法实现： 
全局变量： 
参    数： 
返 回 值： u16
----------------------------------------------------------------------
修改记录    ：
日  期		    版本		修改人		走读人    修改内容
2010/04/13     4.6		    陈代伟                  创建
=============================================================================*/
u16 CMcuVcData::Get720P6050FpsBpLeastBR() const
{
    return m_tMcuDebugVal.m_w720P6050FpsBpLeastBR;
}

/*=============================================================================
函 数 名： Get720pLeastBR
功    能： 获取720p的最低呼叫码率
算法实现： 
全局变量： 
参    数： 
返 回 值： u16
----------------------------------------------------------------------
修改记录    ：
日  期		    版本		修改人		走读人    修改内容
2010/04/13     4.6		    陈代伟                  创建
=============================================================================*/
u16 CMcuVcData::Get720P3025FpsBpLeastBR() const
{
    return m_tMcuDebugVal.m_w720P3025FpsBpLeastBR;
}

/*=============================================================================
函 数 名： Get720pLeastBR
功    能： 获取720p的最低呼叫码率
算法实现： 
全局变量： 
参    数： 
返 回 值： u16
----------------------------------------------------------------------
修改记录    ：
日  期		    版本		修改人		走读人    修改内容
2010/04/13     4.6		    陈代伟                  创建
=============================================================================*/
u16 CMcuVcData::Get720P6050FpsHpLeastBR() const
{
    return m_tMcuDebugVal.m_w720P6050FpsHpLeastBR;
}

/*=============================================================================
函 数 名： Get720pLeastBR
功    能： 获取720p的最低呼叫码率
算法实现： 
全局变量： 
参    数： 
返 回 值： u16
----------------------------------------------------------------------
修改记录    ：
日  期		    版本		修改人		走读人    修改内容
2010/04/13     4.6		    陈代伟                  创建
=============================================================================*/
u16 CMcuVcData::Get720P3025FpsHpLeastBR() const
{
    return m_tMcuDebugVal.m_w720P3025FpsHpLeastBR;
}

/*=============================================================================
函 数 名： Get4cifLeastBR
功    能： 获取4cif的最低呼叫码率
算法实现： 
全局变量： 
参    数： 
返 回 值： u16
----------------------------------------------------------------------
修改记录    ：
日  期		    版本		修改人		走读人    修改内容
2011/03/31     4.6		    陈代伟                  创建
=============================================================================*/
u16 CMcuVcData::Get4CifLeastBR() const
{
    return m_tMcuDebugVal.m_w4CifLeastBR;
}

/*=============================================================================
函 数 名： GetCifLeastBR
功    能： 获取Cif的最低呼叫码率
算法实现： 
全局变量： 
参    数： 
返 回 值： u16
----------------------------------------------------------------------
修改记录    ：
日  期		    版本		修改人		走读人    修改内容
2010/04/13     4.6		    陈代伟                  创建
=============================================================================*/
u16 CMcuVcData::GetCifLeastBR() const
{
    return m_tMcuDebugVal.m_wCifLeastBR;
}

/*=============================================================================
函 数 名： GetVcsMtOverTimeInterval
功    能： 获取vcs会议呼叫超时时间
算法实现： 
全局变量： 
参    数： 
返 回 值： u8
----------------------------------------------------------------------
修改记录    ：
日  期		    版本		修改人		走读人    修改内容
2010/07/02     4.6		    周翼亮                  创建
=============================================================================*/
u8 CMcuVcData::GetVcsMtOverTimeInterval() const
{
    return m_tMcuDebugVal.m_byVcsMtOverTimeInterval;
}

/*=============================================================================
函 数 名： GetMmcuOlcTimerOut
功    能： 获取开级联通道定时间隔
算法实现： 
全局变量： 
参    数： 
返 回 值： u16
----------------------------------------------------------------------
修改记录    ：
日  期		    版本		修改人		走读人    修改内容
2011/01/13     4.6		    薛亮                  创建
=============================================================================*/
u16 CMcuVcData::GetMmcuOlcTimerOut() const
{
	return m_tMcuDebugVal.m_wMmcuOlcTimerOut;
}

/*=============================================================================
函 数 名： GetFastUpdateToSpeakerNum
功    能： 获取向发言人请求关键帧的次数
算法实现： 
全局变量： 
参    数： 
返 回 值： u16
----------------------------------------------------------------------
修改记录    ：
日  期		    版本		修改人		走读人    修改内容
2011/01/13     4.6		    薛亮                  创建
=============================================================================*/
u8 CMcuVcData::GetFastUpdateToSpeakerNum() const
{
	return m_tMcuDebugVal.m_byFastUpdateToSpeakerNum;
}

/*=============================================================================
函 数 名： GetPerfLimit
功    能： 获取性能参数
算法实现： 
全局变量： 
参    数： 
返 回 值： TMcuPerfLimit
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2007/1/17  4.0			顾振华                  创建
=============================================================================*/
TMcuPerfLimit& CMcuVcData::GetPerfLimit()
{
/*lint -save -e1536*/
    return m_tMcuDebugVal.m_tPerfLimit;
/*lint -restore*/
}

//获得适配帧率
u8 CMcuVcData::GetFpsAdp()
{
    return m_tMcuDebugVal.m_byFpsAdp;
}
/*=============================================================================
函 数 名： ShowDebugInfo
功    能： 打印Debug文件的信息
算法实现： 
全局变量： 
参    数： 
返 回 值： 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/9/05   4.0			顾振华                创建
2006/12/20  4.0          王亮                 增加E164号码段输出
2007/01/26  4.0			周广程				  增加读Licnese错误提示输出	
=============================================================================*/
void CMcuVcData::ShowDebugInfo()
{
    m_tMcuDebugVal.Print();

    StaticLog("\n");

#ifdef _MINIMCU_
    TMcu8kbPfmFilter tFilter = CMcuPfmLmt::GetFilter();
    tFilter.Print();
#endif

    StaticLog("\nMt Call Interface Table: %d\n", m_dwMtCallInterfaceNum);
    if ( m_dwMtCallInterfaceNum > 0 )
    {
        StaticLog("IP Start(E164)\tIP End\t\tMTAdp\t\tMP\n");
        for (u32 nLoop = 0; nLoop < m_dwMtCallInterfaceNum; nLoop ++)
        {
            if (m_atMtCallInterface[nLoop].m_byAliasType == mtAliasTypeTransportAddress)
            {
                StaticLog("0x%x\t0x%x\t0x%x\t0x%x\n",
                    ntohl(m_atMtCallInterface[nLoop].m_tIpSeg.dwIpStart),
                    ntohl(m_atMtCallInterface[nLoop].m_tIpSeg.dwIpEnd),
                    (m_atMtCallInterface[nLoop].m_dwMtadpIpAddr),
                    (m_atMtCallInterface[nLoop].m_dwMpIpAddr));
            }
            else if  (m_atMtCallInterface[nLoop].m_byAliasType == mtAliasTypeE164)
            {
                StaticLog("%s\t\t\t0x%x\t0x%x\n",
                    (m_atMtCallInterface[nLoop].m_szE164),
                    (m_atMtCallInterface[nLoop].m_dwMtadpIpAddr),
                    (m_atMtCallInterface[nLoop].m_dwMpIpAddr));
            }
            else
            {
                StaticLog("Unknown Alias: %s\t%s\n",
                    (m_atMtCallInterface[nLoop].m_szE164) );
            }
        }               
    }
    StaticLog("\n\n");

    TMcuStatus tStatus;
    GetMcuCurStatus(tStatus);
    tStatus.Print(); 
	
	StaticLog("\nE1 Config:\n");
	for(u8 byIdx = 0; byIdx < MAXNUM_SUB_MCU; byIdx++)
	{
		StaticLog("byIdx:%d driIp:0x%x portNum:%d smcu Ip:0x%x\n",byIdx,m_atDri2E1CfgTable[byIdx].GetDriIp(),m_atDri2E1CfgTable[byIdx].GetPortNO(),m_atDri2E1CfgTable[byIdx].GetIpAddr());
	}
	
	for ( u8 byIndex = 0; byIndex < MAXNUM_PERIEQP; byIndex++)
	{
		if(!m_tNplusVmpModule[byIndex].IsNull())
		{
			StaticLog("[%d]",byIndex);
			m_tNplusVmpModule[byIndex].Print();
		}
	}

	StaticLog( "\nIsTranDataMp.%d\n",g_cMcuAgent.GetIsUseMpcTranData() );
}

/*=============================================================================
    函 数 名： GetMcuCurStatus
    功    能： 获取当前MCU状态
    算法实现： 
    全局变量： 
    参    数： const CMessage * pcMsg
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/12/31  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetMcuCurStatus( TMcuStatus &tMcuStatus )
{
	memset( &tMcuStatus, 0 ,sizeof(TMcuStatus) );
	tMcuStatus.SetMcu( LOCAL_MCUID );
	u32 dwEqpIP = 0;
	u8  byEqpType = 0;
	u8  byEqpId = 1;
    
	//外设状态(包括离线外设)
	while (byEqpId <= MAXNUM_OLDMCU_PERIEQP)
	{
		if (IsPeriEqpValid(byEqpId))
		{
			g_cMcuAgent.GetPeriInfo(byEqpId, &dwEqpIP, &byEqpType);
			tMcuStatus.m_atPeriEqp[tMcuStatus.m_byPeriEqpNum] = GetEqp(byEqpId);
			tMcuStatus.m_byEqpOnline[tMcuStatus.m_byPeriEqpNum]  = IsPeriEqpConnected(byEqpId);
            tMcuStatus.m_dwPeriEqpIpAddr[tMcuStatus.m_byPeriEqpNum] = GetEqpIp(byEqpId);
            
			tMcuStatus.m_byPeriEqpNum++;
		}
		byEqpId++;
	}

    u8  byDcsId = 1;

    //DCS状态(包括离线DCS)
    while (byDcsId <= MAXNUM_MCU_DCS) 
    {
        if (IsPeriDcsValid(byDcsId)) 
        {
            //TPeriDcsStatus tDcsStatus;
            tMcuStatus.m_atPeriDcs[tMcuStatus.m_byPeriDcsNum] = GetDcs(byDcsId);
            tMcuStatus.m_byDcsOnline[tMcuStatus.m_byPeriDcsNum] = IsPeriDcsConnected(byDcsId);
            //目前只支持一个，后续需 MCU代理扩展
            tMcuStatus.m_dwPeriDcsIpAddr[tMcuStatus.m_byPeriDcsNum] = g_cMcuAgent.GetDcsIp();
            tMcuStatus.m_byPeriDcsNum ++ ;
        }
        byDcsId ++ ;
    }

	//即时会议个数, 预约会议个数, 所有会议与会终端总数
	CApp* pcApp = &g_cMcuVcApp;
	CMcuVcInst* pcVcInst = NULL;
	for (u8 byInstID = 1; byInstID <= MAXNUM_MCU_CONF; byInstID++)
	{
		pcVcInst = (CMcuVcInst *)pcApp->GetInstance(byInstID);
		if (NULL != pcVcInst)
		{            
            if ( pcVcInst->CurState() == CMcuVcInst::STATE_ONGOING )
			{
				tMcuStatus.m_byOngoingConfNum++;
				tMcuStatus.m_wAllJoinedMtNum += pcVcInst->m_tConfAllMtInfo.GetLocalJoinedMtNum();
			}
            if ( pcVcInst->CurState() == CMcuVcInst::STATE_SCHEDULED )
			{
				tMcuStatus.m_byScheduleConfNum++;
			}
		}
	}
	tMcuStatus.m_wAllJoinedMtNum = htons(tMcuStatus.m_wAllJoinedMtNum);

    // 顾振华 [5/29/2006] 增加MCU注册GK的情况
    tMcuStatus.m_byRegedGk = GetConfRegState(0);

    if ( g_cMSSsnApp.IsDoubleLink() )
    {
        tMcuStatus.m_tMSSynState.SetEntityType(TMSSynState::emNone);
        if ( g_cMSSsnApp.IsRemoteMpcConnected() )
        {
            if ( !g_cMSSsnApp.IsMSSynOK() ) 
            {
                tMcuStatus.m_tMSSynState = g_cMSSsnApp.GetCurMSSynState();
            }
        }
        else
        {
            // guzh [9/25/2006] 标记为未连接
            tMcuStatus.m_tMSSynState.SetEntityType(TMSSynState::emMpc);
        }
    }
	
    // License 数量 
	tMcuStatus.m_wLicenseNum = htons( GetLicenseNum() );
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
 	g_cMcuAgent.SetAuthMTTotal( ntohs(tMcuStatus.m_wLicenseNum) );
#else
    g_cMcuAgent.SetAuthMTTotal( tMcuStatus.m_wLicenseNum );
#endif

    // 在线的Mp和MtAdp
    tMcuStatus.m_byRegedMpNum = GetMpNum();
    tMcuStatus.m_byRegedMtAdpNum = GetMtAdpNum(PROTOCOL_TYPE_H323);

    //N+1备份数据同步状态
    tMcuStatus.m_dwNPlusReplacedMcuIp = 0;
    switch (g_cNPlusApp.GetLocalNPlusState())
    {
    case MCU_NPLUS_IDLE:
        tMcuStatus.m_byNPlusState = NPLUS_NONE;
        break;
    case MCU_NPLUS_MASTER_IDLE:
        tMcuStatus.m_byNPlusState = NPLUS_BAKCLIENT_IDLE;
        break;
    case MCU_NPLUS_MASTER_CONNECTED:
        tMcuStatus.m_byNPlusState = NPLUS_BAKCLIENT_CONNECT;
        break;
    case MCU_NPLUS_SLAVE_IDLE:
        tMcuStatus.m_byNPlusState = NPLUS_BAKSERVER_IDLE;
        break;
    case MCU_NPLUS_SLAVE_SWITCH:
        tMcuStatus.m_byNPlusState = NPLUS_BAKSERVER_SWITCHED;
        if (!g_cNPlusApp.GetNPlusSynOk())
        {
            tMcuStatus.m_byNPlusState = NPLUS_BAKSERVER_SWITCHERR;
        }
        tMcuStatus.m_dwNPlusReplacedMcuIp = htonl(g_cNPlusApp.GetMcuSwitchedIp());
        break;
    default:
        tMcuStatus.m_byNPlusState = NPLUS_NONE;
        break;
    }
	
	//MCU是否被配置过的标识 zgc [12/21/2006] for支持MCU导航配置需求
	tMcuStatus.m_byMcuIsConfiged = g_cMcuAgent.IsMcuConfiged() ? 1 : 0;
	
	// 是否有MP zgc [07/25/2007]
	if (tMcuStatus.m_byRegedMpNum > 0)
	{
		tMcuStatus.SetIsExistMp( TRUE );
	}
	else
	{
		tMcuStatus.SetIsExistMp( FALSE );
	}
	
	// 是否有mtadp zgc [07/25/2007]
	if ( tMcuStatus.m_byRegedMtAdpNum > 0 )
	{ 
		tMcuStatus.SetIsExistMtadp( TRUE );
	}
	else
	{
		tMcuStatus.SetIsExistMtadp( FALSE );
	}
	
	// mcu配置信息可信级别  zgc [07/25/2007]
	tMcuStatus.m_byMcuCfgLevel = g_cMcuAgent.GetMcuCfgInfoLevel();

#ifdef _MINIMCU_
    // 考虑兼容老版本，三种DSC都设置IsExistDSC, 具体区分由会控侧处理, zgc, 2008-06-27
	u8 byDSCType = BRD_TYPE_UNKNOW;
	if ( g_cMcuAgent.IsDscReged(byDSCType) )
	{
		switch(byDSCType)
		{
		case BRD_TYPE_DSC:
			tMcuStatus.SetIsExistDSC( TRUE );
			break;
		case BRD_TYPE_MDSC:
            tMcuStatus.SetIsExistDSC( TRUE );
			tMcuStatus.SetIsExistMDSC( TRUE );
			break;
		case BRD_TYPE_HDSC:
            tMcuStatus.SetIsExistDSC( TRUE );
			tMcuStatus.SetIsExistHDSC( TRUE );
			break;
		default:
			LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetCurMcuStatus] unexpected reged dsc type.%d\n", byDSCType );
			break;
		}
	}
#endif

    //设置MCU状态位 zgc [07/25/2007]
    // guzh [8/2/2007] 目前的标准是有License，且MP/MtAdp 均在线
    BOOL32 bRunOk = tMcuStatus.IsExistMp() && 
                  tMcuStatus.IsExistMtadp() && 
                  (ntohs(tMcuStatus.m_wLicenseNum) > 0);
#ifdef _MINIMCU_		
#ifndef WIN32
    // 如果是 MINIMCU ，在非启用内置接入和转发的情况下（即商用环境下），则必须有注册的DSC模块
    if ( !g_cMcuAgent.GetIsUseMpcTranData() && !g_cMcuAgent.GetIsUseMpcStack() )
    {
        bRunOk &= tMcuStatus.IsExistDSC();
    }	
#endif
#endif
    tMcuStatus.SetIsMcuRunOk( bRunOk );

    //zbq[12/13/2007] MCU持续运行时间获取
	u32 dwRunTick = OspTickGet();
    dwRunTick -= g_cMcuVcApp.GetMcuStartTick();	//在不同平台，tick基准并不一样
    u32 dwOspClkRate = OspClkRateGet();
    tMcuStatus.SetPersistantRunningTime(dwRunTick/dwOspClkRate);

#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
	tMcuStatus.m_wAllHdiAccessMtNum = htons( GetLicenseHDMtNum() );	//接入高清终端能力
#elif defined(_MINIMCU_)
	tMcuStatus.m_wAllHdiAccessMtNum = ~0;  //用65535表示:  8000b，不用HDI
#else
	u16 wAllHdiAccessMtNum = GetMpcHDAccessNum();

	tMcuStatus.m_wAllHdiAccessMtNum = htons(wAllHdiAccessMtNum);	// xliang [11/20/2008] HDI 接入能力

#endif

	tMcuStatus.m_wAudioMtAccessNum = htons(GetAudMtLicenseNum());
	//tMcuStatus.m_wAccessPCMtNum = htons( GetLicensePCMtNum() );		//接入PCMT能力
	
	tMcuStatus.SetVcsAccessNum( g_cMcuVcApp.GetVCSAccessNum() );
	// xliang [11/20/2008] CRI(标清接入板)接入能力 (暂不支持，预留)
//	tMcuStatus.m_wStdCriAccessMtNum = ~0;

    if ( g_bPrintCfgMsg )
    {
        tMcuStatus.Print();
    }

	return TRUE;
}

/*=============================================================================
函 数 名： GetMcuExtCurStatus
功    能： 获取当前MCU状态
算法实现： 
全局变量： 
参    数： u8  byCurEqpId        当前eqp起始id
u8 &byPeriEqpNum      返回额外需要的eqp个数			
TEqp *atPeriEqp       返回额外的eqp
u8 *byEqpOnline	     返回设备在线信息
u32 *dwPeriEqpIpAddr  返回设备IP
返 回 值： BOOL32 
-----------------------------------------------------------------------------
修改记录：
日  期		版本		修改人		走读人    修改内容
2011/09/09  4.0			倪志俊                 创建
=============================================================================*/
BOOL32 CMcuVcData::GetMcuExtCurStatus( u8 byCurEqpId,  u8 &byPeriEqpNum, TEqp *patPeriEqp, u8 *pbyEqpOnline, u32 *pdwPeriEqpIpAddr)
{
	if ( NULL == patPeriEqp || NULL == pbyEqpOnline || NULL == pdwPeriEqpIpAddr)
	{
		OspPrintf( TRUE, FALSE,"[GetMcuExtCurStatus] GetMcuExtCurStatus failed!\n");
		return FALSE;
	}
	
	byPeriEqpNum = 0;
	
	while (byCurEqpId <= MAXNUM_MCU_PERIEQP)
	{
		if (IsPeriEqpValid(byCurEqpId) && byPeriEqpNum < MAXNUM_MCU_PERIEQP - MAXNUM_OLDMCU_PERIEQP)
		{
			patPeriEqp[byPeriEqpNum] = GetEqp(byCurEqpId);
			pbyEqpOnline[byPeriEqpNum]  = IsPeriEqpConnected(byCurEqpId);
            pdwPeriEqpIpAddr[byPeriEqpNum] = GetEqpIp(byCurEqpId);        
			byPeriEqpNum++;
		}
		byCurEqpId++;
	}
	
	return TRUE;
}

/*=============================================================================
    函 数 名： GetMcuCurUserList
    功    能： 获取当前MCU用户列表
    算法实现： 
    全局变量： 
    参    数： [IN]  CUsrManage& cUsrManageObj, 操作的用户管理对象
			   [IN]  u8 byGrpId,                用户组ID
               [OUT] u8 *pbyBuf,                包缓冲
	           [IN/OUT] u8 &byUsrItr,           数组访问指针
	           [IN/OUT] u8 &byUserNumInPack     此包中的有效用户数

    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/12/31  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetMcuCurUserList(CUsrManage& cUsrManageObj, u8 byGrpId, u8 *pbyBuf, u8 &byUsrItr, u8 &byUserNumInPack )
{    
    //若为N+1备份工作模式（即切换后），取内存中的信息
    if (MCU_NPLUS_SLAVE_SWITCH == g_cNPlusApp.GetLocalNPlusState())
    {
        u8 byInsId = g_cNPlusApp.GetMcuSwitchedInsId();
        if (0 == byInsId || byInsId > MAXNUM_NPLUS_MCU)
        {
            LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[GetMcuCurUserList] McuSwitchedInsId is invalid in NPlus switched mode.\n");
            return FALSE;
        }
        else
        {
            CApp *pcApp = &g_cNPlusApp;
            CNPlusInst *pcInst = (CNPlusInst *)pcApp->GetInstance(byInsId);
            if (NULL != pcInst)
            {
                return pcInst->GetGrpUserList(byGrpId, pbyBuf, byUsrItr, byUserNumInPack);
            }
            else
            {
                LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[GetMcuCurUserList] GetInstance(%d) failed.\n", byInsId);
                return FALSE;
            }
        }                
    }

    byUserNumInPack = 0;
	if (NULL == pbyBuf)
	{
		return FALSE;
	}

	CExUsrInfo cUserInfo;

    s32 nTotalCount = cUsrManageObj.GetUserNum();
	for (; byUserNumInPack < USERNUM_PERPKT && byUsrItr < nTotalCount; byUsrItr ++ )
	{
		cUserInfo.Empty();
		if ( cUsrManageObj.GetUserFullInfo(&cUserInfo, byUsrItr) && 
			 !cUserInfo.IsEmpty() )
		{

            if ( byGrpId == USRGRPID_SADMIN ||
                 byGrpId == cUserInfo.GetUsrGrpId()  )
            {
			    memcpy(pbyBuf + byUserNumInPack * sizeof(CExUsrInfo), &cUserInfo, sizeof(CExUsrInfo));
			    byUserNumInPack++;
            }
		}
	}

	if (0 == byUserNumInPack)
	{
		return FALSE;
	}
	
	return TRUE;
}
/*=============================================================================
    函 数 名： GetMCSCurUserList
    功    能： 获取当前MCS用户列表
    算法实现： 
    全局变量： 
    参    数：
			   [IN]  u8 byGrpId,                用户组ID
               [OUT] u8 *pbyBuf,                包缓冲
	           [IN/OUT] u8 &byUsrItr,           数组访问指针
	           [IN/OUT] u8 &byUserNumInPack     此包中的有效用户数

    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    08/11/21     		    付秀华                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetMCSCurUserList(u8 byGrpId, u8 *pbyBuf, u8 &byUsrItr, u8 &byUserNumInPack )
{
	return GetMcuCurUserList(g_cUsrManage, byGrpId, pbyBuf, byUsrItr, byUserNumInPack);
}

/*=============================================================================
    函 数 名： GetVCSCurUserList
    功    能： 获取当前VCS用户列表
    算法实现： 
    全局变量： 
    参    数：
			   [IN]  u8 byGrpId,                用户组ID
               [OUT] u8 *pbyBuf,                包缓冲
	           [IN/OUT] u8 &byUsrItr,           数组访问指针
	           [IN/OUT] u8 &byUserNumInPack     此包中的有效用户数

    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    08/11/21     		    付秀华                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetVCSCurUserList(u8 byGrpId, u8 *pbyBuf, u8 &byUsrItr, u8 &byUserNumInPack )
{
	return GetMcuCurUserList(g_cVCSUsrManage, byGrpId, pbyBuf, byUsrItr, byUserNumInPack);
}

/*=============================================================================
  函 数 名： CreateTemplate
  功    能： 
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::CreateTemplate(void)
{
    if(NULL == m_ptTemplateInfo)
    {
        m_ptTemplateInfo = new TTemplateInfo[MAXNUM_MCU_TEMPLATE];
        if(NULL == m_ptTemplateInfo)
        {
            return FALSE;
        }
    }

    return TRUE;
}

/*=============================================================================
  函 数 名： AddTemplate
  功    能： 
  算法实现： 
  全局变量： 
  参    数： [IN/OUT]       TTemplateInfo &tTemInfo
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::AddTemplate(TTemplateInfo &tTemInfo)
{
	if (!m_ptTemplateInfo) return FALSE;

    // guzh [4/11/2007] 检查是否从文件恢复
    BOOL32 bTemplateFromFile =  tTemInfo.m_tConfInfo.m_tStatus.IsTakeFromFile();

    //zbq [09/06/2007] 本字段在SaveConfToFile里统一处理
    //tTemInfo.m_tConfInfo.m_tStatus.SetTakeFromFile(FALSE);

	u8 byIndex = MAXNUM_MCU_TEMPLATE;
	u8 byVCSTempNum = 0;
	u8 byMCSTempNum = 0;
    for(u8 byInd = 0; byInd < MAXNUM_MCU_TEMPLATE; byInd++)
    {

        if(m_ptTemplateInfo[byInd].IsEmpty())
        {
			if (MAXNUM_MCU_TEMPLATE == byIndex)
			{
				byIndex = byInd;
			}
        }
		else
		{
            if (VCS_CONF == m_ptTemplateInfo[byInd].m_tConfInfo.GetConfSource())
            {
				byVCSTempNum++;
            }
			else if (MCS_CONF == m_ptTemplateInfo[byInd].m_tConfInfo.GetConfSource())
			{
				byMCSTempNum++;
			}
		}
    }	

	if (VCS_CONF == tTemInfo.m_tConfInfo.GetConfSource() && byVCSTempNum >= MAXNUM_MCU_VCSTEMPLATE )
	{
		//TBD
		OspPrintf(TRUE,FALSE,"[AddTemlate] byVCSTempNum%d over max limit%d\n",byVCSTempNum,MAXNUM_MCU_VCSTEMPLATE);

		LogPrint(LOG_LVL_ERROR,MID_MCU_CFG,"[AddTemlate] byVCSTempNum%d over max limit%d\n",byVCSTempNum,MAXNUM_MCU_VCSTEMPLATE);
		return FALSE;
	}
	else if (MCS_CONF == tTemInfo.m_tConfInfo.GetConfSource() && byMCSTempNum >= MAXNUM_MCU_MCSTEMPLATE )
	{
		//TBD
		OspPrintf(TRUE,FALSE,"[AddTemlate] byMCSTempNum%d over max limit%d\n",byMCSTempNum,MAXNUM_MCU_MCSTEMPLATE);
		
		LogPrint(LOG_LVL_ERROR,MID_MCU_CFG,"[AddTemlate] byMCSTempNum%d over max limit%d\n",byMCSTempNum,MAXNUM_MCU_MCSTEMPLATE);
		return FALSE;
	}

    //template array full
    if(MAXNUM_MCU_TEMPLATE == byIndex)
    {
		//TBD
		OspPrintf(TRUE,FALSE,"[AddTemlate] byIndex%d == MAXNUM_MCU_TEMPLATE",byIndex);
		
		LogPrint(LOG_LVL_ERROR,MID_MCU_CFG,"[AddTemlate] byIndex%d == MAXNUM_MCU_TEMPLATE",byIndex);
        return FALSE;
    }

    u8 byConfIdx = GetOngoingConfIdxByE164(tTemInfo.m_tConfInfo.GetConfE164());
    if(0 == byConfIdx)
    {
        byConfIdx = GetIdleConfidx();
        if(0 == byConfIdx)
        {
			//TBD
			OspPrintf(TRUE,FALSE,"[AddTemlate] GetIdleConfidx == %d",byConfIdx);
			
            return FALSE;
        }
    }    

    //save template info
    if(CONF_LOCKMODE_LOCK == tTemInfo.m_tConfInfo.m_tStatus.GetProtectMode())
    {
        tTemInfo.m_tConfInfo.m_tStatus.SetProtectMode(CONF_LOCKMODE_NONE);
    }    
    tTemInfo.m_tConfInfo.m_tStatus.SetRegToGK(FALSE);
    // guzh [4/11/2007] 如果从文件恢复,则沿用原来的ConfId

    if (!bTemplateFromFile)    
    {
		// 会议ID中保留发起者如MCS设置的配置源信息
		CConfId cConfID = MakeConfId(byConfIdx, 1, tTemInfo.m_tConfInfo.GetUsrGrpId(),
			                         tTemInfo.m_tConfInfo.GetConfSource());
        tTemInfo.m_tConfInfo.SetConfId(cConfID);
    }

    tTemInfo.m_byConfIdx = byConfIdx;
    memcpy(&m_ptTemplateInfo[byIndex], &tTemInfo, sizeof(tTemInfo));

    //save map info
    m_atConfMapData[byConfIdx-MIN_CONFIDX].SetTemIndex(byIndex);    

	//MCU启动恢复时读取的会议模板不需再写入FILE[8/18/2012 chendaiwei]
	if( bTemplateFromFile )
	{
		m_ptTemplateInfo[byIndex].m_tConfInfo.m_tStatus.SetTakeFromFile(FALSE);
	}
	else
	{
		//save to file
		if(!SaveConfToFile(byConfIdx, TRUE))
		{
			LogPrint(LOG_LVL_ERROR,MID_MCU_CFG,"[SaveConfToFile] failed!!!\n");
		}
	}

    //reg to gk
    RegisterConfToGK(byConfIdx, GetRegGKDriId(), TRUE);

    return TRUE;
}

/*=============================================================================
  函 数 名： ModifyTemplate
  功    能： 
  算法实现： 
  全局变量： 
  参    数： TTemplateInfo &tTemInfo
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::ModifyTemplate(TTemplateInfo &tTemInfo, BOOL32 bSameE164AndName)
{
    if(tTemInfo.m_byConfIdx < MIN_CONFIDX || tTemInfo.m_byConfIdx > MAX_CONFIDX)
    {
        return FALSE;
    }
  
	//zjj20091102
	TConfStore tConfStore;
	TTemplateInfo tOldTemInfo;
	if( GetTemplate( tTemInfo.m_byConfIdx,tOldTemInfo )  )
	{
		memcpy(&tConfStore, &tOldTemInfo, sizeof(TConfStore));
	}

	if(CONF_LOCKMODE_LOCK == tTemInfo.m_tConfInfo.m_tStatus.GetProtectMode())
	{
		tTemInfo.m_tConfInfo.m_tStatus.SetProtectMode(CONF_LOCKMODE_NONE);       
	}        
	tTemInfo.m_tConfInfo.m_tStatus.SetTemplate();
	
	u8 byConfIdx = tTemInfo.m_byConfIdx;
	TConfMapData tMapData = GetConfMapData(byConfIdx);
	if(!tMapData.IsTemUsed())
	{
		return FALSE;
	}
	
	// 对于164号改变的会议模板，还需要完成原模板在GK上的解注册及新模板的注册
	// 而不采取删除会议再重新添加的策略，没必要，且导致confid改变影响用户任务信息
	if (!bSameE164AndName)
	{
		// 解注册
		CMcuVcInst *pcInst = GetConfInstHandle(byConfIdx);
		if (!m_atConfMapData[byConfIdx-MIN_CONFIDX].IsValidConf() || 
			(NULL != pcInst && pcInst->m_tConf.m_tStatus.IsScheduled()))
		{
			if ( 0 != g_cMcuVcApp.GetConfRegState( byConfIdx ) )
			{
				RegisterConfToGK(byConfIdx, GetRegGKDriId(), TRUE, TRUE);
			}
		} 	

		//Bug00043916 [20101220 zjl] 先召开一个会议，再修改其模板覆盖保存(修改其E164),
		//再召开这个会议，由于还是复用了原来的ConfIdx，导致当第二个会议被结束后，
		//ConfIdx对应的insId(两个会议)均被删除，导致第一个会议无法操作
		
		u8 tTmpOldConfIdx = byConfIdx;
		byConfIdx = GetIdleConfidx();
		if(0 == byConfIdx)
		{
			LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[ModifyTemplate] GetIdleConfidx failed!\n");
			return FALSE;
		}
		
		//清除原来的m_atConfMapData对应confidx的temIndex
		m_atConfMapData[tTmpOldConfIdx-MIN_CONFIDX].SetTemIndex(MAXNUM_MCU_TEMPLATE);
		
		//保存修改后的m_atConfMapData对应新confidx的temIndex(仍为原先的temIndex)
		m_atConfMapData[byConfIdx-MIN_CONFIDX].SetTemIndex(tMapData.GetTemIndex());
		//模板保存为重新分配的ConfIdx
		tTemInfo.m_byConfIdx = byConfIdx;
	}
	
	// 新模板注册
	tTemInfo.m_tConfInfo.m_tStatus.SetRegToGK(FALSE);
	memcpy(&m_ptTemplateInfo[tMapData.GetTemIndex()], &tTemInfo, sizeof(tTemInfo));
	RegisterConfToGK(byConfIdx, GetRegGKDriId(), TRUE);
	
	//save to file
	SaveConfToFile(byConfIdx, TRUE,FALSE,&tConfStore );

    return TRUE;
}

/*=============================================================================
  函 数 名： DelTemplate
  功    能： 
  算法实现： 
  全局变量： 
  参    数： u8 byConfIdx
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::DelTemplate(u8 byConfIdx)
{
    if(byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX)
    {
        return FALSE;
    }

    //clear template info
    u8 byIndex = m_atConfMapData[byConfIdx-MIN_CONFIDX].GetTemIndex();
    if(byIndex >= MAXNUM_MCU_TEMPLATE) 
    {
        return FALSE;
    }
            
    //unreg to gk
    CMcuVcInst *pcInst = GetConfInstHandle(byConfIdx);
    if (!m_atConfMapData[byConfIdx-MIN_CONFIDX].IsValidConf() || 
       (NULL != pcInst && pcInst->m_tConf.m_tStatus.IsScheduled()))
    {
        // zbq [03/30/2007] 模板未注册成功，不做注销
        if ( 0 != g_cMcuVcApp.GetConfRegState( byConfIdx ) )
        {
            RegisterConfToGK(byConfIdx, GetRegGKDriId(), TRUE, TRUE);
        }
    }    
    
    //remove to file
    if(!RemoveConfFromFile(m_ptTemplateInfo[byIndex].m_tConfInfo.GetConfId()))
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[DelTemplate] Remove Conf From File failed!\n");
    }

    m_ptTemplateInfo[byIndex].Clear();

    //clear map info
    m_atConfMapData[byConfIdx-MIN_CONFIDX].SetTemIndex(MAXNUM_MCU_TEMPLATE); 

    return TRUE;
}

/*=============================================================================
  函 数 名： GetTemplate
  功    能： 
  算法实现： 
  全局变量： 
  参    数： u8 byConfIdx
             TTemplateInfo &tTemInfo
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::GetTemplate(u8 byConfIdx, TTemplateInfo &tTemInfo)
{
	tTemInfo.Clear();

	if(!m_ptTemplateInfo) return FALSE;

    if(byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX)
    {
        return FALSE;
    }

    u8 byIndex = m_atConfMapData[byConfIdx-MIN_CONFIDX].GetTemIndex();
    if(byIndex >= MAXNUM_MCU_TEMPLATE) 
    {
        return FALSE;
    }
    memcpy(&tTemInfo, &m_ptTemplateInfo[byIndex], sizeof(TTemplateInfo));

    return TRUE;
}



/*=============================================================================
  函 数 名： SetConfMapInsId
  功    能： 
  算法实现： 
  全局变量： 
  参    数： u8 byConfIdx
             u8 byInsId
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::SetConfMapInsId(u8 byConfIdx, u8 byInsId)
{
    if(byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX)
    {
        return FALSE;
    }

    m_atConfMapData[byConfIdx-MIN_CONFIDX].SetInsId(byInsId);

    return TRUE;
}

/*=============================================================================
  函 数 名： GetConfMapInsId
  功    能： 
  算法实现： 
  全局变量： 
  参    数： u8 byConfIdx
  返 回 值： u8  
=============================================================================*/
u8  CMcuVcData::GetConfMapInsId(u8 byConfIdx)
{
    if(byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX)
    {
        return 0;
    }

    return m_atConfMapData[byConfIdx-MIN_CONFIDX].GetInsId();
}

/*=============================================================================
  函 数 名： GetConfMapData
  功    能： 
  算法实现： 
  全局变量： 
  参    数： u8 byConfIdx
  返 回 值： TConfMapData  
=============================================================================*/
TConfMapData  CMcuVcData::GetConfMapData(u8 byConfIdx)
{
    return m_atConfMapData[byConfIdx-MIN_CONFIDX];
}

/*=============================================================================
  函 数 名： SetTemRegGK
  功    能： 设置模板注册gk状态
  算法实现： 
  全局变量： 
  参    数： BOOL32 bReg
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::SetTemRegGK(u8 byConfIdx, BOOL32 bReg)
{
    CHECK_CONFIDX(byConfIdx)
	if(!m_ptTemplateInfo) return FALSE;

    u8 byIndex = m_atConfMapData[byConfIdx-MIN_CONFIDX].GetTemIndex();
    if(byIndex >= MAXNUM_MCU_TEMPLATE) 
    {
        return FALSE;
    }
    
    m_ptTemplateInfo[byIndex].m_tConfInfo.m_tStatus.SetRegToGK(bReg);
    return TRUE;
}

/*=============================================================================
  函 数 名： GetTemRegGK
  功    能： 模板注册gk状态
  算法实现： 
  全局变量： 
  参    数： u8 byConfIdx
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::IsTemRegGK(u8 byConfIdx)
{
    CHECK_CONFIDX(byConfIdx)

	PTR_CHECK(m_ptTemplateInfo, FALSE);

    u8 byIndex = m_atConfMapData[byConfIdx-MIN_CONFIDX].GetTemIndex();
    if(byIndex >= MAXNUM_MCU_TEMPLATE) 
    {
        return FALSE;
    } 

    return m_ptTemplateInfo[byIndex].m_tConfInfo.m_tStatus.IsRegToGK();
}

/*=============================================================================
  函 数 名： GetIdleConfidx
  功    能： 
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： u8  
=============================================================================*/
u8    CMcuVcData::GetIdleConfidx(void)
{    
    for(u8 byConfIdx = MIN_CONFIDX; byConfIdx <= MAX_CONFIDX; byConfIdx++)
    {
        if (!m_atConfMapData[byConfIdx-MIN_CONFIDX].IsValidConf() && 
            !m_atConfMapData[byConfIdx-MIN_CONFIDX].IsTemUsed())
        {
            return byConfIdx;
        }
    }

    return 0;
}

/*=============================================================================
  函 数 名： SetAudMtLicenseNum
  功    能： 设置语音终端License
  算法实现： 
  全局变量： 
  参    数： u16 wAudLicenseValue
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::SetAudMtLicenseNum(u16 wAudLicenseValue)
{
	m_tMcuDebugVal.m_tPerfLimit.m_wMaxConnAudMtNum = wAudLicenseValue;
	return TRUE;
}

/*=============================================================================
  函 数 名： GetAudMtLicenseNum
  功    能： 获取语音终端License
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： u16 
=============================================================================*/
u16 CMcuVcData::GetAudMtLicenseNum()
{
	return GetPerfLimit().m_wMaxConnAudMtNum;
}

/*=============================================================================
  函 数 名： GetMpcCurrentAudMtAdpNum
  功    能： 获取MPC当前支持接入语音终端总数
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： u16 
=============================================================================*/
u16 CMcuVcData::GetMpcCurrentAudMtAdpNum(void)
{
	u16 wMpcAudAccessNum = 0;
	
	for( u8 byIndx = 0; byIndx < MAXNUM_DRI; byIndx ++ )
	{
		if( m_atMtAdpData[byIndx].m_bConnected)
		{
			wMpcAudAccessNum += m_atMtAdpData[byIndx].m_wMaxAudMtNum;
		}
	}	
	return wMpcAudAccessNum;
}
/*=============================================================================
  函 数 名： SetLicenseNum
  功    能： 设置License
  算法实现： 
  全局变量： 
  参    数： u16 wLicenseValue
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::SetLicenseNum( u16 wLicenseValue )
{
	m_tMcuDebugVal.m_tPerfLimit.m_wMaxConnMtNum = wLicenseValue;
	return TRUE;
}

/*=============================================================================
  函 数 名： GetLicenseNum
  功    能： 取License
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： u16 
=============================================================================*/
u16 CMcuVcData::GetLicenseNum( void )
{
	return GetPerfLimit().m_wMaxConnMtNum;
}

/*=============================================================================
  函 数 名： SetLicenseHDMtNum
  功    能： 设置License
  算法实现： 
  全局变量： 
  参    数： u16 wLicenseValue
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::SetLicenseHDMtNum(u16 wLicenseValue)
{
	m_tMcuDebugVal.m_tPerfLimit.m_wMaxConnHDMtNum = wLicenseValue;
	return TRUE;
}

/*=============================================================================
  函 数 名： GetLicenseHDMtNum
  功    能： 取License
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： u16 
=============================================================================*/
u16 CMcuVcData::GetLicenseHDMtNum( void )
{
	return GetPerfLimit().m_wMaxConnHDMtNum;
}

/*=============================================================================
  函 数 名： SetLicensePCMtNum
  功    能： 设置License
  算法实现： 
  全局变量： 
  参    数： u16 wLicenseValue
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::SetLicensePCMtNum(u16 wLicenseValue)
{
	m_tMcuDebugVal.m_tPerfLimit.m_wMaxConnPCMtNum = wLicenseValue;
	return TRUE;
}

/*=============================================================================
  函 数 名： GetLicensePCMtNum
  功    能： 取License
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： u16 
=============================================================================*/
u16 CMcuVcData::GetLicensePCMtNum( void )
{
	return GetPerfLimit().m_wMaxConnPCMtNum;
}
/*=============================================================================
  函 数 名： SetVCSAccessNum
  功    能： 设置License写入的VCS接入数
  算法实现： 
  全局变量： 
  参    数： u16 wAccessNum
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::SetVCSAccessNum( u16 wAccessNum )
{
	m_tMcuDebugVal.m_tPerfLimit.m_wMaxVCSAccessNum = wAccessNum;
	return TRUE;
}

/*=============================================================================
  函 数 名： GetVCSAccessNum
  功    能： 取License写入的VCS接入数
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： u16 
=============================================================================*/
u16 CMcuVcData::GetVCSAccessNum( void )
{
	return GetPerfLimit().m_wMaxVCSAccessNum;
}

/*=============================================================================
函 数 名： SetMcuExpireDate
功    能： 设置mcu license 超时使用日期
算法实现： 
全局变量： 
参    数： TKdvTime &tExpireDate
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/10/20  4.0			许世林                  创建
=============================================================================*/
void CMcuVcData::SetMcuExpireDate( TKdvTime &tExpireDate )
{
    m_tMcuDebugVal.m_tExpireDate = tExpireDate;
}

/*=============================================================================
函 数 名： GetMcuExpireDate
功    能： 
算法实现： 
全局变量： 
参    数： void
返 回 值： TKdvTime 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/10/20  4.0			许世林                  创建
=============================================================================*/
TKdvTime CMcuVcData::GetMcuExpireDate( void )
{
    return m_tMcuDebugVal.m_tExpireDate;
}

/*=============================================================================
函 数 名： IsMcuExpiredDate
功    能： mcu license是否超期
算法实现： 
全局变量： 
参    数： void
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/10/20  4.0			许世林                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsMcuExpiredDate(void)
{
    if (m_tMcuDebugVal.m_tExpireDate.GetYear() == 0)
    {
        return FALSE;
    }

    time_t tExpireDate;
    m_tMcuDebugVal.m_tExpireDate.GetTime(tExpireDate);

    return (time(NULL) > tExpireDate);
}



/*=============================================================================
函 数 名： GetPcmtAccessPointNum
功    能： 计算Pcmt接入点数
算法实现： 
全局变量： 
参    数： void
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2010/03/12  4.6			薛亮                  创建
=============================================================================*/
u16 CMcuVcData::GetPcmtAccessPointNum( void )
{
	u16 wPointNum = 0;

    for(u8 byIndex = 0; byIndex < MAXNUM_MCU_CONF; byIndex++)
    {
        CMcuVcInst *pcIns = m_apConfInst[byIndex];
        if (NULL == pcIns)
            continue;

        if ( !pcIns->m_tConf.m_tStatus.IsOngoing() )
            continue;
		
		// [11/17/2010 xliang] vcs 会议的pcmt不计数
		// [6/13/2011 xliang] 不再区分VCS还是MCS
// 		if( VCS_CONF == pcIns->m_tConf.GetConfSource() )
// 			continue;
        
		for ( u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId ++ )
        {
			if ( pcIns->m_tConfAllMtInfo.MtJoinedConf( byMtId ) 
				&& pcIns->m_ptMtTable->GetMtType( byMtId ) == MT_TYPE_MT 
				)
			{
				LPCSTR pszMtProductId = pcIns->m_ptMtTable->GetProductId( byMtId );
				if ( 0 == strncmp( pszMtProductId, "Kdvpcmt", strlen("Kdvpcmt") ) )
				{
					wPointNum ++;
				}
			}
        }
    }

	return wPointNum;
}
/*=============================================================================
函 数 名： GetAccessPointNum
功    能： 计算接入点数
算法实现： 
全局变量： 
参    数： void
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2010/03/12  4.6			薛亮                  创建
=============================================================================*/
u16 CMcuVcData::GetAccessPointNum( void )
{
	// count point num: 1 mt	= 1 point
	//					1 smcu	= 1 point
	//					1 mmcu	= 0 point
	u16 wPointNum = 0;
#ifdef _8KH_
	BOOL32 bIsCanCalculatePoint = FALSE;
#endif

    for(u8 byIndex = 0; byIndex < MAXNUM_MCU_CONF; byIndex++)
    {
        CMcuVcInst *pcIns = m_apConfInst[byIndex];
        if (NULL == pcIns)
            continue;
        if ( !pcIns->m_tConf.m_tStatus.IsOngoing() )
            continue;
		
//         if ( !pcIns->m_tConf.GetConfAttrb().IsSupportCascade() )
//             continue;

		
        for ( u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId ++ )
        {
#ifdef _8KH_
			if( g_cMcuAgent.Is8000HmMcu() &&
				IsOccupyAudAccessPoint(pcIns->m_byConfIdx, byMtId) )//8000h-m语音终端不占MCU的授权点数[12/6/2012 chendaiwei]
			{
				bIsCanCalculatePoint = FALSE;
			}
			else
			{
				bIsCanCalculatePoint = TRUE;
			}
#endif
			if ( pcIns->m_tConfAllMtInfo.MtJoinedConf( byMtId ) 
				&& ( pcIns->m_ptMtTable->GetMtType( byMtId ) == MT_TYPE_SMCU 
					|| pcIns->m_ptMtTable->GetMtType( byMtId ) == MT_TYPE_MT)
#ifdef _8KH_
				&& bIsCanCalculatePoint 
#endif
				)
			{
				wPointNum ++;
			}
        }
    }

	return wPointNum;
}

/*=============================================================================
函 数 名： IsHdMtNumOverMcuLicense
功    能： mcu license 高清终端接入能力限制
算法实现： 
全局变量： 
参    数：	u8 byConfIdx				[i]
			TMt			&tMt			[i]
			TCapSupport &tCapSupport	[i]
			u16 &wErrorCode				[o]
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2010/12/17  4.6			薛亮                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsHdMtNumOverMcuLicense(u8 byConfIdx, const TMt &tMt, const TCapSupport &tCapSupport, u16 &wErrorCode)
{
	if( tCapSupport.GetMainVideoType() == MEDIA_TYPE_H264 &&
		(tCapSupport.GetMainVideoResolution() == VIDEO_FORMAT_HD1080 ||
		tCapSupport.GetMainVideoResolution() == VIDEO_FORMAT_HD720) 
		)
	{
		TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
		if(tMapData.IsValidConf()) 
		{
			CMcuVcInst *pcIns = m_apConfInst[tMapData.GetInsId()-1];
			if( NULL != pcIns )
			{
				if( pcIns->m_ptMtTable->GetMtType( tMt.GetMtId() ) == MT_TYPE_MMCU )
				{
					//if mt is mmcu, skip this limit check
					LogPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[IsMtNumOverMcuLicense] mtid.%d is MMCU, skip hd mt access limit check!\n", tMt.GetMtId());
				}
				else
				{
					u8 byDriId = MCU_BOARD_MPC;	
					
					u8 byIdx;
					u16 wMaxHdMtLimit = GetLicenseHDMtNum();
					u16 wEmptyIdx = wMaxHdMtLimit;
					
					BOOL32 bAlreadyExist = FALSE;
					TMtAdpHDChnnlInfo tHdChnnlInfo;
					tHdChnnlInfo.SetConfIdx(byConfIdx);
					tHdChnnlInfo.SetHDMtId(tMt.GetMtId());
					for (byIdx = 0; byIdx < wMaxHdMtLimit; byIdx ++)
					{
						if(m_atMtAdpData[byDriId-1].m_atHdChnnlInfo[byIdx] == tHdChnnlInfo)
						{
							bAlreadyExist = TRUE;
							break;
						}
						if(m_atMtAdpData[byDriId-1].m_atHdChnnlInfo[byIdx].GetHDMtId() == 0 &&
							wEmptyIdx == wMaxHdMtLimit)
						{
							wEmptyIdx = byIdx;
						}
					}
					if( !bAlreadyExist)
					{
						if(wEmptyIdx < wMaxHdMtLimit )
						{
							m_atMtAdpData[byDriId-1].m_atHdChnnlInfo[wEmptyIdx].SetHDMtId(tMt.GetMtId());
							m_atMtAdpData[byDriId-1].m_atHdChnnlInfo[wEmptyIdx].SetConfIdx(byConfIdx);
						}
						else 
						{
							wErrorCode = ERR_MCU_CALLHDMTFAIL;
							return TRUE;
						}
					}
					else
					{
						//已计算在HD接入能力信息中,不做处理
					}
				}
			}
			else
			{
				// LogPrint(LOG_LVL_ERROR, MID_MCU_MT, "[IsMtNumOverMcuLicense] invalid instance id :%d\n", tMapData.GetInsId());
                LogPrint(LOG_LVL_ERROR, MID_MCU_CALL, "[IsMtNumOverMcuLicense] invalid instance id :%d\n", tMapData.GetInsId());
			}
			
		}
	}

	return FALSE;
}
/*=============================================================================
函 数 名： IsMtNumOverMcuLicense
功    能： mcu license 接入能力限制
算法实现： 
全局变量： 
参    数：	TCapSupport &tCapSupport	[i]
			u16 &wErrorCode				[o]
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2010/03/12  4.6			薛亮                  创建
=============================================================================*/
BOOL32 CMcuVcData::IsMtNumOverMcuLicense( u8 byConfIdx, TMt tMt, const TCapSupport &tCapSupport, u16 &wErrorCode )
{
	// check general mt access limit
	u16 wPointNum = GetAccessPointNum();
	LogPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "confidx:%d current Mt access point num is %d,  LicenseNum is %d tMt Id:%d mainRes:%d ErrorCode:%d\n", byConfIdx,wPointNum, GetLicenseNum(),tMt.GetMtId(),tCapSupport.GetMainVideoResolution(),wErrorCode);

	if( wPointNum > GetLicenseNum() )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CALL, "[IsMtNumOverMcuLicense] PointNum: %d > LicenseNum: %d \n", wPointNum, GetLicenseNum());
		wErrorCode = ERR_MCU_LICENSECALLMT_FULL;
		return TRUE;
	}
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
	// check hd mt access limit
	if( IsHdMtNumOverMcuLicense(byConfIdx, tMt, tCapSupport, wErrorCode) )
	{
		return TRUE;
	}
#endif
	// [pengjie 2011/7/25] 不再限制pcmt的接入数量
	// check pc mt access limit
// 	u16 wPcmtPointNum = GetPcmtAccessPointNum();
// 	if(wPcmtPointNum > GetLicensePCMtNum())
// 	{
// 		wErrorCode = ERR_MCU_CALLPCMTFAIL;
// 		return TRUE;
// 	}
	
	return FALSE;
}

u8 CMcuVcData::GetMixerWaitRspTimeout()
{
	return m_tMcuDebugVal.m_byWaitMixerRspTimeout;
}

u8 CMcuVcData::GetDelayReleaseConfTime()
{
	return m_tMcuDebugVal.m_byDelayReleaseConfTime;
}
/*=============================================================================
  函 数 名： IsMtNumOverLicense
  功    能： 是否超过最大终端接入能力
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： BOOL32  
=============================================================================*/
BOOL32  CMcuVcData::IsMtNumOverLicense(void)
{
    u16 wMtNum = 0;
    for(u8 byIndex = 0; byIndex < MAXNUM_MCU_CONF; byIndex++)
    {
        CMcuVcInst *pcIns = m_apConfInst[byIndex];
        if(NULL != pcIns && pcIns->m_tConf.m_tStatus.IsOngoing())
        {
            wMtNum += pcIns->m_tConfAllMtInfo.GetLocalJoinedMtNum();
        }
    }

    return (wMtNum >= GetLicenseNum());
}

//[add][liulijiu][2010.07.15]验证USBKEY里的授权数据是否正确
/*=============================================================================
  函 数 名： GetLicesenUSBKEYFlag
  功    能： 验证USBKEY里的授权数据是否正确
  算法实现： 
  全局变量： 
  参    数： wErrorCode[out]:返回错误码
  返 回 值： void  
=============================================================================*/
BOOL32 CMcuVcData::GetLicesenUSBKEYFlag(u16 &wErrorCode)
{
	
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
	//zjj20120517 测试用,正式版本需要删除
	if( !IsWatchDogEnable() )
	{
		return TRUE;
	}
	wErrorCode = m_wUSBKEYErrorCode;
#endif// _8KE_ ends

	LogPrint(LOG_LVL_DETAIL,MID_MCU_CONF,"[GetLicesenUSBKEYFlag]wErrorCode:%d\n",wErrorCode);
	return m_bUSBKEYFlag;

}

/*=============================================================================
  函 数 名： SetLicesenUSBKEYFlag
  功    能： 验证USBKEY里的授权数据是否正确
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： void  
=============================================================================*/
void CMcuVcData::SetLicesenUSBKEYFlag(void)
{
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
	if(ReadLicenseFromUSBKEY(m_wUSBKEYErrorCode))
	{
		m_bUSBKEYFlag = TRUE;
	}
	else
	{
		m_bUSBKEYFlag = FALSE;
	}
	LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetLicesenUSBKEYFlag] m_bUSBKEYFlag is %d!\n", m_bUSBKEYFlag);
	LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetLicesenUSBKEYFlag] m_wUSBKEYErrorCode is %d!\n", m_wUSBKEYErrorCode);
	printf("[SetLicesenUSBKEYFlag] m_bUSBKEYFlag is %d!\n", m_bUSBKEYFlag);
	printf("[SetLicesenUSBKEYFlag] m_wUSBKEYErrorCode is %d!\n", m_wUSBKEYErrorCode);
#endif//_8KE_ ends
}

/*=============================================================================
  函 数 名： ReadLicenseFromUSBKEY
  功    能： 验证USBKEY里的授权数据是否正确
  算法实现： 
  全局变量： 
  参    数： wErrorCode[out]:返回错误码
  返 回 值： BOOL32  
=============================================================================*/
BOOL32 CMcuVcData::ReadLicenseFromUSBKEY(u16 &wErrorCode)
{

#if defined(_8KI_)
#ifdef _LINUX_
	ELE_DEVICE_CONTEXT EleDevCxt = {0};
	BOOL32 bRet = FALSE;
	u32 dwret = 0;
	s32 dwError = 0;

	EleDevCxt.ulSize = sizeof(ELE_DEVICE_CONTEXT);		
    bRet=EleOpenFirstDevice(NULL,NULL,NULL,ELE_EXCLUSIVE_MODE,&EleDevCxt);
	if( !bRet )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[ReadLicenseFromUSBKEY]:Fail to open usbkey!\n");
		printf("[ReadLicenseFromUSBKEY]:Fail to open usbkey!\n");
		wErrorCode = ERR_MCU_USBKEYLICENSEDATA_INVALIDATION;
		return FALSE;
	}

	s8* pinbuff = "kdvx86series";
	s8 abyOutbuf[strlen(pinbuff) + 1];

	if (!EleExecute(&EleDevCxt, "MODULE1", (u8*)pinbuff, strlen(pinbuff), (u8*)abyOutbuf, sizeof(abyOutbuf), &dwret))	
	{		
		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[ReadLicenseFromUSBKEY]:Fail to read usbkey!\n");
		printf("[ReadLicenseFromUSBKEY]:Fail to read usbkey!\n");
		wErrorCode = ERR_MCU_USBKEYLICENSEDATA_INVALIDATION;
		return FALSE;
	}

	if( strcmp( abyOutbuf,"yes") != 0 )
	{
		abyOutbuf[strlen(pinbuff)] = 0;
		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[ReadLicenseFromUSBKEY]:usbkey content error.%s!\n",abyOutbuf);
		printf("[ReadLicenseFromUSBKEY]:usbkey content error.%s!\n",abyOutbuf);
		wErrorCode = ERR_MCU_USBKEYLICENSEDATA_INVALIDATION;
		return FALSE;
	}
#endif

	return TRUE;

#endif


#if defined(_8KE_) || defined(_8KH_)
	TUsbkeySN tUsbkeySN; //保存搜索到的USBKEY的SN
	s32 nNumUSB = 1;     //保存返回搜索到的USBKEY的数目
	
    //搜索插入的USBKEY
	if(SUCCESS_LICENSE != GetUsbkeyNum(&tUsbkeySN, nNumUSB))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[ReadLicenseFromUSBKEY]:Fail to enumerate USB!\n");
		printf("[ReadLicenseFromUSBKEY]:Fail to enumerate USB!\n");
		wErrorCode = ERR_MCU_USBKEYLICENSEDATA_INVALIDATION;
		return FALSE;
	}

	
	//打开索引为tUsbkeySN的USBKEY
	u16 wRet = ReadLicenseFileBySN(tUsbkeySN);
	if(SUCCESS_LICENSE != wRet)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[ReadLicenseFromUSBKEY]:Faile to Read license file by sn!\n");
		printf("[ReadLicenseFromUSBKEY]:Faile to Read license file by sn!\n");
		wErrorCode = ERR_MCU_USBKEYLICENSEDATA_INVALIDATION;
		return FALSE;
	}
		
	//枚举USBKEY中的键值对
    TKeyValue atKeyValuePair[MAXIANUM_OF_PAIRKEYVALUE];
	s32 nListLen = MAXIANUM_OF_PAIRKEYVALUE;  //USBKEY中键值对的最大数目
	wRet = EnumKeyList(atKeyValuePair, nListLen);

	//列举键值对发生错误
	if (SUCCESS_LICENSE != wRet) 
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[ReadLicenseFromUSBKEY]:Faile to enumerate key list!\n");
		printf("[ReadLicenseFromUSBKEY]:Faile to enumerate key list!\n");
		wErrorCode = ERR_MCU_USBKEYLICENSEDATA_INVALIDATION;
		return FALSE;
	}

	//遍历USBKEY中所有的键值对
	for(s32 nPairIndex = 0; nPairIndex < nListLen; nPairIndex++)
	{
		//校验key为KEY_LICENSE_TYPE的值
		if( 0 == strcmp(KEY_LICENSE_TYPE, atKeyValuePair[nPairIndex].achKey))
		{
			if(0 != strcmp(LICENSE_TYPE_8KE, atKeyValuePair[nPairIndex].achValue))
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[ReadLicenseFromUSBKEY]:Faile to verify the value of the key: KEY_LICENSE_TYPE!\n");
				printf("[ReadLicenseFromUSBKEY]:Faile to verify the value of the key: KEY_LICENSE_TYPE!\n");
				wErrorCode = ERR_MCU_USBKEYLICENSEDATA_INVALIDATION;
				return FALSE;
			}
		}
		//校验key为KEY_LICENSE_VERSION的值
	    else if (0 == strcmp(KEY_LICENSE_VERSION, atKeyValuePair[nPairIndex].achKey))
		{
			if(0 != strcmp(LICENSE_VERSION_8KE, atKeyValuePair[nPairIndex].achValue))
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[ReadLicenseFromUSBKEY]:Faile to verify the value of the key: KEY_LICENSE_VERSION!\n");
				printf("[ReadLicenseFromUSBKEY]:Faile to verify the value of the key: KEY_LICENSE_VERSION!\n");
			    wErrorCode = ERR_MCU_USBKEYLICENSEDATA_INVALIDATION;
			    return FALSE;
			}
		}
	}
	LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[ReadLicenseFromUSBKEY]: Read license from USBKEY , Passed!\n");
#endif//_8KE_ ends

	printf("[ReadLicenseFromUSBKEY]: Read license from USBKEY , Passed! wErrorCode:%d\n",wErrorCode);
	return TRUE;
}
//[add][liulijiu][2010.07.15]end
/*=============================================================================
  函 数 名： IsVCSNumOverLicense
  功    能： 是否超过最大VCS接入能力
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： BOOL32  
=============================================================================*/
BOOL32  CMcuVcData::IsVCSNumOverLicense(void)
{
    u16 wVCSAccessNum = 0;
	for (u16 wInstIdx = MAXNUM_MCU_MC + 1; wInstIdx <= (MAXNUM_MCU_VC + MAXNUM_MCU_MC); wInstIdx++)
	{
		if (g_cMcuVcApp.IsMcConnected(wInstIdx))
		{
			wVCSAccessNum++;
		}
	}
	
	LogPrint(LOG_LVL_DETAIL, MID_MCU_CFG, "[IsVCSNumOverLicense]current vcs access num:%d\n", wVCSAccessNum);

    return (wVCSAccessNum >= GetVCSAccessNum());
}

/*=============================================================================
  函 数 名： IsConfNumOverCap
  功    能： 会议数量是否超限
  算法实现： 
  全局变量： 
  参    数： bOngoing               - 欲创建的会议是即时会议
             byConfSource           - 指定发起方MCS_CONF、VCS_CONF、ALL_CONF
  返 回 值： BOOL32  
  ----------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2007/1/18     4.0			顾振华                  创建
=============================================================================*/
BOOL32  CMcuVcData::IsConfNumOverCap ( BOOL32 bOngoing, u8 byConfSource /*= MCS_CONF*/)
{
	LogPrint(LOG_LVL_DETAIL, MID_MCU_CFG, "[IsConfNumOverCap] byConfSource:%u\n",byConfSource);
	// 检查MCU各发起方即时及预约会议是否超过了mcu会议能力
    u8 byAllConfNum = GetConfNum( TRUE, TRUE, FALSE, ALL_CONF );

    // 超最大会议能力
	//最大会议能力用实测数据，不再用MAXNUM_MCU_CONF,v4r7mpc最大4个即时4个预约，mpc2最大16个即时16个预约
    if (byAllConfNum >= MAXNUM_MCU_CONF )
    {
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CFG, "[IsConfNumOverCap]cur conf num(%d) > max conf num(%d)\n",
			byAllConfNum, MAXNUM_MCU_CONF);
        return TRUE;    
    }

    if ( bOngoing )
    {
		// 增加总即时会议的总数判断
        u8 byConfNum = 0;
		byConfNum = GetConfNum( TRUE, FALSE, FALSE, ALL_CONF );
		
		//[chendaiwei2010/10/27]GetMaxMcsOngoingConfNum返回的实际上是所有Ongoing会议的最大上限
		//(包括MCS和VCS创建的会议)
		if (byConfNum >= g_cMcuVcApp.GetMaxMcsOngoingConfNum())
		{
			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CFG, "[IsConfNumOverCap]totoal on-going conf num has passed max(%d)\n",
				      g_cMcuVcApp.GetMaxMcsOngoingConfNum());
			return TRUE;
		}

        // 超最大即时会议能力 
		// 查看指定的发起方会议是否超过分配给各发起方的即时会议的能力
        //byConfNum = GetConfNum( TRUE, FALSE, FALSE, byConfSource );
		//zhouyiliang 20100925 mcs/vcs共用最大会议数统计 
//		u8 byAllOngoConfNum = GetConfNum( TRUE, FALSE, FALSE, ALL_CONF );
		u8 byMaxOnGoConf = MAXNUM_ONGO_CONF;
		//zhouyiliang 20120601 8kg,8kh,8ki空间足够，不用减,TODO：8000b（个数和处理）待市场定，先和8000A一样
#if defined(_8KH_) || defined(_8KE_) || defined(_8KI_) /*|| defined(_MINIMCU_)*/

#else //8000A
		if ( g_cMcuAgent.GetIsUseMpcTranData() && !g_cMSSsnApp.IsDoubleLink() ) //如果内置了mp，需要占去7M左右的内存
		{	
			byMaxOnGoConf--;
			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CFG, "[IsConfNumOverCap] IsMpcRunMp(TRUE),  max conf num(%d)\n", byMaxOnGoConf);
		}
		
		if ( g_cMcuAgent.GetIsUseMpcStack() && !g_cMSSsnApp.IsDoubleLink()) //如果内置了mp，需要占去12M左右的内存
		{
			byMaxOnGoConf--;
			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CFG, "[IsConfNumOverCap] IsMpcRunMtAdp(TRUE),  max conf num(%d)\n", byMaxOnGoConf);
		}
#endif
		if ( byConfNum >= byMaxOnGoConf ) 
		{
			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CFG, "[IsConfNumOverCap] curr conf num(%), max conf num(%d)\n",byConfNum, byMaxOnGoConf);
			return TRUE;
		}
		
//		if (VCS_CONF == byConfSource && byConfNum >= MAXNUM_ONGO_VCSCONF)
//		{
//			return TRUE;
//		}
//		//else if (MCS_CONF == byConfSource && byConfNum >= (MAXNUM_ONGO_CONF - MAXNUM_ONGO_VCSCONF))
//		else if (MCS_CONF == byConfSource && byConfNum >= g_cMcuVcApp.GetMaxMcsOngoingConfNum() )		
//		{
//			return TRUE;
//		}
//		else if (ALL_CONF == byConfSource && byConfNum >= MAXNUM_ONGO_CONF)
//		{
//			return TRUE;
//		}
    }
	else //考虑到主备备份情况，预约会议数量也要限
	{
		u8 byScheduleConfNum = 0;
		byScheduleConfNum = GetConfNum( FALSE, TRUE, FALSE, ALL_CONF );
		if ( byScheduleConfNum >= MAXNUM_MCU_SCHEDULE_CONF )
		{
			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CFG, "[IsConfNumOverCap]cur schedule conf num(%d) > max schedule conf num(%d)\n",
			byScheduleConfNum, MAXNUM_MCU_SCHEDULE_CONF);
			return TRUE;
		}
	}


    return FALSE;
}

/*=============================================================================
  函 数 名： GetMcuCasConfNum
  功    能： 获取级联会议总数
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： BOOL32  
  ----------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2007/01/19    4.0			顾振华                  创建
=============================================================================*/
u8  CMcuVcData::GetMcuCasConfNum ( )
{
    u8 byCasConfNum = 0;
    for(u8 byIndex = 0; byIndex < MAXNUM_MCU_CONF; byIndex++)
    {
        CMcuVcInst *pcIns = m_apConfInst[byIndex];
        if (NULL == pcIns)
            continue;
        if ( !pcIns->m_tConf.m_tStatus.IsOngoing() )
            continue;
        
        if ( pcIns->m_tConfAllMcuInfo.GetSMcuNum() > 0 )
        {
            byCasConfNum ++;
        }            
    }

    return byCasConfNum;
}

/*=============================================================================
  函 数 名： IsCasConfOverCap
  功    能： 级联会议数量是否超限
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： BOOL32  
  ----------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2007/01/19    4.0			顾振华                  创建
=============================================================================*/
BOOL32  CMcuVcData::IsCasConfOverCap ( )
{
    return ( GetMcuCasConfNum() >= MAXLIMIT_MCU_CASCONF );
}

/*=============================================================================
  函 数 名： GetMtNumOnDri
  功    能： 获得某个DRI MtAdp上在线的终端或者Mcu数量，返回是否超限
  算法实现： 
  全局变量： 
  参    数： byDriId    [in]
             bOnilne    [in]    是否检测Online值
             byMtNum    [out]
             bySMcuNum  [out]
  返 回 值： BOOL32  是否超限(找不到、不在线等都认为超限)
  ----------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2007/1/18     4.0			顾振华                  创建
=============================================================================*/
BOOL32  CMcuVcData::GetMtNumOnDri( u8 byDriId, BOOL32 bOnline, u8 &byMtNum, u8 &byMcuNum )
{
    if ( byDriId == 0 || byDriId > MAXNUM_DRI )
        return TRUE;

    u8 byIdx = byDriId - 1;
    if ( !m_atMtAdpData[byIdx].m_bConnected || 
         PROTOCOL_TYPE_H323 != m_atMtAdpData[byIdx].m_byProtocolType ) 
    {
         return TRUE;
    }

    
    if (!bOnline)
    {
        // Mt数量有统计值
        byMtNum = (u8)m_atMtAdpData[byIdx].m_wMtNum;
    }    
    else
    {
        byMtNum = 0;
    }

    // 遍历计算SMcu数量
    byMcuNum = 0;
    u8 byMMcuNum = 0;
    for(u8 byIndex = 0; byIndex < MAXNUM_MCU_CONF; byIndex++)
    {
        CMcuVcInst *pcIns = m_apConfInst[byIndex];
        if (NULL == pcIns)
            continue;
        if ( !pcIns->m_tConf.m_tStatus.IsOngoing() )
            continue;

        if ( !pcIns->m_tConf.GetConfAttrb().IsSupportCascade() )
            continue;

        for ( u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId ++ )
        {
            if ( pcIns->m_ptMtTable->GetDriId(byMtId) == byDriId )
            {
                if ( bOnline && pcIns->m_tConfAllMtInfo.MtJoinedConf( byMtId ) )
                {
                    byMtNum ++;
                }
                if ( pcIns->m_tConfAllMtInfo.MtJoinedConf( byMtId ) &&
                     ( pcIns->m_ptMtTable->GetMtType( byMtId ) == MT_TYPE_SMCU ) )
                {
                    // MCU 永远检测online
                    byMcuNum ++;
                }
                //[9/19/2011 zhushengze]将上级mcu计入接入点
                if ( pcIns->m_tConfAllMtInfo.MtJoinedConf( byMtId ) &&
                     ( pcIns->m_ptMtTable->GetMtType( byMtId ) == MT_TYPE_MMCU ))
                {
                    byMMcuNum++;
                }
            }
        }
    }

    if ( byMtNum + byMcuNum + byMMcuNum >= m_atMtAdpData[byIdx].m_byMaxMtNum || 
         byMcuNum >= m_atMtAdpData[byIdx].m_byMaxSMcuNum )
    {
         return TRUE;
    }

    return FALSE;
    
}

/*=============================================================================
  函 数 名： IsMtNumOverDriLimit
  功    能： 获得某个DRI MtAdp上在线的终端或者Mcu数量，返回是否超限
  算法实现： 
  全局变量： 
  参    数： byDriId    [in]
             bOnilne    [in]    是否检测Online值
             byMtNum    [out]
             bySMcuNum  [out]
  返 回 值： BOOL32  是否超限(找不到、不在线等都认为超限)
  ----------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2010/12/22    4.0		    陈代伟                  创建
=============================================================================*/
BOOL32  CMcuVcData::IsMtNumOverDriLimit( u8 byDriId, BOOL32 bOnline, u8 &byMtNum, u8 &byMcuNum )
{
	//  [12/22/2010 chendaiwei] Fix me: 该函数应该只用与返回byMtNum和byMcuNum,而判断是否MT个数超过DRI的限制
	// 应该放到外面来做。现在对GetMtNumOnDri的调用不同的地方具有歧义，暂时采用IsMtNumOverDriLimit
	// 来封装一下.
	GetMtNumOnDri(byDriId,bOnline,byMtNum,byMcuNum);
    
	// [12/22/2010 chendaiwei]把GetMtNumOnDri中判断是否超限的代码放到外层
    if ( byDriId == 0 || byDriId > MAXNUM_DRI )
        return TRUE;

    u8 byIdx = byDriId - 1;
    if ( !m_atMtAdpData[byIdx].m_bConnected || 
         PROTOCOL_TYPE_H323 != m_atMtAdpData[byIdx].m_byProtocolType ) 
    {
         return TRUE;
    }

    if ( byMtNum + byMcuNum > m_atMtAdpData[byIdx].m_byMaxMtNum || 
         byMcuNum > m_atMtAdpData[byIdx].m_byMaxSMcuNum )
    {
         return TRUE;
    }

    return FALSE;
}

/*=============================================================================
  函 数 名： IsSavingBandwidth
  功    能： 是否节省带宽
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::IsSavingBandwidth(void)         
{
    TLocalInfo tLocalInfo;
    if(SUCCESS_AGENT != g_cMcuAgent.GetLocalInfo(&tLocalInfo))
    {
        return FALSE;
    }

    return (1 == tLocalInfo.GetIsSaveBand());
}

/*=============================================================================
  函 数 名： IsHoldDefaultConf
  功    能： 是否支持召开缺省会议
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcData::IsHoldDefaultConf(void)
{
	TLocalInfo tLocalInfo;
    if(SUCCESS_AGENT != g_cMcuAgent.GetLocalInfo(&tLocalInfo))
    {
        return FALSE;
    }

    return (1 == tLocalInfo.GetIsHoldDefaultConf() );
}


/*=============================================================================
  函 数 名： Msg2TemInfo
  功    能： 
  算法实现： 
  全局变量： 
  参    数： CServMsg &cMsg
             TTemplateInfo &tTemInfo
  返 回 值： void  
=============================================================================*/
void CMcuVcData::Msg2TemInfo(CServMsg &cMsg, TTemplateInfo &tTemInfo)
{
    // guzh [5/17/2007] 先清空
    tTemInfo.Clear();

	TConfInfo *ptConfInfo = (TConfInfo *)cMsg.GetMsgBody();
	u16 wAliasBufLen = ntohs( *(u16*)(cMsg.GetMsgBody() + sizeof(TConfInfo)) );
	s8 *pszAliaseBuf = (s8*)(cMsg.GetMsgBody() + sizeof(TConfInfo) + sizeof(u16));
	s8 *pszModBuf = (s8*)(cMsg.GetMsgBody() + sizeof(TConfInfo) + sizeof(u16) + wAliasBufLen);

    u8 byMtNum = tTemInfo.m_byMtNum;
	UnPackTMtAliasArray(pszAliaseBuf, wAliasBufLen, ptConfInfo, tTemInfo.m_atMtAlias,
		                tTemInfo.m_awMtDialBitRate, byMtNum);
    tTemInfo.m_byMtNum = byMtNum;
	memcpy(&tTemInfo.m_tConfInfo, ptConfInfo, sizeof(TConfInfo));

	TConfAttrb tTempConfAttrb = ptConfInfo->GetConfAttrb();
	if (tTempConfAttrb.IsHasTvWallModule())
	{
		TMultiTvWallModule *ptMultiTvWallModule = (TMultiTvWallModule *)pszModBuf;
		tTemInfo.m_tMultiTvWallModule = *ptMultiTvWallModule;
		pszModBuf += sizeof(TMultiTvWallModule);
	}
	if (tTempConfAttrb.IsHasVmpModule())
	{
		memcpy(&tTemInfo.m_atVmpModule, pszModBuf, sizeof(TVmpModule));
		pszModBuf += sizeof(TVmpModule);
	}

	// 对于VCS创建的会议模板，包含所需要的额外信息 
	//                  + 1byte(u8: 0 1  是否配置了高清电视墙)
	//                  +(可选, THDTvWall)
	//                  + 1byte(u8: 会议配置HDU的通道总数)
	//                  + (可选, THduModChnlInfo+...)	
	//                  + 1byte(是否为级联调度)＋(可选，2byte[u16 网络序，配置打包的总长度]+下级mcu配置[1byte(终端类型)+1byte(别名长度)+xbyte(别名字符串)+2byte(呼叫码率)...)])
	//                  + 1byte(是否支持分组)＋(可选，2byte(u16 网络序，信息总长)+内容(1byte(组数)+n组[1TVCSGroupInfo＋m个TVCSEntryInfo])
	//                  + 1 mtAlias(备份本地地址)

	s8* pszVCSInfoEx = pszModBuf;

	if (VCS_CONF == ptConfInfo->GetConfSource())
	{
		// 配置了高清电视墙
		if (*pszVCSInfoEx++)
		{
			memcpy(&tTemInfo.m_tHDTWInfo, pszVCSInfoEx, sizeof(THDTvWall));
			pszVCSInfoEx += sizeof(THDTvWall);			
		}
		else
		{
			tTemInfo.m_tHDTWInfo.SetNull();
		}

		// 配置HDU
		tTemInfo.m_tHduModule.SetNull();
		u8 byChnlNum = *pszVCSInfoEx++;
		if (byChnlNum)
		{
			tTemInfo.m_tHduModule.SetHduModuleInfo(byChnlNum, pszVCSInfoEx);
			pszVCSInfoEx += byChnlNum * sizeof(THduModChnlInfo);
		}

		// 配置了下级mcu
		if (*pszVCSInfoEx++)
		{
			u16 wSMCUInfoLen = ntohs(*(u16*)pszVCSInfoEx);
			pszVCSInfoEx = (s8*)(pszVCSInfoEx + sizeof(u16));
			u8 bySmcuNum = tTemInfo.m_tVCSSMCUCfg.m_wSMCUNum;
			UnPackTMtAliasArray(pszVCSInfoEx, wSMCUInfoLen, &tTemInfo.m_tConfInfo,
								tTemInfo.m_tVCSSMCUCfg.m_atSMCUAlias, 
								tTemInfo.m_tVCSSMCUCfg.m_awSMCUDialBitRate, 
								bySmcuNum/*tTemInfo.m_tVCSSMCUCfg.m_wSMCUNum*/);
			pszVCSInfoEx = (s8*)(pszVCSInfoEx + wSMCUInfoLen);
		}
		else
		{
			tTemInfo.m_tVCSSMCUCfg.SetNull();
		}

		// 配置了分组
		// 不在会议模板中配置分组信息
// 		if (*pszVCSInfoEx++)
// 		{
// 			tTemInfo.m_byMTPackExist = TRUE;
// 			if (pszUnProcInfoHead != NULL)
// 			{
// 				*pszUnProcInfoHead = pszVCSInfoEx;
// 				*pwUnProcLen = ntohs(*(u16*)pszVCSInfoEx) + sizeof(u16);
// 			}
// 		}
		tTemInfo.m_byMTPackExist = FALSE;
		pszVCSInfoEx++;
		//zhouyiliang 20100818 读backupchairman
		{
			memcpy(&tTemInfo.m_tVCSBackupChairMan , pszVCSInfoEx , sizeof(TMtAlias) );


		}
		// [4/20/2011 xliang] VCAutoMode
		pszVCSInfoEx += sizeof(TMtAlias);
		tTemInfo.m_byVCAutoMode = *(u8*)pszVCSInfoEx;
		
		//偏移取可能的TConfInfoEx信息[12/26/2011 chendaiwei]
		pszVCSInfoEx++;
	}

	u16 wConfExLength = 0;
	if( (u8*)pszVCSInfoEx - cMsg.GetMsgBody() == cMsg.GetMsgBodyLen() )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_CONF,"[Msg2TemInfo]no confex info, set exinfo length 0!\n");
	}
	else
	{
		//扩展信息解析  u16扩展信息总长度+ u8信息类型A + u16信息类型A字节数 + 信息类型A数据（前面标识字节数大小）+ u16信息类型B......[12/29/2011 chendaiwei]
		wConfExLength = ntohs(*(u16*)pszVCSInfoEx);
	}

	if( wConfExLength != 0 && (wConfExLength + sizeof(u16)) <= CONFINFO_EX_BUFFER_LENGTH)
	{
		wConfExLength += sizeof(u16);
		memcpy(tTemInfo.m_byConInfoExBuf,pszVCSInfoEx,wConfExLength);
	}

	return;
}

/*=============================================================================
  函 数 名： TemInfo2Msg
  功    能： 
  算法实现： 
  全局变量： 
  参    数： TTemplateInfo &tTemInfo
             CServMsg &cMsg
  返 回 值： void  
=============================================================================*/
void CMcuVcData::TemInfo2Msg(TTemplateInfo &tTemInfo, CServMsg &cMsg)
{
	s8  achAliasBuf[SERV_MSG_LEN];
	u16 wAliasBufLen = 0;

	cMsg.SetMsgBody( (u8*)&tTemInfo.m_tConfInfo, sizeof(TConfInfo) );

	//终端别名数组打包 
	PackTMtAliasArray(tTemInfo.m_atMtAlias, tTemInfo.m_awMtDialBitRate, 
		              tTemInfo.m_byMtNum, achAliasBuf, wAliasBufLen);
	wAliasBufLen = htons(wAliasBufLen);
	cMsg.CatMsgBody((u8*)&wAliasBufLen, sizeof(wAliasBufLen));
	cMsg.CatMsgBody((u8*)achAliasBuf, ntohs(wAliasBufLen));

	//电视墙模板
	TConfAttrb tTempAttrb = tTemInfo.m_tConfInfo.GetConfAttrb();
	if( tTempAttrb.IsHasTvWallModule() )
	{			
		cMsg.CatMsgBody( (u8*)&tTemInfo.m_tMultiTvWallModule, sizeof(TMultiTvWallModule) );
	}
	//画面合成模板 
	if( tTempAttrb.IsHasVmpModule() )
	{			
		cMsg.CatMsgBody( (u8*)&tTemInfo.m_atVmpModule, sizeof(TVmpModule) );
	}
	// 对于VCS创建的会议模板，包含所需要的额外信息 
	//                  + 1byte(u8: 0 1  是否配置了高清电视墙)
	//                  +(可选, THDTvWall)
	//                  + 1byte(u8: 会议配置HDU的通道总数)
	//                  + (可选, THduModChnlInfo+...)
	//                  + 1byte(是否为级联调度)＋(可选，2byte[u16 网络序，配置打包的总长度]+下级mcu配置[1byte(终端类型)+1byte(别名长度)+xbyte(别名字符串)+2byte(呼叫码率)...)])
	//                  + 1byte(是否支持分组)＋(可选，2byte(u16 网络序，信息总长)+内容(1byte(组数)+n组[1TVCSGroupInfo＋m个TVCSEntryInfo])
	//                  + 1 TMtAlias（本地终端备份）
	if (VCS_CONF == tTemInfo.m_tConfInfo.GetConfSource())
	{
		u8 byIsHDTWCfg = (u8)tTemInfo.IsHDTWCfg();
		cMsg.CatMsgBody(&byIsHDTWCfg, sizeof(u8));
		// 配置了高清电视墙
		if (byIsHDTWCfg)
		{
			cMsg.CatMsgBody((u8*)&tTemInfo.m_tHDTWInfo, sizeof(THDTvWall));
		}
		// 配置了Hdu
		u8 byHduChnlNum = tTemInfo.m_tHduModule.GetHduChnlNum( FALSE );
		cMsg.CatMsgBody(&byHduChnlNum, sizeof(u8));
		if (byHduChnlNum)
		{
			cMsg.CatMsgBody(tTemInfo.m_tHduModule.GetHduModuleInfo(), byHduChnlNum * sizeof(THduModChnlInfo));
		}

		// 配置了下级mcu
		u8 byIsVCSSMCUCfg = (u8)tTemInfo.IsVCSMCUCfg();
		cMsg.CatMsgBody(&byIsVCSSMCUCfg, sizeof(u8));
		if (byIsVCSSMCUCfg)
		{
			PackTMtAliasArray(tTemInfo.m_tVCSSMCUCfg.m_atSMCUAlias, tTemInfo.m_tVCSSMCUCfg.m_awSMCUDialBitRate,
							  tTemInfo.m_tVCSSMCUCfg.m_wSMCUNum, achAliasBuf, wAliasBufLen);
			wAliasBufLen = htons(wAliasBufLen);
			cMsg.CatMsgBody((u8*)&wAliasBufLen, sizeof(u16));
			cMsg.CatMsgBody((u8*)achAliasBuf, ntohs(wAliasBufLen));
		}
		// 配置了分组		
		// 分组信息不由模板信息中给出
		tTemInfo.m_byMTPackExist = FALSE;
		cMsg.CatMsgBody((u8*)&tTemInfo.m_byMTPackExist, sizeof(u8));


		//zhouyiliang 20100818 打包backupchairman
		{
			cMsg.CatMsgBody( (u8*)&tTemInfo.m_tVCSBackupChairMan, sizeof(TMtAlias) );

		}

		// [4/20/2011 xliang] pack VCAutoMode
		cMsg.CatMsgBody( (u8*)&tTemInfo.m_byVCAutoMode, sizeof(u8));
			
	}
	
	u16 wConfExInfoLength = ntohs(*(u16*)&tTemInfo.m_byConInfoExBuf[0]) + sizeof(u16);
	if( wConfExInfoLength <= CONFINFO_EX_BUFFER_LENGTH)
	{
		cMsg.CatMsgBody((u8*)&tTemInfo.m_byConInfoExBuf[0],wConfExInfoLength);
	}
	else
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_CONF,"[TemInfo2Msg] confExInfoLength:%d > CONFINFO_EX_BUFFER_LENGTH:%d, error!\n",wConfExInfoLength,CONFINFO_EX_BUFFER_LENGTH);
	}

	cMsg.SetConfId(tTemInfo.m_tConfInfo.GetConfId());

	return;
}

/*=============================================================================
  函 数 名： ConfInfoMsgPack
  功    能： 会议信息消息打包
  算法实现： 
  全局变量： 
  参    数： CMcuVcInst *pcSchInst
             CServMsg &cServMsg
  返 回 值： void 
=============================================================================*/
void CMcuVcData::ConfInfoMsgPack(CMcuVcInst *pcSchInst, CServMsg &cServMsg)
{
    if(NULL == pcSchInst)
    {
        return;
    }

    u8  byLoop;
    TMt tMt;
    TMtAlias  tMtAlias;
    TConfInfo tNewConfInfo;
    TMtAlias  atMtAlias[MAXNUM_CONF_MT];
    u16       awMtDialBitRate[MAXNUM_CONF_MT];
    
    s8  achAliasBuf[SERV_MSG_LEN];
    u16 wAliasBufLen = 0;
    u8  byMtPos = 0;
    
    TMultiTvWallModule tMultiTvWallModule;
    pcSchInst->m_tConfEqpModule.GetMultiTvWallModule(tMultiTvWallModule);
    TVmpModule tVmpModule = pcSchInst->GetVmpModule();   

    memset(tVmpModule.m_abyVmpMember, 0, sizeof(tVmpModule.m_abyVmpMember));
    
    //清除GK注册信息，即时模板本身注册成功
    tNewConfInfo = pcSchInst->m_tConf;
    tNewConfInfo.m_tStatus.SetRegToGK( FALSE );
    if( tNewConfInfo.m_tStatus.GetProtectMode() == CONF_LOCKMODE_LOCK )
    {
        tNewConfInfo.m_tStatus.SetProtectMode( CONF_LOCKMODE_NONE );
    }    
    
	TConfAttrb tNewConfAttrb = tNewConfInfo.GetConfAttrb();
	THduVmpModuleOrTHDTvWall tHduVmpModule = pcSchInst->m_tConfEqpModule.m_tHduVmpModuleOrHDTvWall;

    //终端列表
    BOOL32 bExist = FALSE;
    u8 byMemberType = 0;
	TVmpModuleInfo tVmpModuleINfo;
	memcpy(&tVmpModuleINfo,&(pcSchInst->m_tConfEqpModule.m_tVmpModuleInfo),sizeof(tVmpModuleINfo));
	tVmpModuleINfo.EmptyAllVmpMember();

    for( byLoop = 0; byLoop < pcSchInst->m_ptMtTable->m_byMaxNumInUse; byLoop++)
    {
        tMt = pcSchInst->m_ptMtTable->GetMt(byLoop+1);
        if(!tMt.IsNull())
        {			
            //由于mtAliasTypeH320Alias类型不能用作呼叫信息，所以不加载
            if( pcSchInst->m_ptMtTable->GetMtAlias( (byLoop+1), mtAliasTypeH320ID, &tMtAlias ) )
            {
                atMtAlias[byLoop] = tMtAlias;
            }
            else if( pcSchInst->m_ptMtTable->GetMtAlias( (byLoop+1), mtAliasTypeTransportAddress, &tMtAlias ) )
            {
                atMtAlias[byLoop] = tMtAlias;			
            }
            else 
            {
                if( pcSchInst->m_ptMtTable->GetMtAlias( (byLoop+1), mtAliasTypeE164, &tMtAlias ) )
                {
                    atMtAlias[byLoop] = tMtAlias;			
                } 
                else 
                {
                    if( pcSchInst->m_ptMtTable->GetMtAlias( (byLoop+1), mtAliasTypeH323ID, &tMtAlias ) )
                    {
                        atMtAlias[byLoop] = tMtAlias;
                    }
                }
            }
            
            awMtDialBitRate[byLoop] = pcSchInst->m_ptMtTable->GetDialBitrate( (byLoop+1) );
            
            //更新模板映射关系

            if(tNewConfAttrb.IsHasTvWallModule())
            {
                for(u8 byTvLp = 0; byTvLp < MAXNUM_PERIEQP_CHNNL; byTvLp++)
                {
                    u8 byTvId = pcSchInst->m_tConfEqpModule.m_tTvWallInfo[byTvLp].m_tTvWallEqp.GetEqpId();
                    bExist = pcSchInst->m_tConfEqpModule.GetTvWallMemberByMt(byTvId, tMt, byMtPos, byMemberType);
                    if( bExist )
                    {
                        tMultiTvWallModule.SetTvWallMember(byTvId, byMtPos, byLoop+1, byMemberType);
                    }
                }
            }

			//子通道member从mtId转换成mtalias数组下标+1[3/8/2013 chendaiwei]					
			for( u8 byLoopChIdx = 0; byLoopChIdx <(HDUID_MAX-HDUID_MIN+1)*MAXNUM_HDU_CHANNEL;byLoopChIdx++)
			{
				for(u8 byLoopSubIdx = 0; byLoopSubIdx <HDU_MODEFOUR_MAX_SUBCHNNUM; byLoopSubIdx++)
				{
					if(pcSchInst->m_tConfEqpModule.IsMtInHduVmpChnnl(byLoopChIdx,byLoopSubIdx,tMt))
					{
						tHduVmpModule.SetHduVmpSubChnlMember(byLoopChIdx,byLoopSubIdx,(byLoop+1));
					}
				}
			}
			
            if(tNewConfAttrb.IsHasVmpModule())
            {
                for (u8 byVmpIdx = 0; byVmpIdx < MAXNUM_MPU2VMP_MEMBER; byVmpIdx++)
                {
                    if( pcSchInst->m_tConfEqpModule.IsMtAtVmpChannel(byVmpIdx, tMt, byMemberType) )
					{
						if( byVmpIdx < MAXNUM_MPUSVMP_MEMBER )
						{
							tVmpModule.SetVmpMember(byVmpIdx, byLoop+1, byMemberType);
						}
						else
						{
							tVmpModuleINfo.m_abyVmpMember[byVmpIdx] = byLoop+1;
							tVmpModuleINfo.m_abyMemberType[byVmpIdx] = byMemberType;
						}
					}
                }                
            }            
        }
    }   
    
    //终端别名数组打包 
    PackTMtAliasArray(atMtAlias, awMtDialBitRate, 
		              pcSchInst->m_ptMtTable->m_byMaxNumInUse, achAliasBuf, wAliasBufLen);	
    wAliasBufLen = htons(wAliasBufLen);
	cServMsg.SetMsgBody((u8 *)&tNewConfInfo, sizeof(TConfInfo));
    cServMsg.CatMsgBody((u8*)&wAliasBufLen, sizeof(wAliasBufLen));
    cServMsg.CatMsgBody((u8*)achAliasBuf, ntohs(wAliasBufLen));
    
    //电视墙模板
    if( tNewConfAttrb.IsHasTvWallModule() )
    {			
        cServMsg.CatMsgBody( (u8*)&tMultiTvWallModule, sizeof(TMultiTvWallModule) );
    }
    //画面合成模板 
	// 2011-10-28 comment by pgf:已经单独上报，此处不再需要
	if( tNewConfAttrb.IsHasVmpModule() )
	{			
		cServMsg.CatMsgBody( (u8*)&tVmpModule, sizeof(TVmpModule) );
	}
	
	u8 abyConfInfExBuf[CONFINFO_EX_BUFFER_LENGTH] = {0};
	u16 wPackDataLen = 0;
	PackConfInfoEx(pcSchInst->m_tConfEx,abyConfInfExBuf,wPackDataLen,&tHduVmpModule,&tVmpModuleINfo);
	cServMsg.CatMsgBody(abyConfInfExBuf, wPackDataLen);

    return;
}

/*=============================================================================
  函 数 名： ShowTemplate
  功    能： 打印模板基本信息
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： void  
=============================================================================*/
void   CMcuVcData::ShowTemplate(void)
{
    s8 szInfo[255];
    StaticLog("\nconf template info as followed:\n");

	if (!m_ptTemplateInfo)
	{
		StaticLog("Error, m_ptTemplateInfo is null\n");
		return;
	}
    
    for(u8 byIndex = 0; byIndex < MAXNUM_MCU_TEMPLATE; byIndex++)
    {
        if(m_ptTemplateInfo[byIndex].IsEmpty())
        {
            continue;
        }

        TConfInfo *ptConfInfo = &m_ptTemplateInfo[byIndex].m_tConfInfo;
        ptConfInfo->GetConfId().GetConfIdString(szInfo, sizeof(szInfo));
        StaticLog("\nTemplate name: %s, E164: %s, isTakeFromfile:%d\n", 
                  ptConfInfo->GetConfName(), ptConfInfo->GetConfE164(),ptConfInfo->m_tStatus.IsTakeFromFile());
        StaticLog("temindex: %d, insid: %d confidx: %d, usrgrp: %d\n  confid: %s\n", 
                  byIndex, GetConfMapInsId(m_ptTemplateInfo[byIndex].m_byConfIdx), m_ptTemplateInfo[byIndex].m_byConfIdx, 
                  ptConfInfo->GetUsrGrpId(), szInfo);
        
        StaticLog("MTs(number %d) in template:\n", m_ptTemplateInfo[byIndex].m_byMtNum);
        for(u8 byMtIndex = 0; byMtIndex < MAXNUM_CONF_MT; byMtIndex++)
        {
            if(!m_ptTemplateInfo[byIndex].m_atMtAlias[byMtIndex].IsNull())
            {
                StaticLog("Mt%d :", byMtIndex);
                m_ptTemplateInfo[byIndex].m_atMtAlias[byMtIndex].Print();
            }
        }
        
		TConfAttrb tTempConfAttrb = ptConfInfo->GetConfAttrb();
        if(tTempConfAttrb.IsHasTvWallModule())
        {
            for(u8 byTvLp = 0; byTvLp < m_ptTemplateInfo->m_tMultiTvWallModule.m_byTvModuleNum; byTvLp++)
            {
                TTvWallModule *ptTW = &m_ptTemplateInfo[byIndex].m_tMultiTvWallModule.m_atTvWallModule[byTvLp];
                StaticLog("TvWall Module <%d, %d>:\n", ptTW->m_tTvWall.GetMcuId(), ptTW->m_tTvWall.GetMtId());
                memset(szInfo, 0, sizeof(szInfo));
                for(u8 byTWIndex = 0; byTWIndex < MAXNUM_TVWALL_CHNNL_INSMOUDLE; byTWIndex++)
                {
                    sprintf(szInfo, "%s:%d", szInfo, ptTW->m_abyTvWallMember[byTWIndex]);
                }
                StaticLog("TvWall mt index %s", szInfo);
            }
        }

        if(tTempConfAttrb.IsHasVmpModule())
        {
            TVmpModule *ptVmp = &m_ptTemplateInfo[byIndex].m_atVmpModule;
            StaticLog("Vmp Module:\n");
            memset(szInfo, 0, sizeof(szInfo));
            for(u8 byVmpIndex = 0; byVmpIndex < MAXNUM_MPUSVMP_MEMBER; byVmpIndex++)
            {
                sprintf(szInfo, "%s:%d", szInfo, ptVmp->m_abyVmpMember[byVmpIndex]);
            }
            StaticLog("Vmp mt index %s", szInfo);
        }
    }

    return;
}

/*=============================================================================
  函 数 名： ShowConfMap
  功    能： 
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： void  
=============================================================================*/
void   CMcuVcData::ShowConfMap(void)
{
    StaticLog("\n---------VC Map Data---------\n");

    s8 szConfId[64] = {0};
    TConfInfo *ptConf;
    for(u8 byIndex = 0; byIndex < MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE; byIndex++)
    {
        if ( !m_atConfMapData[byIndex].IsTemUsed() && 
             !m_atConfMapData[byIndex].IsValidConf() )
             continue;

        StaticLog("Map Index: %3d\tTemplateIdx: %2d\tVCInstID: %2d\n", 
                  byIndex+1,
                  m_atConfMapData[byIndex].GetTemIndex(), 
                  m_atConfMapData[byIndex].GetInsId() );

        if ( m_atConfMapData[byIndex].IsTemUsed() && m_ptTemplateInfo )
        {
            u8 byTemIdx = m_atConfMapData[byIndex].GetTemIndex();
            m_ptTemplateInfo[byTemIdx].m_tConfInfo.GetConfId().GetConfIdString(szConfId, 63);
            StaticLog("\tTmpt Name: %s\tConfID:%s\n", 
                      m_ptTemplateInfo[byTemIdx].m_tConfInfo.GetConfName(),
                      szConfId);
        }

		u8 byInsId =  m_atConfMapData[byIndex].GetInsId()-MIN_CONFIDX;
        if ( m_atConfMapData[byIndex].IsValidConf() && m_apConfInst[byInsId] )
        {
            ptConf = &m_apConfInst[byInsId]->m_tConf;
            ptConf->GetConfId().GetConfIdString(szConfId, 63);
            StaticLog("\tConf Name: %s\tConfID:%s\n", 
                      ptConf->GetConfName(),
                      szConfId);
        }
    }
}
/*=============================================================================
  函 数 名： GetTempEditerInfo
  功    能： 
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： void  
=============================================================================*/
u8 CMcuVcData::GetTempEditerInfo(u8 byConfPos)
{
	if (byConfPos < (MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE))
	{
		return m_abyTempEditer[byConfPos];
	}
	return 0;
}
/*=============================================================================
  函 数 名： SetTempEditerInfo
  功    能： 
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： void  
=============================================================================*/
void CMcuVcData::SetTempEditerInfo(u8 byConfPos, u8 byInstId)
{
	if (byConfPos < MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE)
	{
		m_abyTempEditer[byConfPos] = byInstId;
	}

}
/*=============================================================================
  函 数 名： UpdateExInfoInTemplate
  功    能：更新模板信息中的扩展信息项内容 
  算法实现： 
  全局变量： 
  参    数： tTemp：模板信息，byExenumType：扩展信息类型enum值，wInfoLen：扩展信息长度，pbyBuf：扩展信息内存
  返 回 值： void  
=============================================================================*/
void CMcuVcData::UpdateExInfoInTemplate(TTemplateInfo &  tTemp,const emCommunicateType& emExenumType,const u16& wInfoLen,u8* pbyBuf)
{
	
	//扩展信息解析  u16扩展信息总长度+ u8信息类型A + u16信息类型A字节数 + 信息类型A数据（前面标识字节数大小）+ u8信息类型B....
	u8 * pbyExInbuf = tTemp.m_byConInfoExBuf;
	u16 wConfExSize = ntohs( *(u16*)pbyExInbuf);
	pbyExInbuf = pbyExInbuf + sizeof(u16);
	BOOL32 bExistInfo = FALSE;
	
	s32 nConfExSize = wConfExSize;
	u16 wLength = 0;
	emCommunicateType etype ;
	while( nConfExSize > 0)
	{
		wLength = 0;
		etype = (emCommunicateType)(*pbyExInbuf);
		pbyExInbuf ++;
		wLength = ntohs( *(u16*)pbyExInbuf);
		//不同的类型，跳过
		if (emExenumType != etype)
		{
			pbyExInbuf = pbyExInbuf + sizeof(u16) +wLength;
		}
		else //有相同类型，更新
		{
			//类型相同，长度不同，错误，返回
			if ( wInfoLen != wLength )
			{
				LogPrint(LOG_LVL_ERROR,MID_MCU_CONF,"[UpdateExInfoInTemplate] type:%d wInfoLen:%d,len not equal with oldinfolen(%d),error!\n",emExenumType,wInfoLen,wLength);
				return;
			}
			//更新内容
			pbyExInbuf += sizeof(u16);
			memcpy(pbyExInbuf,pbyBuf,wInfoLen);
			pbyExInbuf += wInfoLen;
			bExistInfo = TRUE;
			break;
		}
		
		nConfExSize = nConfExSize - (s32)sizeof(u8) - (s32)sizeof(u16) - (s32)wLength;
	}
	//没找到相同类型内容，新加
	if ( !bExistInfo )
	{
		//内存保护
		if ( (wConfExSize + sizeof(u8) + sizeof(u16) + wInfoLen + sizeof(u16)/*总长度*/) > CONFINFO_EX_BUFFER_LENGTH )
		{

			LogPrint(LOG_LVL_ERROR,MID_MCU_CONF,"[UpdateExInfoInTemplate] addinfolen + confexsize > CONFINFO_EX_BUFFER_LENGTH!\n");
			return;
		}
		*pbyExInbuf = (u8)emExenumType;
		pbyExInbuf += sizeof(u8);
		*(u16*)pbyExInbuf = htons(wInfoLen);
		pbyExInbuf += sizeof(u16);
		memcpy(pbyExInbuf,pbyBuf,wInfoLen);

		//更新总长度
		wConfExSize += sizeof(u8) + sizeof(u16) + wInfoLen;
		*(u16*)&tTemp.m_byConInfoExBuf[0] = htons(wConfExSize);
	
	}



}
/*=============================================================================
    函 数 名： GetVcDeamonEnvState
    功    能： 主备数据倒换时 获取 同步前的MTADP/MP/外设/会控 等环境信息
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  TMSSynEnvState &tMSSynEnvState
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/12/12  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetVcDeamonEnvState( TMSSynEnvState &tMSSynEnvState )
{
	u8 byLoop = 0;
	memset(&tMSSynEnvState, 0, sizeof(tMSSynEnvState));

	//会控实际连接状态
	for (byLoop = 0; byLoop < (MAXNUM_MCU_MC + MAXNUM_MCU_VC); byLoop++)
	{
		if (m_atMcTable[byLoop].m_bConnected)
		{
			tMSSynEnvState.m_tMCState.m_abyOnline[byLoop] = 1;
			memcpy((s8*)&tMSSynEnvState.m_tMCState.m_tMcsRegInfo[byLoop], 
				   (s8*)&m_atMcTable[byLoop].m_tMcsRegInfo, sizeof(TMcsRegInfo));
		}
	}
	for (byLoop = 0; byLoop < MAXNUM_MCU_PERIEQP; byLoop++)
	{	
		if (m_atPeriEqpTable[byLoop].m_tPeriEqpStatus.m_byOnline)
		{
			tMSSynEnvState.m_tEqpState.m_abyOnline[byLoop] = 1;
		}
	}
	//Mp实际连接状态
	for (byLoop = 0; byLoop < MAXNUM_DRI; byLoop++)
	{
		if (m_atMpData[byLoop].m_bConnected)
		{
			tMSSynEnvState.m_tMpState.m_abyOnline[byLoop] = 1;
		}	
	}
	//MTADP实际连接状态
	for (byLoop = 0; byLoop < MAXNUM_DRI; byLoop++)
	{
		if (m_atMtAdpData[byLoop].m_bConnected)
		{
			tMSSynEnvState.m_tMtAdpState.m_abyOnline[byLoop] = 1;
		}	
	}
    //DCS实际连接状态
	for (byLoop = 0; byLoop < MAXNUM_MCU_DCS; byLoop++)
	{
		if (m_atPeriDcsTable[byLoop].m_tDcsStatus.m_byOnline)
		{
			tMSSynEnvState.m_tDcsState.m_abyOnline[byLoop] = 1;
		}	
	}
	return TRUE;
}

/*=============================================================================
    函 数 名： IsEqualToVcDeamonEnvState
    功    能： 主备数据倒换时 比较是否一致 同步前的MTADP/MP/外设/会控 等环境信息
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  TMSSynEnvState *ptMSSynEnvState 待比较的外部环境信息               
	           [IN]      BOOL32 bPrintErr                  是否打印失败信息
               [OUT]     TMSEnvConflict &tMSEnvConflict  详细失败信息
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                创建
    2006/06/01  4.0         张宝卿                增加失败信息上报会控处理
=============================================================================*/
BOOL32 CMcuVcData::IsEqualToVcDeamonEnvState( TMSSynEnvState *ptMSSynEnvState, BOOL32 bPrintErr, TMSSynState *ptMSSynState )
{
	if (NULL == ptMSSynEnvState)
	{
		return FALSE;
	}

	//MTADP/Mp/外设 EqpID 由MCU指定，对应InstID唯一，所以可采用InstID唯一标识，进行连接状态校验；
	//会控 无EqpID等ID值指定，对应InstID也不唯一，由会控的提供连接随机值dwMcsSSRC唯一标识，组成TMcsRegInfo进行连接状态校验；

	u8 byLoop  = 0;
	u8 byState = 0;

	//会控实际连接状态
	//会控有效连接数 校验
	u8 byLocalNum  = 0;  //本端会控有效连接数
	u8 byRemoteNum = 0;  //远端会控有效连接数
	for (byLoop = 0; byLoop < (MAXNUM_MCU_MC + MAXNUM_MCU_VC); byLoop++)
	{
		if (m_atMcTable[byLoop].m_bConnected)
		{			
			byLocalNum++; 
		}
		if (1 == ptMSSynEnvState->m_tMCState.m_abyOnline[byLoop])
		{			
			byRemoteNum++; 
		}
	}
	if (byLocalNum != byRemoteNum)
	{
        //设置冲突类型
        ptMSSynState->SetEntityType( TMSSynState::emMC );
        
		if (bPrintErr)
		{
			LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "Mcs Online_Num is not Equal: LocalNum.%d RemoteNum.%d\n", 
				      byLocalNum, byRemoteNum);
		}
		return FALSE;
	}

	//有效会控的连接参数 校验
	if (byRemoteNum > 0)
	{
		for (byLoop = 0; byLoop < (MAXNUM_MCU_MC + MAXNUM_MCU_VC); byLoop++)
		{
			if (1 != ptMSSynEnvState->m_tMCState.m_abyOnline[byLoop])
			{
				continue;
			}
			u8 byLocalPos = 0;
			for (byLocalPos = 0; byLocalPos < (MAXNUM_MCU_MC + MAXNUM_MCU_VC); byLocalPos++)
			{
				if (m_atMcTable[byLocalPos].m_bConnected && 
					m_atMcTable[byLocalPos].m_tMcsRegInfo == ptMSSynEnvState->m_tMCState.m_tMcsRegInfo[byLoop])
				{
					break;
				}
			}
			if (MAXNUM_MCU_MC + MAXNUM_MCU_VC == byLocalPos)
			{
                //设置冲突信息
                ptMSSynState->SetEntityType( TMSSynState::emMC );

				if (bPrintErr)
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_MSMGR, "McsInstId.%d McsRegInfo no match with LocalMC's: RemoteMcsIp.0x%0x McsSSRC.0x%0x\n", 
						      (byLoop+1), ptMSSynEnvState->m_tMCState.m_tMcsRegInfo[byLoop].GetMcsIpAddr(), 
						      ptMSSynEnvState->m_tMCState.m_tMcsRegInfo[byLoop].GetMcsSSRC());
				}
				return FALSE;
			}
		}
	}

	//外设实际连接状态
	for (byLoop = 0; byLoop < MAXNUM_MCU_PERIEQP; byLoop++)
	{
		if (m_atPeriEqpTable[byLoop].m_tPeriEqpStatus.m_byOnline != 
			ptMSSynEnvState->m_tEqpState.m_abyOnline[byLoop])
		{
            //设置冲突信息
            ptMSSynState->SetEntityType( TMSSynState::emPeriEqp );
            ptMSSynState->SetEntityId( byLoop + 1 ); 
            
			if (bPrintErr)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_MSMGR, "EqpId.%d Online_State is not Equal:Local.%d Remote.%d\n", 
					      (byLoop+1), m_atPeriEqpTable[byLoop].m_tPeriEqpStatus.m_byOnline, 
						  ptMSSynEnvState->m_tEqpState.m_abyOnline[byLoop]);
			}
			return FALSE;
		}
	}
	//Mp实际连接状态
	for (byLoop = 0; byLoop < MAXNUM_DRI; byLoop++)
	{
		byState = m_atMpData[byLoop].m_bConnected ? 1 : 0;
		if (byState != ptMSSynEnvState->m_tMpState.m_abyOnline[byLoop])
		{
            //设置冲突信息
            ptMSSynState->SetEntityType( TMSSynState::emMp );
            
			if (bPrintErr)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_MSMGR, "MpId.%d Online_State is not Equal:Local.%d Remote.%d\n", 
					      (byLoop+1), byState, ptMSSynEnvState->m_tMpState.m_abyOnline[byLoop]);
			}
			return FALSE;
		}	
	}
	//MTADP实际连接状态
	for (byLoop = 0; byLoop < MAXNUM_DRI; byLoop++)
	{
		byState = m_atMtAdpData[byLoop].m_bConnected ? 1 : 0;
		if (byState != ptMSSynEnvState->m_tMtAdpState.m_abyOnline[byLoop])
		{
            //设置冲突信息
            ptMSSynState->SetEntityType( TMSSynState::emMtAdp );

			if (bPrintErr)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_MSMGR, "MtadpId.%d Online_State is not Equal:Local.%d Remote.%d\n", 
					      (byLoop+1), byState, ptMSSynEnvState->m_tMtAdpState.m_abyOnline[byLoop]);
			}
			return FALSE;
		}	
	}
	//DCS实际连接状态
	for (byLoop = 0; byLoop < MAXNUM_MCU_DCS; byLoop++)
	{
		if (m_atPeriDcsTable[byLoop].m_tDcsStatus.m_byOnline != 
			ptMSSynEnvState->m_tDcsState.m_abyOnline[byLoop])
		{
            //设置冲突信息
            ptMSSynState->SetEntityType( TMSSynState::emDcs );
            ptMSSynState->SetEntityId( byLoop + 1 );            

			if (bPrintErr)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_MSMGR, "DcsId.%d Online_State is not Equal:Local.%d Remote.%d\n", 
					      (byLoop+1), m_atPeriDcsTable[byLoop].m_tDcsStatus.m_byOnline, 
						  ptMSSynEnvState->m_tDcsState.m_abyOnline[byLoop]);
			}
			return FALSE;
		}
	}	
	return TRUE;
}

/*=============================================================================
    函 数 名： GetVcDeamonPeriEqpData
    功    能： 主备数据倒换时 获取 会议应用的公用数据区的外设信息表(包括离线外设) 信息
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
			   [OUT]     u32 &dwOutBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetVcDeamonPeriEqpData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen )
{
	if (NULL == pbyBuf || dwInBufLen < (sizeof(TMSVcPeriEqpStateHead)+sizeof(m_atPeriEqpTable)))
	{
		return FALSE;
	}
	
	TMSVcPeriEqpStateHead *ptPeriEqpState = (TMSVcPeriEqpStateHead*)pbyBuf;
	u8 *pbyEqpDataBuf = pbyBuf+sizeof(TMSVcPeriEqpStateHead);
	u8  byPeriEqpNum  = 0;
	memset(pbyBuf, 0, sizeof(TMSVcPeriEqpState));
		
	for (u8 byLoop = 0; byLoop < MAXNUM_MCU_PERIEQP; byLoop++)
	{
		if (m_atPeriEqpTable[byLoop].m_bIsValid) //包括离线外设
		{
			ptPeriEqpState->m_abyValid[byLoop] = 1;
			memcpy(pbyEqpDataBuf, (s8*)(&m_atPeriEqpTable[byLoop]), sizeof(TPeriEqpData));
			pbyEqpDataBuf += sizeof(TPeriEqpData);
			
			byPeriEqpNum += 1;
		}
		else
		{
			ptPeriEqpState->m_abyValid[byLoop] = 0;
		}
	}
	
	dwOutBufLen = sizeof(TMSVcPeriEqpStateHead) + byPeriEqpNum*sizeof(TPeriEqpData);
	
	return TRUE;
}

/*=============================================================================
    函 数 名： SetVcDeamonPeriEqpData
    功    能： 主备数据倒换时 恢复 会议应用的公用数据区的外设信息表(包括离线外设) 信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetVcDeamonPeriEqpData( u8 *pbyBuf, u32 dwInBufLen )
{
	if (NULL == pbyBuf || dwInBufLen < sizeof(TMSVcPeriEqpStateHead))
	{
		return FALSE;
	}
	
	TMSVcPeriEqpStateHead *ptPeriEqpState = (TMSVcPeriEqpStateHead*)pbyBuf;
	u8 *pbyEqpDataBuf = pbyBuf+sizeof(TMSVcPeriEqpStateHead);
	
	//zbq[06/05/2008] 连接状态主备独立修正
	for (u8 byLoop = 0; byLoop < MAXNUM_MCU_PERIEQP; byLoop++)
	{
		if (1 == ptPeriEqpState->m_abyValid[byLoop])
		{
            //zbq[2006/10/11]外设的连接状态在物理上认为是主备独立，不进行倒换
            u8 byOnline = m_atPeriEqpTable[byLoop].m_tPeriEqpStatus.m_byOnline;
			memcpy((s8*)(&m_atPeriEqpTable[byLoop]), pbyEqpDataBuf, sizeof(TPeriEqpData));
            m_atPeriEqpTable[byLoop].m_tPeriEqpStatus.m_byOnline = byOnline;
			//根据同步过来的外设逻辑通道ip和当前所挂转发板ip比较看主板是否进行了转发板备份
			u8 byCurMpId = g_cMcuAgent.GetEqpSwitchBrdId(byLoop+1);
		
			u32 dwNewIpAddr  = m_atPeriEqpTable[byLoop].m_tFwdVideoChannel.GetSndMediaCtrlChannel().GetIpAddr();
			u8 byNewMpId = FindMp(dwNewIpAddr);
			if ( byNewMpId != 0 && byCurMpId != byNewMpId )
			{
				LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_MSMGR, "[SetVcDeamonPeriEqpData]EqpId:%d,setNewMpId:%d\n",byLoop+1,byNewMpId);
				g_cMcuAgent.SetEqpSwitchBrdId(byLoop+1, byNewMpId);
			}
			pbyEqpDataBuf += sizeof(TPeriEqpData);	
		}
		else
		{
			//memset((s8*)(&m_atPeriEqpTable[byLoop]), 0, sizeof(TPeriEqpData));
		}
	}

	return TRUE;
}

/*=============================================================================
    函 数 名： GetVcDeamonMCData
    功    能： 主备数据倒换时 获取 会议应用的公用数据区的会控信息表 信息
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
			   [OUT]     u32 &dwOutBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetVcDeamonMCData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen )
{
	if (NULL == pbyBuf || dwInBufLen < (sizeof(TMSVcMCStateHead)+sizeof(m_atMcTable)))
	{
		return FALSE;
	}
	
	TMSVcMCStateHead *ptMCStateHead = (TMSVcMCStateHead*)pbyBuf;
	u8 *pbyMCDataBuf = pbyBuf+sizeof(TMSVcMCStateHead);
	u8  byMCNum = 0;
	memset(pbyBuf, 0, sizeof(TMSVcMCStateHead));
		
	for (u8 byLoop = 0; byLoop < (MAXNUM_MCU_MC + MAXNUM_MCU_VC); byLoop++)
	{
		if (m_atMcTable[byLoop].m_bConnected)
		{
			ptMCStateHead->m_abyValid[byLoop] = 1;
			memcpy(pbyMCDataBuf, (s8*)(&m_atMcTable[byLoop]), sizeof(TMcData));
			pbyMCDataBuf += sizeof(TMcData);
			
			byMCNum += 1;
		}
		else
		{
			ptMCStateHead->m_abyValid[byLoop] = 0;
		}
	}
	
	dwOutBufLen = sizeof(TMSVcMCStateHead) + byMCNum*sizeof(TMcData);
	
	return TRUE;
}

/*=============================================================================
    函 数 名： SetVcDeamonMCData
    功    能： 主备数据倒换时 恢复 会议应用的公用数据区的会控信息表 信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetVcDeamonMCData( u8 *pbyBuf, u32 dwInBufLen )
{
	if (NULL == pbyBuf || dwInBufLen < sizeof(TMSVcMCStateHead))
	{
		return FALSE;
	}
	
	BOOL32 bRet = TRUE;
	TMSVcMCStateHead *ptMCStateHead = (TMSVcMCStateHead*)pbyBuf;
	TMcData *ptMCData = (TMcData *)(pbyBuf+sizeof(TMSVcMCStateHead));

	//MTADP/Mp/外设 EqpID 由MCU指定，对应InstID唯一，所以可采用InstID唯一标识，进行连接状态校验；
	//会控 无EqpID等ID值指定，对应InstID也不唯一，由会控的提供连接随机值dwMcsSSRC唯一标识，组成TMcsRegInfo进行连接状态校验；
	
	for (u8 byLoop = 0; byLoop < MAXNUM_MCU_MC + MAXNUM_MCU_VC; byLoop++)
	{
		if (1 != ptMCStateHead->m_abyValid[byLoop])
		{
			continue;
		}
		u8 byLocalPos = 0;
		for (byLocalPos = 0; byLocalPos < (MAXNUM_MCU_MC + MAXNUM_MCU_VC); byLocalPos++)
		{
			if (m_atMcTable[byLocalPos].m_bConnected && ptMCData->m_bConnected && 
				m_atMcTable[byLocalPos].m_tMcsRegInfo == ptMCData->m_tMcsRegInfo)
			{
				break;
			}
		}
		if ((MAXNUM_MCU_MC + MAXNUM_MCU_VC) == byLocalPos)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_NPLUS, "McsInstId.%d McsRegInfo no match with LocalMC's: Connected.%d RemoteMcsIp.0x%0x McsSSRC.0x%0x\n", 
					  (byLoop+1), ptMCData->m_bConnected, 
					  ptMCData->m_tMcsRegInfo.GetMcsIpAddr(), ptMCData->m_tMcsRegInfo.GetMcsSSRC());
			bRet = FALSE;
		}
		else
		{
            //MC的连接状态在物理上认为是主备独立，不进行倒换 2006-10-11
            BOOL32 bConnected = m_atMcTable[byLocalPos].m_bConnected;
			memcpy((s8*)(&m_atMcTable[byLocalPos]), (s8*)ptMCData, sizeof(TMcData));
            m_atMcTable[byLocalPos].m_bConnected = bConnected;
		}
		ptMCData += 1;
	}
	
	return bRet;
}

/*=============================================================================
    函 数 名： GetVcDeamonMpData
    功    能： 主备数据倒换时 获取 会议应用的公用数据区的MP信息表 信息
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
			   [OUT]     u32 &dwOutBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetVcDeamonMpData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen )
{
	if (NULL == pbyBuf || dwInBufLen < (sizeof(TMSVcMpState)+sizeof(m_atMpData)))
	{
		return FALSE;
	}
	
	TMSVcMpState *ptMpState = (TMSVcMpState*)pbyBuf;
	u8 *pbyMpDataBuf = pbyBuf+sizeof(TMSVcMpState);
	u8  byMpNum = 0;
	memset(pbyBuf, 0, sizeof(TMSVcMpState));
		
	for (u8 byLoop = 0; byLoop < MAXNUM_DRI; byLoop++)
	{
		if (m_atMpData[byLoop].m_bConnected)
		{
			ptMpState->m_abyOnline[byLoop] = 1;
			memcpy(pbyMpDataBuf, (s8*)(&m_atMpData[byLoop]), sizeof(TMpData));
			pbyMpDataBuf += sizeof(TMpData);
			
			byMpNum += 1;
		}
		else
		{
			ptMpState->m_abyOnline[byLoop] = 0;
		}
	}
	
	dwOutBufLen = sizeof(TMSVcMpState) + byMpNum*sizeof(TMpData);
	
	return TRUE;
}

/*=============================================================================
    函 数 名： SetVcDeamonMpData
    功    能： 主备数据倒换时 恢复 会议应用的公用数据区的MP信息表 信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetVcDeamonMpData( u8 *pbyBuf, u32 dwInBufLen )
{
	if (NULL == pbyBuf || dwInBufLen < sizeof(TMSVcMpState))
	{
		return FALSE;
	}
	
	TMSVcMpState *ptMpState = (TMSVcMpState*)pbyBuf;
	u8 *pbyMpDataBuf = pbyBuf+sizeof(TMSVcMpState);
	
	//zbq[06/05/2008] 连接状态主备独立修正
	for (u8 byLoop = 0; byLoop < MAXNUM_DRI; byLoop++)
	{
		if (1 == ptMpState->m_abyOnline[byLoop])
		{ 
            //MP的连接状态在物理上认为是主备独立，不进行倒换 2006-10-11
            BOOL32 bConnected = m_atMpData[byLoop].m_bConnected;
			memcpy((s8*)(&m_atMpData[byLoop]), pbyMpDataBuf, sizeof(TMpData)); 
            m_atMpData[byLoop].m_bConnected = bConnected;

			pbyMpDataBuf += sizeof(TMpData);	
		}
		else
		{
			//memset((s8*)(&m_atMpData[byLoop]), 0, sizeof(TMpData));
		}
	}

	return TRUE;
}

/*=============================================================================
    函 数 名： GetVcDeamonMtadpData
    功    能： 主备数据倒换时 获取 会议应用的公用数据区的MTADP信息表 信息
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
			   [OUT]     u32 &dwOutBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetVcDeamonMtadpData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen )
{
	if (NULL == pbyBuf || dwInBufLen < (sizeof(TMSVcMtAdpState)+sizeof(m_atMtAdpData)))
	{
		return FALSE;
	}
	
	TMSVcMtAdpState *ptMtadpState = (TMSVcMtAdpState*)pbyBuf;
	u8 *pbyMtadpDataBuf = pbyBuf+sizeof(TMSVcMtAdpState);
	u8  byMtadpNum = 0;
	memset(pbyBuf, 0, sizeof(TMSVcMtAdpState));
		
	for (u8 byLoop = 0; byLoop < MAXNUM_DRI; byLoop++)
	{
		if (m_atMtAdpData[byLoop].m_bConnected)
		{
			ptMtadpState->m_abyOnline[byLoop] = 1;
			memcpy(pbyMtadpDataBuf, (s8*)(&m_atMtAdpData[byLoop]), sizeof(TMtAdpData));
			pbyMtadpDataBuf += sizeof(TMtAdpData);
			
			byMtadpNum += 1;
		}
		else
		{
			ptMtadpState->m_abyOnline[byLoop] = 0;
		}
	}
	
	dwOutBufLen = sizeof(TMSVcMtAdpState) + byMtadpNum*sizeof(TMtAdpData);
	
	return TRUE;
}

/*=============================================================================
    函 数 名： SetVcDeamonMtadpData
    功    能： 主备数据倒换时 恢复 会议应用的公用数据区的MTADP信息表 信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetVcDeamonMtadpData( u8 *pbyBuf, u32 dwInBufLen )
{
	if (NULL == pbyBuf || dwInBufLen < sizeof(TMSVcMtAdpState))
	{
		return FALSE;
	}
	
	TMSVcMtAdpState *ptMtadpState = (TMSVcMtAdpState*)pbyBuf;
	u8 *pbyMtadpDataBuf = pbyBuf+sizeof(TMSVcMtAdpState);
	
	//zbq[06/05/2008] 连接状态主备独立修正
	for (u8 byLoop = 0; byLoop < MAXNUM_DRI; byLoop++)
	{
		if (1 == ptMtadpState->m_abyOnline[byLoop])
		{ 
            //MtAdp的连接状态在物理上认为是主备独立，不进行倒换 2006-10-11
            BOOL32 bConnected = m_atMtAdpData[byLoop].m_bConnected;
			memcpy((s8*)(&m_atMtAdpData[byLoop]), pbyMtadpDataBuf, sizeof(TMtAdpData));
            m_atMtAdpData[byLoop].m_bConnected = bConnected;

			pbyMtadpDataBuf += sizeof(TMtAdpData);	
		}
		else
		{
			//memset((s8*)(&m_atMtAdpData[byLoop]), 0, sizeof(TMtAdpData));
		}
	}

	return TRUE;
}

/*=============================================================================
    函 数 名： GetVcDeamonTemplateData
    功    能： 主备数据倒换时 获取 会议应用的公用数据区的模板信息表 信息
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
			   [OUT]     u32 &dwOutBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetVcDeamonTemplateData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen )
{
	if (NULL == pbyBuf || dwInBufLen < (sizeof(TMSVcTemplateState)+MAXNUM_MCU_TEMPLATE*sizeof(TTemplateInfo)))
	{
		return FALSE;
	}
	
	if (!m_ptTemplateInfo)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetVcDeamonTemplateData] m_ptTemplateInfo is null\n");
		printf("[GetVcDeamonTemplateData] m_ptTemplateInfo is null\n");
		return FALSE;
	}

	TMSVcTemplateState *ptTemplateState = (TMSVcTemplateState*)pbyBuf;
	u8 *pbyTemplateDataBuf = pbyBuf+sizeof(TMSVcTemplateState);
	u8  byTemplateNum = 0;
	memset(pbyBuf, 0, sizeof(TMSVcTemplateState));
	
	for (u8 byLoop = 0; byLoop < MAXNUM_MCU_TEMPLATE; byLoop++)
	{
		if (m_ptTemplateInfo[byLoop].IsEmpty())
		{
			ptTemplateState->m_abyValid[byLoop] = 0;
		}
		else
		{
			ptTemplateState->m_abyValid[byLoop] = 1;
			memcpy(pbyTemplateDataBuf, (s8*)(&m_ptTemplateInfo[byLoop]), sizeof(TTemplateInfo));
			pbyTemplateDataBuf += sizeof(TTemplateInfo);
			
			byTemplateNum += 1;
		}
	}
	
	dwOutBufLen = sizeof(TMSVcTemplateState) + byTemplateNum*sizeof(TTemplateInfo);
	
	return TRUE;
}

/*=============================================================================
    函 数 名： SetVcDeamonTemplateData
    功    能： 主备数据倒换时 恢复 会议应用的公用数据区的模板信息表 信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetVcDeamonTemplateData( u8 *pbyBuf, u32 dwInBufLen )
{
	if (NULL == pbyBuf || dwInBufLen < sizeof(TMSVcTemplateState))
	{
		return FALSE;
	}

	if (!m_ptTemplateInfo)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[SetVcDeamonTemplateData] m_ptTemplateInfo is null\n");
		printf("[SetVcDeamonTemplateData] m_ptTemplateInfo is null\n");
		return FALSE;
	}
	
	TMSVcTemplateState *ptTemplateState = (TMSVcTemplateState*)pbyBuf;
	u8 *ptTemplateData = pbyBuf+sizeof(TMSVcTemplateState);

	
	for (u8 byLoop = 0; byLoop < MAXNUM_MCU_TEMPLATE; byLoop++)
	{
		if (1 == ptTemplateState->m_abyValid[byLoop])
		{
			memcpy((s8*)(&m_ptTemplateInfo[byLoop]), ptTemplateData, sizeof(TTemplateInfo));
			ptTemplateData += sizeof(TTemplateInfo);	
		}
		else
		{
			m_ptTemplateInfo[byLoop].Clear();
		}
	}
	
	return TRUE;
}

/*=============================================================================
    函 数 名： GetVcDeamonOtherData
    功    能： 主备数据倒换时 获取 会议应用的公用数据区的除EQP/MC/MP/MTADP信息表的其他需同步 信息
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
			   [OUT]     u32 &dwOutBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetVcDeamonOtherData( u8 *pbyBuf, u32 &dwOutBufLen )
{
	/*lint -save -e715*/
	dwOutBufLen  = 0;
	u32 dwOutLen = OprVcDeamonOtherData(pbyBuf, TRUE);
	if (0 == dwOutLen)
	{
		return FALSE;
	}
	
	dwOutBufLen = dwOutLen;
	return TRUE;
	/*lint -restore*/
}

/*=============================================================================
    函 数 名： SetVcDeamonOtherData
    功    能： 主备数据倒换时 恢复 会议应用的公用数据区的除EQP/MC/MP/MTADP信息表的其他需同步 信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
    返 回 值： BOOL32 

-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetVcDeamonOtherData( u8 *pbyBuf )
{
	if (0 == OprVcDeamonOtherData(pbyBuf, FALSE))
	{
		return FALSE;
	}
	
	return TRUE;
}

/*=============================================================================
    函 数 名： OprVcDataOtherData
    功    能： 主备数据倒换时 同步 会议应用的公用数据区的除EQP/MC/MP/MTADP信息表的其他需同步 数据
	           由于同步的主从MCU应用环境一致，同步的数据结构暂不考虑紧凑压栈问题：Pack Ingore
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
               [IN]      BOOL32 bGet TRUE －获取 FALSE - 恢复 
    返 回 值： u32  同步的数据总长度
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                 创建
    2006/08/07  4.0         顾振华                 增加同步License数据
=============================================================================*/
u32 CMcuVcData::OprVcDeamonOtherData( u8 *pbyBuf, BOOL32 bGet )
{
	u32 dwOtherDataLen = 0;
	//允许大于---
	if (NULL == pbyBuf /*|| dwInBufLen == 0*/)
	{
		return 0;
	}

	if (bGet)
	{
		
		memcpy(pbyBuf, (s8*)m_atMonitorTable, sizeof(m_atMonitorTable));
		pbyBuf += sizeof(m_atMonitorTable);
		dwOtherDataLen += sizeof(m_atMonitorTable);

		memcpy(pbyBuf, (s8*)m_atRecvMtPort, sizeof(m_atRecvMtPort));
		pbyBuf += sizeof(m_atRecvMtPort);
		dwOtherDataLen += sizeof(m_atRecvMtPort);

//		memcpy(pbyBuf, (s8*)m_atMulticastIp, sizeof(m_atMulticastIp));
//		pbyBuf += sizeof(m_atMulticastIp);
		memcpy(pbyBuf, (s8*)m_atMulticastPort, sizeof(m_atMulticastPort));
		pbyBuf += sizeof(m_atMulticastPort);
		dwOtherDataLen += sizeof(m_atMulticastPort);

		//不需同步这个，防止误操作
		//memcpy(pbyBuf, (s8*)m_abyConfStoreInfo, sizeof(m_abyConfStoreInfo));
		//pbyBuf += sizeof(m_abyConfStoreInfo);
		memcpy(pbyBuf, (s8*)m_abyConfRegState, sizeof(m_abyConfRegState));
		pbyBuf += sizeof(m_abyConfRegState);
		dwOtherDataLen += sizeof(m_abyConfRegState);

		memcpy(pbyBuf, (s8*)&m_byRegGKDriId, sizeof(m_byRegGKDriId));
		pbyBuf += sizeof(m_byRegGKDriId);
		dwOtherDataLen += sizeof(m_byRegGKDriId);

		memcpy(pbyBuf, (s8*)&m_tGKID, sizeof(m_tGKID));
		pbyBuf += sizeof(m_tGKID);
		dwOtherDataLen += sizeof(m_tGKID);

		memcpy(pbyBuf, (s8*)&m_tEPID, sizeof(m_tEPID));
		pbyBuf += sizeof(m_tEPID);
		dwOtherDataLen += sizeof(m_tEPID);

		memcpy(pbyBuf, (s8*)&m_dwMakeConfIdTimes, sizeof(m_dwMakeConfIdTimes));
		pbyBuf += sizeof(m_dwMakeConfIdTimes);
		dwOtherDataLen += sizeof(m_dwMakeConfIdTimes);

		memcpy(pbyBuf, (s8*)&m_tMcuDebugVal, sizeof(m_tMcuDebugVal));
		pbyBuf += sizeof(m_tMcuDebugVal);
		dwOtherDataLen += sizeof(m_tMcuDebugVal);

		memcpy(pbyBuf, (s8*)&m_dwMtCallInterfaceNum, sizeof(m_dwMtCallInterfaceNum));
		pbyBuf += sizeof(m_dwMtCallInterfaceNum);
		dwOtherDataLen += sizeof(m_dwMtCallInterfaceNum);

		memcpy(pbyBuf, (s8*)m_atMtCallInterface, m_dwMtCallInterfaceNum*sizeof(TMtCallInterface));
		pbyBuf += m_dwMtCallInterfaceNum*sizeof(TMtCallInterface);
		dwOtherDataLen += m_dwMtCallInterfaceNum*sizeof(TMtCallInterface);

		memcpy(pbyBuf, (s8*)m_atConfMapData, sizeof(m_atConfMapData));
		pbyBuf += sizeof(m_atConfMapData);
		dwOtherDataLen += sizeof(m_atConfMapData);

        memcpy(pbyBuf, (s8*)m_atPeriDcsTable, sizeof(m_atPeriDcsTable));
        pbyBuf += sizeof(m_atPeriDcsTable);
		dwOtherDataLen += sizeof(m_atPeriDcsTable);

        memcpy(pbyBuf, (s8*)&m_byChargeRegOK, sizeof(m_byChargeRegOK));
        pbyBuf += sizeof(m_byChargeRegOK);
		dwOtherDataLen += sizeof(m_byChargeRegOK);

		u32 dwBasListLen = m_cBasChnListMgr.GetBasListBuf(pbyBuf);
		pbyBuf += dwBasListLen;
		dwOtherDataLen += dwBasListLen;
		
		u16 wTWChnDataLen= GetChnModeData(pbyBuf);
		pbyBuf += wTWChnDataLen;
		dwOtherDataLen += wTWChnDataLen;
		
		u16 wMultiLen = m_cMultiSpyMgr.GetMSMultiSpy(pbyBuf);
		pbyBuf += wMultiLen;
		dwOtherDataLen += wMultiLen;
		
        memcpy(pbyBuf, (s8*)&m_cVmpInfoMgr, sizeof(m_cVmpInfoMgr));
        pbyBuf += sizeof(m_cVmpInfoMgr);
		dwOtherDataLen += sizeof(m_cVmpInfoMgr);

		memcpy(pbyBuf,(u8*)&m_tNplusVmpModule[0],sizeof(m_tNplusVmpModule));
		pbyBuf += sizeof(m_tNplusVmpModule);
		dwOtherDataLen += sizeof(m_tNplusVmpModule);
	}
	else
	{
		memcpy((s8*)m_atMonitorTable, pbyBuf, sizeof(m_atMonitorTable));
		pbyBuf += sizeof(m_atMonitorTable);
		dwOtherDataLen += sizeof(m_atMonitorTable);

		memcpy((s8*)m_atRecvMtPort, pbyBuf, sizeof(m_atRecvMtPort));
		pbyBuf += sizeof(m_atRecvMtPort);
		dwOtherDataLen += sizeof(m_atRecvMtPort);

//		memcpy((s8*)&m_atMulticastIp, pbyBuf, sizeof(m_atMulticastIp));
//		pbyBuf += sizeof(m_atMulticastIp);
		memcpy((s8*)m_atMulticastPort, pbyBuf, sizeof(m_atMulticastPort));
		pbyBuf += sizeof(m_atMulticastPort);
		dwOtherDataLen += sizeof(m_atMulticastPort);

		//不需同步这个，防止误操作
		//memcpy((s8*)m_abyConfStoreInfo, pbyBuf, sizeof(m_abyConfStoreInfo));
		//pbyBuf += sizeof(m_abyConfStoreInfo);
		memcpy((s8*)m_abyConfRegState, pbyBuf, sizeof(m_abyConfRegState));
		pbyBuf += sizeof(m_abyConfRegState);
		dwOtherDataLen += sizeof(m_abyConfRegState);

		memcpy((s8*)&m_byRegGKDriId, pbyBuf, sizeof(m_byRegGKDriId));
		pbyBuf += sizeof(m_byRegGKDriId);
		dwOtherDataLen += sizeof(m_byRegGKDriId);

		memcpy((s8*)&m_tGKID, pbyBuf, sizeof(m_tGKID));
		pbyBuf += sizeof(m_tGKID);
		dwOtherDataLen += sizeof(m_tGKID);
		
		memcpy((s8*)&m_tEPID, pbyBuf, sizeof(m_tEPID));
		pbyBuf += sizeof(m_tEPID);
		dwOtherDataLen += sizeof(m_tEPID);
		
		memcpy((s8*)&m_dwMakeConfIdTimes, pbyBuf, sizeof(m_dwMakeConfIdTimes));
		pbyBuf += sizeof(m_dwMakeConfIdTimes);   
		dwOtherDataLen += sizeof(m_dwMakeConfIdTimes);   
		
		memcpy((s8*)&m_tMcuDebugVal, pbyBuf, sizeof(m_tMcuDebugVal));
		pbyBuf += sizeof(m_tMcuDebugVal);
		dwOtherDataLen += sizeof(m_tMcuDebugVal);
        
		memcpy((s8*)&m_dwMtCallInterfaceNum, pbyBuf, sizeof(m_dwMtCallInterfaceNum));
		pbyBuf += sizeof(m_dwMtCallInterfaceNum);
		dwOtherDataLen += sizeof(m_dwMtCallInterfaceNum);
		
		memcpy((s8*)m_atMtCallInterface, pbyBuf, m_dwMtCallInterfaceNum*sizeof(TMtCallInterface));
		pbyBuf += m_dwMtCallInterfaceNum*sizeof(TMtCallInterface);
		dwOtherDataLen += m_dwMtCallInterfaceNum*sizeof(TMtCallInterface);
		
		memcpy((s8*)m_atConfMapData, pbyBuf, sizeof(m_atConfMapData));
		pbyBuf += sizeof(m_atConfMapData);
		dwOtherDataLen += sizeof(m_atConfMapData);
		
		//zbq[06/05/2008] 连接状态主备独立修正
		/*
        //DCS的连接状态在物理上认为是主备独立，不进行倒换 2006-10-11
        u8 byIndex = 0;
        u8 abyDcsOnline[MAXNUM_MCU_DCS] = { 0 }; 
        for( ; byIndex < MAXNUM_MCU_DCS; byIndex ++ )
        {
		abyDcsOnline[byIndex] = m_atPeriDcsTable[byIndex].m_tDcsStatus.m_byOnline;
        }
        memcpy((s8*)&m_atPeriDcsTable, pbyBuf, sizeof(m_atPeriDcsTable));
        for( byIndex = 0; byIndex < MAXNUM_MCU_DCS; byIndex ++ )
        {
		m_atPeriDcsTable[byIndex].m_tDcsStatus.m_byOnline = abyDcsOnline[byIndex];
        }
		*/
        pbyBuf += sizeof(m_atPeriDcsTable);
		dwOtherDataLen += sizeof(m_atPeriDcsTable);
		
        memcpy((s8*)&m_byChargeRegOK, pbyBuf, sizeof(m_byChargeRegOK));
        pbyBuf += sizeof(m_byChargeRegOK);
		dwOtherDataLen += sizeof(m_byChargeRegOK);
		
		u32 dwBasListLen = m_cBasChnListMgr.SetBasListBuf(pbyBuf);
		pbyBuf += dwBasListLen;
		dwOtherDataLen += dwBasListLen;
		
		u16 wTWChnDataLen = SetChnModeData(pbyBuf);
		pbyBuf += wTWChnDataLen;
		dwOtherDataLen += wTWChnDataLen;
		
		u16 wMultiLen = m_cMultiSpyMgr.SetMSMultiSpy(pbyBuf);
		pbyBuf += wMultiLen;
		dwOtherDataLen += wMultiLen;

        memcpy((s8*)&m_cVmpInfoMgr, pbyBuf, sizeof(m_cVmpInfoMgr));
        pbyBuf += sizeof(m_cVmpInfoMgr);
		dwOtherDataLen += sizeof(m_cVmpInfoMgr);

		memcpy((u8*)&m_tNplusVmpModule[0],pbyBuf,sizeof(m_tNplusVmpModule));
		pbyBuf += sizeof(m_tNplusVmpModule);
		dwOtherDataLen += sizeof(m_tNplusVmpModule);
	}
	
	return dwOtherDataLen;
}

/*=============================================================================
    函 数 名： GetVcDeamonOtherDataLen
    功    能： 主备数据倒换时 获取 会议应用的公用数据区的除EQP/MC/MP/MTADP信息表的其他需同步 数据总长度
	           由于同步的主从MCU应用环境一致，同步的数据结构暂不考虑紧凑压栈问题：Pack Ingore
    算法实现： 
    全局变量： 
    参    数： void
    返 回 值： u32  数据总长度
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                 创建
    2006/08/07  4.0         顾振华                 增加同步License数据
=============================================================================*/
// u32 CMcuVcData::GetVcDeamonOtherDataLen( void )
// {
// 	u32 dwOtherDataLen = 0;
// 	
// 	//12
// 	dwOtherDataLen += sizeof(m_atRecvMtPort);
// //	dwOtherDataLen += sizeof(m_atMulticastIp);
// 	dwOtherDataLen += sizeof(m_atMulticastPort);
// 	//dwOtherDataLen += sizeof(m_abyConfStoreInfo);
// 	dwOtherDataLen += sizeof(m_abyConfRegState);
// 	dwOtherDataLen += sizeof(m_byRegGKDriId);
// 	dwOtherDataLen += sizeof(m_tGKID);
// 	dwOtherDataLen += sizeof(m_tEPID);
// 	dwOtherDataLen += sizeof(m_dwMakeConfIdTimes);
// 	dwOtherDataLen += sizeof(m_tMcuDebugVal);
// 	dwOtherDataLen += sizeof(m_dwMtCallInterfaceNum);
// 	dwOtherDataLen += m_dwMtCallInterfaceNum*sizeof(TMtCallInterface);
// 	dwOtherDataLen += sizeof(m_atConfMapData);
//     dwOtherDataLen += sizeof(m_atPeriDcsTable);
//     dwOtherDataLen += sizeof(m_byChargeRegOK);
// 	
// 	return dwOtherDataLen;
// }

/*=============================================================================
    函 数 名： HangupAllVcInstTimer
    功    能： 主备数据倒换时 暂停 所有会议实例 轮循、预约会议等会议定时器（非STATE_IDLE实例）
    算法实现： 
    全局变量： 
    参    数： void
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::HangupAllVcInstTimer( void )
{
	BOOL32 bRet = TRUE;
	
	CMcuVcInst* pcVcInst = NULL;
	for (u8 byInstID = 1; byInstID <= MAXNUM_MCU_CONF; byInstID++)
	{
		pcVcInst = m_apConfInst[byInstID-1];
		if (NULL != pcVcInst)
		{
			if (FALSE == pcVcInst->HangupInstTimer())
			{
				bRet = FALSE;
			}
		}	
	}
	
	return bRet;
}

/*=============================================================================
    函 数 名： ResumeAllVcInstTimer
    功    能： 主备数据倒换时 恢复 所有会议实例 轮循、预约会议等会议定时器（非STATE_IDLE实例）
    算法实现： 
    全局变量： 
    参    数： void
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::ResumeAllVcInstTimer( void )
{
	BOOL32 bRet = TRUE;
	
	CMcuVcInst* pcVcInst = NULL;
	for (u8 byInstID = 1; byInstID <= MAXNUM_MCU_CONF; byInstID++)
	{
		pcVcInst = m_apConfInst[byInstID-1];
		if (NULL != pcVcInst)
		{
			if (FALSE == pcVcInst->ResumeInstTimer())
			{
				bRet = FALSE;
			}
		}	
	}
	
	return bRet;
}

/*=============================================================================
    函 数 名： GetAllVcInstState
    功    能： 主备数据倒换时 获取 所有会议实例 状态机 状态
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  TMSVcInstState &tVcInstState 状态数据
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetAllVcInstState( TMSVcInstState &tVcInstState )
{
	BOOL32 bRet = TRUE;
	
	u8 byState  = 0;
	u8  byconfIdx = 0;
	CConfId cConfId;
	CApp* pcApp = &g_cMcuVcApp;
	CMcuVcInst* pcVcInst = NULL;
	for (u8 byInstID = 1; byInstID <= MAXNUM_MCU_CONF; byInstID++)
	{
		byconfIdx = 0;
		cConfId.SetNull();
		pcVcInst = (CMcuVcInst*)pcApp->GetInstance(byInstID);
		if (NULL != pcVcInst)
		{
			pcVcInst->GetInstStateAndConfIdIdx(byState,cConfId,byconfIdx);
		}
		else
		{
			byState = 0;
			bRet = FALSE;
		}
		tVcInstState.m_abyState[byInstID-1] = byState;
		tVcInstState.m_abyConfIdx[byInstID-1] = byconfIdx;
		tVcInstState.m_acConfId[byInstID -1 ]= cConfId;
	}
	
	return bRet;
}

/*=============================================================================
    函 数 名： SetAllVcInstState
    功    能： 主备数据倒换时 恢复 所有会议实例 状态机 状态
	           同时同步公用区数据
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  TMSVcInstState &tVcInstState 状态数据
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetAllVcInstState( TMSVcInstState &tVcInstState )
{
	BOOL32 bRet = TRUE;

	CApp* pcApp = &g_cMcuVcApp;
	CMcuVcInst* pcVcInst = NULL;

	memset(m_apConfInst, 0, sizeof(m_apConfInst));

	for (u8 byInstID = 1; byInstID <= MAXNUM_MCU_CONF; byInstID++)
	{
		pcVcInst = (CMcuVcInst*)pcApp->GetInstance(byInstID);
		if (NULL != pcVcInst)
		{
			//直接把confidx先备份过去，如果会议备一半重启了，备板也能根据这个confidx将会议结束
			pcVcInst->SetInstStateAndConfIdIdx(tVcInstState.m_abyState[byInstID-1],tVcInstState.m_acConfId[byInstID - 1],tVcInstState.m_abyConfIdx[byInstID -1 ]);
			
		}
		else
		{
			bRet = FALSE;
		}
	}

	RefreshHtml();
	
	return bRet;
}

/*=============================================================================
    函 数 名： FindNextConfInstIDOfNotIdle
    功    能： 根据上一个会议实例ID 查询大于此ID的下一个非空闲会议实例ID
    算法实现： 
    全局变量： 
    参    数： [IN] u8  byPreInstID  －Preview No-Idle-Inst ID
    返 回 值： u8 - Next No-Idle-Inst ID  [1, MAXNUM_MCU_CONF]  0－Not Find
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
u8 CMcuVcData::FindNextConfInstIDOfNotIdle( u8 byPreInstID )
{
	u8 byNextInstID = 0;
	u8 byState = 0;
	CMcuVcInst* pcVcInst = NULL;
	
	for (u8 byInstID = (byPreInstID+1); byInstID < MAXNUM_MCU_CONF; byInstID++)
	{	
		pcVcInst = m_apConfInst[byInstID-1];
		if (NULL != pcVcInst)
		{
			u8 byConfIdx = 0;
			CConfId cConfId;
			pcVcInst->GetInstStateAndConfIdIdx(byState,cConfId,byConfIdx);
			if( 0 != byState && !cConfId.IsNull() )
			{
				byNextInstID = byInstID;
				break;
			}
		}
		
	}
	
	return byNextInstID;
}


/*=============================================================================
函 数 名： GetTakeModeOfInstId
功    能： 根据会议实例ID 查询会议的召开模式
算法实现： 
全局变量： 
参    数： 
返 回 值：
-----------------------------------------------------------------------------
修改记录：
日  期		版本		修改人		走读人    修改内容
2007/04/18  4.0			顾振华                  创建
=============================================================================*/
u8 CMcuVcData::GetTakeModeOfInstId( u8 byInstId )
{
    CMcuVcInst* pcVcInst = NULL;
    
    if ( byInstId == 0 || byInstId >= MAXNUM_MCU_CONF )
    {
        return 0;   // 返回0误认为是Schedule没有关系
    }
    
    pcVcInst = m_apConfInst[byInstId-1];
    if (NULL != pcVcInst)
    {
        return pcVcInst->m_tConf.m_tStatus.GetTakeMode();
    }
    else
    {
        return 0;
    }
}

/*=============================================================================
    函 数 名： GetOneVcInstConfMtTableData
    功    能： 主备数据倒换时 获取 指定实例的 会议终端表 信息
    算法实现： 
    全局变量： 
    参    数： [IN]      u8  byInstID
               [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
               [OUT]     u32 &dwOutBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetOneVcInstConfMtTableData( u8 byInstID, u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen )
{
	if (0 == byInstID || byInstID > MAXNUM_MCU_CONF)
	{
		return FALSE;
	}
	
	CMcuVcInst* pcVcInst = m_apConfInst[byInstID-1];
	if (NULL == pcVcInst)
	{
		return FALSE;
	}
	
	return pcVcInst->GetConfMtTableData(pbyBuf, dwInBufLen, dwOutBufLen);
}

/*=============================================================================
    函 数 名： SetOneVcInstConfMtTableData
    功    能： 主备数据倒换时 恢复 指定实例的 会议终端表 信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8  byInstID
               [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetOneVcInstConfMtTableData( u8 byInstID, u8 *pbyBuf, u32 dwInBufLen )
{
	if (0 == byInstID || byInstID > MAXNUM_MCU_CONF)
	{
		return FALSE;
	}
	
	CMcuVcInst* pcVcInst = m_apConfInst[byInstID-1];
	if (NULL == pcVcInst)
	{
		return FALSE;
	}
	
	return pcVcInst->SetConfMtTableData(pbyBuf, dwInBufLen);
}

/*=============================================================================
    函 数 名： GetOneVcInstConfSwitchTableData
    功    能： 主备数据倒换时 获取 指定实例的 会议交换表 信息
    算法实现： 
    全局变量： 
    参    数： [IN]      u8  byInstID
               [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
               [OUT]     u32 &dwOutBufLen
    返 回 值： BOOL32 
	-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetOneVcInstConfSwitchTableData( u8 byInstID, u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen )
{
	if (0 == byInstID || byInstID > MAXNUM_MCU_CONF)
	{
		return FALSE;
	}
	
	CMcuVcInst* pcVcInst = m_apConfInst[byInstID-1];
	if (NULL == pcVcInst)
	{
		return FALSE;
	}
	
	return pcVcInst->GetConfSwitchTableData(pbyBuf, dwInBufLen, dwOutBufLen);
}

/*=============================================================================
    函 数 名： SetOneVcInstConfSwitchTableData
    功    能： 主备数据倒换时 恢复 指定实例的 会议交换表 信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8  byInstID
               [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
    返 回 值： BOOL32 
	-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetOneVcInstConfSwitchTableData( u8 byInstID, u8 *pbyBuf, u32 dwInBufLen )
{
	if (0 == byInstID || byInstID > MAXNUM_MCU_CONF)
	{
		return FALSE;
	}
	
	CMcuVcInst* pcVcInst = m_apConfInst[byInstID-1];
	if (NULL == pcVcInst)
	{
		return FALSE;
	}
	
	return pcVcInst->SetConfSwitchTableData(pbyBuf, dwInBufLen);
}

/*=============================================================================
    函 数 名： GetOneVcInstConfOtherMcTableData
    功    能： 主备数据倒换时 获取 指定实例的 其它Mc终端列表 信息
    算法实现： 
    全局变量： 
    参    数： [IN]      u8  byInstID
               [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
               [OUT]     u32 &dwOutBufLen
    返 回 值： BOOL32 
	-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetOneVcInstConfOtherMcTableData( u8 byInstID, u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen )
{
	if (0 == byInstID || byInstID > MAXNUM_MCU_CONF)
	{
		return FALSE;
	}
	
	CMcuVcInst* pcVcInst = m_apConfInst[byInstID-1];
	if (NULL == pcVcInst)
	{
		return FALSE;
	}
	
	return pcVcInst->GetConfOtherMcTableData(pbyBuf, dwInBufLen, dwOutBufLen);
}

/*=============================================================================
    函 数 名： SetOneVcInstConfOtherMcTableData
    功    能： 主备数据倒换时 恢复 指定实例的 其它Mc终端列表 信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8  byInstID
               [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
    返 回 值： BOOL32 
	-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetOneVcInstConfOtherMcTableData( u8 byInstID, u8 *pbyBuf, u32 dwInBufLen )
{
	if (0 == byInstID || byInstID > MAXNUM_MCU_CONF)
	{
		return FALSE;
	}
	
	CMcuVcInst* pcVcInst = m_apConfInst[byInstID-1];
	if (NULL == pcVcInst)
	{
		return FALSE;
	}
	
	return pcVcInst->SetConfOtherMcTableData(pbyBuf, dwInBufLen);
}

/*=============================================================================
    函 数 名： GetOneVcInstOtherData
    功    能： 主备数据倒换时 获取 指定实例的 除上述动态分配的列表信息外的其他需同步 信息
    算法实现： 
    全局变量： 
    参    数： [IN]      u8  byInstID
               [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
			   [OUT]     u32 &dwOutBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetOneVcInstOtherData( u8 byInstID, u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen )
{
	if (0 == byInstID || byInstID > MAXNUM_MCU_CONF)
	{
		return FALSE;
	}
	
	CMcuVcInst* pcVcInst = m_apConfInst[byInstID-1];
	if (NULL == pcVcInst)
	{
		return FALSE;
	}
	
	return pcVcInst->GetInstOtherData(pbyBuf, dwInBufLen, dwOutBufLen);
}

/*=============================================================================
    函 数 名： SetOneVcInstOtherData
    功    能： 主备数据倒换时 恢复 指定实例的 除上述动态分配的列表信息外的其他需同步 信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8  byInstID
               [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
               [IN]  BOOL32 bResumeTimer
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetOneVcInstOtherData( u8 byInstID, u8 *pbyBuf, u32 dwInBufLen, BOOL32 bResumeTimer )
{
	if (0 == byInstID || byInstID > MAXNUM_MCU_CONF)
	{
		return FALSE;
	}

	CMcuVcInst* pcVcInst = m_apConfInst[byInstID-1];
	if (NULL == pcVcInst)
	{
		StaticLog("pcVcInst is null ,byInstID:%d\n",byInstID);
		return FALSE;
	}

	return pcVcInst->SetInstOtherData(pbyBuf, dwInBufLen, bResumeTimer);
}

/*=============================================================================
    函 数 名： GetCfgFileData
    功    能： 主备数据倒换时 获取 mcu/conf下的 mcucfg.ini 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
               [OUT] u32 &dwOutBufLen
	           [IN]  BOOL32 bPrintErr 是否打印失败信息
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetCfgFileData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen, BOOL32 bPrintErr )
{
	if (NULL == pbyBuf)
	{
		if (bPrintErr)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetCfgFileData] NULL == pbyBuf\n");
		}
		return FALSE;
	}
	
	s8  achFullName[64];
	sprintf(achFullName, "%s/%s", DIR_CONFIG, MCUCFGFILENAME);
	
	FILE *hFile  = fopen(achFullName, "rb");
	s32 nFileLen = 0;
	if (NULL != hFile)
	{
		fseek(hFile, 0, SEEK_END);
		nFileLen = ftell(hFile);
		if (nFileLen > (s32)dwInBufLen)
		{
			if (bPrintErr)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetCfgFileData] mcucfg.ini FileLen(%d)>%d\n", nFileLen, dwInBufLen);			
			}
			fclose(hFile);
			hFile = NULL;
			return FALSE;
		}
		if (nFileLen > 0)
		{
			fseek(hFile, 0, SEEK_SET);
			fread(pbyBuf, nFileLen, 1, hFile);
		}
		fclose(hFile);

		/*lint -save -e438*/
		hFile = NULL;

	}else
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetCfgFileData] open mcucfg.ini failed\n");			
	}
	
	//允许文件长度为0，文件存在则同步清空该文件
	dwOutBufLen = (u32)nFileLen;

	return TRUE;

	/*lint -restore*/
}

/*=============================================================================
    函 数 名： SetCfgFileData
    功    能： 主备数据倒换时 恢复 mcu/conf下的 mcucfg.ini 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
	           [IN]  BOOL32 bPrintErr 是否打印失败信息
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetCfgFileData( u8 *pbyBuf, u32 dwInBufLen, BOOL32 bPrintErr )
{
	// 禁止对error 438: (Warning -- Last value assigned to variable 'hFile' 
	/*lint -save -e438*/
	
	BOOL32 bRet = FALSE;
	
	//允许文件长度为0，文件存在则同步清空该文件
	if (NULL == pbyBuf && dwInBufLen > 0)
	{
		if (bPrintErr)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetCfgFileData] NULL == pbyBuf || InBufLen(%d) == 0\n", dwInBufLen);
		}
		return bRet;
	}
	
	s8  achFullName[64];
	sprintf(achFullName, "%s/%s", DIR_CONFIG, MCUCFGFILENAME);

	LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CFG, "SetCfgFileData(pbyBuf.%u, dwInBufLen.%u, bPrintErr.%d)\n", 
		NULL != pbyBuf ? pbyBuf : 0,
		dwInBufLen,
		bPrintErr);
	
	BOOL32 bReWrite = TRUE;
	if (0 == dwInBufLen)
	{
		FILE *hFile = fopen(achFullName, "rb");
		if (NULL != hFile)
		{
			fclose(hFile);
			hFile = NULL;
		}
		else
		{
			bReWrite = FALSE;
			bRet = TRUE;
		}
	}
	if (bReWrite)
	{
		FILE *hFile = fopen(achFullName, "wb");
		if (NULL != hFile)
		{
			if ( pbyBuf && 0 != dwInBufLen)
			{
				fwrite(pbyBuf, 1, dwInBufLen, hFile);
#ifdef WIN32    //VX下不作多余的 fflush 操作
				fflush(hFile);
#endif
			}
			fclose(hFile);
			hFile = NULL;
			bRet = TRUE;
		}
		else
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetCfgFileData] save mcucfg.ini failed\n");
		}
	}
	
	return bRet;
	
	// 恢复对e438的检查
	/*lint -restore*/
}

/*=============================================================================
    函 数 名： GetDebugFileData
    功    能： 主备数据倒换时 获取 mcu/conf下的 mcudebug.ini 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
               [OUT] u32 &dwOutBufLen
	           [IN]  BOOL32 bPrintErr 是否打印失败信息
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetDebugFileData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen, BOOL32 bPrintErr )
{
	// 禁止对error 438: (Warning -- Last value assigned to variable 'hFile' 
	/*lint -save -e438*/

	if (NULL == pbyBuf)
	{
		if (bPrintErr)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetDebugFileData] NULL == pbyBuf\n");
		}
		return FALSE;
	}
	
	s8  achFullName[64];
	sprintf(achFullName, "%s/%s", DIR_CONFIG, MCUDEBUGFILENAME);
	
	FILE *hFile  = fopen(achFullName, "rb");
	s32 nFileLen = 0;
	if (NULL != hFile)
	{
		fseek(hFile, 0, SEEK_END);
		nFileLen = ftell(hFile);
		if (nFileLen > (s32)dwInBufLen)
		{
			if (bPrintErr)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetDebugFileData] mcudebug.ini FileLen(%d)>%d\n", nFileLen, dwInBufLen);			
			}
			fclose(hFile) ; //防止文件未关闭  [pengguofeng 9/10/2013]
			return FALSE;
		}
		if (nFileLen > 0)
		{
			fseek(hFile, 0, SEEK_SET);
			fread(pbyBuf, nFileLen, 1, hFile);
		}
		fclose(hFile);
		hFile = NULL;
	}
	
	//允许文件长度为0，文件存在则同步清空该文件
	dwOutBufLen = (u32)nFileLen;

	return TRUE;

	// 恢复对e438的检查
	/*lint -restore*/
}

/*=============================================================================
    函 数 名： SetDebugFileData
    功    能： 主备数据倒换时 恢复 mcu/conf下的 mcudebug.ini 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
	           [IN]  BOOL32 bPrintErr 是否打印失败信息
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetDebugFileData( u8 *pbyBuf, u32 dwInBufLen, BOOL32 bPrintErr )
{
	// 禁止对error 438: (Warning -- Last value assigned to variable 'hFile' 
	/*lint -save -e438*/


	BOOL32 bRet = FALSE;
	
	//允许文件长度为0，文件存在则同步清空该文件
	if (NULL == pbyBuf && dwInBufLen > 0)
	{
		if (bPrintErr)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetDebugFileData] NULL == pbyBuf || InBufLen(%d) == 0\n", dwInBufLen);
		}
		return bRet;
	}
	
	s8  achFullName[64];
	sprintf(achFullName, "%s/%s", DIR_CONFIG, MCUDEBUGFILENAME);
	
	BOOL32 bReWrite = TRUE;
	if (0 == dwInBufLen)
	{
		FILE *hFile = fopen(achFullName, "rb");
		if (NULL != hFile)
		{
			fclose(hFile);
			hFile = NULL;
		}
		else
		{
			bReWrite = FALSE;
			bRet = TRUE;
		}
	}
	if (bReWrite)
	{
		FILE *hFile = fopen(achFullName, "wb");
		if (NULL != hFile)
		{
			if (pbyBuf && 0 != dwInBufLen)
			{
				fwrite(pbyBuf, 1, dwInBufLen, hFile);
#ifdef WIN32    //VX下不作多余的 fflush 操作
				fflush(hFile);
#endif
			}
			fclose(hFile);
			hFile = NULL;
			bRet = TRUE;
		}
		else
		{
			if (bPrintErr)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetDebugFileData] save mcudebug.ini failed\n");
			}
		}
	}

	return bRet;

	// 恢复pclint对e438的检查
	/*lint -restore*/
}

/*=============================================================================
    函 数 名： GetAddrbookFileDataUtf8
    功    能： 主备数据倒换时 获取 mcu/conf下的 kdvaddrbook.kdv 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
               [OUT] u32 &dwOutBufLen
	           [IN]  BOOL32 bPrintErr 是否打印失败信息
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2013/07/31  4.7			liaokang                创建
=============================================================================*/
BOOL32 CMcuVcData::GetAddrbookFileDataUtf8( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen, BOOL32 bPrintErr )
{
	// 禁止对error 438: (Warning -- Last value assigned to variable 'hFile' 
	/*lint -save -e438*/

	if (NULL == pbyBuf)
	{
		if (bPrintErr)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetAddrbookFileDataUtf8] NULL == pbyBuf\n");
		}
		return FALSE;
	}
	
	s8  achFullName[64];
	sprintf(achFullName, "%s/%s", DIR_DATA, MCUADDRFILENAME_UTF8);
	
	FILE *hFile  = fopen(achFullName, "rb");
	s32 nFileLen = 0;
	if (NULL != hFile)
	{
		fseek(hFile, 0, SEEK_END);
		nFileLen = ftell(hFile);
		if (nFileLen > (s32)dwInBufLen)
		{
			if (bPrintErr)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetAddrbookFileDataUtf8] kdvaddrbook.kdv FileLen(%d)>%d\n", nFileLen, dwInBufLen);			
			}
			fclose(hFile); //防止文件未关闭  [pengguofeng 9/10/2013]
			return FALSE;
		}
		if (nFileLen > 0)
		{
			fseek(hFile, 0, SEEK_SET);
			fread(pbyBuf, nFileLen, 1, hFile);
		}
		fclose(hFile);
		hFile = NULL;
	}
	
	//允许文件长度为0，文件存在则同步清空该文件
	dwOutBufLen = (u32)nFileLen;

	return TRUE;

	
	// 恢复pclint对e438的检查
	/*lint -restore*/
}

/*=============================================================================
    函 数 名： GetAddrbookFileData
    功    能： 主备数据倒换时 获取 mcu/conf下的 addrbook.kdv 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
               [OUT] u32 &dwOutBufLen
	           [IN]  BOOL32 bPrintErr 是否打印失败信息
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetAddrbookFileData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen, BOOL32 bPrintErr )
{
    // 禁止对error 438: (Warning -- Last value assigned to variable 'hFile' 
    /*lint -save -e438*/
    
    if (NULL == pbyBuf)
    {
        if (bPrintErr)
        {
            LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetAddrbookFileData] NULL == pbyBuf\n");
        }
        return FALSE;
    }
    
    s8  achFullName[64];
    memset(achFullName, 0, sizeof(achFullName));
    // 存在kdvaddrbook.kdv则不同步addrbook.kdv [7/31/2013 liaokang]
    sprintf(achFullName, "%s/%s", DIR_DATA, MCUADDRFILENAME_UTF8);
    FILE *hFile  = fopen(achFullName, "rb");
    s32 nFileLen = 0;
    if (NULL != hFile)
    {
        dwOutBufLen = (u32)nFileLen;
		//防止文件未关闭  [pengguofeng 9/10/2013]
		fclose(hFile);
        return TRUE;
    }

    memset(achFullName, 0, sizeof(achFullName));
    sprintf(achFullName, "%s/%s", DIR_DATA, MCUADDRFILENAME);
    
    hFile  = fopen(achFullName, "rb");
    if (NULL != hFile)
    {
        fseek(hFile, 0, SEEK_END);
        nFileLen = ftell(hFile);
        if (nFileLen > (s32)dwInBufLen)
        {
            if (bPrintErr)
            {
                LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetAddrbookFileData] addrbook.kdv FileLen(%d)>%d\n", nFileLen, dwInBufLen);			
            }
			// 防止文件未关闭 [pengguofeng 9/10/2013]
			fclose(hFile);
            return FALSE;
        }
        if (nFileLen > 0)
        {
            fseek(hFile, 0, SEEK_SET);
            fread(pbyBuf, nFileLen, 1, hFile);
        }
        fclose(hFile);
        hFile = NULL;
    }
    
    //允许文件长度为0，文件存在则同步清空该文件
    dwOutBufLen = (u32)nFileLen;
    
    return TRUE;
    
    
    // 恢复pclint对e438的检查
    /*lint -restore*/
}

/*=============================================================================
    函 数 名： SetAddrbookFileDataUtf8
    功    能： 主备数据倒换时 恢复 mcu/conf下的 kdvaddrbook.kdv 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
	           [IN]  BOOL32 bPrintErr 是否打印失败信息
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2013/07/31  4.7			liaokang                创建
=============================================================================*/
BOOL32 CMcuVcData::SetAddrbookFileDataUtf8( u8 *pbyBuf, u32 dwInBufLen, BOOL32 bPrintErr )
{
	// 禁止对error 438: (Warning -- Last value assigned to variable 'hFile' 
	/*lint -save -e438*/

	BOOL32 bRet = FALSE;

	//允许文件长度为0，文件存在则同步清空该文件
	if (NULL == pbyBuf && dwInBufLen > 0)
	{
		if (bPrintErr)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetAddrbookFileDataUtf8] NULL == pbyBuf || InBufLen(%d) == 0\n", dwInBufLen);
		}
		return bRet;
	}
	
	s8  achFullName[64];
	sprintf(achFullName, "%s/%s", DIR_DATA, MCUADDRFILENAME_UTF8);
	
	BOOL32 bReWrite = TRUE;
	if (0 == dwInBufLen)
	{
		FILE *hFile = fopen(achFullName, "rb");
		if (NULL != hFile)
		{
			fclose(hFile);
			hFile = NULL;
		}
		else
		{
			bReWrite = FALSE;
			bRet = TRUE;
		}
	}
	if (bReWrite)
	{
		FILE *hFile = fopen(achFullName, "wb");
		if (NULL != hFile)
		{
			if (pbyBuf && 0 != dwInBufLen)
			{
				fwrite(pbyBuf, 1, dwInBufLen, hFile);
#ifdef WIN32    //VX下不作多余的 fflush 操作
				fflush(hFile);
#endif
			}
			fclose(hFile);
			hFile = NULL;
			bRet = TRUE;
		}
		else
		{
			if (bPrintErr)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetAddrbookFileDataUtf8] save addrbook.kdv failed\n");
			}
		}
	}

	return bRet;	

	// 恢复pclint对e438的检查
	/*lint -restore*/
}

/*=============================================================================
    函 数 名： SetAddrbookFileData
    功    能： 主备数据倒换时 恢复 mcu/conf下的 addrbook.kdv 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
	           [IN]  BOOL32 bPrintErr 是否打印失败信息
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetAddrbookFileData( u8 *pbyBuf, u32 dwInBufLen, BOOL32 bPrintErr )
{
	// 禁止对error 438: (Warning -- Last value assigned to variable 'hFile' 
	/*lint -save -e438*/

	BOOL32 bRet = FALSE;

	//允许文件长度为0，文件存在则同步清空该文件
	if (NULL == pbyBuf && dwInBufLen > 0)
	{
		if (bPrintErr)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetAddrbookFileData] NULL == pbyBuf || InBufLen(%d) == 0\n", dwInBufLen);
		}
		return bRet;
	}
	
	s8  achFullName[64];
	sprintf(achFullName, "%s/%s", DIR_DATA, MCUADDRFILENAME);
	
	BOOL32 bReWrite = TRUE;
	if (0 == dwInBufLen)
	{
		FILE *hFile = fopen(achFullName, "rb");
		if (NULL != hFile)
		{
			fclose(hFile);
			hFile = NULL;
		}
		else
		{
			bReWrite = FALSE;
			bRet = TRUE;
		}
	}
	if (bReWrite)
	{
		FILE *hFile = fopen(achFullName, "wb");
		if (NULL != hFile)
		{
			if (pbyBuf && 0 != dwInBufLen)
			{
				fwrite(pbyBuf, 1, dwInBufLen, hFile);
#ifdef WIN32    //VX下不作多余的 fflush 操作
				fflush(hFile);
#endif
			}
			fclose(hFile);
			hFile = NULL;
			bRet = TRUE;
		}
		else
		{
			if (bPrintErr)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetAddrbookFileData] save addrbook.kdv failed\n");
			}
		}
	}

	return bRet;	

	// 恢复pclint对e438的检查
	/*lint -restore*/
}

/*=============================================================================
    函 数 名： GetConfinfoFileData
    功    能： 主备数据倒换时 获取 mcu/data下的 confinfo.dat 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
               [OUT] u32 &dwOutBufLen
	           [IN]  BOOL32 bPrintErr 是否打印失败信息
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetConfinfoFileData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen, BOOL32 bPrintErr )
{
	if (NULL == pbyBuf || dwInBufLen < sizeof(TMSVcConfState)) //?? 缓冲大小需要判别
	{
		if (bPrintErr)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetConfinfoFileData] NULL==pbyBuf InBufLen.%d\n", dwInBufLen);
		}
		return FALSE;
	}

	TMSVcConfState *ptConfState = (TMSVcConfState*)pbyBuf;
	u8 *pbyConfDataBuf = pbyBuf+sizeof(TMSVcConfState);
	u32 dwConfDataTotalLen = 0;
	CConfId acConfId[MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE+1];
	memset(pbyBuf, 0, sizeof(TMSVcConfState));	
	memset(acConfId, 0, sizeof(acConfId));
	
	//读取 会议头信息及缺省会议信息_存储文件
	if (TRUE == GetAllConfHeadFromFile(acConfId, sizeof(acConfId)))
	{
		u8  byLoop = 0;
		u16 wConfDataLen = 0;
		
		//包括最后一个位置上的缺省会议信息
		for (byLoop = 0; byLoop < (MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE+1); byLoop++)
		{
			if (FALSE == acConfId[byLoop].IsNull())
			{
				if (TRUE == ::GetConfDataFromFile(byLoop, acConfId[byLoop], 
					                              pbyConfDataBuf, sizeof(TConfStore), wConfDataLen,TRUE)) 
				{
					ptConfState->m_abyValid[byLoop] = 1;
					ptConfState->m_awConfDataLen[byLoop] = htons(wConfDataLen);
					pbyConfDataBuf += wConfDataLen;
					dwConfDataTotalLen += wConfDataLen;

                    // 测试 [4/28/2006]
                    // LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GuZhenhua MS Dump] Loaded Confinfo_%d!\n", byLoop );
				}
				else
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetConfinfoFileData] GetConfDataFromFile Err: Loop.%d\n", byLoop);
				}
			}
		}
	}
	else
	{
		if (bPrintErr)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetConfinfoFileData] GetAllConfHeadFromFile Err\n");
		}
	}
	
	//允许文件长度为0，文件存在则同步清空
	dwOutBufLen = sizeof(TMSVcConfState)+dwConfDataTotalLen;

    // 顾振华 [4/28/2006] 这里为什么要写一遍？？？
    // 暂时注释
	// SetConfinfoFileData(pbyBuf, dwOutBufLen, TRUE);

	return TRUE;
}

/*=============================================================================
    函 数 名： SetConfinfoFileData
    功    能： 主备数据倒换时 恢复 mcu/data下的 confinfo.dat 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
	           [IN]  BOOL32 bPrintErr 是否打印失败信息
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetConfinfoFileData( u8 *pbyBuf, u32 dwInBufLen, BOOL32 bPrintErr )
{
	//允许文件长度为0，文件存在则同步清空该文件
	if (NULL == pbyBuf || dwInBufLen < sizeof(TMSVcConfState))
	{
		if (bPrintErr)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetConfinfoFileData] NULL==pbyBuf || InBufLen(%d)>0\n", dwInBufLen);
		}
		return FALSE;
	}
	
	TMSVcConfState *ptConfState = (TMSVcConfState*)pbyBuf;
	u8 *pbyConfDataBuf = pbyBuf+sizeof(TMSVcConfState);
	CConfId acConfId[MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE+1];
	memset(acConfId, 0, sizeof(acConfId));
	    
	u8  byLoop = 0;
	u16 wConfDataLen = 0;
	CConfId cConfId;
	cConfId.SetNull();
	for (byLoop = 0; byLoop < (MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE+1); byLoop++)
	{
		wConfDataLen = ntohs(u16(ptConfState->m_awConfDataLen[byLoop]));
		if (1 == ptConfState->m_abyValid[byLoop])
		{
			if (TRUE == ::SetConfDataToFile(byLoop, cConfId, pbyConfDataBuf, wConfDataLen,TRUE))
			{
                // 测试 [4/28/2006]
                // LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GuZhenhua MS Dump] Writed Confinfo_%d!\n", byLoop );
				acConfId[byLoop] = cConfId;
			}
			else
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetConfinfoFileData] SetConfDataToFile Err: Loop.%d\n", byLoop);
			}
			pbyConfDataBuf += wConfDataLen;
		}
	}

	if (FALSE == SetAllConfHeadToFile(acConfId, sizeof(acConfId)))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetConfinfoFileData] SetAllConfHeadToFile Err\n");
	}

    // 测试 [4/28/2006]
    // LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GuZhenhua MS Dump] Writed Confinfo_head!\n" );

	return TRUE;
}

/*=============================================================================
    函 数 名： GetLoguserFileData
    功    能： 主备数据倒换时 获取 mcu/data下的 login.usr 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
               [OUT] u32 &dwOutBufLen
	           [IN]  BOOL32 bPrintErr 是否打印失败信息
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::GetLoguserFileData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen, BOOL32 bPrintErr )
{
	// 禁止对error 438: (Warning -- Last value assigned to variable 'hFile' 
	/*lint -save -e438*/

	if (NULL == pbyBuf)
	{
		if (bPrintErr)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetLoguserFileData] NULL == pbyBuf\n");
		}
		return FALSE;
	}
	
	s8  achFullName[64];
	sprintf(achFullName, "%s/%s", DIR_DATA, USERINFOFILENAME_UTF8);
	
	FILE *hFile  = fopen(achFullName, "rb");
	s32 nFileLen = 0;
	if (NULL != hFile)
	{
		fseek(hFile, 0, SEEK_END);
		nFileLen = ftell(hFile);
		if (nFileLen > (s32)dwInBufLen)
		{
			if (bPrintErr)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetLoguserFileData] login.usr FileLen(%d)>%d\n", nFileLen, dwInBufLen);
			}
			// 防止文件未关闭  [pengguofeng 9/10/2013]
			fclose(hFile);
			return FALSE;
		}
		if (nFileLen > 0)
		{
			fseek(hFile, 0, SEEK_SET);
			fread(pbyBuf, nFileLen, 1, hFile);
		}
		fclose(hFile);
		hFile = NULL;
	}
	else
	{
		StaticLog("[GetConfinfoFileData] open %s failed.(%s)\n", achFullName, strerror(errno));
	}
	
	//允许文件长度为0，文件存在则同步清空该文件
	dwOutBufLen = (u32)nFileLen;

	return TRUE;

	// 恢复对438的检查
	/*lint -restore*/
}

/*=============================================================================
    函 数 名： SetLoguserFileData
    功    能： 主备数据倒换时 恢复 mcu/data下的 login.usr 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
	           [IN]  BOOL32 bPrintErr 是否打印失败信息
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcData::SetLoguserFileData( u8 *pbyBuf, u32 dwInBufLen, BOOL32 bPrintErr )
{
	// 禁止对error 438: (Warning -- Last value assigned to variable 'hFile' 
	/*lint -save -e438*/

	BOOL32 bRet = FALSE;

	//允许文件长度为0，文件存在则同步清空该文件
	if (NULL == pbyBuf && dwInBufLen > 0)
	{
		if (bPrintErr)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetLoguserFileData] NULL == pbyBuf && InBufLen(%d) > 0\n", dwInBufLen);
		}
		return bRet;
	}
	
	s8  achFullName[64];
	sprintf(achFullName, "%s/%s", DIR_DATA, USERINFOFILENAME_UTF8);
	
	BOOL32 bReWrite = TRUE;
	if (0 == dwInBufLen)
	{
		FILE *hFile = fopen(achFullName, "rb");
		if (NULL != hFile)
		{
			fclose(hFile);
			hFile = NULL;
		}
		else
		{
			bReWrite = FALSE;
			bRet = TRUE;
		}
	}
	if (bReWrite)
	{
		FILE *hFile = fopen(achFullName, "wb");
		if (NULL != hFile)
		{
			if ( pbyBuf && 0 != dwInBufLen)
			{
				fwrite(pbyBuf, 1, dwInBufLen, hFile);
#ifdef WIN32    //VX下不作多余的 fflush 操作
				fflush(hFile);
#endif
			}
			fclose(hFile);
			hFile = NULL;
			bRet = TRUE;
		}
		else
		{
			if (bPrintErr)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetLoguserFileData] save login.usr failed\n");
			}
		}
	}

	return bRet;

	// 恢复对438的检查
	/*lint -restore*/
}

/*=============================================================================
    函 数 名： GetUserExFileData
    功    能： 主备数据倒换时 获取 mcu/data下的 usrgrp.usr 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
               [OUT] u32 &dwOutBufLen
	           [IN]  BOOL32 bPrintErr 是否打印失败信息
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2006/06/22  4.0			顾振华                创建
=============================================================================*/
BOOL32 CMcuVcData::GetUserExFileData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen, BOOL32 bPrintErr )
{
	// 禁止对error 438: (Warning -- Last value assigned to variable 'hFile' 
	/*lint -save -e438*/

	if (NULL == pbyBuf)
	{
		if (bPrintErr)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetUserExFileData] NULL == pbyBuf\n");
		}
		return FALSE;
	}
	
	s8  achFullName[64];
	sprintf(achFullName, "%s/%s", DIR_DATA, USERGRPINFOFILENAME);
	
	FILE *hFile  = fopen(achFullName, "rb");
	s32 nFileLen = 0;
	if (NULL != hFile)
	{
		fseek(hFile, 0, SEEK_END);
		nFileLen = ftell(hFile);
		if (nFileLen > (s32)dwInBufLen)
		{
			if (bPrintErr)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetUserExFileData] usrgrp.usr FileLen(%d)>%d\n", nFileLen, dwInBufLen);
			}
			fclose(hFile); // 防止文件未关闭  [pengguofeng 9/10/2013]
			return FALSE;
		}
		if (nFileLen > 0)
		{
			fseek(hFile, 0, SEEK_SET);
			fread(pbyBuf, nFileLen, 1, hFile);
		}
		fclose(hFile);
		hFile = NULL;
	}
	
	//允许文件长度为0，文件存在则同步清空该文件
	dwOutBufLen = (u32)nFileLen;

	return TRUE;

	// 恢复对438的检查
	/*lint -restore*/
}

/*=============================================================================
    函 数 名： SetUserExFileData
    功    能： 主备数据倒换时 恢复 mcu/data下的 usrgrp.usr 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
	           [IN]  BOOL32 bPrintErr 是否打印失败信息
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2006/06/22  4.0			顾振华                创建
=============================================================================*/
BOOL32 CMcuVcData::SetUserExFileData( u8 *pbyBuf, u32 dwInBufLen, BOOL32 bPrintErr )
{
	// 禁止对error 438: (Warning -- Last value assigned to variable 'hFile' 
	/*lint -save -e438*/

	BOOL32 bRet = FALSE;

	//允许文件长度为0，文件存在则同步清空该文件
	if (NULL == pbyBuf && dwInBufLen > 0)
	{
		if (bPrintErr)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetUserExFileData] NULL == pbyBuf && InBufLen(%d) > 0\n", dwInBufLen);
		}
		return bRet;
	}
	
	s8  achFullName[64];
	sprintf(achFullName, "%s/%s", DIR_DATA, USERGRPINFOFILENAME);
	
	BOOL32 bReWrite = TRUE;
	if (0 == dwInBufLen)
	{
		FILE *hFile = fopen(achFullName, "rb");
		if (NULL != hFile)
		{
			fclose(hFile);
			hFile = NULL;
		}
		else
		{
			bReWrite = FALSE;
			bRet = TRUE;
		}
	}
	if (bReWrite)
	{
		FILE *hFile = fopen(achFullName, "wb");
		if (NULL != hFile)
		{
			if ( pbyBuf && 0 != dwInBufLen)
			{
				fwrite(pbyBuf, 1, dwInBufLen, hFile);
#ifdef WIN32    //VX下不作多余的 fflush 操作
				fflush(hFile);
#endif
			}
			fclose(hFile);
			hFile = NULL;
			bRet = TRUE;
		}
		else
		{
			if (bPrintErr)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetUserExFileData] save usrgrp.usr failed\n");
			}
		}
	}

	return bRet;

	// 恢复对438的检查
	/*lint -restore*/
}
/*=============================================================================
    函 数 名： GetUnProcConfinfoFileData
    功    能： 主备数据倒换时 获取 mcu/data下的 unprocconfinfo.dat 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
               [OUT] u32 &dwOutBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2006/06/22  4.0			fxh                   创建
=============================================================================*/
BOOL32 CMcuVcData::GetUnProcConfinfoFileData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen)
{
	if (NULL == pbyBuf || dwInBufLen < sizeof(TMSVcConfState)) 
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetUnProcConfinfoFileData] NULL==pbyBuf InBufLen.%d\n", dwInBufLen);
		return FALSE;
	}

	TMSVcConfState *ptConfState = (TMSVcConfState*)pbyBuf;
	u8 *pbyConfDataBuf = pbyBuf + sizeof(TMSVcConfState);
	u32 dwConfDataTotalLen = 0;
	CConfId acConfId[MAXNUM_MCU_CONF + MAXNUM_MCU_TEMPLATE + 1];
	memset(pbyBuf, 0, sizeof(TMSVcConfState));	
	memset(acConfId, 0, sizeof(acConfId));
	
	//读取 会议头信息及缺省会议信息_存储文件
	if (TRUE == GetAllConfHeadFromFile(acConfId, sizeof(acConfId)))
	{
		u32 dwUnProcConfDataLen = 0;		
		for (u8 byLoop = 0; byLoop < (MAXNUM_MCU_CONF + MAXNUM_MCU_TEMPLATE); byLoop++)
		{
			if (FALSE == acConfId[byLoop].IsNull() &&
				VCS_CONF == acConfId[byLoop].GetConfSource())
			{
				dwUnProcConfDataLen = GetUnProConfDataToFileLen(byLoop);
				if (TRUE == ::GetUnProConfDataToFile(byLoop, (s8*)pbyConfDataBuf, dwUnProcConfDataLen)) 
				{
					ptConfState->m_abyValid[byLoop] = 1;
					ptConfState->m_awConfDataLen[byLoop] = htonl(dwUnProcConfDataLen);
					pbyConfDataBuf += dwUnProcConfDataLen;
					dwConfDataTotalLen += dwUnProcConfDataLen;
				}
				else
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetUnProcConfinfoFileData] GetUnProConfDataToFile Err: Loop.%d\n", byLoop);
				}
			}
		}
	}
	else
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetUnProcConfinfoFileData] GetAllConfHeadFromFile Err\n");
	}
	
	dwOutBufLen = sizeof(TMSVcConfState) + dwConfDataTotalLen;
	return TRUE;
}
/*=============================================================================
    函 数 名： SetUnProcConfinfoFileData
    功    能： 主备数据倒换时 保存mcu/data下的 unprocconfinfo.dat 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2006/06/22  4.0			fxh                   创建
=============================================================================*/
BOOL32 CMcuVcData::SetUnProcConfinfoFileData( u8 *pbyBuf, u32 dwInBufLen)
{
	if (NULL == pbyBuf || dwInBufLen < sizeof(TMSVcConfState))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetUnProcConfinfoFileData] NULL==pbyBuf || InBufLen(%d)< sizeof(TMSVcConfState)\n", dwInBufLen);
		return FALSE;
	}
	
	TMSVcConfState *ptConfState = (TMSVcConfState*)pbyBuf;
	u8 *pbyConfDataBuf = pbyBuf + sizeof(TMSVcConfState);    
	u32 dwConfDataLen = 0;
	for (u8 byLoop = 0; byLoop < (MAXNUM_MCU_CONF + MAXNUM_MCU_TEMPLATE); byLoop++)
	{
		dwConfDataLen = ntohl(ptConfState->m_awConfDataLen[byLoop]);
		if (1 == ptConfState->m_abyValid[byLoop])
		{
			if (FALSE == ::SetUnProConfDataToFile(byLoop, (s8*)pbyConfDataBuf, dwConfDataLen))
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetUnProcConfinfoFileData] SetUnProConfDataToFile Err: Loop.%d\n", byLoop);
			}
			pbyConfDataBuf += dwConfDataLen;
		}
	}
	return TRUE;
}
/*=============================================================================
    函 数 名： GetVCSLoguserFileData
    功    能： 主备数据倒换时 获取 mcu/data下的 vcslogin.usr 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
               [OUT] u32 &dwOutBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2009/04/03  4.0			fxh                   创建
=============================================================================*/
BOOL32 CMcuVcData::GetVCSLoguserFileData(u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen)
{
	// 禁止对error 438: (Warning -- Last value assigned to variable 'hFile' 
	/*lint -save -e438*/

	if (NULL == pbyBuf)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetVCSLoguserFileData] NULL == pbyBuf\n");
		return FALSE;
	}
	
	s8  achFullName[64];
	sprintf(achFullName, "%s/%s", DIR_DATA, MCU_VCSUSER_FILENAME_UTF8);
	
	FILE *hFile  = fopen(achFullName, "rb");
	s32 nFileLen = 0;
	if (NULL != hFile)
	{
		fseek(hFile, 0, SEEK_END);
		nFileLen = ftell(hFile);
		if (nFileLen > (s32)dwInBufLen)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetVCSLoguserFileData] vcslogin.usr FileLen(%d)>%d\n", nFileLen, dwInBufLen);
			fclose(hFile);
			hFile = NULL;
			return FALSE;
		}

		if (nFileLen > 0)
		{
			fseek(hFile, 0, SEEK_SET);
			fread(pbyBuf, nFileLen, 1, hFile);
		}
		fclose(hFile);
		hFile = NULL;
		dwOutBufLen = (u32)nFileLen;
	}
// 屏蔽由于文件不存在而返回FALSE导致的主备配置失败 [7/31/2013 liaokang]
// 	else
// 	{
// 		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetVCSLoguserFileData] open vcslogin.usr Fail\n");
// 		return FALSE;
// 	}
	return TRUE;

	// 恢复对438的检查
	/*lint -restore*/
}
/*=============================================================================
    函 数 名： SetVCSLoguserFileData
    功    能： 主备数据倒换时 保存mcu/data下的 vcslogin.usr 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2006/06/22  4.0			fxh                   创建
=============================================================================*/
BOOL32 CMcuVcData::SetVCSLoguserFileData(u8 *pbyBuf, u32 dwInBufLen)
{
	// 禁止对error 438: (Warning -- Last value assigned to variable 'hFile' 
	/*lint -save -e438*/

	BOOL32 bRet = FALSE;
	if (NULL == pbyBuf /*|| dwInBufLen < 0*/)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetVCSLoguserFileData] NULL == pbyBuf || InBufLen(%d) < 0 \n", dwInBufLen);
		return bRet;
	}

	s8  achFullName[64];
	sprintf(achFullName, "%s/%s", DIR_DATA, MCU_VCSUSER_FILENAME_UTF8);
	
	BOOL32 bReWrite = TRUE;
	if (0 == dwInBufLen)
	{
		FILE *hFile = fopen(achFullName, "rb");
		if (NULL != hFile)
		{
			fclose(hFile);
			hFile = NULL;
		}
		else
		{
			bReWrite = FALSE;
			bRet = TRUE;
		}
	}

	if (bReWrite)
	{
		FILE *hFile = fopen(achFullName, "wb");
		if (NULL != hFile)
		{
			if (0 != dwInBufLen)
			{
				fwrite(pbyBuf, 1, dwInBufLen, hFile);
#ifdef WIN32    //VX下不作多余的 fflush 操作
				fflush(hFile);
#endif
			}
			fclose(hFile);
			hFile = NULL;
			bRet = TRUE;
		}
		else
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetVCSLoguserFileData] fopen vcslogin.usr failed\n");
		}
	}

	return bRet;

	// 恢复对438的检查
	/*lint -restore*/
}
/*=============================================================================
    函 数 名： GetVCSUserTaskFileData
    功    能： 主备数据倒换时 获取 mcu/data下的 usrtask.dat 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
               [OUT] u32 &dwOutBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2009/04/03  4.0			fxh                   创建
=============================================================================*/
BOOL32 CMcuVcData::GetVCSUserTaskFileData(u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen)
{
	// 禁止对error 438: (Warning -- Last value assigned to variable 'hFile' 
	/*lint -save -e438*/

	if (NULL == pbyBuf)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetVCSUserTaskFileData] NULL == pbyBuf\n");
		return FALSE;
	}
	
	s8  achFullName[64];
	sprintf(achFullName, "%s/%s", DIR_DATA, USERTASKINFOFILENAME);
	
	FILE *hFile  = fopen(achFullName, "rb");
	s32 nFileLen = 0;
	if (NULL != hFile)
	{
		fseek(hFile, 0, SEEK_END);
		nFileLen = ftell(hFile);
		if (nFileLen > (s32)dwInBufLen)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[GetVCSUserTaskFileData] usrtask.dat FileLen(%d)>%d\n", nFileLen, dwInBufLen);
			fclose(hFile);// 防止文件未关闭 [pengguofeng 9/10/2013]
			return FALSE;
		}
		if (nFileLen > 0)
		{
			fseek(hFile, 0, SEEK_SET);
			fread(pbyBuf, nFileLen, 1, hFile);
		}
		fclose(hFile);
		hFile = NULL;
		dwOutBufLen = (u32)nFileLen;
	}
	return TRUE;

	// 恢复对438的检查
	/*lint -restore*/
}
/*=============================================================================
    函 数 名： SetVCSUserTaskFileData
    功    能： 主备数据倒换时 保存mcu/data下的 usrtask.dat 文件信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2006/06/22  4.0			fxh                   创建
=============================================================================*/
BOOL32 CMcuVcData::SetVCSUserTaskFileData(u8 *pbyBuf, u32 dwInBufLen)
{
	// 禁止对error 438: (Warning -- Last value assigned to variable 'hFile' 
	/*lint -save -e438*/

	BOOL32 bRet = FALSE;
	if (NULL == pbyBuf /*|| dwInBufLen < 0*/)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetVCSUserTaskFileData] NULL == pbyBuf || InBufLen(%d) < 0 \n", dwInBufLen);
		return bRet;
	}
	
	s8  achFullName[64];
	sprintf(achFullName, "%s/%s", DIR_DATA, USERTASKINFOFILENAME);
	
	BOOL32 bReWrite = TRUE;
	if (0 == dwInBufLen)
	{
		FILE *hFile = fopen(achFullName, "rb");
		if (NULL != hFile)
		{
			fclose(hFile);
			hFile = NULL;
		}
		else
		{
			bReWrite = FALSE;
			bRet = TRUE;
		}
	}

	if (bReWrite)
	{
		FILE *hFile = fopen(achFullName, "wb");
		if (NULL != hFile)
		{
			if (0 != dwInBufLen)
			{
				fwrite(pbyBuf, 1, dwInBufLen, hFile);
#ifdef WIN32    //VX下不作多余的 fflush 操作
				fflush(hFile);
#endif
			}
			fclose(hFile);
			hFile = NULL;
			bRet = TRUE;
		}
		else
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[SetVCSUserTaskFileData] save usrtask.dat failed\n");
		}
	}

	return bRet;

	// 恢复对438的检查
	/*lint -restore*/
}
/*=============================================================================
    函 数 名： ReloadMcuUserList
    功    能： 用户列表模块重新从文件装载用户列表
    算法实现： 
    全局变量： 
    参    数： void
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2006/01/05  4.0			万春雷                  创建
    2006/06/22  4.0         顾振华                  增加用户组支持
=============================================================================*/
BOOL32 CMcuVcData::ReloadMcuUserList( void )
{
	BOOL32 bRet = g_cUsrManage.GetAllUserFromFile();    
    g_cUsrManage.SetSingle(FALSE);

    CUserFullInfo cUserInfo;

    s32 nNum = g_cUsrManage.GetUserNum();
    if (nNum == 0)
    {
        printf("[UserMgrLoad]Load User ret: %d. User Number: %d\n", bRet, nNum);
    }    

    // 处理一下admin

    for (s32 nLoop = 0; nLoop < nNum; nLoop ++)
    {        
        g_cUsrManage.GetUserFullInfo( &cUserInfo,  nLoop );

        if ( cUserInfo.IsEqualName("admin") )
        {
            // 如果是admin的话，需要过滤一下。可能是自动生成的
            // 要给它加上组标记
            CExUsrInfo cNewExnfo = cUserInfo;

            char *szDesc = cUserInfo.GetDiscription();
            if ( szDesc !=  NULL &&
                 (u8)szDesc[0] != USRGRPID_SADMIN )
            {
                cNewExnfo.SetDiscription( szDesc );
                cNewExnfo.SetUsrGrpId( USRGRPID_SADMIN );
                if (!g_cUsrManage.ModifyInfo( &cNewExnfo ))
                {
                    LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[ReloadMcuUserList] Modify Admin error: %d!\n", g_cUsrManage.GetLastError());
                }
            }

            break;
        }
    }

    // 读取用户组信息
    bRet = bRet & m_cUsrGrpInfo.Load();

    return bRet;
}

/*=============================================================================
函 数 名： VcsReloadMcuUserList
功    能： VCS用户列表模块重新从文件装载用户列表
算法实现： 
全局变量： 
参    数： void
返 回 值： BOOL32 
-----------------------------------------------------------------------------
修改记录：
日  期		版本		修改人		走读人    修改内容
2010/06/03  4.0	         sgx
=============================================================================*/
BOOL32 CMcuVcData::VcsReloadMcuUserList( void )    
{
	BOOL32 bRet = g_cVCSUsrManage.GetAllUserFromFile();    
    g_cVCSUsrManage.SetSingle(FALSE);
	
    CUserFullInfo cUserInfo;
	
    s32 nNum = g_cVCSUsrManage.GetUserNum();
    if (nNum == 0)
    {
        printf("[VcsUserMgrLoad]Load User ret: %d. User Number: %d\n", bRet, nNum);
    }    
	
    // 处理一下admin
	
    for (s32 nLoop = 0; nLoop < nNum; nLoop ++)
    {        
        g_cVCSUsrManage.GetUserFullInfo( &cUserInfo,  nLoop );
		
        if ( cUserInfo.IsEqualName("admin") )
        {
            // 如果是admin的话，需要过滤一下。可能是自动生成的
            // 要给它加上组标记
            CExUsrInfo cNewExnfo = cUserInfo;
			
            char *szDesc = cUserInfo.GetDiscription();
            if ( szDesc !=  NULL &&
				(u8)szDesc[0] != USRGRPID_SADMIN )
            {
                cNewExnfo.SetDiscription( szDesc );
                cNewExnfo.SetUsrGrpId( USRGRPID_SADMIN );
                if (!g_cVCSUsrManage.ModifyInfo( &cNewExnfo ))
                {
                    LogPrint(LOG_LVL_ERROR, MID_MCU_CFG, "[VcsReloadMcuUserList] Modify Admin error: %d!\n", g_cVCSUsrManage.GetLastError());
                }
            }
			
            break;
        }
    }
	
    // 读取用户组信息
    //bRet = bRet & m_cUsrGrpInfo.Load();
	
    return bRet;
}

/*=============================================================================
  函 数 名： GetMcuEqpCapacity
  功    能： 
  算法实现： 
  全局变量： 
  参    数： [OUT] TEqpCapacity& tMcuEqpCap
  返 回 值： void 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2006/02/25  4.0			刘辉云                  创建
=============================================================================*/
void CMcuVcData::GetMcuEqpCapacity(TEqpCapacity& tMcuEqpCap)
{

	u8  byVmpNum = 0;
	u8  byMixNum = 0;
	u8  byTvNum = 0;
	u8  byMpwNum = 0;
	u8 byEqpIdLp = 0;
	
	TEqpReqInfo tPrsCap;
	GetPrsCapacity( tPrsCap ); // 取Prs空闲通道数
	
	// 电视墙空闲通道数 ?
	
    while( byEqpIdLp <= MAXNUM_MCU_PERIEQP )
	{
		if( IsPeriEqpValid( byEqpIdLp )
			&& m_atPeriEqpTable[byEqpIdLp-1].m_tPeriEqpStatus.m_byOnline )
		{
			//tianzhiyong
			if(	EQP_TYPE_MIXER == GetEqpType(byEqpIdLp) )
			{
				u8 byMixerSubtype = UNKONW_MIXER;
				g_cMcuAgent.GetMixerSubTypeByEqpId(byEqpIdLp,byMixerSubtype);
				if ( byMixerSubtype == APU_MIXER || byMixerSubtype == EAPU_MIXER || byMixerSubtype == APU2_MIXER ||
					 byMixerSubtype == MIXER_8KG || byMixerSubtype == MIXER_8KH || byMixerSubtype == MIXER_8KI
					)
				{
					//zbq[04/10/2008] 混音组没有准备好不认为该混音器可用. 只记录数量会误判.
					TPeriEqpStatus tEqpStatus;
					if (!GetPeriEqpStatus(byEqpIdLp, &tEqpStatus))
					{
						OspPrintf(TRUE, FALSE, "[GetMcuEqpCapacity] get Mixer.%d's status failed\n", byEqpIdLp);
						continue;
					}
					u8 byLoopGrpId = 0;
					TMixerStatus tMixerStatus = tEqpStatus.m_tStatus.tMixer;
					while( byLoopGrpId < tMixerStatus.m_byGrpNum )
					{
						if( tMixerStatus.m_atGrpStatus[byLoopGrpId].m_byGrpState == TMixerGrpStatus::READY )
						{
							byMixNum++;
						}
						byLoopGrpId++;				
					}
				}
				//byMixNum++; // 只记录了混音器数量
			}

			// recorder 
			if( EQP_TYPE_RECORDER == GetEqpType(byEqpIdLp) )
			{
				// do nothing;
			}
						
			// tv
			if( EQP_TYPE_TVWALL == GetEqpType(byEqpIdLp) || 
				EQP_TYPE_HDU    == GetEqpType(byEqpIdLp) /*||
				EQP_TYPE_HDU_H  == GetEqpType(byEqpIdLp) ||
				EQP_TYPE_HDU_L == GetEqpType(byEqpIdLp)  ||
				EQP_TYPE_HDU2   == GetEqpType(byEqpIdLp) ||
				EQP_TYPE_HDU2_L == GetEqpType(byEqpIdLp)*/)
			{
				byTvNum++;
			}
						
			// bas
			if( EQP_TYPE_BAS == GetEqpType(byEqpIdLp) )
			{
				// do nothing;
			}
			
			// vmp
			if(EQP_TYPE_VMP == GetEqpType( byEqpIdLp )
				&& m_atPeriEqpTable[byEqpIdLp-1].m_tPeriEqpStatus.m_tStatus.tVmp.m_byUseState == TVmpStatus::IDLE )
			{
				byVmpNum++;
			}

			// mpw 
			if( EQP_TYPE_VMPTW == GetEqpType( byEqpIdLp) )
			{
				byMpwNum++;
			}
			// prs
			if( EQP_TYPE_PRS == GetEqpType( byEqpIdLp ) )
			{
				// get prs channels
			}
		}		
        byEqpIdLp++;
	}

    // mix
	if( 0 != byMixNum )
	{
		tMcuEqpCap.m_tMixCap.SetNeedEqp(TRUE);
		tMcuEqpCap.m_tMixCap.SetNeedChannles( byMixNum );
	}
	else
	{
		tMcuEqpCap.m_tMixCap.SetNeedEqp(FALSE);
	}
	// tvwall
	if( 0 != byTvNum )
	{
		tMcuEqpCap.m_tTvCap.SetNeedEqp(TRUE);
		tMcuEqpCap.m_tTvCap.SetNeedChannles( byTvNum );
	}
	else
	{
		tMcuEqpCap.m_tTvCap.SetNeedEqp(FALSE);
	}
	// vmp
	if( 0!= byVmpNum)
	{
		tMcuEqpCap.m_tVmpCap.SetNeedEqp( TRUE );
		tMcuEqpCap.m_tVmpCap.SetNeedChannles( byVmpNum );
	}
	else
	{
		tMcuEqpCap.m_tVmpCap.SetNeedEqp( FALSE );
	}
	// mpw
	if( 0 != byMpwNum )
	{
		tMcuEqpCap.m_tMpwCap.SetNeedEqp( TRUE );
		tMcuEqpCap.m_tMpwCap.SetNeedChannles( byMpwNum );
	}
	else
	{
		tMcuEqpCap.m_tMpwCap.SetNeedEqp( FALSE );
	}

	// prs
	tMcuEqpCap.m_tPrsCap = tPrsCap;

	return;
}

/*=============================================================================
  函 数 名： GetConfEqpDemand
  功    能： 
  算法实现： 
  全局变量： 
  参    数： [IN] TConfInfo& tConfInfo
             [OUT] TEqpCapacity& tConfEqpDemand
  返 回 值： void 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2006/02/25  4.0			刘辉云                  创建
=============================================================================*/
void CMcuVcData::GetConfEqpDemand(TConfInfo& tConfInfo, TEqpCapacity& tConfEqpDemand )
{
	TConfAttrb tConfAttribute = tConfInfo.GetConfAttrb();

	BOOL32 bIsNeedEqp = FALSE;
	if( tConfAttribute.IsHasVmpModule() || CONF_VMPMODE_AUTO == tConfInfo.m_tStatus.GetVMPMode() )
	{
		bIsNeedEqp = TRUE;
	}
	tConfEqpDemand.m_tVmpCap.SetNeedEqp(bIsNeedEqp);
	tConfEqpDemand.m_tPrsCap.SetNeedEqp( tConfAttribute.IsResendLosePack() );// prs

    // 会议BAS和高清BAS需求, zgc, 2008-08-11
    BOOL32 bIsNeedBas = FALSE;
    BOOL32 bIsNeedHDBas = FALSE;
    if ( IsHDConf(tConfInfo) && tConfAttribute.IsUseAdapter() )
    {   
        bIsNeedHDBas = TRUE;
    }
    tConfEqpDemand.m_tHDBasCap.SetNeedEqp( bIsNeedHDBas );
    
    if ( tConfAttribute.IsUseAdapter() &&
         (( tConfInfo.GetSecAudioMediaType() != MEDIA_TYPE_NULL && 
           tConfInfo.GetMainAudioMediaType() != tConfInfo.GetSecAudioMediaType() ) ||
          ( tConfInfo.GetSecVideoMediaType() != MEDIA_TYPE_NULL &&
            tConfInfo.GetMainVideoMediaType() != tConfInfo.GetSecVideoMediaType() ) ||
          ( tConfInfo.GetSecBitRate() != 0 && 
            tConfInfo.GetBitRate() != tConfInfo.GetSecBitRate())  ) )
    {
        bIsNeedBas = TRUE;
    }
    tConfEqpDemand.m_tBasCap.SetNeedEqp( FALSE );
	//tConfEqpDemand.m_tBasCap.SetNeedEqp( tConfAttribute.IsUseAdapter() ); // bas
	tConfEqpDemand.m_tMixCap.SetNeedEqp( tConfAttribute.IsDiscussConf()  ); // mixer

	tConfEqpDemand.m_tMpwCap.SetNeedEqp( FALSE );
	tConfEqpDemand.m_tRecCap.SetNeedEqp( FALSE );

	// tvwall(多电视墙没有考虑) (电视墙通道数不在会议信息中，所以在外面判断)
	tConfEqpDemand.m_tTvCap.SetNeedEqp( tConfAttribute.IsHasTvWallModule() ); // tv
	
	u8 byNeedPrsChannles = DEFAULT_PRS_CHANNELS;
	u8 byNeedVidBasChannels = 0;
	u8 byNeedAudBasChannels = 0;

	// bas (具体通道数目)
    // guzh [8/28/2007] 如果是 8000B/8000C，则检查是否是双媒体会议（只需要1路视频适配)
#ifdef _MINIMCU_
    BOOL32 bNeedBas = FALSE;
#endif
    // 高清BAS和普通BAS分开, zgc, 2008-08-11
	//if( tConfAttribute.IsUseAdapter() )
    if ( bIsNeedBas )
	{
		u8 byMainMediaType   = tConfInfo.GetMainAudioMediaType();
		u8 bySecondMediaType = tConfInfo.GetSecAudioMediaType();
		if (MEDIA_TYPE_NULL != bySecondMediaType && byMainMediaType != bySecondMediaType)
		{
			byNeedPrsChannles++;
			byNeedAudBasChannels++;
		}

		byMainMediaType = tConfInfo.GetMainVideoMediaType();
		bySecondMediaType = tConfInfo.GetSecVideoMediaType();
		u8 byMainVidFormat = tConfInfo.GetMainVideoFormat();
		u8 bySecVidFormat = tConfInfo.GetSecVideoFormat();
		if ( (MEDIA_TYPE_NULL != bySecondMediaType && byMainMediaType != bySecondMediaType)
			||(byMainMediaType == bySecondMediaType && byMainVidFormat != bySecVidFormat) )
		{
			byNeedPrsChannles++;
#ifdef _MINIMCU_
            bNeedBas = TRUE;
#else
			byNeedVidBasChannels++;
#endif
		}

		if( 0 != tConfInfo.GetSecBitRate() )
		{
			byNeedPrsChannles++;
#ifdef _MINIMCU_
            bNeedBas = TRUE;
#else
			byNeedVidBasChannels++;
#endif
		}

		tConfEqpDemand.m_tBasCap.SetAudChannels( byNeedAudBasChannels );
#ifdef _MINIMCU_
        tConfEqpDemand.m_tBasCap.SetNeedChannles( bNeedBas ? 1: 0 );
#else
		tConfEqpDemand.m_tBasCap.SetNeedChannles( byNeedVidBasChannels );
#endif
	}

	//[nizhijun 2011/12/32]  BAS能力不需要通过以下方式计算，已经有另外接口判断IsBasChnlEnoughForConf
//     // 高清BAS
//     if ( bIsNeedHDBas )
//     {
//         u8 byNVChn = 0;
//         u8 byDSChnVGA = 0;
//         u8 byDSChnH263p = 0;
// 
//         //CBasMgr cBasMgr;
// 
// #ifdef _8KE_ //[03/01/2010] zjl add
// 	    //cBasMgr.GetNeeded8keBas(tConfInfo, byNVChn, byDSChnVGA);
// 		GetBasChnNumNeededByConf(tConfInfo, tConfInfoEx, byNVChn, byDSChnVGA);
// #else
//     	//cBasMgr.GetNeededMau(tConfInfo, byNVChn, byDSChnH263p, byDSChnVGA);
// 		GetMauChnNumNeededByConf(tConfInfo, tConfInfoEx, byNVChn, byDSChnH263p, byDSChnVGA);
// #endif
//         
//         tConfEqpDemand.m_tHDBasCap.SetNeedChannles( byNVChn );
//         tConfEqpDemand.m_tHDBasCap.SetDVidChannels( byDSChnVGA );
//         tConfEqpDemand.m_tHDBasCap.SetDVidH263pChn( byDSChnH263p );
//     }

	// prs (具体通道数目)
	if(tConfAttribute.IsResendLosePack())
	{
		tConfEqpDemand.m_tPrsCap.SetNeedChannles( byNeedPrsChannles );
	}
	return;
}

/*=============================================================================
  函 数 名： AnalyEqpCapacity
  功    能： 
  算法实现： 
  全局变量： 
  参    数：  [IN] TEqpCapacity& tConfEqpDemand
              [IN] TEqpCapacity& tMcuSupportCap
  返 回 值： BOOL32: TRUE: Mcu支持该会议的外设需求， FALSE；不支持
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2006/02/25  4.0			刘辉云                  创建
=============================================================================*/
BOOL32 CMcuVcData::AnalyEqpCapacity( const TConfInfo &tConfInfo, const TConfInfoEx &tConfInfoEx,
									TEqpCapacity& tConfEqpDemand, TEqpCapacity& tMcuSupportCap)
{
	//bas
	BOOL32 bRet = TRUE;
	CBasChn *aptNeedChn[MAXNUM_PERIEQP]={NULL};
	TBasChnCapData atBasChnCapData[MAXNUM_PERIEQP];
	u16 wErrorCode = ERR_MCU_NOENOUGH_HDBAS_CONF;
	if (tConfInfo.GetConfAttrb().IsUseAdapter())
	{
		bRet = g_cMcuVcApp.IsBasChnlEnoughForConf(tConfInfo,tConfInfoEx,aptNeedChn,atBasChnCapData,wErrorCode);
	}	
	//这里先不占，真实开启会议的时候再占用
	for ( u8 byIdx =0 ; byIdx < MAXNUM_PERIEQP; byIdx++ )
	{
		if ( aptNeedChn[byIdx] == NULL )
		{
			continue;
		}

		aptNeedChn[byIdx]->SetIsReserved(FALSE);
	}

	// prs
	if( tConfEqpDemand.m_tPrsCap.IsNeedEqp() )
	{
		if( tMcuSupportCap.m_tPrsCap.IsNeedEqp() )
		{
			if( tMcuSupportCap.m_tPrsCap.GetSupportChannels() < tConfEqpDemand.m_tPrsCap.GetSupportChannels() )
			{
				bRet = FALSE;
			}
		}
		else
		{
			bRet = FALSE;
		}
	}
	
	// tv
	if( tConfEqpDemand.m_tTvCap.IsNeedEqp() )
	{
		if( !tMcuSupportCap.m_tTvCap.IsNeedEqp() )
		{
			bRet = FALSE;
		}
	}

	// vmp
	if( tConfEqpDemand.m_tVmpCap.IsNeedEqp() )
	{
		if( !tMcuSupportCap.m_tVmpCap.IsNeedEqp() )
		{
			bRet = FALSE;
		}
	}

	// mixer
	if( tConfEqpDemand.m_tMixCap.IsNeedEqp()  )
	{
		/*if( !tMcuSupportCap.m_tMixCap.IsNeedEqp() )
		{
			bRet = FALSE;
		}*/
		u8 byEqpId = 0;
		TAudioTypeDesc atAudioTypeDesc[MAXNUM_CONF_AUDIOTYPE];
		memset(atAudioTypeDesc, 0, sizeof(atAudioTypeDesc));
		u8 byAudioCapNum = tConfInfoEx.GetAudioTypeDesc(atAudioTypeDesc);

        byEqpId = g_cMcuVcApp.GetIdleMixer(0, byAudioCapNum, atAudioTypeDesc);
		if( 0 == byEqpId )
		{
			bRet = FALSE;
		}
	}
/*
	// mpw
	if( tConfEqpDemand.m_tMpwCap.IsNeedEqp()  )
	{
		if( !tMcuSupportCap.m_tMpwCap.IsNeedEqp() )
		{
			bRet = FALSE;
		}
	}
*/
	return bRet;
}

/*=============================================================================
  函 数 名： GetBasCapacity
  功    能： 取Bas能力集
  算法实现： 
  全局变量： 
  参    数： TBasReqInfo& tBasCap
  返 回 值： void 
=============================================================================*/
void CMcuVcData::GetBasCapacity(TBasReqInfo& tBasCap )
{
	u8 byAudChannels = 0;
	u8 byVidChannels = 0;
	u8 byBasIdLp = BASID_MIN;
	TBasStatus *ptStatus = NULL;
	
	while( byBasIdLp >= BASID_MIN && byBasIdLp <= BASID_MAX )
	{
		if( IsPeriEqpValid( byBasIdLp )
            && !g_cMcuAgent.IsEqpBasHD(byBasIdLp)
			&& m_atPeriEqpTable[byBasIdLp-1].m_tPeriEqpStatus.m_byOnline )
		{
			ptStatus = &(m_atPeriEqpTable[byBasIdLp-1].m_tPeriEqpStatus.m_tStatus.tBas);
			u8 byMinChnl = 0;
			u8 byMaxChnl = ptStatus->byChnNum;

			//查找空闲通道
			for (u8 byChnIdx = byMinChnl; byChnIdx < byMaxChnl; byChnIdx++)
			{
				if (!ptStatus->tChnnl[byChnIdx].IsReserved())
				{
					u8 byBasChnnlType = ptStatus->tChnnl[byChnIdx].GetChannelType();
					if (BAS_CHAN_AUDIO == byBasChnnlType)
					{
						byAudChannels++;
					}
					else if (BAS_CHAN_VIDEO == byBasChnnlType)
					{
						byVidChannels++;
					}
				}
			}
		}
		byBasIdLp++;
	}
	
	tBasCap.SetNeedEqp(FALSE);
	tBasCap.SetAudChannels( 0 );
	tBasCap.SetNeedChannles( 0 );

	if( 0 != byAudChannels )
	{
		tBasCap.SetNeedEqp(TRUE);
		tBasCap.SetAudChannels( byAudChannels );
	}

	if( 0!= byVidChannels )
	{
		tBasCap.SetNeedEqp( TRUE );
		tBasCap.SetNeedChannles( byVidChannels );
	}

	return;
}

/*=============================================================================
  函 数 名： GetPrsCapacity
  功    能： 取Prs能力集
  算法实现： 
  全局变量： 
  参    数： TEqpReqInfo& tPrsCap
  返 回 值： void 
=============================================================================*/
void CMcuVcData::GetPrsCapacity(TEqpReqInfo& tPrsCap )
{
	u8 byPrsIdLp = PRSID_MIN;
	u8 byPrsChannels = 0;
	
	tPrsCap.SetNeedEqp( FALSE );
	tPrsCap.SetNeedChannles( 0 );
	
	TPrsStatus *ptStatus = NULL;
	while (byPrsIdLp >= PRSID_MIN && byPrsIdLp <= PRSID_MAX)
    {
        if ( 1 == m_atPeriEqpTable[byPrsIdLp-1].m_tPeriEqpStatus.m_byOnline ) // 在线
		{
			if (IsPeriEqpValid(byPrsIdLp) 
				&& EQP_TYPE_PRS == GetEqpType(byPrsIdLp) ) // 合法性检测
			{
				ptStatus = &(m_atPeriEqpTable[byPrsIdLp - 1].m_tPeriEqpStatus.m_tStatus.tPrs);
				byPrsChannels += ptStatus->GetIdleChlNum();
            }
        }
		byPrsIdLp++;
    }
	
	if( 0 != byPrsChannels )
	{
		tPrsCap.SetNeedEqp(TRUE);
		tPrsCap.SetNeedChannles( byPrsChannels ); 
	}
	return;
}

/*=============================================================================
  函 数 名： GetConfFECType
  功    能： 
  算法实现： 
  全局变量： 
  参    数： [IN] u8 byConfIdx
             [IN] u8 byMode
  返 回 值： u8: 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2007/10/11  4.0			张宝卿                创建
=============================================================================*/
u8 CMcuVcData::GetConfFECType( u8 byConfIdx, u8 byMode )
{
    u8 byFECType = FECTYPE_NONE;

    if ( byConfIdx > MAX_CONFIDX ) 
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetConfFECType] ConfIdx.%d, unexpected, ignore it\n", byConfIdx );
        return byFECType;
    }

    TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
    if(!tMapData.IsValidConf()) 
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetConfFECType] invalid instance id :%d\n", tMapData.GetInsId());
        return byFECType;
    }
    
    if ( NULL == m_apConfInst[tMapData.GetInsId()-1] )
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetConfFECType] Inst.%d has no conf, unexpected\n", tMapData.GetInsId());
        return byFECType;
    }
    switch( byMode )
    {
    case MODE_AUDIO:
        byFECType = m_apConfInst[tMapData.GetInsId()-1]->m_tConf.GetCapSupportEx().GetAudioFECType();
        break;

    case MODE_VIDEO:
        byFECType = m_apConfInst[tMapData.GetInsId()-1]->m_tConf.GetCapSupportEx().GetVideoFECType();
    	break;

    case MODE_BOTH:
        {
        u8 byFECTypeA = m_apConfInst[tMapData.GetInsId()-1]->m_tConf.GetCapSupportEx().GetAudioFECType();
        u8 byFECTypeV = m_apConfInst[tMapData.GetInsId()-1]->m_tConf.GetCapSupportEx().GetVideoFECType();
        byFECType = byFECTypeA == byFECTypeV ? byFECTypeV : FECTYPE_NONE;
        }
        break;

    case MODE_SECVIDEO:
        byFECType = m_apConfInst[tMapData.GetInsId()-1]->m_tConf.GetCapSupportEx().GetDVideoFECType();
        break;

    default:
        LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetConfFECType] unexpected mode.%d, ignore it\n", byMode );
        break;
    }

    return byFECType;
}

/*=============================================================================
  函 数 名： GetConfEncryptMode
  功    能： 
  算法实现： 
  全局变量： 
  参    数： [IN] u8 byConfIdx
  返 回 值： u8: 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2007/10/16  4.0			张宝卿                创建
=============================================================================*/
u8 CMcuVcData::GetConfEncryptMode( u8 byConfIdx )
{
    u8 byEncMode = CONF_ENCRYPTMODE_NONE;

    if ( byConfIdx > MAX_CONFIDX ) 
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetConfEncryptMode] ConfIdx.%d, unexpected, ignore it\n", byConfIdx );
        return byEncMode;
    }
    TConfMapData tMapData = m_atConfMapData[byConfIdx-MIN_CONFIDX];
    if(!tMapData.IsValidConf()) 
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetConfEncryptMode] invalid instance id :%d\n", tMapData.GetInsId());
        return byEncMode;
    }
    
    if ( NULL == m_apConfInst[tMapData.GetInsId()-1] )
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetConfEncryptMode] ConfIdx.%d unexist, ignore it\n", byConfIdx );
        return byEncMode;
    }

    return m_apConfInst[tMapData.GetInsId()-1]->m_tConf.GetMediaKey().GetEncryptMode();
}

/********************************************

        用户组扩展

  *******************************************/


/*=============================================================================
  函 数 名： GetGrpById
  功    能：根据GroupId查找组，没找到返回False
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： BOOL32       FALSE 没有找到
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
=============================================================================*/
BOOL32 CUsrGrpsInfo::GetGrpById(u8 byGrpId, TUsrGrpInfo &tGrpInfo) const
{
    tGrpInfo.SetNull();
    if (byGrpId == USRGRPID_INVALID ||
        byGrpId > MAXNUM_USRGRP)
    {
        // 非法
        return FALSE;
    }
    tGrpInfo = m_atInfo[byGrpId-1];
    return TRUE;
    
    /*
    for ( s32 nLoop = 0; nLoop < m_nGrpNum; nLoop ++ )
    {
        if ( m_atInfo[ nLoop ].GetUsrGrpId() == byGrpId )
        {
            tGrpInfo = m_atInfo[nLoop];
            return TRUE;
        }
    }    
    */
    
}


/*=============================================================================
  函 数 名： GetGrpByName
  功    能：根据组名查找组，没找到返回False
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： BOOL32       FALSE 没有找到
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
=============================================================================*/
BOOL32 CUsrGrpsInfo::GetGrpByName(LPCSTR szName,  TUsrGrpInfo &tGrpInfo) const
{
    tGrpInfo.SetNull();
    for ( s32 nLoop = 0; nLoop < MAXNUM_USRGRP; nLoop ++ )
    {
        if ( strncmp( m_atInfo[ nLoop ].GetUsrGrpName(), szName, MAX_CHARLENGTH ) == 0 )
        {
            tGrpInfo = m_atInfo[nLoop];
            return TRUE;
        }
    }    
    return FALSE;    
}


/*=============================================================================
  函 数 名： AddGrp
  功    能：添加组。返回组Id，已满返回 USRGRPID_INVALID
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： u8         组Id
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
    06/09/07    4.0         顾振华        调整策略，允许用户自己配制组ID
=============================================================================*/
u8 CUsrGrpsInfo::AddGrp ( const TUsrGrpInfo &tGrpInfo )
{
/*
    if ( m_nGrpNum >= MAXNUM_USRGRP )
    {
        return USRGRPID_INVALID;
    }

    TUsrGrpInfo tTargetInfo = tGrpInfo;
    // 查找第一个可用的组ID
    tTargetInfo.byGrpId = USRGRPID_INVALID;
    
    BOOL32 bIdUsed[MAXNUM_USRGRP + 1];
    memset( &bIdUsed, 0, sizeof(bIdUsed) );
    u8 byLoop = 0;
    for (; byLoop < m_nGrpNum; byLoop ++)
    {
        bIdUsed [ m_atInfo[byLoop].byGrpId ] = TRUE;
    }

    for ( byLoop = 1; byLoop < MAXNUM_USRGRP + 1; byLoop ++)
    {
        if ( !bIdUsed[byLoop] )
        {
            // 第一个未使用的
            break;
        }
    }

    if ( byLoop > MAXNUM_USRGRP )
    {
        // 没有空闲，应该不可能
        return USRGRPID_INVALID;           
    }
    
    tTargetInfo.byGrpId = byLoop;
    m_atInfo[m_nGrpNum] = tTargetInfo;
    m_nGrpNum ++;
    return tTargetInfo.byGrpId;
*/
    
    u8 byTargetId = tGrpInfo.GetUsrGrpId();
    TUsrGrpInfo tOldOne;
    if ( GetGrpById(byTargetId, tOldOne) )
    {
        if (!tOldOne.IsFree())
        {
            // 组ID已用
            return USRGRPID_INVALID;
        }
    }
    else
    {
        // 非法
        return USRGRPID_INVALID;
    }

    // 保存
    m_atInfo[byTargetId-1] = tGrpInfo;
    return byTargetId;
}


/*=============================================================================
  函 数 名： ChgGrp
  功    能：修改组操作，返回是否找到
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： BOOL32
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
=============================================================================*/
BOOL32 CUsrGrpsInfo::ChgGrp ( const TUsrGrpInfo &tGrpInfo )
{
    TUsrGrpInfo tOldOne;
    if ( !GetGrpById(tGrpInfo.GetUsrGrpId(), tOldOne) ) 
    {
        return FALSE;
    }
    if (tOldOne.IsFree())
    {
        return FALSE;
    }

    m_atInfo[tGrpInfo.GetUsrGrpId()-1] = tGrpInfo;

    return TRUE;
}

/*=============================================================================
  函 数 名： DelGrp
  功    能： 删除组操作。不进行相关其他资源释放操作。返回是否找到
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： BOOL32
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
=============================================================================*/
BOOL32 CUsrGrpsInfo::DelGrp ( u8 byGrpId )
{
    /*
    for (s32 nLoop = 0; nLoop < m_nGrpNum; nLoop ++)
    {
        if ( m_atInfo[nLoop].byGrpId == byGrpId )
        {
            // 找到则删除
            // 移动后面的
            for ( s32 nLoop2 = nLoop + 1; nLoop2 < m_nGrpNum; nLoop2 ++ )
            {
                m_atInfo[nLoop2 - 1] = m_atInfo[nLoop2];
            }

            m_atInfo[m_nGrpNum-1].SetNull();
            m_nGrpNum --;

            return TRUE;
        }
    }
    return FALSE;    
    */

    TUsrGrpInfo tOldOne;
    if ( !GetGrpById(byGrpId, tOldOne) ) 
    {
        return FALSE;
    }
    if (tOldOne.IsFree())
    {
        return FALSE;
    }

    m_atInfo[byGrpId-1].SetNull();
    return TRUE;
}

/*=============================================================================
  函 数 名： Save
  功    能： 保存到文件
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： BOOL32
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
=============================================================================*/
BOOL32 CUsrGrpsInfo::Save() const
{
    s8 szPath[KDV_MAX_PATH] = {0};
    
    sprintf(szPath, "%s/%s", DIR_DATA, USERGRPINFOFILENAME);

    FILE *fp;
    fp = fopen( szPath, "wb" );
    if (fp == NULL)
    {
        return FALSE;
    }

    //fwrite( &m_nGrpNum, sizeof(s32), 1, fp );  
    //fwrite( m_atInfo, sizeof( TUsrGrpInfo ), m_nGrpNum, fp );
    s32 nTmp = MAXNUM_USRGRP;
    fwrite( &nTmp, sizeof(s32), 1, fp );  
    fwrite( m_atInfo, sizeof( TUsrGrpInfo ), MAXNUM_USRGRP, fp );

	// 多国语言 [pengguofeng 4/12/2013]
#ifdef _UTF8
	u8 byIsUtf8 = 1;
	fwrite(&byIsUtf8, 1, 1, fp);
#endif

#ifdef WIN32
    fflush(fp);
#endif

    fclose(fp);

    return TRUE;       
}


/*=============================================================================
  函 数 名： Load
  功    能： 用户组信息从文件读取
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： BOOL32
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
=============================================================================*/
BOOL32 CUsrGrpsInfo::Load()
{
    s8 szPath[KDV_MAX_PATH] = {0};
    
    sprintf(szPath, "%s/%s", DIR_DATA, USERGRPINFOFILENAME);

    FILE *fp;
    fp = fopen( szPath, "rb" );
    if (fp == NULL)
    {
        return FALSE;
    }

    fread( &m_nGrpNum, sizeof(s32), 1, fp );  
    fread( m_atInfo, sizeof( TUsrGrpInfo ), m_nGrpNum, fp );
#ifdef _UTF8
	u8 byIsUtf8 = 0; //多国语言支持
	fread(&byIsUtf8, 1, 1, fp);
	s8 achGrpInfo[2*MAX_CHARLENGTH];
	// 非1表示GBK，需要转 [pengguofeng 4/12/2013]
	if ( byIsUtf8 != 1)
	{
		// 防止读出来的m_nGrpNum不正确 [pengguofeng 7/24/2013]
		for ( s32 nLoop = 0; nLoop < m_nGrpNum && nLoop < MAXNUM_USRGRP; nLoop++)
		{
			memset(achGrpInfo, 0, sizeof(achGrpInfo));
			const s8 *pGrpInfo = m_atInfo[nLoop].GetUsrGrpName();
			if ( pGrpInfo && strlen(pGrpInfo) > 0 )
			{
				gb2312_to_utf8(pGrpInfo, achGrpInfo, MAX_CHARLENGTH-1);
				m_atInfo[nLoop].SetUsrGrpName(achGrpInfo);
			}
			
			pGrpInfo = m_atInfo[nLoop].GetUsrGrpDesc();
			if ( pGrpInfo && strlen(pGrpInfo) > 0 )
			{
				memset(achGrpInfo, 0, sizeof(achGrpInfo));
				gb2312_to_utf8(pGrpInfo, achGrpInfo, 2*MAX_CHARLENGTH-1);
				m_atInfo[nLoop].SetUsrGrpDesc(achGrpInfo);
			}
		}
	}
#endif
    //m_nGrpNum = MAXNUM_USRGRP;
	SetGrpNum(MAXNUM_USRGRP);

    fclose(fp);

    return TRUE;
}

/*=============================================================================
  函 数 名： Print
  功    能： 调试打印
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
=============================================================================*/
void CUsrGrpsInfo::Print() const
{
	s32 nGrpNum = GetGrpNum();
    StaticLog( "User Group Info, Total Number: %d\n", m_nGrpNum);
    for (s32 nIndex = 0; nIndex < nGrpNum; nIndex ++)
    {
		if( nIndex >= MAXNUM_USRGRP )
		{
			break;
		}
        if (m_atInfo[nIndex].IsFree())
        {
            continue;
        }
        StaticLog( "User Group Info Index: %d\n", nIndex);
        m_atInfo[nIndex].Print();
        // 哪些用户属于这个组

        StaticLog( "\tUsers in Group:\n");
        CExUsrInfo cInfo;
        for ( s32 nUserLoop = 0; nUserLoop < g_cUsrManage.GetUserNum(); nUserLoop ++ )
        {
            g_cUsrManage.GetUserFullInfo( &cInfo, nUserLoop );
            if ( cInfo.GetUsrGrpId() == m_atInfo[nIndex].GetUsrGrpId() )
            {
                StaticLog( "\t\t%s\n", cInfo.GetName());
            }
        }
    }
}

/*=============================================================================
  函 数 名： GetUsrGrpUserCount
  功    能： 获取该组用户当前数量和最大值
  算法实现： 
  全局变量： 
  参    数： cUsrGrpObj: 操作的用户管理对象
			 cUsrGrp:    操作的用户组管理对象             
			 byGrpId：   指定的用户组号
             byMaxNum：  指定组允许加入的最大用户数
			 byNum：     指定组目前的用户数
  返 回 值： BOOL32              FALSE 没有找到
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
	08/11/21                付秀华        对于两类控制台（VCS MCS）采取两类不同的用户管理对象
	                                      各自操作各自的用户对象
=============================================================================*/
BOOL32  CMcuVcData::GetUsrGrpUserCount(CUsrManage& cUsrManageObj, 
									   CUsrGrpsInfo& cUsrGrpObj, u8 byGrpId, 
									   u8 &byMaxNum, u8 &byNum)
{
    //若为N+1备份工作模式（即切换后），取内存中的信息
    if (MCU_NPLUS_SLAVE_SWITCH == g_cNPlusApp.GetLocalNPlusState())
    {
        u8 byInsId = g_cNPlusApp.GetMcuSwitchedInsId();
        if (0 == byInsId || byInsId > MAXNUM_NPLUS_MCU)
        {
            LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetUsrGrpUserCount] McuSwitchedInsId is invalid in NPlus switched mode.\n");
            return FALSE;
        }
        else
        {
            CApp *pcApp = &g_cNPlusApp;
            CNPlusInst *pcInst = (CNPlusInst *)pcApp->GetInstance(byInsId);
            if (NULL != pcInst)
            {
                return pcInst->GetGrpUsrCount(byGrpId, byMaxNum, byNum);
            }
            else
            {
                LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[GetUsrGrpUserCount] GetInstance(%d) failed.\n", byInsId);
                return FALSE;
            }
        }                
    }

    if (byGrpId == USRGRPID_SADMIN)
    {
        // 如果是超级管理员返回系统值
        byMaxNum = MAXNUM_GRPUSRNUM;
        byNum = cUsrManageObj.GetUserNum();
        return TRUE;
    }

    TUsrGrpInfo tGrpInfo;
    BOOL32 bRet = cUsrGrpObj.GetGrpById( byGrpId, tGrpInfo );

    byNum = 0;
    byMaxNum = 0;

    if ( !bRet )
    {
        // 没找到
        return FALSE;
    }

    byMaxNum = tGrpInfo.GetMaxUsrNum();

    s32 nTotalUserNum = cUsrManageObj.GetUserNum();

    CExUsrInfo cUsrInfo;

    for (s32 nUsrLoop = 0; nUsrLoop < nTotalUserNum; nUsrLoop ++)
    {
        cUsrManageObj.GetUserFullInfo( &cUsrInfo, nUsrLoop );
        if ( byGrpId == cUsrInfo.GetUsrGrpId() )
        {
            byNum ++;
        }
    }
    return TRUE;
}

/*=============================================================================
  函 数 名： GetMCSUsrGrpUserCount
  功    能： 获取MCS控制台对应用户组的用户当前数量和最大值
  算法实现： 
  全局变量： 
  参    数：        
			 byGrpId：   指定的用户组号
             byMaxNum：  指定组允许加入的最大用户数
			 byNum：     指定组目前的用户数
  返 回 值： BOOL32              FALSE 没有找到
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	08/11/21                付秀华        创建
=============================================================================*/
BOOL32  CMcuVcData::GetMCSUsrGrpUserCount(u8 byGrpId, u8 &byMaxNum, u8 &byNum)
{
	return GetUsrGrpUserCount(g_cUsrManage, m_cUsrGrpInfo, byGrpId, byMaxNum, byNum);
}
/*=============================================================================
  函 数 名： GetVCSUsrGrpUserCount
  功    能： 获取VCS控制台对应用户组的用户当前数量和最大值
  算法实现： 
  全局变量： 
  参    数：        
			 byGrpId：   指定的用户组号
             byMaxNum：  指定组允许加入的最大用户数
			 byNum：     指定组目前的用户数
  返 回 值： BOOL32              FALSE 没有找到
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	08/11/21                付秀华        创建
=============================================================================*/
BOOL32  CMcuVcData::GetVCSUsrGrpUserCount(u8 byGrpId, u8 &byMaxNum, u8 &byNum)
{
	return GetUsrGrpUserCount(g_cVCSUsrManage, m_cVCSUsrGrpInfo, byGrpId, byMaxNum, byNum);
}

/*=============================================================================
  函 数 名： AddUserGroup
  功    能： 增加一个用户组
  算法实现： CUsrGrpsInfo: 操作的用户组对象
             TUsrGrpInfo:  添加的用户组信息
			 wErrorNo：    失败原因
  全局变量： 
  参    数： 
  返 回 值： u8              返回组ID，如USRGRPID_INVALID 表示添加失败，填写wErrorNo。
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
    06/09/07    4.0         顾振华        调整策略，允许用户自己配制用户组ID
=============================================================================*/
u8 CMcuVcData::AddUserGroup( CUsrGrpsInfo &cUsrGrpObj, const TUsrGrpInfo &tGrpInfo, u16 &wErrorNo  )
{
    wErrorNo = 0;
    /*
    TUsrGrpInfo tOldOne;
    if ( m_cUsrGrpInfo.GetGrpByName( tGrpInfo.szName, tOldOne ) )
    {
        // 已存在
        wErrorNo = UM_EX_USRGRPDUP;
        return USRGRPID_INVALID;
    }

    u8 byGrpId = m_cUsrGrpInfo.AddGrp( tGrpInfo );

    if (byGrpId == USRGRPID_INVALID)
    {
        // 用户组满
        wErrorNo = UM_EX_USRGRPFULL;
    }
    else
    {
        m_cUsrGrpInfo.Save();
    } 
    */
    
    if (tGrpInfo.GetUsrGrpId() == USRGRPID_INVALID ||
        tGrpInfo.GetUsrGrpId() > MAXNUM_USRGRP)
    {
        // 非法保护
        wErrorNo = UM_EX_USRGRPIDINV;
        return USRGRPID_INVALID;
    }
    TUsrGrpInfo tOldOne;
    if ( cUsrGrpObj.GetGrpByName( tGrpInfo.GetUsrGrpName(), tOldOne ) )
    {
        //  组名已存在
        wErrorNo = UM_EX_USRGRPDUP;
        return USRGRPID_INVALID;
    }

    u8 byGrpId = cUsrGrpObj.AddGrp( tGrpInfo );

    if (byGrpId == USRGRPID_INVALID)
    {
        // 组ID已存在
        wErrorNo = UM_EX_USRGRPIDDUP;
    }
    else
    {
        cUsrGrpObj.Save();
    } 

    return byGrpId;
}

/*=============================================================================
  函 数 名： AddMCSUserGroup
  功    能： 增加一个MCS用户组
  算法实现：
             TUsrGrpInfo:  添加的用户组信息
			 wErrorNo：    失败原因
  全局变量： 
  参    数： 
  返 回 值： u8              返回组ID，如USRGRPID_INVALID 表示添加失败，填写wErrorNo。
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	08/11/21                付秀华        创建
=============================================================================*/
u8 CMcuVcData::AddMCSUserGroup( const TUsrGrpInfo &tGrpInfo, u16 &wErrorNo  )
{
    return AddUserGroup(m_cUsrGrpInfo, tGrpInfo, wErrorNo);
}

/*=============================================================================
  函 数 名： AddVCSUserGroup
  功    能： 增加一个VCS用户组
  算法实现：
             TUsrGrpInfo:  添加的用户组信息
			 wErrorNo：    失败原因
  全局变量： 
  参    数： 
  返 回 值： u8              返回组ID，如USRGRPID_INVALID 表示添加失败，填写wErrorNo。
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	08/11/21                付秀华        创建
=============================================================================*/
u8 CMcuVcData::AddVCSUserGroup( const TUsrGrpInfo &tGrpInfo, u16 &wErrorNo  )
{
    return AddUserGroup(m_cVCSUsrGrpInfo, tGrpInfo, wErrorNo);
}

/*=============================================================================
  函 数 名： ChgUserGroup
  功    能： 修改一个用户组，如果失败填写 wErrorNo
  算法实现： 
  全局变量： 
  参    数： CUsrGrpsInfo: 操作的用户组对象
             TUsrGrpInfo:  添加的用户组信息
			 wErrorNo：    失败原因
  返 回 值： BOOL32
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
=============================================================================*/
BOOL32 CMcuVcData::ChgUserGroup(CUsrGrpsInfo &cUsrGrpObj, const TUsrGrpInfo &tGrpInfo, u16 &wErrorNo )
{
    wErrorNo = 0;

    if ( !cUsrGrpObj.ChgGrp( tGrpInfo ) )
    {
        // 没有找到
        wErrorNo = UM_EX_USRGRPNOEXIST;
        return FALSE;
    }

    cUsrGrpObj.Save();

    return TRUE;    
}
/*=============================================================================
  函 数 名： ChgMCSUserGroup
  功    能： 修改MCS的一个用户组，如果失败填写 wErrorNo
  算法实现： 
  全局变量： 
  参    数： TUsrGrpInfo:  修改的用户组信息
			 wErrorNo：    失败原因
  返 回 值： BOOL32
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	08/11/21                付秀华        创建
=============================================================================*/
BOOL32 CMcuVcData::ChgMCSUserGroup(const TUsrGrpInfo &tGrpInfo, u16 &wErrorNo )
{
    return ChgUserGroup(m_cUsrGrpInfo, tGrpInfo, wErrorNo);  
}

/*=============================================================================
  函 数 名： ChgVCSUserGroup
  功    能： 修改VCS的一个用户组，如果失败填写 wErrorNo
  算法实现： 
  全局变量： 
  参    数： TUsrGrpInfo:  添加的用户组信息
			 wErrorNo：    失败原因
  返 回 值： BOOL32
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	08/11/21                付秀华        创建
=============================================================================*/
BOOL32 CMcuVcData::ChgVCSUserGroup(const TUsrGrpInfo &tGrpInfo, u16 &wErrorNo )
{
    return ChgUserGroup(m_cVCSUsrGrpInfo, tGrpInfo, wErrorNo);  
}
/*=============================================================================
  函 数 名： DelMCSUserGroup
  功    能： 删除一个MCS用户组，同时完成相关的资源释放。如果失败填写 wErrorNo
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： BOOL32
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
=============================================================================*/
BOOL32 CMcuVcData::DelMCSUserGroup( u8 byGrpId, u16 &wErrorNo )
{
    wErrorNo = 0;

    if ( ! m_cUsrGrpInfo.DelGrp( byGrpId ) )
    {
        // 没有找到
        wErrorNo = UM_EX_USRGRPNOEXIST;
        return FALSE;
    }

    // 删除所有相关的信息，包括用户、模版、会议等
    CServMsg cServMsg;
    cServMsg.SetMcuId(LOCAL_MCUID);
    cServMsg.SetSrcMtId(0);
    cServMsg.SetSrcSsnId(0);
    
    cServMsg.SetMsgBody();
    


    s32 nUserNum = g_cUsrManage.GetUserNum();
    CExUsrInfo cInfo;
    for (s32 nLoop = nUserNum -1 ;nLoop >= 0; nLoop --)
    {
        g_cUsrManage.GetUserFullInfo( &cInfo, nLoop);
        if (cInfo.GetUsrGrpId() == byGrpId)
        {
            g_cUsrManage.DelUser( &cInfo );

            // 通知
            cServMsg.SetEventId(MCU_MCS_DELUSER_NOTIF);
            cServMsg.SetMsgBody( (u8*)cInfo.GetName(), MAX_CHARLENGTH );
			g_cMcsSsnApp.Broadcast2SpecGrpMcsSsn( byGrpId, MCU_MCS_DELUSER_NOTIF, 
											      cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
        }
    }


    cServMsg.SetMsgBody();

	for (u8 byConfIdx = MIN_CONFIDX; byConfIdx <= MAX_CONFIDX; byConfIdx++)
	{
		TConfMapData tMapData = g_cMcuVcApp.GetConfMapData(byConfIdx);
		if (tMapData.IsTemUsed())
		{
			TTemplateInfo tTemConf;
			if (g_cMcuVcApp.GetTemplate(byConfIdx, tTemConf))
			{
                if ( byGrpId == tTemConf.m_tConfInfo.GetUsrGrpId() &&
					 MCS_CONF == tTemConf.m_tConfInfo.GetConfSource())
                {
                    // 结束模版                            
                    cServMsg.SetEventId(MCS_MCU_DELTEMPLATE_REQ);
                    cServMsg.SetConfId( tTemConf.m_tConfInfo.GetConfId() );
                    g_cMcuVcApp.SendMsgToDaemonConf(MCS_MCU_DELTEMPLATE_REQ,
                                                    cServMsg.GetServMsg(), cServMsg.GetServMsgLen());                    
                }
			}
		}

        
		if (tMapData.IsValidConf())
		{
			CMcuVcInst *pcMcuVcInst = g_cMcuVcApp.GetConfInstHandle( byConfIdx );
			if (NULL == pcMcuVcInst)
			{
				continue;
			}

			TConfInfo* ptConfInfo = &pcMcuVcInst->m_tConf;
            if ( byGrpId == ptConfInfo->GetUsrGrpId() && 
				 MCS_CONF == ptConfInfo->GetConfSource())
            {
                // 结束会议
                cServMsg.SetEventId(MCS_MCU_RELEASECONF_REQ);
                cServMsg.SetConfId( ptConfInfo->GetConfId() );
                g_cMcuVcApp.SendMsgToConf(cServMsg.GetConfId(), MCS_MCU_RELEASECONF_REQ,
                                          cServMsg.GetServMsg(), cServMsg.GetServMsgLen());  
            }
		}
	}        

    // TODO: 删除用户组暂时不删除相关会议录像

    m_cUsrGrpInfo.Save();

    return TRUE;
}
/*=============================================================================
  函 数 名： DelVCSUserGroup
  功    能： 删除一个VCS用户组，同时完成相关的资源释放。如果失败填写 wErrorNo
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： BOOL32
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
=============================================================================*/
BOOL32 CMcuVcData::DelVCSUserGroup( u8 byGrpId, u16 &wErrorNo )
{
    wErrorNo = 0;

    if ( ! m_cVCSUsrGrpInfo.DelGrp( byGrpId ) )
    {
        // 没有找到
        wErrorNo = UM_EX_USRGRPNOEXIST;
        return FALSE;
    }

    // 删除所有相关的信息，包括用户、模版、会议等
    CServMsg cServMsg;
    cServMsg.SetMcuId(LOCAL_MCUID);
    cServMsg.SetSrcMtId(0);
    cServMsg.SetSrcSsnId(0);    
    cServMsg.SetMsgBody();
    


    s32 nUserNum = g_cVCSUsrManage.GetUserNum();
    CExUsrInfo cInfo;
    for (s32 nLoop = nUserNum -1 ;nLoop >= 0; nLoop --)
    {
        g_cVCSUsrManage.GetUserFullInfo( &cInfo, nLoop);
        if (cInfo.GetUsrGrpId() == byGrpId)
        {
            g_cVCSUsrManage.DelUser( &cInfo );

            // 通知
            cServMsg.SetEventId(MCU_MCS_DELUSER_NOTIF);
            cServMsg.SetMsgBody( (u8*)cInfo.GetName(), MAX_CHARLENGTH );
			g_cVcsSsnApp.Broadcast2SpecGrpVcsSsn( byGrpId, MCU_MCS_DELUSER_NOTIF, 
											      cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
        }
    }


    cServMsg.SetMsgBody();

	for (u8 byConfIdx = MIN_CONFIDX; byConfIdx <= MAX_CONFIDX; byConfIdx++)
	{
		TConfMapData tMapData = g_cMcuVcApp.GetConfMapData(byConfIdx);
		if (tMapData.IsTemUsed())
		{
			TTemplateInfo tTemConf;
			if (g_cMcuVcApp.GetTemplate(byConfIdx, tTemConf))
			{
                if ( byGrpId == tTemConf.m_tConfInfo.GetUsrGrpId() &&
					 VCS_CONF == tTemConf.m_tConfInfo.GetConfSource())
                {
                    // 结束模版                            
                    cServMsg.SetEventId(MCS_MCU_DELTEMPLATE_REQ);
                    cServMsg.SetConfId(tTemConf.m_tConfInfo.GetConfId());
                    g_cMcuVcApp.SendMsgToDaemonConf(MCS_MCU_DELTEMPLATE_REQ,
                                                    cServMsg.GetServMsg(), cServMsg.GetServMsgLen());                    
                }
			}
		}

        
		if (tMapData.IsValidConf())
		{
			CMcuVcInst *pcMcuVcInst = g_cMcuVcApp.GetConfInstHandle( byConfIdx );
			if (NULL == pcMcuVcInst)
			{
				continue;
			}

			TConfInfo* ptConfInfo = &pcMcuVcInst->m_tConf;
            if ( byGrpId == ptConfInfo->GetUsrGrpId() && 
				 VCS_CONF == ptConfInfo->GetConfSource())
            {
                // 结束会议
                cServMsg.SetEventId(MCS_MCU_RELEASECONF_REQ);
                cServMsg.SetConfId( ptConfInfo->GetConfId() );
                g_cMcuVcApp.SendMsgToConf(cServMsg.GetConfId(), MCS_MCU_RELEASECONF_REQ,
                                          cServMsg.GetServMsg(), cServMsg.GetServMsgLen());  
            }
		}
	}        

    // TODO: 删除用户组暂时不删除相关会议录像

    m_cVCSUsrGrpInfo.Save();

    return TRUE;
}

/*=============================================================================
  函 数 名： GetMCSUserGroupInfo
  功    能： 获取所有用户组信息
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
=============================================================================*/
void  CMcuVcData::GetMCSUserGroupInfo ( u8 &byNum, TUsrGrpInfo **ptInfo )
{
    //若为N+1备份工作模式（即切换后），取内存中的信息
    if (MCU_NPLUS_SLAVE_SWITCH == g_cNPlusApp.GetLocalNPlusState())
    {
        u8 byInsId = g_cNPlusApp.GetMcuSwitchedInsId();
        if (0 == byInsId || byInsId > MAXNUM_NPLUS_MCU)
        {
            LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[GetUsrGrpUserCount] McuSwitchedInsId is invalid in NPlus switched mode.\n");
        }
        else
        {
            CApp *pcApp = &g_cNPlusApp;
            CNPlusInst *pcInst = (CNPlusInst *)pcApp->GetInstance(byInsId);
            if (NULL != pcInst)
            {
                CUsrGrpsInfo* pcUsrGrpsInfo = pcInst->GetUsrGrpInfo();
                byNum = pcUsrGrpsInfo->GetGrpNum();
                *ptInfo = pcUsrGrpsInfo->m_atInfo;                
            }
            else
            {
                LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[GetUsrGrpUserCount] GetInstance(%d) failed.\n", byInsId);
            }
        }                
        return ;
    }

    // 普通模式
    byNum = (u8)m_cUsrGrpInfo.GetGrpNum();

    *ptInfo = m_cUsrGrpInfo.m_atInfo;

}
/*=============================================================================
  函 数 名： GetVCSUserGroupInfo
  功    能： 获取VCS所有用户组信息
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	08/11/21                付秀华        创建
=============================================================================*/
void  CMcuVcData::GetVCSUserGroupInfo ( u8 &byNum, TUsrGrpInfo **ptInfo )
{
    //若为N+1备份工作模式（即切换后），取内存中的信息
//     if (MCU_NPLUS_SLAVE_SWITCH == g_cNPlusApp.GetLocalNPlusState())
//     {
//         u8 byInsId = g_cNPlusApp.GetMcuSwitchedInsId();
//         if (0 == byInsId || byInsId > MAXNUM_NPLUS_MCU)
//         {
//             LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[GetUsrGrpUserCount] McuSwitchedInsId is invalid in NPlus switched mode.\n");
//         }
//         else
//         {
//             CApp *pcApp = &g_cNPlusApp;
//             CNPlusInst *pcInst = (CNPlusInst *)pcApp->GetInstance(byInsId);
//             if (NULL != pcInst)
//             {
//                 CUsrGrpsInfo* pcUsrGrpsInfo = pcInst->GetUsrGrpInfo();
//                 byNum = pcUsrGrpsInfo->GetGrpNum();
//                 *ptInfo = pcUsrGrpsInfo->m_atInfo;                
//             }
//             else
//             {
//                 LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[GetUsrGrpUserCount] GetInstance(%d) failed.\n", byInsId);
//             }
//         }                
//         return ;
//     }

    // 普通模式
    byNum = (u8)m_cVCSUsrGrpInfo.GetGrpNum();

    *ptInfo = m_cVCSUsrGrpInfo.m_atInfo;

}
/*=============================================================================
函 数 名： GetUserGroupInfo
功    能： 
算法实现： 
全局变量： 
参    数： void
返 回 值： CUsrGrpsInfo * 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/11/23  4.0			许世林                  创建
=============================================================================*/
CUsrGrpsInfo * CMcuVcData::GetUserGroupInfo( void )
{
    //若为N+1备份工作模式（即切换后），取内存中的信息
    if (MCU_NPLUS_SLAVE_SWITCH == g_cNPlusApp.GetLocalNPlusState())
    {
        u8 byInsId = g_cNPlusApp.GetMcuSwitchedInsId();
        if (0 == byInsId || byInsId > MAXNUM_NPLUS_MCU)
        {
            LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[GetUsrGrpUserCount] McuSwitchedInsId is invalid in NPlus switched mode.\n");
            return NULL;
        }
        else
        {
            CApp *pcApp = &g_cNPlusApp;
            CNPlusInst *pcInst = (CNPlusInst *)pcApp->GetInstance(byInsId);
            if (NULL != pcInst)
            {
                return pcInst->GetUsrGrpInfo();
            }
            else
            {
                LogPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[GetUsrGrpUserCount] GetInstance(%d) failed.\n", byInsId);
                return NULL;
            }
        }                
    }

	// error 1536: (Warning -- Exposing low access member 'CMcuVcData::m_cUsrGrpInfo')
	/*lint -save -e1536*/

    // 普通模式
    return &m_cUsrGrpInfo;

	/*lint -restore*/

}


/*=============================================================================
  函 数 名： IsMtIpInAllowSeg
  功    能： 指定IP是否在指定用户组的允许范围内
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
=============================================================================*/
BOOL32 CMcuVcData::IsMtIpInAllowSeg ( u8 byGrpId, u32 dwIp )
{
    TUsrGrpInfo tGroup;
    
    if (byGrpId == USRGRPID_SADMIN)
    {
        // guzh [7/26/2006] 如果是超级用户组，直接认为不允许
        return FALSE;
    }
    if (byGrpId == USRGRPID_INVALID)
    {
        return TRUE;
    }

    if ( !m_cUsrGrpInfo.GetGrpById(byGrpId, tGroup) )
    {
        return FALSE;
    }
    if ( tGroup.IsFree() )
    {
        // 用户组空
        return FALSE;
    }

    return tGroup.IsMtIpInAllowSeg(dwIp);
}

/*=============================================================================
  函 数 名： PrtUserGroup
  功    能： 调试打印
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/23    4.0         顾振华        创建
=============================================================================*/
void CMcuVcData::PrtUserGroup()
{
    m_cUsrGrpInfo.Print();
	m_cVCSUsrGrpInfo.Print();
	m_cVCSUsrTaskInfo.Print();
}


/*=============================================================================
  函 数 名： GetCMultiSpyMgr
  功    能： 调试打印
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	10/02/01    4.0         彭杰        创建
=============================================================================*/
CMultiSpyMgr* CMcuVcData::GetCMultiSpyMgr( void )
{
	/*lint -save -e1536*/
	return &m_cMultiSpyMgr;
	/*lint -restore*/
}

/*=============================================================================
  函 数 名： AddUserTaskInfo
  功    能： 添加用户分配的任务信息
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： FALSE:用户已存在/用户数已满
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/11/24    4.5         付秀华        创建
=============================================================================*/
BOOL  CUsersTaskInfo::AddUserTaskInfo(TUserTaskInfo& tUserTaskInfo)
{
	u16 wSpacePos = MAXNUM_VCSUSERNUM;
	for (u16 wIndex = 0; wIndex < MAXNUM_VCSUSERNUM; wIndex++)
	{
		if (0 == strcmp(tUserTaskInfo.GetUserName(), m_tUserTaskInfo[wIndex].GetUserName()))
		{
			// 用户已存在
			return FALSE;
		}
		// 找到空闲的位置放新的用户信息，从小存放起
		if (!m_abyUsed[wIndex] && wSpacePos == MAXNUM_VCSUSERNUM)
		{
			wSpacePos = wIndex;
		}
	}

	if (MAXNUM_VCSUSERNUM == wSpacePos)
	{
		return FALSE;
	}
	else
	{
		m_abyUsed[wSpacePos] = 1;
		memcpy(&m_tUserTaskInfo[wSpacePos], &tUserTaskInfo, sizeof(TUserTaskInfo));
		SaveUsersTaskInfo();
		return TRUE;
	}
}

/*=============================================================================
  函 数 名： DelUserTaskInfo
  功    能： 删除用户分配的任务信息
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： FALSE:指定删除的用户不存在
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/11/24    4.5         付秀华        创建
=============================================================================*/
BOOL  CUsersTaskInfo::DelUserTaskInfo(s8* pachUserName)
{
	u16 wUserPos = MAXNUM_VCSUSERNUM;
	for (u16 wIndex = 0; wIndex < MAXNUM_VCSUSERNUM; wIndex++)
	{
		if (0 == strcmp(pachUserName, m_tUserTaskInfo[wIndex].GetUserName()))
		{
			wUserPos = wIndex;
			break;
		}
	}

	if (MAXNUM_VCSUSERNUM == wUserPos)
	{
		return FALSE;
	}
	else
	{
		m_abyUsed[wUserPos] = 0;
		memset(&m_tUserTaskInfo[wUserPos], 0, sizeof(TUserTaskInfo));
		SaveUsersTaskInfo();
		return TRUE;
	}
}
/*=============================================================================
  函 数 名： DelSpecTaskInfo
  功    能： 将所有用户中的指定任务删除
  算法实现： 
  全局变量： 
  参    数： [IN]      cConfId：待删除的任务信息
             [IN/OUT]pdwChgIdx：被删除的用户索引
			 [IN/OUT] dwChgNum：被删除的用户数
  返 回 值： 
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/11/24    4.5         付秀华        创建
=============================================================================*/
void  CUsersTaskInfo::DelSpecTaskInfo(CConfId cConfId, u16* const pdwChgIdx, u16& dwChgNum)
{
	u16* pdwTemp = pdwChgIdx;
	dwChgNum = 0;
	for (u16 dwIdx = 0; dwIdx < MAXNUM_VCSUSERNUM; dwIdx++)
	{
		if (m_abyUsed[dwIdx] && m_tUserTaskInfo[dwIdx].IsYourTask(cConfId, TRUE) && pdwChgIdx != NULL)
		{
			*pdwTemp++ = dwIdx;
			dwChgNum++;				
		}
	}
	SaveUsersTaskInfo();
}

/*=============================================================================
  函 数 名： ChgUserTaskInfo
  功    能： 修改用户分配的任务信息
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： FALSE:指定修改的用户不存在
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/11/24    4.5         付秀华        创建
=============================================================================*/
BOOL  CUsersTaskInfo::ChgUserTaskInfo(TUserTaskInfo& tUserTaskInfo)
{
	u16 wUserPos = MAXNUM_VCSUSERNUM;
	for (u16 wIndex = 0; wIndex < MAXNUM_VCSUSERNUM; wIndex++)
	{
		if (0 == strcmp(tUserTaskInfo.GetUserName(), m_tUserTaskInfo[wIndex].GetUserName()))
		{
			wUserPos = wIndex;
			break;
		}
	}

	if (MAXNUM_VCSUSERNUM == wUserPos)
	{
		return FALSE;
	}
	else
	{
		memcpy(&m_tUserTaskInfo[wUserPos], &tUserTaskInfo, sizeof(TUserTaskInfo));
		SaveUsersTaskInfo();
		return TRUE;
	}
}
/*=============================================================================
  函 数 名： GetSpecUserTaskInfo
  功    能： 根据用户名获取指定用户的任务信息
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： FALSE:指定的用户不存在
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/11/24    4.5         付秀华        创建
=============================================================================*/
BOOL  CUsersTaskInfo::GetSpecUserTaskInfo(const s8* pachUserName, TUserTaskInfo& tUserTaskInfo) 
{
	u16 wUserPos = MAXNUM_VCSUSERNUM;
	for (u16 wIndex = 0; wIndex < MAXNUM_VCSUSERNUM; wIndex++)
	{
		if (0 == strcmp(m_tUserTaskInfo[wIndex].GetUserName(), pachUserName))
		{
			wUserPos = wIndex;
			break;
		}
	}

	if (MAXNUM_VCSUSERNUM == wUserPos)
	{
		return FALSE;
	}
	else
	{
		tUserTaskInfo = m_tUserTaskInfo[wUserPos];
		return TRUE;
	}
}
/*=============================================================================
  函 数 名： GetSpecUserTaskInfo
  功    能： 根据索引获取指定用户的任务信息
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： FALSE:指定的用户不存在
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/11/24    4.5         付秀华        创建
=============================================================================*/
BOOL  CUsersTaskInfo::GetSpecUserTaskInfo(u16 dwIdx, TUserTaskInfo& tUserTaskInfo)
{
	if (m_abyUsed[dwIdx])
	{
		tUserTaskInfo = m_tUserTaskInfo[dwIdx];
		return TRUE;
	}
	return FALSE;
}

/*=============================================================================
  函 数 名： IsYourTask
  功    能： 判断该用户是否有操作任务的权限
  算法实现： 
  全局变量： 
  参    数： [IN]pachUserName: 用户名
             [IN]cConfId:      会议ID
  返 回 值： FALSE:指定的用户不能操作该会议
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/11/24    4.5         付秀华        创建
=============================================================================*/
BOOL  CUsersTaskInfo::IsYourTask(const s8* pachUserName, const CConfId& cConfId)
{
	TUserTaskInfo tTaskInfo;
	if(GetSpecUserTaskInfo(pachUserName, tTaskInfo))
	{
		const CConfId* pcConfId = tTaskInfo.GetUserTaskInfo();
		for (u8 byTaskIndex = 0; byTaskIndex < tTaskInfo.GetUserTaskNum(); byTaskIndex++)
		{
			if (cConfId == *pcConfId)
			{
				return TRUE;
			}
			pcConfId++;
		}
	}
	return FALSE;
}


void CMcuVcData::UpdateAgentAuthMtNum()
{
	u16 wAuthMtNum = 0;
	
	// [20110211 miaoqingsong] 解决Bug00043820,获取已占用授权点数for循环修改
	/*for (u8 byMtIdx = 1; byMtIdx <= MAXNUM_CONF_MT; ++byMtIdx)*/
	for (u8 byMtIdx = 1; byMtIdx <= MAXNUM_DRI; ++byMtIdx)
    {
		wAuthMtNum += m_atMtAdpData[byMtIdx-1].m_wMtNum;
	}
	
	g_cMcuAgent.SetAuthMTNum(wAuthMtNum);
	
	LogPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "UpdateAgentAuthMtNum AuthMtNum:%d\n", wAuthMtNum);
}

/*=============================================================================
  函 数 名： SaveUsersTaskInfo
  功    能： 保存所有用户的任务信息到文件
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/11/24    4.5         付秀华        创建
=============================================================================*/
BOOL  CUsersTaskInfo::SaveUsersTaskInfo() const
{
   s8 szPath[KDV_MAX_PATH] = {0};
    
    sprintf(szPath, "%s/%s", DIR_DATA, USERTASKINFOFILENAME);

    FILE *fp;
    fp = fopen( szPath, "wb" );
    if (fp == NULL)
    {
        return FALSE;
    }

	fwrite(m_abyUsed, sizeof(u8), MAXNUM_VCSUSERNUM, fp);
	fwrite(m_tUserTaskInfo, sizeof(TUserTaskInfo), MAXNUM_VCSUSERNUM, fp);
	// 多国语言 [pengguofeng 4/12/2013]
#ifdef _UTF8
	u8 byIsUtf8 = 1;
	fwrite(&byIsUtf8, 1, sizeof(u8), fp);
#endif

#ifdef WIN32
    fflush(fp);
#endif

    fclose(fp);

    return TRUE;    
}
/*=============================================================================
  函 数 名： LoadUsersTaskInfo
  功    能： 下载所有用户的任务信息到文件
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/11/24    4.5         付秀华        创建
=============================================================================*/
BOOL  CUsersTaskInfo::LoadUsersTaskInfo()
{
   s8 szPath[KDV_MAX_PATH] = {0};
    
    sprintf(szPath, "%s/%s", DIR_DATA, USERTASKINFOFILENAME);

    FILE *fp;
    fp = fopen( szPath, "rb" );
    if (fp == NULL)
    {
        return FALSE;
    }

 	fread(m_abyUsed, sizeof(u8), MAXNUM_VCSUSERNUM, fp);
	fread(m_tUserTaskInfo, sizeof(TUserTaskInfo), MAXNUM_VCSUSERNUM, fp);
#ifdef _UTF8
	u8 byIsUtf8 = 0; //多国语言支持　pengguofeng
	fread(&byIsUtf8, 1, 1, fp);
	s8 achUsrName[MAX_CHARLENGTH];
	//非Utf8，必须转码
	if ( byIsUtf8 != 1)
	{
		for ( u8 byLoop = 0; byLoop < MAXNUM_VCSUSERNUM; byLoop++)
		{
			const s8 *pUsrName = m_tUserTaskInfo[byLoop].GetUserName();
			if ( !pUsrName || strlen(pUsrName) == 0 )
			{
				continue;
			}
			
			memset(achUsrName, 0, sizeof(achUsrName));
			gb2312_to_utf8(pUsrName, achUsrName, MAX_CHARLENGTH-1);
			m_tUserTaskInfo[byLoop].SetUserName(achUsrName);
		}
	}
#endif
    fclose(fp);
    return TRUE;    
}

/*=============================================================================
  函 数 名： AddVCSUserTaskInfo
  功    能： 添加VCS用户分配的任务信息
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： FALSE:用户已存在/用户数已满
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/11/24    4.5         付秀华        创建
=============================================================================*/
BOOL  CMcuVcData::AddVCSUserTaskInfo(TUserTaskInfo& tUserTaskInfo)
{
	return m_cVCSUsrTaskInfo.AddUserTaskInfo(tUserTaskInfo);
}

/*=============================================================================
  函 数 名： DelVCSUserTaskInfo
  功    能： 删除VCS用户分配的任务信息
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： FALSE:用户已存在/用户数已满
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/11/24    4.5         付秀华        创建
=============================================================================*/
BOOL  CMcuVcData::DelVCSUserTaskInfo(s8* pachUserName)
{
	return m_cVCSUsrTaskInfo.DelUserTaskInfo(pachUserName);
}
/*=============================================================================
  函 数 名： DelVCSSpecTaskInfo
  功    能： 对所有用户，删除该指定任务，并发出消息通告
  算法实现： 
  全局变量： 
  参    数： [IN]      cConfId：待删除的任务信息
  返 回 值： FALSE:用户已存在/用户数已满
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/11/24    4.5         付秀华        创建
=============================================================================*/
void  CMcuVcData::DelVCSSpecTaskInfo(CConfId cConfId)
{
	u16 dwChgIdx[MAXNUM_VCSUSERNUM];
	u16 *pdwChgIdx = dwChgIdx;
	memset(dwChgIdx, 0, sizeof(dwChgIdx));
	u16  dwChgNum = 0;


	m_cVCSUsrTaskInfo.DelSpecTaskInfo(cConfId, pdwChgIdx, dwChgNum);
	for (u16 dwIdx = 0; dwIdx <	dwChgNum; dwIdx++)
	{
		TUserTaskInfo tTaskInfo;
		CServMsg      cMsg;
		if(m_cVCSUsrTaskInfo.GetSpecUserTaskInfo(*pdwChgIdx++, tTaskInfo))
		{
			s32 nUsrNum = g_cVCSUsrManage.GetUserNum();
			CVCSUsrInfo cUsrInfo;
			for (s32 nUsrLoop = 0; nUsrLoop < nUsrNum; nUsrLoop ++)
			{
				g_cVCSUsrManage.GetUserFullInfo( &cUsrInfo, nUsrLoop );
				if ( strcmp(cUsrInfo.GetName(), tTaskInfo.GetUserName()))
				{
					cUsrInfo.AssignTask(tTaskInfo.GetUserTaskNum(), tTaskInfo.GetUserTaskInfo());

					cMsg.SetMcuId(LOCAL_MCUID);
					cMsg.SetSrcMtId(0);
					cMsg.SetSrcSsnId(0);
					cMsg.SetMsgBody((u8*)&cUsrInfo, sizeof(CVCSUsrInfo));
					g_cVcsSsnApp.Broadcast2SpecGrpVcsSsn(cUsrInfo.GetUsrGrpId(), MCU_MCS_CHANGEUSER_NOTIF,
						                             cMsg.GetServMsg(), cMsg.GetServMsgLen());
					break;
				}
			}
			

		}


	}
}

/*=============================================================================
  函 数 名： ChgVCSUserTaskInfo
  功    能： 修改VCS用户分配的任务信息
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： FALSE:用户已存在/用户数已满
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/11/24    4.5         付秀华        创建
=============================================================================*/
BOOL  CMcuVcData::ChgVCSUserTaskInfo(TUserTaskInfo& tUserTaskInfo)
{
	return m_cVCSUsrTaskInfo.ChgUserTaskInfo(tUserTaskInfo);
}
/*=============================================================================
  函 数 名： GetSpecVCSUserTaskInfo
  功    能： 获取指定用户的任务信息
  算法实现： 
  全局变量： 
  参    数： [IN]pachUserName:查询的用户名
             [OUT]tUserTaskInfo:接收该用户的任务信息
  返 回 值： 是否为该用户指定任务
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/11/24    4.5         付秀华        创建
=============================================================================*/
BOOL  CMcuVcData::GetSpecVCSUserTaskInfo(s8* pachUserName, TUserTaskInfo& tUserTaskInfo)
{
	return m_cVCSUsrTaskInfo.GetSpecUserTaskInfo(pachUserName, tUserTaskInfo);
}
/*=============================================================================
  函 数 名： LoadVCSUsersTaskInfo
  功    能： 文件中读取所有用户的任务信息
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 是否为该用户指定任务
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/11/24    4.5         付秀华        创建
=============================================================================*/
BOOL  CMcuVcData::LoadVCSUsersTaskInfo()
{
	return m_cVCSUsrTaskInfo.LoadUsersTaskInfo();
}
/*=============================================================================
  函 数 名： IsYourTask
  功    能： 判定指定会议是否为指定用户的任务范围内
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 是否为该用户指定的任务
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  08/12/15    4.5         付秀华        创建
=============================================================================*/
BOOL  CMcuVcData::IsYourTask(const s8* pachUserName, const CConfId& cConfId)
{
	return m_cVCSUsrTaskInfo.IsYourTask(pachUserName, cConfId);
}

//抓包相关
#if defined(_8KH_) ||  defined(_8KE_) || defined(_8KI_)
/*=============================================================================
  函 数 名： SetNetCapStatus
  功    能： 设置当前抓包状态
  算法实现： 
  全局变量： 
  参    数： emNetCapStatus：抓包状态
  返 回 值： 
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  13/03/25    4.7         zhouyiliang        创建
=============================================================================*/
void  CMcuVcData::SetNetCapStatus( const emNetCapState& emNetCapStatus)
{
	m_tNetCapMgr.SetNetCapStatus(emNetCapStatus);
}

/*=============================================================================
  函 数 名： GetNetCapStatus
  功    能： 获取当前抓包状态
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： emNetCapState 当前抓包状态
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  13/03/25    4.7         zhouyiliang        创建
=============================================================================*/
emNetCapState CMcuVcData::GetNetCapStatus()const
{
	return m_tNetCapMgr.GetNetCapStatus();
}

/*=============================================================================
  函 数 名： SetOprNetCapMcsInstID
  功    能： 设置当前抓包的mcsinstanceid
  算法实现： 
  全局变量： 
  参    数： byMcsInstId：当前正在抓包的mcsinstanceid
  返 回 值： 
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  13/03/25    4.7         zhouyiliang        创建
=============================================================================*/
void  CMcuVcData::SetOprNetCapMcsInstID(const u8& byMcsInstId)
{
	m_tNetCapMgr.SetOprNetCapMcsInstID(byMcsInstId);
}
/*=============================================================================
  函 数 名： GetNetCapStatus
  功    能： 获取当前抓包的mcsinstanceid
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： u8 当前抓包的mcsinstanceid
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  13/03/25    4.7         zhouyiliang        创建
=============================================================================*/
u8 CMcuVcData::GetOprNetCapMcsInstID()const
{
	return m_tNetCapMgr.GetOprNetCapMcsInstID();
}

/*=============================================================================
  函 数 名： StartNetCap
  功    能： 开始抓包
  算法实现： 
  全局变量： 
  参    数： u8 当前抓包的mcsinstanceid
  返 回 值： TRUE:开始成功，FALSE:开始失败
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  13/03/25    4.7         zhouyiliang        创建
=============================================================================*/
BOOL32  CMcuVcData::StartNetCap(const u8& byMcsInstId)
{
	emNetCapState emState = m_tNetCapMgr.GetNetCapStatus();
	if( emState != emNetCapIdle )
	{
		return FALSE;
	}
	m_tNetCapMgr.StartNetCap();
	m_tNetCapMgr.SetOprNetCapMcsInstID(byMcsInstId);
	m_tNetCapMgr.SetNetCapStatus(  emNetCapStart);
	OspDelay( 100 );
	return TRUE;
}

/*=============================================================================
  函 数 名： StopNetCap
  功    能： 停止抓包
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： TRUE:停止成功，FALSE:停止失败
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  13/03/25    4.7         zhouyiliang        创建
=============================================================================*/
BOOL32  CMcuVcData::StopNetCap()
{
	emNetCapState emState = m_tNetCapMgr.GetNetCapStatus();
	if( emState != emNetCapStart )
	{
		return FALSE;
	}
	m_tNetCapMgr.StopNetCap();
	m_tNetCapMgr.SetOprNetCapMcsInstID(0);
	m_tNetCapMgr.SetNetCapStatus(  emNetCapIdle);
	OspDelay( 100 );
	return TRUE;
}

#endif
/*=============================================================================
  函 数 名： GetAllTvWallPlanName
  功    能： 获得电视墙一个会议中所有预案名称
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/11/02    4.6.1         周晶晶        创建
=============================================================================*/
/*lint -save -esym(438, byPlanNum)*/
void CConfInfoFileExtraDataMgr::GetAllPlanName( s8 **pPlanData,u8 &byPlanNum )
{
	
	if( !IsReadPlan() || NULL == m_pPlanData )
	{
		byPlanNum = 0;
		return;
	}

	//保护
	if( m_wBufLen < 3 )
	{
		byPlanNum = 0;
		return;
	}

	u8 *pbyBuf = m_pPlanData;
	
	//第一个字节是预案个数
	byPlanNum = *pbyBuf;
	pbyBuf++;

	//预案个数0 返回
	if( 0 == byPlanNum )
	{
		return;
	}

	u8 byTemp = 0;

	for( u8 idx = 0;idx < byPlanNum;idx++ )
	{
		//现在只支持到8个电视墙预案
		if( idx >= VCS_MAXNUM_PLAN )
		{
			byPlanNum = VCS_MAXNUM_PLAN;
			break;
		}
		//预案名字长度，不包括\0
		byTemp = *pbyBuf;
		pbyBuf++;
		memcpy( pPlanData[idx],pbyBuf,byTemp );

		pPlanData[idx][byTemp] = '\0';

		pbyBuf += byTemp;
		
		//终端别名个数
		byTemp = *pbyBuf;
		pbyBuf++;
		pbyBuf += sizeof( TMtVCSPlanAlias ) * byTemp;

		if( ( m_wBufLen + m_pPlanData ) <= pbyBuf )
		{
			byPlanNum = idx + 1;
			break;
		}
	}

	
}

/*=============================================================================
  函 数 名： IsReadPlan
  功    能： 获得电视墙一个会议中所有预案名称
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/11/02    4.6.1         周晶晶        创建
=============================================================================*/
BOOL32 CConfInfoFileExtraDataMgr::IsReadPlan()
{
	return ( 1 == m_byIsReadPlan );
}

/*=============================================================================
  函 数 名： GetMtPlanAliasByPlanName
  功    能： 获得一个会议预案中的TMt别名
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/11/02    4.6.1         周晶晶        创建
=============================================================================*/
BOOL32 CConfInfoFileExtraDataMgr::GetMtPlanAliasByPlanName( s8 *pPlanName, 
							TMtVCSPlanAlias *pMtVCSPlanAlias,
							u8 &byMtAliasNum )
{
	if( !IsReadPlan() )
	{
		return FALSE;
	}

	if( NULL == pPlanName )
	{
		return FALSE;
	}

	u8 byStrLen = strlen( pPlanName );
	if( byStrLen > VCS_MAXLEN_ALIAS )
	{
		return FALSE;
	}

	if( !IsHasPlanName( pPlanName ) )
	{
		return FALSE;
	}
	
	u8 *pbyBuf = m_pPlanData;
	
	//第一个字节是预案个数
	u8 byPlanNum = *pbyBuf;
	pbyBuf++;

	//预案个数0 返回
	if( 0 == byPlanNum )
	{
		return FALSE;
	}

	u8 byTemp = 0;

	for( u8 idx = 0;idx < byPlanNum;idx++ )
	{
		//现在只支持到8个电视墙预案
		if( idx >= VCS_MAXNUM_PLAN )
		{
			byPlanNum = VCS_MAXNUM_PLAN;
			break;
		}
		//预案名字长度，不包括\0
		byTemp = *pbyBuf;
		pbyBuf++;
		
		if( byStrLen == byTemp &&
			0 == memcmp( pPlanName,pbyBuf,byStrLen)
			)
		{
			pbyBuf += byStrLen;
			//终端别名个数
			byTemp = *pbyBuf;
			pbyBuf++;

			//pMtVCSPlanAlias = (TMtVCSPlanAlias*)pbyBuf;
			memcpy( (u8*)pMtVCSPlanAlias,pbyBuf,sizeof( TMtVCSPlanAlias ) * byTemp );
			byMtAliasNum = byTemp;

			return TRUE;
			
		}

		pbyBuf += byTemp;
		
		//终端别名个数
		byTemp = *pbyBuf;
		pbyBuf++;
		pbyBuf += sizeof( TMtVCSPlanAlias ) * byTemp;

		if( ( m_wBufLen + m_pPlanData ) <= pbyBuf )
		{
			byPlanNum = idx + 1;
			break;
		}
	}

	return FALSE;

}

/*=============================================================================
  函 数 名： TransEncoding2Utf8
  功    能： 将内存中的MCS预案信息转为UTF8编码
  算法实现： 保险的话，是先调一把CheckPlanData，但是实在是重复操作，故舍弃
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2013/07/17  4.7.2       彭国锋        创建
=============================================================================*/
void CConfInfoFileExtraDataMgr::TransEncoding2Utf8()
{
	if ( !m_pPlanData )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[TransEncoding2Utf8] no PlanData now\n");
		return;
	}

	if ( !IsReadPlan() )
	{
		if ( !CheckPlanData())
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[TransEncoding2Utf8] CheckPlanData failed\n");
			return;
		}
	}
	else
	{
		LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[TransEncoding2Utf8] CheckPlanData has been done, no need to check\n");
	}

	//1. set pointer
	u8 *pbyBuf = m_pPlanData;

	u8 byPlanNum = *pbyBuf++;

	//临时变量加修改
	u8 byTmpLen =0;
	u8 byNameLen = 0;
	s8 achName[VCS_MAXLEN_ALIAS];
	s8 achUtf8Name[VCS_MAXLEN_ALIAS];
	u16 wUtf8BufLen = m_wBufLen-VCS_MAXLEN_ALIAS + VCS_MAXLEN_ALIAS*3/2+1;//汉字的话，由GBK转到UTF8由2B->3B
	u16 wUtf8RealLen = 0;
	u8 *pbyUtf8PlanData = new u8[wUtf8BufLen]; 

	if ( !pbyUtf8PlanData )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[TransEncoding2Utf8] alloc memory len.%d failed\n", wUtf8BufLen);
		return;
	}

	memset(pbyUtf8PlanData, 0, wUtf8BufLen);

	memcpy(pbyUtf8PlanData, &byPlanNum, sizeof(u8));
	wUtf8RealLen += sizeof(u8);

	TMtVCSPlanAlias tMtAlias;

	for( u8 idx = 0;idx < byPlanNum;idx++ )
	{
		byTmpLen = *pbyBuf++;
		memcpy( achName,pbyBuf,byTmpLen );
		achName[byTmpLen] = 0;
		pbyBuf += byTmpLen;

		byNameLen = gb2312_to_utf8(achName, achUtf8Name, sizeof(achUtf8Name));

		if ( byNameLen == 0 )
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[TransEncoding2Utf8] achUtf8Name.%s has none standard UTF8 char,return\n", achUtf8Name);
			return;
		}
		else
		{
			memcpy(pbyUtf8PlanData+wUtf8RealLen, &byNameLen, sizeof(u8));
			wUtf8RealLen += sizeof(u8);
			memcpy(pbyUtf8PlanData+wUtf8RealLen, achUtf8Name, byNameLen);
			wUtf8RealLen += byNameLen;
		}

		byTmpLen = *pbyBuf++; //此处代表终端数目
		memcpy(pbyUtf8PlanData+wUtf8RealLen, &byTmpLen, sizeof(u8));
		wUtf8RealLen += sizeof(u8);

		while ( byTmpLen-- )
		{
			memcpy(&tMtAlias, pbyBuf, sizeof(TMtVCSPlanAlias));
			byNameLen = gb2312_to_utf8(tMtAlias.m_achAlias, achUtf8Name, sizeof(achUtf8Name));
			memcpy(tMtAlias.m_achAlias, achUtf8Name, byNameLen);
			tMtAlias.m_achAlias[byNameLen] = 0;

			pbyBuf += sizeof(TMtVCSPlanAlias);
			memcpy(pbyUtf8PlanData+ wUtf8RealLen, &tMtAlias, sizeof(TMtVCSPlanAlias));
			wUtf8RealLen += sizeof(TMtVCSPlanAlias);
		}
	}

	LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[TransEncoding2Utf8]trans plan data len from %d to %d\n", m_wBufLen, wUtf8RealLen);
	m_wBufLen = wUtf8RealLen;
	delete [] m_pPlanData;
	m_pPlanData = pbyUtf8PlanData;

	return;
}

/*=============================================================================
  函 数 名： CheckPlanData
  功    能： 校验预案数据(当前内存中预案数据是否正确)
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    13/05/03    4.7.2        chendaiwei       创建
=============================================================================*/
BOOL32 CConfInfoFileExtraDataMgr::CheckPlanData( void )
{
	//1.检验预案内存是否为空
	if( NULL == m_pPlanData )
	{
		if( m_byTvWallPlanNum == 0)
		{
			return TRUE;
		}
		else
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[CheckPlanData] NULL == m_pPlanData ,but m_byTvWallPlanNum.%d failed!\n", m_byTvWallPlanNum);

			return FALSE;
		}
	}
		
	u8 *pbyBuf = m_pPlanData;
	
	//第一个字节是预案个数
	u8 byPlanNum = *pbyBuf;
	pbyBuf++;
	
	//2.检验预案个数一致性及上限
	if( byPlanNum != m_byTvWallPlanNum || byPlanNum >VCS_MAXNUM_PLAN )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[CheckPlanData] byPlanNum.%d != m_byTvWallPlanNum.%d ,error!\n", byPlanNum,m_byTvWallPlanNum);
		
		return FALSE;
	}
	else
	{
		if( m_byTvWallPlanNum == 0)
		{
			return TRUE;
		}
	}

	u8 byTemp = 0;
	
	for( u8 idx = 0;idx < byPlanNum;idx++ )
	{
		//预案名字长度，不包括\0
		byTemp = *pbyBuf;
		pbyBuf++;
		
		//3.预案名字长度非法值校验
		if( byTemp == 0 || byTemp >= VCS_MAXLEN_ALIAS)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[CheckPlanData] planNameLen.%d,error!\n",byTemp);

			return FALSE;
		}

		s8 achPlanName[VCS_MAXLEN_ALIAS] = {0};

		memcpy( achPlanName,pbyBuf,byTemp );
		
		//4.预案名字符串长度与实际长度校验
		if(strlen(achPlanName) != byTemp )
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[CheckPlanData] planName.%s UnMatched with Len.%d,error!\n",achPlanName,byTemp);
			
			return FALSE;
		}
		
		pbyBuf += byTemp;
		
		//终端别名个数
		byTemp = *pbyBuf;
		pbyBuf++;
		pbyBuf += sizeof( TMtVCSPlanAlias ) * byTemp;


		if( m_wBufLen + m_pPlanData > pbyBuf )
		{
			//nothing to do
		}
		else if (m_wBufLen + m_pPlanData == pbyBuf)
		{
			return TRUE;
		}
		//5.预案数据长度校验
		else
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[CheckPlanData] m_pPlanData.0x%p+m_wBufLen.%d <pbyBuf.0x%p,error!\n",m_pPlanData,m_wBufLen,pbyBuf);

			return FALSE;
		}
	}
	
	return FALSE;
}



/*=============================================================================
  函 数 名： GetDefaultConfStore
  功    能： 获取缺省会议数据信息
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
12/07/18    4.7         chendaiwei        创建
=============================================================================*/
BOOL32 CConfInfoFileExtraDataMgr::GetDefaultConfStore( TConfStore & tConfStore )
{
	TConfStore tConfStoreBuf;
	TPackConfStore *ptPackConfStore = (TPackConfStore *)&tConfStoreBuf;
	
	//提取后的 tConfStore 为 TPackConfStore 结构，即已进行Pack处理的会议数据
	
	//根据缺省会议创会
	if (!GetConfFromFile(MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE, ptPackConfStore))
	{
		return FALSE;
	}
	//将 已进行Pack处理的会议数据 进行UnPack处理
	u16 wPackConfDataLen = 0;
	if (!UnPackConfStore(ptPackConfStore, tConfStore,wPackConfDataLen))
	{
		return FALSE;
	}

	return TRUE;
}

/*=============================================================================
  函 数 名： AddPlanName
  功    能： 增加一个会议预案名称
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/11/02    4.6.1         周晶晶        创建
=============================================================================*/
BOOL32 CConfInfoFileExtraDataMgr::AddPlanName( s8 *pPlanName , u8 byConfIdx, BOOL32 bIsDefaultCconf)
{
	if( !IsReadPlan() )
	{
		return FALSE;
	}

	if( NULL == pPlanName )
	{
		return FALSE;
	}
	u8 byStrLen = strlen( pPlanName );

	if( 0 == byStrLen || byStrLen > (VCS_MAXLEN_ALIAS-1) )
	{
		return FALSE;
	}

	if( IsHasPlanName(pPlanName) )
	{
		return FALSE;
	}

	TConfStore tConfStore;
	TTemplateInfo tTmpInfo;
	
	if(	bIsDefaultCconf)
	{
		GetDefaultConfStore(tConfStore);
	}
	else if( g_cMcuVcApp.GetTemplate( byConfIdx, tTmpInfo ) )
	{
		memcpy( &tConfStore, &tTmpInfo, sizeof(TConfStore) );
	}
	else 
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[AddPlanName] GetTemplate ConfIdx.%d failed!\n", byConfIdx);
		return FALSE;	
	}

	// 帮会议加上utf8标志 [pengguofeng 7/17/2013] 
	CMcuVcInst *pcVcIns = g_cMcuVcApp.GetConfInstHandle(byConfIdx);
	if ( pcVcIns && pcVcIns->m_tConf.GetConfSource() == MCS_CONF )
	{
		u16 wPackLen = 0;
		BOOL32 bExistUnknowExInfo = FALSE;
		u8 byEncoding = emenCoding_Utf8;
		THduVmpModuleOrTHDTvWall tHduVmpModule;
		TVmpModuleInfo tVmpModule;
		TConfInfoEx tConfInfoEx;
		memcpy(&tConfInfoEx, &(pcVcIns->m_tConfEx), sizeof(TConfInfoEx));
		UnPackConfInfoEx(tConfInfoEx, tConfStore.m_byConInfoExBuf,
			wPackLen, bExistUnknowExInfo, &tHduVmpModule, &tVmpModule);
		PackConfInfoEx(tConfInfoEx, tConfStore.m_byConInfoExBuf, 
			wPackLen, &tHduVmpModule, &tVmpModule, &byEncoding); //不认识的Buffer会被丢弃
	}

	//在现有数据上咱增加1个字节的预案名长度，再加预案名字的长度，再加别名个数,因为只是加预案名字，所以填0
	u16 wDataLen = m_wBufLen + sizeof(u8) * 2 + byStrLen;

	//还没有数据，要再加一个字节的预案个数
	//(如果是添加预案后再全部删除,这时候m_wBufLen为1(预案个数一个字节),不用再预留1个自己的预案个数)
	if( 0 == m_byTvWallPlanNum && 0 == m_wBufLen)
	{		
		wDataLen += sizeof( u8 );
	}
	u8 *pbyDataBuf = new u8[ wDataLen ];
	memset( pbyDataBuf,0,wDataLen );

	if( NULL == pbyDataBuf )
	{
		return FALSE;
	}

	m_byTvWallPlanNum += 1;
	if( m_wBufLen > 0 && m_pPlanData != NULL )
	{		
		u8 *pbyBuf = m_pPlanData;
		pbyBuf++;

		u8 byTemp = 0;
		for( u8 idx = 0;idx < m_byTvWallPlanNum;idx++ )
		{
			//预案名字大小
			byTemp = *pbyBuf;
			pbyBuf++;

			if( byTemp == byStrLen &&
				0 == memcmp( pbyBuf,pPlanName,byStrLen ) )
			{
				delete []pbyDataBuf;
				m_byTvWallPlanNum -= 1;
				return FALSE;
			}

			pbyBuf += byTemp;

			//终端别名个数
			byTemp = *pbyBuf;
			pbyBuf++;

			pbyBuf += sizeof(TMtVCSPlanAlias) * byTemp;

			if( pbyBuf >= (m_pPlanData + m_wBufLen ) )	
			{
				break;
			}			
		}
		
		//拷贝到新申请的内存
		memcpy( pbyDataBuf,m_pPlanData,m_wBufLen );
		//更新第一个字节，即预案个数
		memcpy( pbyDataBuf,&m_byTvWallPlanNum,sizeof( m_byTvWallPlanNum ) );
		//拷贝预案名字到尾部
		memcpy( pbyDataBuf + m_wBufLen,&byStrLen,sizeof( byStrLen ) );
		//再在之后拷贝预案名字
		memcpy( pbyDataBuf + m_wBufLen + sizeof( byStrLen ),pPlanName,byStrLen );
		//之后跟预案别名个数，因为只是加预案名字，所以是0 ，不用填了
	}
	else
	{
		memcpy( pbyDataBuf,&m_byTvWallPlanNum,sizeof( m_byTvWallPlanNum ) );
		//拷贝预案名字到尾部
		memcpy( pbyDataBuf + sizeof(m_byTvWallPlanNum),&byStrLen,sizeof( byStrLen ) );
		//再在之后拷贝预案名字
		memcpy( pbyDataBuf + sizeof(m_byTvWallPlanNum) + sizeof( byStrLen ),pPlanName,byStrLen );
		//之后跟预案别名个数，因为只是加预案名字，所以是0 ，不用填了
	}

	if( !::SaveConfExtraPlanDataToFile( tConfStore/*m_tConfStore*/,pbyDataBuf,wDataLen,bIsDefaultCconf ) )
	{		
		m_byTvWallPlanNum -= 1;				
		delete []pbyDataBuf;
		return FALSE;
	}

	//将新数据拷贝到本地
	if( NULL != m_pPlanData )
	{
		delete []m_pPlanData;
	}
	m_pPlanData = new u8[ wDataLen ];
	memcpy( m_pPlanData,pbyDataBuf,wDataLen );
	m_wBufLen = wDataLen;
	

	delete []pbyDataBuf;
	return TRUE;	
	
}

/*=============================================================================
  函 数 名： DelPlanName
  功    能： 删除一个预案
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/11/02    4.6.1         周晶晶        创建
=============================================================================*/
BOOL32 CConfInfoFileExtraDataMgr::DelPlanName( s8 *pPlanName, u8 byConfIdx, BOOL32 bIsDefaultConf )
{
	if( !IsReadPlan() )
	{
		return FALSE;
	}

	if( m_byTvWallPlanNum ==0 )
	{
		return FALSE;
	}

	if( NULL == pPlanName )
	{
		return FALSE;
	}
	u8 byStrLen = strlen( pPlanName );
	if( byStrLen > VCS_MAXLEN_ALIAS )
	{
		return FALSE;
	}

	if( !IsHasPlanName(pPlanName) )
	{
		return FALSE;
	}

	u8 *pbyBuf = m_pPlanData;
	
	//第一个字节是预案个数
	u8 byPlanNum = *pbyBuf;
	pbyBuf++;

	//预案个数0 返回
	if( 0 == byPlanNum )
	{
		return FALSE;
	}

	u8 byTemp = 0;

	TConfStore tConfStore;
	TTemplateInfo tTmpInfo;

	if(	bIsDefaultConf)
	{
		GetDefaultConfStore(tConfStore);
	}
	else if (g_cMcuVcApp.GetTemplate( byConfIdx, tTmpInfo ))
	{
		memcpy( &tConfStore, &tTmpInfo, sizeof(TConfStore) );
	}
	else
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[DelPlanName] GetTemplate ConfIdx.%d failed!\n", byConfIdx);
		return FALSE;	
	}
	
	// 帮会议加上utf8标志 [pengguofeng 7/17/2013] 
	CMcuVcInst *pcVcIns = g_cMcuVcApp.GetConfInstHandle(byConfIdx);
	if ( pcVcIns && pcVcIns->m_tConf.GetConfSource() == MCS_CONF )
	{
		u16 wPackLen = 0;
		BOOL32 bExistUnknowExInfo = FALSE;
		u8 byEncoding = emenCoding_Utf8;
		THduVmpModuleOrTHDTvWall tHduVmpModule;
		TVmpModuleInfo tVmpModule;
		TConfInfoEx tConfInfoEx;
		memcpy(&tConfInfoEx, &(pcVcIns->m_tConfEx), sizeof(TConfInfoEx));
		UnPackConfInfoEx(/*pcVcIns->m_tConfEx*/tConfInfoEx, tConfStore.m_byConInfoExBuf,
			wPackLen, bExistUnknowExInfo, &tHduVmpModule, &tVmpModule);
		PackConfInfoEx(tConfInfoEx, tConfStore.m_byConInfoExBuf, 
			wPackLen, &tHduVmpModule, &tVmpModule, &byEncoding);
	}

	for( u8 idx = 0;idx < byPlanNum;idx++ )
	{
		
		//预案名字长度，不包括\0
		byTemp = *pbyBuf;
		pbyBuf++;
		
		if( byStrLen == byTemp &&
			0 == memcmp( pPlanName,pbyBuf,byStrLen)
			)
		{
			
			m_byTvWallPlanNum -= 1;

			u16 byDecBytes = sizeof( u8 ) * 2 + byStrLen;
			pbyBuf += byStrLen;
			//终端别名个数
			byTemp = *pbyBuf;

			//这个预案总共占的字节数
			byDecBytes += sizeof(TMtVCSPlanAlias) * byTemp;

			//回退指针
			pbyBuf -= byStrLen;
			pbyBuf -= sizeof( u8 );
			
			u16 wDataLen = m_wBufLen - byDecBytes;
			u8 *pbyDataBuf = new u8[ wDataLen ];
			
			//将这个预案前的数据拷贝到新申请的内存
			memcpy( pbyDataBuf,m_pPlanData,(pbyBuf - m_pPlanData) );

			//将这个预案后的数据拷贝到新申请的内存
			pbyBuf += byDecBytes;
			memcpy( pbyDataBuf + (pbyBuf - byDecBytes - m_pPlanData),pbyBuf,m_pPlanData+m_wBufLen - pbyBuf );
			//更新第一个字节，即预案个数
			memcpy( pbyDataBuf,&m_byTvWallPlanNum,sizeof( m_byTvWallPlanNum ) );					

			if( m_byTvWallPlanNum > 0 )
			{
				//保存
				if( !::SaveConfExtraPlanDataToFile( tConfStore/*m_tConfStore*/,pbyDataBuf,wDataLen,bIsDefaultConf ) )
				{		
					m_byTvWallPlanNum += 1;				
					delete []pbyDataBuf;
					return FALSE;
				}
			}
			else
			{
				if( !::SaveConfExtraPlanDataToFile( tConfStore/*m_tConfStore*/,pbyDataBuf,0,bIsDefaultConf ) )
				{		
					m_byTvWallPlanNum += 1;				
					delete []pbyDataBuf;
					return FALSE;
				}
			}
			

			//删除本地内存
			if( NULL != m_pPlanData)
			{
				delete []m_pPlanData;	
			}			
			//申请新内存
			m_pPlanData = new u8[wDataLen];
			memcpy( m_pPlanData,pbyDataBuf,wDataLen );
			m_wBufLen = wDataLen;

			delete []pbyDataBuf;
			return TRUE;			
		}

		pbyBuf += byTemp;
		
		//终端别名个数
		byTemp = *pbyBuf;
		pbyBuf++;
		pbyBuf += sizeof( TMtVCSPlanAlias ) * byTemp;

		if( pbyBuf >= ( m_wBufLen + m_pPlanData ) )
		{
			byPlanNum = idx + 1;
			break;
		}
	}


	return FALSE;
}

/*=============================================================================
  函 数 名： ModifyPlanName
  功    能： 修改预案名称
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/11/02    4.6.1         周晶晶        创建
=============================================================================*/
BOOL32 CConfInfoFileExtraDataMgr::ModifyPlanName( s8 *pPlanOldName,s8 *pPlanNewName, u8 byConfIdx, BOOL32 bIsDefaultConf )
{
	if( !IsReadPlan() )
	{
		return FALSE;
	}

	if( m_byTvWallPlanNum ==0 )
	{
		return FALSE;
	}

	if( NULL == pPlanOldName || NULL == pPlanNewName )
	{
		return FALSE;
	}

	u8 byStrLen = strlen( pPlanOldName );
	if( byStrLen > VCS_MAXLEN_ALIAS )
	{
		return FALSE;
	}

	u8 byNewStrLen = strlen( pPlanNewName );
	if( byNewStrLen > VCS_MAXLEN_ALIAS )
	{
		return FALSE;
	}

	if( !IsHasPlanName(pPlanOldName) )
	{
		return FALSE;
	}

	if( IsHasPlanName(pPlanNewName) )
	{
		return FALSE;
	}

	u8 *pbyBuf = m_pPlanData;
	
	//第一个字节是预案个数
	u8 byPlanNum = *pbyBuf;
	pbyBuf++;

	//预案个数0 返回
	if( 0 == byPlanNum )
	{
		return FALSE;
	}

	u8 byTemp = 0;

	TConfStore tConfStore;
	TTemplateInfo tTmpInfo;

	if(	bIsDefaultConf)
	{
		GetDefaultConfStore(tConfStore);
	}
	else if (g_cMcuVcApp.GetTemplate( byConfIdx, tTmpInfo ) )
	{
		memcpy( &tConfStore, &tTmpInfo, sizeof(TConfStore) );
	}
	else
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[ModifyPlanName] GetTemplate ConfIdx.%d failed!\n", byConfIdx);
		return FALSE;
	}
	
	// 帮会议加上utf8标志 [pengguofeng 7/17/2013] 
	CMcuVcInst *pcVcIns = g_cMcuVcApp.GetConfInstHandle(byConfIdx);
	if ( pcVcIns && pcVcIns->m_tConf.GetConfSource() == MCS_CONF )
	{
		u16 wPackLen = 0;
		BOOL32 bExistUnknowExInfo = FALSE;
		u8 byEncoding = emenCoding_Utf8;
		THduVmpModuleOrTHDTvWall tHduVmpModule;
		TVmpModuleInfo tVmpModule;
		TConfInfoEx tConfInfoEx;
		memcpy(&tConfInfoEx, &(pcVcIns->m_tConfEx), sizeof(TConfInfoEx));
		UnPackConfInfoEx(tConfInfoEx, tConfStore.m_byConInfoExBuf,
			wPackLen, bExistUnknowExInfo, &tHduVmpModule, &tVmpModule);
		PackConfInfoEx(tConfInfoEx, tConfStore.m_byConInfoExBuf, 
			wPackLen, &tHduVmpModule, &tVmpModule, &byEncoding);
	}

	for( u8 idx = 0;idx < byPlanNum;idx++ )
	{
		
		//预案名字长度，不包括\0
		byTemp = *pbyBuf;
		pbyBuf++;
		
		if( byStrLen == byTemp &&
			0 == memcmp( pPlanOldName,pbyBuf,byStrLen)
			)
		{
			
			if( byStrLen == byNewStrLen )	
			{
				memcpy( pbyBuf,pPlanNewName,byStrLen );
				//保存
				if( !::SaveConfExtraPlanDataToFile( tConfStore/*m_tConfStore*/,m_pPlanData,m_wBufLen,bIsDefaultConf ) )
				{				
					return FALSE;
				}
				return TRUE;
			}

			u8 *pbyDataBuf = NULL;
			u16 wDataLen = 0;

			//新名字比老名字短
			if( byStrLen > byNewStrLen )
			{
				wDataLen = m_wBufLen - ( byStrLen - byNewStrLen );
			}
			else//新名字比老名字长
			{
				wDataLen = m_wBufLen + ( byNewStrLen - byStrLen );
			}
			pbyDataBuf = new u8[ wDataLen ];
			
			

			//将这个预案前的数据拷贝到新申请的内存(注意，这里包括了要修改的预案的大小的一个字节)
			memcpy( pbyDataBuf,m_pPlanData,(pbyBuf - m_pPlanData) );
			//设置新字符串的大小
			pbyDataBuf[pbyBuf - m_pPlanData-1] = byNewStrLen;

			//将新名字拷贝到新申请的内存中
			memcpy( pbyDataBuf + (pbyBuf - m_pPlanData),pPlanNewName,byNewStrLen );

			u8 *pbyDataBufScan = pbyDataBuf + (pbyBuf - m_pPlanData);
			//将名字后面的数据都拷贝到新申请的内存中
			pbyBuf += byStrLen;	

			memcpy( pbyDataBufScan + byNewStrLen ,
						pbyBuf,
						m_wBufLen + m_pPlanData -  pbyBuf);

			//保存
			if( !::SaveConfExtraPlanDataToFile( tConfStore/*m_tConfStore*/,pbyDataBuf,wDataLen,bIsDefaultConf ) )
			{						
				delete []pbyDataBuf;
				return FALSE;
			}


			//删除本地内存
			delete []m_pPlanData;	
			//申请新内存
			m_pPlanData = new u8[wDataLen];
			memcpy( m_pPlanData,pbyDataBuf,wDataLen );
			m_wBufLen = wDataLen;

			delete []pbyDataBuf;
			return TRUE;			
		}

		pbyBuf += byTemp;
		
		//终端别名个数
		byTemp = *pbyBuf;
		pbyBuf++;
		pbyBuf += sizeof( TMtVCSPlanAlias ) * byTemp;

		if( ( m_wBufLen + m_pPlanData ) <= pbyBuf )
		{
			byPlanNum = idx + 1;
			break;
		}
	}



	return FALSE;
}

/*=============================================================================
  函 数 名： SaveMtPlanAliasByPlanName
  功    能： 储存预案中的终端别名
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/11/02    4.6.1         周晶晶        创建
=============================================================================*/
BOOL32 CConfInfoFileExtraDataMgr::SaveMtPlanAliasByPlanName( s8 *pPlanName, 
																TMtVCSPlanAlias *pMtVCSPlanAlias,
																u8 byMtAliasNum,
																u8 byConfIdx,
																BOOL32 bIsDefaultConf)
{
	if( !IsReadPlan() )
	{
		return FALSE;
	}

	if( m_byTvWallPlanNum ==0 )
	{
		return FALSE;
	}

	if( NULL == pPlanName )
	{
		return FALSE;
	}

	u8 byStrLen = strlen( pPlanName );
	if( byStrLen > VCS_MAXLEN_ALIAS )
	{
		return FALSE;
	}

	if( NULL == pMtVCSPlanAlias )
	{
		return FALSE;
	}

	if( !IsHasPlanName( pPlanName ) )
	{
		return FALSE;
	}

	u8 *pbyBuf = m_pPlanData;
	
	//第一个字节是预案个数
	u8 byPlanNum = *pbyBuf;
	pbyBuf++;

	//预案个数0 返回
	if( 0 == byPlanNum )
	{
		return FALSE;
	}

	u8 byTemp = 0;

	TConfStore tConfStore;
	TTemplateInfo tTmpInfo;

	if(	bIsDefaultConf )
	{
		GetDefaultConfStore(tConfStore);
	}
	else if ( g_cMcuVcApp.GetTemplate( byConfIdx, tTmpInfo ) )
	{
		memcpy( &tConfStore, &tTmpInfo, sizeof(TConfStore) );
	}
	else
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[SaveMtPlanAliasByPlanName] GetTemplate ConfIdx.%d failed!\n", byConfIdx);
		return FALSE;
	}
	
	// 帮会议加上utf8标志 [pengguofeng 7/17/2013] 
	CMcuVcInst *pcVcIns = g_cMcuVcApp.GetConfInstHandle(byConfIdx);
	if ( pcVcIns && pcVcIns->m_tConf.GetConfSource() == MCS_CONF )
	{
		u16 wPackLen = 0;
		BOOL32 bExistUnknowExInfo = FALSE;
		u8 byEncoding = emenCoding_Utf8;
		THduVmpModuleOrTHDTvWall tHduVmpModule;
		TVmpModuleInfo tVmpModule;
		TConfInfoEx tConfInfoEx;
		memcpy(&tConfInfoEx, &(pcVcIns->m_tConfEx), sizeof(TConfInfoEx));
		UnPackConfInfoEx(tConfInfoEx, tConfStore.m_byConInfoExBuf,
			wPackLen, bExistUnknowExInfo, &tHduVmpModule, &tVmpModule);
		PackConfInfoEx(tConfInfoEx, tConfStore.m_byConInfoExBuf, 
			wPackLen, &tHduVmpModule, &tVmpModule, &byEncoding);
	}

	for( u8 idx = 0;idx < byPlanNum;idx++ )
	{
		
		//预案名字长度，不包括\0
		byTemp = *pbyBuf;
		pbyBuf++;
		
		if( byStrLen == byTemp &&
			0 == memcmp( pPlanName,pbyBuf,byStrLen)
			)
		{
			
			pbyBuf += byStrLen;
			//终端别名个数
			byTemp = *pbyBuf;
			
			pbyBuf++;

			//如果原来的终端别名数量和要保存的终端别名数量都是0,就不用保存了
			if( 0 == byTemp && 0 == byMtAliasNum )
			{
				return TRUE;
			}

			//这个预案终端别名占的字节数
			u16 byDecBytes =0;
			byDecBytes += sizeof(TMtVCSPlanAlias) * byTemp;
			
			u8 *pbyDataBuf = NULL;
			u16 wDataLen = m_wBufLen - byDecBytes + sizeof(TMtVCSPlanAlias) * byMtAliasNum;

			pbyDataBuf = new u8[ wDataLen ];
			
			//将这个预案前的数据拷贝到新申请的内存
			memcpy( pbyDataBuf,m_pPlanData,(pbyBuf - m_pPlanData) );
			//设置终端个数
			pbyDataBuf[pbyBuf - m_pPlanData - 1] = byMtAliasNum;

			//将新终端别名到新申请的内存中
			if( byMtAliasNum > 0 )
			{
				memcpy( pbyDataBuf + (pbyBuf - m_pPlanData),pMtVCSPlanAlias,sizeof(TMtVCSPlanAlias) * byMtAliasNum );
			}
			

			//将终端别名后面的数据拷贝到新申请的内存中
			memcpy( pbyDataBuf + (pbyBuf - m_pPlanData) + sizeof(TMtVCSPlanAlias) * byMtAliasNum,
									pbyBuf + byDecBytes,m_wBufLen + m_pPlanData -  (pbyBuf + byDecBytes) );

			//保存
			if( !::SaveConfExtraPlanDataToFile( tConfStore/*m_tConfStore*/,pbyDataBuf,wDataLen,bIsDefaultConf ) )
			{						
				delete []pbyDataBuf;
				return FALSE;
			}

			//删除本地内存
			delete []m_pPlanData;	
			//申请新内存
			m_pPlanData = new u8[wDataLen];
			memcpy( m_pPlanData,pbyDataBuf,wDataLen );
			m_wBufLen = wDataLen;

			delete []pbyDataBuf;
			return TRUE;			
		}

		pbyBuf += byTemp;
		
		//终端别名个数
		byTemp = *pbyBuf;
		pbyBuf++;
		pbyBuf += sizeof( TMtVCSPlanAlias ) * byTemp;

		if( ( m_wBufLen + m_pPlanData ) <= pbyBuf )
		{
			byPlanNum = idx + 1;
			break;
		}
	}



	return FALSE;
}

/*=============================================================================
  函 数 名： ReadExtraDataFromConfInfoFile
  功    能： 读取会议额外数据(现在只有会议信息数据)
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/11/02    4.6.1       周晶晶        创建
2013/07/24      4.7.2       彭国锋　　　　添加参数bNeedChg2GBK，以兼容4.7.1的MCS预案
=============================================================================*/
BOOL32 CConfInfoFileExtraDataMgr::ReadExtraDataFromConfInfoFile(/* TConfStore tConfStore */u8 byConfIdx,
																BOOL32 bIsDefaultConf /*= FALSE*/,
																BOOL32 bNeedChg2GBK /*= FALSE*/)
{
	TConfStore tConfStore;
	TTemplateInfo tTmpInfo;

	if(	bIsDefaultConf)
	{
		GetDefaultConfStore(tConfStore);
	}
	else if(g_cMcuVcApp.GetTemplate( byConfIdx, tTmpInfo))
	{
		memcpy( &tConfStore, &tTmpInfo, sizeof(TConfStore) );
	}
	else
	{
		LogPrint(LOG_LVL_ERROR,  MID_MCU_CONF, "[ReadExtraDataFromConfInfoFile] GetTemplate ConfIdx.%d failed!\n", byConfIdx);
		return FALSE;
	}
	
	if( tConfStore.m_tConfInfo.GetConfId().IsNull() )
	{
		LogPrint(LOG_LVL_ERROR,  MID_MCU_CONF, "[ReadExtraDataFromConfInfoFile]  Conf.%d ConfId is null!\n");
		return FALSE;
	}
	
	Clear();

	u16 wExInfoLength = 0;
	// 根据参数判断来决定需不需要将MtAlias转成GBK [pengguofeng 7/24/2013]
	if ( bNeedChg2GBK )
	{
		//说明:由于tConfStore里只有MtAlias是用的实时的名字长度，如果再去读老版本，则需要转成GBK去读
		//除此以外，其他都是传结构体的，所以不会导致后面的PackConfStore字符增加
		s8 achMtAlias[MAXLEN_ALIAS] = {0};
		u32 dwTransLen = 0;
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ReadExtraDataFromConfInfoFile]Start trans MtAlias to GBK!\n");
		for (u8 byMtId = 0; byMtId < tConfStore.m_byMtNum;byMtId++)
		{
			// 只转有字符串的 [pengguofeng 7/24/2013]
			if ( strlen(tConfStore.m_atMtAlias[byMtId].m_achAlias) == 0 )
			{
				continue;
			}

			dwTransLen = utf8_to_gb2312(tConfStore.m_atMtAlias[byMtId].m_achAlias, achMtAlias, sizeof(achMtAlias)-1);
			if ( dwTransLen > 0 )
			{
				memcpy(tConfStore.m_atMtAlias[byMtId].m_achAlias, achMtAlias, dwTransLen);
				tConfStore.m_atMtAlias[byMtId].m_achAlias[dwTransLen] = 0;
			}
			else
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[ReadExtraDataFromConfInfoFile] trans mt.(%s ) to gbk failed, return\n",
					tConfStore.m_atMtAlias[byMtId].m_achAlias);
				return FALSE;
			}
		}
	}
	GetConfExtraDataLenFromFile( tConfStore, m_wBufLen,wExInfoLength,bIsDefaultConf );

	if( m_wBufLen > 0)
	{	
		if (m_pPlanData)
		{
			delete []m_pPlanData;
			m_pPlanData = NULL;
		}

		u8* pTempPlanData = new u8[ m_wBufLen ];
		if (!pTempPlanData)
		{
			Clear();
			return FALSE;
		}

		TConfStore tTempConfStore;
		BOOL32 bHasFix2PlanData = FALSE;
		if( !GetConfExtraDataFromFile( tConfStore,pTempPlanData,m_wBufLen,(u8*)&tTempConfStore,wExInfoLength,bHasFix2PlanData,bIsDefaultConf ) )
		{
			delete []pTempPlanData;
			Clear();
			return FALSE;
		}
		else
		{
			//第一个字节存放预案个数
			m_byTvWallPlanNum = pTempPlanData[0];			
		}

		if(bHasFix2PlanData)
		{
			u16 wV4R7BufLen = GetPlanDataLenByV4R6B2PlanData(pTempPlanData,m_wBufLen);
			if( wV4R7BufLen == 0 )
			{
				delete []pTempPlanData;
				Clear();
				LogPrint(LOG_LVL_ERROR,MID_MCU_CFG,"[ReadConfExtraDataFromFile]conf.%s wV4R7BufLen == 0,return!\n",tConfStore.m_tConfInfo.GetConfName());
			 	return FALSE;
			}

			m_pPlanData = new u8[ wV4R7BufLen ];
			if (!m_pPlanData)
			{
				delete []pTempPlanData;
				Clear();
			 	return FALSE;
 			}

			TransferV4R6B2planDataToV4R7(pTempPlanData,m_wBufLen,m_pPlanData,wV4R7BufLen);
			LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_CFG,"[ReadExtraDataFromConfInfoFile]Conf.%s v4r6b2 plan Data transfer from len.%d to len.%d\n",
				tConfStore.m_tConfInfo.GetConfName(),m_wBufLen,wV4R7BufLen);

			m_wBufLen = wV4R7BufLen;
		}
		else
		{
			m_pPlanData = new u8[ m_wBufLen ];
			if (!m_pPlanData)
			{
				delete []pTempPlanData;
				Clear();
				return FALSE;
 			}
			
			memcpy(m_pPlanData,pTempPlanData,m_wBufLen);
		}

		delete []pTempPlanData;
	}


	if(CheckPlanData())
	{
		m_byIsReadPlan = 1;
	}
	else
	{
		m_byIsReadPlan = 0;

		LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_CFG,"[ReadExtraDataFromConfInfoFile]Conf.%s check plan data failed\n",
				tConfStore.m_tConfInfo.GetConfName());

		return FALSE;
	}

	//m_tConfStore = tConfStore;
			
	return TRUE;
}

/*=============================================================================
  函 数 名： SaveExtraDataToConfInfoFile
  功    能： 保存会议额外信息数据(现在只有会议信息数据)
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/11/02    4.6.1         周晶晶        创建
=============================================================================*/
// BOOL32 CConfInfoFileExtraDataMgr::SaveExtraDataToConfInfoFile( TConfStore tConfStore )
// {
// 	if( NULL == m_pPlanData || 0 == m_wBufLen )
// 	{
// 		return FALSE;
// 	}
// 
// 	if( !IsReadPlan() )
// 	{
// 		return FALSE;
// 	}
// 
// 	//保存
// 	if( !::SaveConfExtraPlanDataToFile( m_tConfStore,m_pPlanData,m_wBufLen ) )
// 	{		
// 		return FALSE;
// 	}
// 
// 	return TRUE;
// 
// 
// }

/*=============================================================================
  函 数 名： IsHasPlanName
  功    能： 会议信息中是否有指定预案
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/11/02    4.6.1         周晶晶        创建
=============================================================================*/
BOOL32 CConfInfoFileExtraDataMgr::IsHasPlanName( s8 *pPlanName )
{
	if( 0 == m_byTvWallPlanNum )
	{
		return FALSE;
	}

	if( NULL == m_pPlanData || 0 == m_wBufLen )
	{
		return FALSE;
	}

	if( NULL == pPlanName )
	{
		return FALSE;
	}

	u8 byStrLen = strlen( pPlanName );

	if( 0 == byStrLen || byStrLen > (VCS_MAXLEN_ALIAS-1) )
	{
		return FALSE;
	}

	u8* pbyBuf = m_pPlanData;

/*lint -save -esym(661, pbyBuf)*/
/*lint -save -esym(662, pbyBuf)*/
/*lint -save -e661*/
/*lint -save -e662*/
/*lint -save -esym(670, memcmp)*/

	if (!pbyBuf || m_byTvWallPlanNum != *pbyBuf)
	{
		return FALSE;
	}
	
	pbyBuf++;
	
	u8 byTemp = 0;

#define CHECK_SCOPE(p) if(!p || p >= (m_pPlanData + m_wBufLen)) break;

	for( u8 idx = 0; idx < m_byTvWallPlanNum && m_wBufLen > 0 && pbyBuf < ( m_pPlanData + m_wBufLen); idx++ )
	{
		//预案名字大小
		byTemp = *pbyBuf;
		pbyBuf++;
		CHECK_SCOPE(pbyBuf);
	
		if( byTemp == byStrLen &&
			0 == memcmp( pPlanName,pbyBuf,byStrLen) )
		{
			return TRUE;
		}

		pbyBuf += byTemp;
		//终端别名个数
		byTemp = *pbyBuf;

		pbyBuf++;
		CHECK_SCOPE(pbyBuf);

		pbyBuf += byTemp * sizeof( TMtVCSPlanAlias );
		CHECK_SCOPE(pbyBuf);
// 
// 		if( pbyBuf >= ( m_pPlanData + m_wBufLen) )
// 		{
// 			break;
// 		}
	}


	return FALSE;
}

/*=============================================================================
  函 数 名： GetMtPlanAliasNumByPlanName
  功    能： 获得某个预案中的TMt别名的个数
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/11/02    4.6.1         周晶晶        创建
=============================================================================*/
u8 CConfInfoFileExtraDataMgr::GetMtPlanAliasNumByPlanName( s8 *pPlanName )
{
	if( !IsReadPlan() )
	{
		return 0;
	}

	if( NULL == pPlanName )
	{
		return 0;
	}

	u8 byStrLen = strlen( pPlanName );
	if( byStrLen > VCS_MAXLEN_ALIAS )
	{
		return 0;
	}

	if( !IsHasPlanName( pPlanName ) )
	{
		return 0;
	}
	
	u8 *pbyBuf = m_pPlanData;
	
	//第一个字节是预案个数
	u8 byPlanNum = *pbyBuf;
	pbyBuf++;

	//预案个数0 返回
	if( 0 == byPlanNum )
	{
		return 0;
	}

	u8 byTemp = 0;

	for( u8 idx = 0;idx < byPlanNum;idx++ )
	{
		//现在只支持到8个电视墙预案
		if( idx >= VCS_MAXNUM_PLAN )
		{
			byPlanNum = VCS_MAXNUM_PLAN;
			break;
		}
		//预案名字长度，不包括\0
		byTemp = *pbyBuf;
		pbyBuf++;
		
		if( byStrLen == byTemp &&
			0 == memcmp( pPlanName,pbyBuf,byStrLen)
			)
		{
			pbyBuf += byStrLen;
			//终端别名个数
			byTemp = *pbyBuf;
			//pbyBuf++;		

			return byTemp;
			
		}

		pbyBuf += byTemp;
		
		//终端别名个数
		byTemp = *pbyBuf;
		pbyBuf++;
		pbyBuf += sizeof( TMtVCSPlanAlias ) * byTemp;

		if( ( m_wBufLen + m_pPlanData ) <= pbyBuf )
		{
			byPlanNum = idx + 1;
			break;
		}
	}

	return 0;
}

/*=============================================================================
  函 数 名： GetMtPlanNum
  功    能： 获得一个会议的预案数量
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/11/02    4.6.1         周晶晶        创建
=============================================================================*/
u8 CConfInfoFileExtraDataMgr::GetMtPlanNum()
{
	if( m_wBufLen > 0 && NULL != m_pPlanData )
	{
		if( m_byTvWallPlanNum == m_pPlanData[0] )
		{
			return (m_byTvWallPlanNum > VCS_MAXNUM_PLAN) ? VCS_MAXNUM_PLAN : m_byTvWallPlanNum;
		}
	}

	return 0;
	
}

/*=============================================================================
  函 数 名： GetData
  功    能： 获得buf数据并返回长度
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	11/11/14    4.6.1       周嘉麟        创建
=============================================================================*/
u16 CConfInfoFileExtraDataMgr::GetMSData(u8 *pbyBuf)
{
	u16 wLen = 0;
	if (NULL == pbyBuf)
	{
		OspPrintf(TRUE, FALSE, "[GetData] pbyBuf is null!\n");
		return 0;
	}
	//预案总数
	memcpy(pbyBuf, &m_byTvWallPlanNum, sizeof(m_byTvWallPlanNum));
	pbyBuf += sizeof(m_byTvWallPlanNum);
	wLen += sizeof(m_byTvWallPlanNum);

	//是否已读预案
	memcpy(pbyBuf, &m_byIsReadPlan, sizeof(m_byIsReadPlan));
	pbyBuf += sizeof(m_byIsReadPlan);
	wLen += sizeof(m_byIsReadPlan);

	if (NULL != m_pPlanData && 0 != m_wBufLen)
	{
		//预案数据长度
		memcpy(pbyBuf, &m_wBufLen, sizeof(m_wBufLen));
		pbyBuf += sizeof(m_wBufLen);
		wLen += sizeof(m_wBufLen);

		//预案数据
		memcpy(pbyBuf, m_pPlanData, m_wBufLen);		//lint !e670
		pbyBuf += m_wBufLen;
		wLen += m_wBufLen;
	}
	else
	{
		m_wBufLen = 0;
		//预案数据长度
		memcpy(pbyBuf, &m_wBufLen, sizeof(m_wBufLen));
		pbyBuf += sizeof(m_wBufLen);
		wLen += sizeof(m_wBufLen);
	}
	return wLen;
}

/*=============================================================================
  函 数 名： SetMSData
  功    能： 设置buf数据并返回长度
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	11/11/14    4.6.1       周嘉麟        创建
=============================================================================*/
u16 CConfInfoFileExtraDataMgr::SetMSData(u8 *pbyBuf)
{
	u16 wLen = 0;
	if (NULL == pbyBuf)
	{
		OspPrintf(TRUE, FALSE, "[SetMSData] pbyBuf is null!\n");
		return 0;
	}

	//预案总数
	memcpy(&m_byTvWallPlanNum, pbyBuf, sizeof(m_byTvWallPlanNum));
	pbyBuf += sizeof(m_byTvWallPlanNum);
	wLen += sizeof(m_byTvWallPlanNum);

	//是否已读预案
	memcpy(&m_byIsReadPlan, pbyBuf, sizeof(m_byIsReadPlan));
	pbyBuf += sizeof(m_byIsReadPlan);
	wLen += sizeof(m_byIsReadPlan);

	//预案数据长度
	memcpy(&m_wBufLen, pbyBuf, sizeof(m_wBufLen));
	pbyBuf += sizeof(m_wBufLen);
	wLen += sizeof(m_wBufLen);

	if (NULL == m_pPlanData)
	{		
		if (0 != m_wBufLen)
		{
			m_pPlanData = new u8[m_wBufLen];
			if (m_pPlanData)
			{
				//预案数据
				memcpy(m_pPlanData, pbyBuf, m_wBufLen);
				pbyBuf += m_wBufLen;
				wLen += m_wBufLen;
			}
		}
	}
	return wLen;
}

/*=============================================================================
  函 数 名： GetMSDataLen
  功    能： 获得主备CConfInfoFileExtraDataMgr备份信息长度
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： 
  ----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	11/11/14    4.6.1       周嘉麟        创建
=============================================================================*/
u16 CConfInfoFileExtraDataMgr::GetMSDataLen()
{	 
	u16 wLen = sizeof(m_byTvWallPlanNum) 
					+ sizeof(m_byIsReadPlan) 
					+ sizeof(m_wBufLen)
					+ m_wBufLen;
	LogPrint(LOG_LVL_DETAIL,MID_MCU_CFG,"[GetMSDataLen] wLen %u\n",wLen);

	return wLen;
}
////////////////////////
// 下级会议使用
////////////////////////
CConfSendSpyInfo::CConfSendSpyInfo()
{
	Clear();	
}

void CConfSendSpyInfo::Clear( void )
{
	memset( this, 0, sizeof(CConfSendSpyInfo) );
}

// u32 CConfSendSpyInfo::GetConfMaxSpyBW( void )
// {
// 	return m_dwMaxSpyBW;
// }
// 
// void CConfSendSpyInfo::SetConfMaxSpyBW( u32 dwMaxSpyBW )
// {
// 	m_dwMaxSpyBW = dwMaxSpyBW;
// }
// 
// u32 CConfSendSpyInfo::GetConfRemainSpyBW( void )
// {
// 	return m_dwRemainSpyBW;
// }
// 
// void CConfSendSpyInfo::SetConfRemainSpyBW( u32 dwRemainSpyBW )
// {
// 	m_dwRemainSpyBW = dwRemainSpyBW;
// }

/*====================================================================
    函数名      GetSpyMode
    功能        ：获取回传终端的回传Mode
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]对应的终端
    返回值说明  ：u8 回传mode
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
u8 CConfSendSpyInfo::GetSpyMode(const TMt &tMt)
{
	u8 byMode = MODE_NONE;
	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
	{
		if( m_cSpyMember[byLoop].m_tSpy == tMt )
		{
			byMode = m_cSpyMember[byLoop].m_bySpyMode;
			break;			
		}
	}
	return byMode;
}

/*====================================================================
    函数名      SetSpySimCap
    功能        ：获取回传终端的能力集
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]对应的终端
				  TSimCapSet &tDstSimCap [IN]终端能力集
    返回值说明  ：是否有此终端
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// BOOL32 CConfSendSpyInfo::SetSpySimCap(const TMt &tMt, TSimCapSet &tDstSimCap )
// {
// 	u8 byLoop = 0;
// 	for( byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
// 	{
// 		if( m_cSpyMember[byLoop].m_tSpy == tMt )
// 		{
// 			m_cSpyMember[byLoop].m_tDstSimCap = tDstSimCap;
// 			return TRUE;
// 		}
// 	}
// 
// 	for( byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
// 	{
// 		if( m_cSpyMember[byLoop].m_tSpy.IsNull() )
// 		{
// 			m_cSpyMember[byLoop].m_tSpy = tMt;
// 			m_cSpyMember[byLoop].m_tDstSimCap = tDstSimCap;
// 		}
// 		return TRUE;
// 	}
// 	return FALSE;
// }

/*====================================================================
    函数名      GetSpySimCap
    功能        ：获取回传终端的能力集
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]对应的终端
				  TSimCapSet &tDstSimCap [OUT]返回的终端能力集
    返回值说明  ：是否有此终端
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// BOOL32 CConfSendSpyInfo::GetSpySimCap(const TMt &tMt, TSimCapSet &tDstSimCap )
// {
// 	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
// 	{
// 		if( m_cSpyMember[byLoop].m_tSpy == tMt )
// 		{
// 			tDstSimCap = m_cSpyMember[byLoop].m_tDstSimCap;
// 			return TRUE;
// 		}
// 	}
// 	return FALSE;
// }

/*====================================================================
    函数名      GetSpyMtByBasResource
    功能        ：通过bas和通道查找终端回传信息
    算法实现    ：
    引用全局变量：
    输入参数说明：const TEqp &tBas [IN]bas信息
				  u8 byChlIdx	[IN]bas通道
				  u8 &byMode	[OUT]回传mode
				  TMt &tMt		[OUT]此bas通道占用的终端
				  u16 *pwSpyPort[OUT]此终端的回传端口
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// BOOL32 CConfSendSpyInfo::GetSpyMtByBasResource(const TEqp &tBas,u8 byChlIdx,u8 &byMode,TMt &tMt,u16 *pwSpyPort )
// {
// 	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
// 	{
// 		if( m_cSpyMember[byLoop].m_tSpyBasResource.GetVideoBas() == tBas &&
// 			m_cSpyMember[byLoop].m_tSpyBasResource.GetVideoChlIndex() == byChlIdx 			  
// 			)
// 		{
// 			tMt = m_cSpyMember[byLoop].m_tSpy;
// 			byMode = m_cSpyMember[byLoop].m_tSpyBasResource.GetMode();
// 			if( NULL != pwSpyPort )
// 			{
// 				*pwSpyPort = m_cSpyMember[byLoop].m_tSpyAddr.GetPort();
// 			}
// 			return TRUE;
// 		}
// 		if( m_cSpyMember[byLoop].m_tSpyBasResource.GetAudioBas() == tBas &&
// 			m_cSpyMember[byLoop].m_tSpyBasResource.GetAudioChlIndex() == byChlIdx 			  
// 			)
// 		{
// 			tMt = m_cSpyMember[byLoop].m_tSpy;
// 			byMode = m_cSpyMember[byLoop].m_tSpyBasResource.GetMode();
// 			if( NULL != pwSpyPort )
// 			{
// 				*pwSpyPort = m_cSpyMember[byLoop].m_tSpyAddr.GetPort();
// 			}
// 			return TRUE;
// 		}
// 	}
// 	return FALSE;
// }

/*====================================================================
    函数名      ClearSpyBasResourceByMt
    功能        ：删除此终端的bas资源信息
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]相应的终端信息
				  u8 byMode [IN] 回传mode
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// void CConfSendSpyInfo::ClearSpyBasResourceByMt(const TMt &tMt,u8 byMode )
// {
// 	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
// 	{
// 		if( m_cSpyMember[byLoop].m_tSpy == tMt )
// 		{
// 			m_cSpyMember[byLoop].m_tSpyBasResource.Clear( byMode );			
// 			break;
// 		}
// 	}	
// }

/*====================================================================
    函数名      ClearAllSpyBasResource
    功能        ：删除所有回传占用的bas资源信息
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// void CConfSendSpyInfo::ClearAllSpyBasResource()
// {
// 	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
// 	{		
// 		m_cSpyMember[byLoop].m_tSpyBasResource.Clear();			
// 	}
// }

/*====================================================================
    函数名      IsMtHasBasResource
    功能        ：判断终端是否使用了bas信息，如果有，返回相应的bas信息
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]对应的终端
				  TEqp *ptBas [OUT]bas外设信息
				  u8 *pbyChlIdx [OUT] 对应的外设通道
				  u8 byMode [IN]相应的mode
    返回值说明  ：BOOL32 是否有此终端的bas信息
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// BOOL32 CConfSendSpyInfo::IsMtHasBasResource(const TMt &tMt,TEqp *ptBas,u8 *pbyChlIdx,u8 byMode )
// {
// 	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
// 	{
// 		if( m_cSpyMember[byLoop].m_tSpy == tMt )
// 		{
// 			if( NULL != ptBas )
// 			{
// 				if( MODE_VIDEO == byMode )
// 				{				
// 					*ptBas = m_cSpyMember[byLoop].m_tSpyBasResource.GetVideoBas();					
// 				}
// 				else if( MODE_AUDIO == byMode )
// 				{
// 					*ptBas = m_cSpyMember[byLoop].m_tSpyBasResource.GetAudioBas();
// 				}
// 			}
// 			if( NULL != pbyChlIdx )
// 			{
// 				if( MODE_VIDEO == byMode )
// 				{				
// 					*pbyChlIdx = m_cSpyMember[byLoop].m_tSpyBasResource.GetVideoChlIndex();
// 				}
// 				else if( MODE_AUDIO == byMode )
// 				{
// 					*pbyChlIdx = m_cSpyMember[byLoop].m_tSpyBasResource.GetAudioChlIndex();
// 				}
// 			}
// 			if( MODE_VIDEO == byMode )
// 			{				
// 				return !m_cSpyMember[byLoop].m_tSpyBasResource.GetVideoBas().IsNull();
// 			}
// 			else if( MODE_AUDIO == byMode )
// 			{
// 				return !m_cSpyMember[byLoop].m_tSpyBasResource.GetAudioBas().IsNull();
// 			}			
// 									
// 		}
// 	}	
// 	return FALSE;
// }

/*====================================================================
    函数名      SetSpyBasResourceByMt
    功能        ：获取终端的bas资源信息
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]对应的终端
				  TEqp tPrsEqp [IN]bas外设信息
				  u8 byChlIdx [IN] 对应的外设通道
				  u8 byMode [IN]相应的mode
    返回值说明  ：BOOL32 设置是否成功
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// BOOL32 CConfSendSpyInfo::SetSpyBasResourceByMt(const TMt &tMt,TEqp tBas,u8 byChlIdx,u8 byMode )
// {
// 	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
// 	{
// 		if( m_cSpyMember[byLoop].m_tSpy == tMt )
// 		{
// 			/*m_cSpyMember[byLoop].m_tSpyBasResource.SetBas(tBas);
// 			m_cSpyMember[byLoop].m_tSpyBasResource.SetChlIndex(byChlIdx);
// 			m_cSpyMember[byLoop].m_tSpyBasResource.SetMode(byMode);
// 			*/
// 			m_cSpyMember[byLoop].m_tSpyBasResource.SetBasInfo( tBas,byChlIdx,byMode );
// 			return TRUE;
// 		}
// 	}
// 	return FALSE;
// }

/*====================================================================
    函数名      GetSpyBasResourceByMt
    功能        ：获取终端的bas资源信息
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]对应的终端
				  u8 byMode [IN]相应的mode
				  TEqp tPrsEqp [OUT]bas外设信息
				  u8 byChlIdx [OUT] 对应的外设通道
    返回值说明  ：BOOL32 获取是否成功
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// BOOL32 CConfSendSpyInfo::GetSpyBasResourceByMt(const TMt &tMt ,u8 byMode ,TEqp &tBas,u8 &byChlIdx )
// {
// 	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
// 	{
// 		if( m_cSpyMember[byLoop].m_tSpy == tMt )
// 		{
// 			if( m_cSpyMember[byLoop].m_tSpyBasResource.GetMode() == byMode )
// 			{
// 				if( MODE_VIDEO == byMode )
// 				{
// 					tBas = m_cSpyMember[byLoop].m_tSpyBasResource.GetVideoBas();
// 					if( tBas.IsNull() )
// 					{
// 						return FALSE;
// 					}					
// 					byChlIdx = m_cSpyMember[byLoop].m_tSpyBasResource.GetVideoChlIndex();
// 					return TRUE;
// 				}
// 				else if( MODE_AUDIO == byMode )
// 				{
// 					tBas = m_cSpyMember[byLoop].m_tSpyBasResource.GetAudioBas();
// 					if( tBas.IsNull() )
// 					{
// 						return FALSE;
// 					}
// 					byChlIdx = m_cSpyMember[byLoop].m_tSpyBasResource.GetAudioChlIndex();
// 					return TRUE;
// 				}				
// 			}
// 			return FALSE;
// 		}
// 	}
// 	return FALSE;
// }

/*====================================================================
    函数名      GetSpyPrsResourceByMt
    功能        ：获取终端的prs资源信息
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]对应的终端
				  TEqp tPrsEqp [OUT]prs外设信息
				  u8 byChlIdx [OUT] 对应的外设通道
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// BOOL32 CConfSendSpyInfo::GetSpyPrsResourceByMt(const TMt &tMt,TEqp &tPrsEqp,u8 &byChlIdx )
// {
// 	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
// 	{
// 		if( m_cSpyMember[byLoop].m_tSpy == tMt )
// 		{
// 			if( m_cSpyMember[byLoop].m_tSpyPrsResource.IsNull() )
// 			{
// 				return FALSE;
// 			}
// 			else
// 			{
// 				m_cSpyMember[byLoop].m_tSpyPrsResource.GetPrsInfo( tPrsEqp,byChlIdx );
// 				return TRUE;
// 			}
// 		}
// 	}
// 	return FALSE;
// }

/*====================================================================
    函数名      SetSpyPrsResourceByMt
    功能        ：设置终端的prs资源信息
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt tMt [IN]对应的终端信息
				  TEqp tPrsEqp [IN]对应的prs外设信息
				  u8 byChlIdx [IN]对应的prs通道
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// void   CConfSendSpyInfo::SetSpyPrsResourceByMt(const TMt &tMt,TEqp tPrsEqp,u8 byChlIdx )
// {
// 	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
// 	{
// 		if( m_cSpyMember[byLoop].m_tSpy == tMt )
// 		{			
// 			m_cSpyMember[byLoop].m_tSpyPrsResource.SetPrsInfo( tPrsEqp,byChlIdx );
// 			return;
// 		}
// 	}	
// }

/*====================================================================
    函数名      GetSendSpy
    功能        ：获取本地终端回传信息
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wIndex 相应的终端Index
    返回值说明  ：CSendSpy* 返回相应Index的本地回传信息
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
CSendSpy* CConfSendSpyInfo::GetSendSpy(u16 wIndex)
{
/*lint -save -esym(1536,CConfSendSpyInfo::m_cSpyMember)*/
	if (wIndex >= MAXNUM_CONF_SPY/*m_wSpyNum*/)
	{
		return NULL;
	}
	return &m_cSpyMember[wIndex];
/*lint -restore*/
}

/*====================================================================
    函数名      GetSendSpyNum
    功能        ：获取本地回传占用数组最大Num，
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：u16 目前数组最大占用的Num，不一定是回传终端个数
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// u16 CConfSendSpyInfo::GetSendSpyNum()
// {
// 	return m_wSpyNum;
// }


/*====================================================================
    函数名      IsOtherSpyMtUsePort
    功能        ：查找是否还有除tmt外还在用wSpyPort的回传终端
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt & tMt 在用wsport的回传终端,如果传入空的TMT表示查找是否有使用该端口的回传终端
	              const u16 wSpyPort 要查的回传端口号 
    返回值说明  ：BOOL32  TRUE 表示还有除tmt外的回传终端在用这个端口
	                       FALSE 表示没有别的回传终端在用这个端口了
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/28	4.6			zhouyiliang		Create
====================================================================*/
BOOL32 CConfSendSpyInfo::IsOtherSpyMtUsePort( const TMt& tMt, const u16 wSpyPort )
{
	BOOL32 bRet = FALSE;
	for (u8 byLoop = 0 ; byLoop < MAXNUM_CONF_SPY ; byLoop++)
	{
		if ( !m_cSpyMember[byLoop].m_tSpy.IsNull() 
			&& wSpyPort == m_cSpyMember[byLoop].m_tSpyAddr.GetPort()  ) 
		{
			if ( m_cSpyMember[byLoop].m_tSpy == tMt ) //如果就是tmt，跳过
			{
				continue;
			}
			bRet = TRUE;
			break;
		}
	}

	return bRet;
}




/*====================================================================
    函数名      GetAllUsedBasEqpId
    功能        ：获取所有使用的bas 外设ID和bas个数
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 *pabyEqpId bas的外设ID
				  u8 *pbyNum bas的个数
    返回值说明  ：BOOL32 参数是否正确
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// BOOL32 CConfSendSpyInfo::GetAllUsedBasEqpId( u8 *pabyEqpId,u8 *pbyNum )
// {
// 	if( NULL == pabyEqpId || NULL == pbyNum )
// 	{
// 		*pbyNum = 0;
// 		return FALSE;
// 	}
// 	*pbyNum = 0;
// 
// 	u8 *pabyEqpIdTemp = pabyEqpId;
// 
// 
// 	TEqp tBas;
// 	
// 	u8 byIndex = 0;
// 	u8 byIsAdded = 0;
// 	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
// 	{
// 		tBas.SetNull();
// 		tBas = m_cSpyMember[byLoop].m_tSpyBasResource.GetVideoBas();
// 		if( !tBas.IsNull() )
// 		{
// 			byIsAdded = 0;
// 			byIndex = 0;
// 			while( byIndex < *pbyNum )
// 			{
// 				if( tBas.GetEqpId() == 
// 					*(pabyEqpIdTemp+byIndex) 
// 					)
// 				{
// 					byIsAdded = 1;
// 					break;
// 				}
// 				++byIndex;
// 			}
// 			if( 0 == byIsAdded )
// 			{
// 				*pabyEqpId = tBas.GetEqpId();
// 				pabyEqpId++;
// 				*pbyNum = *pbyNum + 1;
// 			}			
// 		}
// 		tBas.SetNull();
// 		tBas = m_cSpyMember[byLoop].m_tSpyBasResource.GetAudioBas();
// 		if( !m_cSpyMember[byLoop].m_tSpyBasResource.GetAudioBas().IsNull())
// 		{
// 			byIsAdded = 0;
// 			byIndex = 0;
// 			while( byIndex < *pbyNum )
// 			{
// 				if( tBas.GetEqpId() == 
// 					*(pabyEqpIdTemp+byIndex) 
// 					)
// 				{
// 					byIsAdded = 1;
// 					break;
// 				}
// 				++byIndex;
// 			}
// 			if( 0 == byIsAdded )
// 			{
// 				*pabyEqpId = tBas.GetEqpId();
// 				pabyEqpId++;
// 				*pbyNum = *pbyNum + 1;
// 			}
// 		}
// 	}
// 
// 	
// 	return TRUE;
// 
// }

/*====================================================================
    函数名      GetAllUsedBasChlByEqp
    功能        ：获取使用此bas的所有通道号及通道数
    算法实现    ：
    引用全局变量：
    输入参数说明：TEqp tBas [IN]bas信息
				  u8 *pabyChl [OUT] 通道号数组
				  u8 *pbyNum  [OUT] 通道数
    返回值说明  ：BOOL32 参数是否正确
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// BOOL32 CConfSendSpyInfo::GetAllUsedBasChlByEqp(const TEqp &tBas,u8 *pabyChl,u8 *pbyNum )
// {
// 	if( NULL == pabyChl || NULL == pbyNum )
// 	{
// 		*pbyNum = 0;
// 		return FALSE;
// 	}
// 	*pbyNum = 0;
// 
// 	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
// 	{
// 		if( !m_cSpyMember[byLoop].m_tSpyBasResource.IsNull() )
// 		{
// 			if( m_cSpyMember[byLoop].m_tSpyBasResource.GetVideoBas() == tBas )
// 			{
// 				*pabyChl = m_cSpyMember[byLoop].m_tSpyBasResource.GetVideoChlIndex();
// 				pabyChl++;
// 				*pbyNum = *pbyNum + 1;
// 			}
// 			if( m_cSpyMember[byLoop].m_tSpyBasResource.GetAudioBas() == tBas )
// 			{
// 				*pabyChl = m_cSpyMember[byLoop].m_tSpyBasResource.GetAudioChlIndex();
// 				pabyChl++;
// 				*pbyNum = *pbyNum + 1;
// 			}
// 		}
// 	}
// 	return TRUE;
// }

/*
BOOL32 CConfSendSpyInfo::IsMtInSendSpyMember( TMt &tMt )
{
	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
	{
		if( m_cSpyMember[byLoop].m_tSpy == tMt )
		{
			return TRUE;
		}
	}
	return FALSE;
}
*/
/*
BOOL32 CConfSendSpyInfo::SetOldMode( TMt &tMt, u8 byOldMode )
{
	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
	{
		if( m_cSpyMember[byLoop].m_tSpy == tMt )
		{
			m_cSpyMember[byLoop].m_byOldSpyMode = byOldMode;
			return TRUE;
		}
	}
	return FALSE;
}
*/

/*
u8 CConfSendSpyInfo::GetOldMode( TMt &tMt )
{
	u8 byMode = MODE_NONE;
	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
	{
		if( m_cSpyMember[byLoop].m_tSpy == tMt )
		{
			byMode = m_cSpyMember[byLoop].m_byOldSpyMode;
			break;
		}
	}
	return byMode;
}
*/

/*====================================================================
    函数名      SetSpyMode
    功能        ：设置回传终端的SpyMode
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt &tMt  [IN] 回传终端
				  u8 byMode [IN] 回传mode
    返回值说明  ：BOOL32 是否查找成功。
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
/*
BOOL32 CConfSendSpyInfo::SetSpyMode( TMt &tMt, u8 byMode )
{
	// 如果已经改回传成员已经存在
	u8 byLoop;
	for( byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
	{
		if( m_cSpyMember[byLoop].m_tSpy == tMt )
		{
			m_cSpyMember[byLoop].m_bySpyMode = byMode;
			return TRUE;
		}
	}

	// 如果不存在
	for( byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
	{
		if( m_cSpyMember[byLoop].m_tSpy.IsNull() )
		{
			m_cSpyMember[byLoop].m_tSpy = tMt;
			m_cSpyMember[byLoop].m_bySpyMode = byMode;
			return TRUE;
		}
	}
	return FALSE;
}
*/
/*====================================================================
    函数名      GetSpyChannlInfo
    功能        ：获取本地终端回传信息
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt &tMt  [IN] 回传终端
				  CSendSpy &tSrcSpyInfo [OUT] 回传终端相关信息
    返回值说明  ：BOOL32 是否查找成功。
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CConfSendSpyInfo::GetSpyChannlInfo( TMt &tMt, CSendSpy &tSrcSpyInfo )
{
	u8 byLoop;
	for( byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
	{
		if( m_cSpyMember[byLoop].m_tSpy == tMt )
		{
			tSrcSpyInfo = m_cSpyMember[byLoop]; 
			return TRUE;
		}
	}
	return FALSE;
}

/*====================================================================
    函数名      IsRepeatedSpy
    功能        ：需回传的终端是否已经在回传列表中
    算法实现    ：
    引用全局变量：
    输入参数说明：CSendSpy	&tSrcSpyInfo	[i]
				：BOOL32	bNeglectMode	[i] 是否忽略回传模式比较
    返回值说明  ：BOOL32 添加是否成功。
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/08/02	4.6			xueliang		Create
====================================================================*/
BOOL32 CConfSendSpyInfo::IsRepeatedSpy( CSendSpy &tSrcSpyInfo, BOOL32 bNeglectMode/* = FALSE*/, BOOL32 bNeglectSpyPort/* = FALSE*/)
{
	BOOL32 bRet = FALSE;

	u8 byLoop = 0;
	for( byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
	{
		if( ( m_cSpyMember[byLoop].m_tSpy == tSrcSpyInfo.m_tSpy )
			&& ( m_cSpyMember[byLoop].m_bySpyMode == tSrcSpyInfo.m_bySpyMode || bNeglectMode )
			&& (m_cSpyMember[byLoop].m_tSpyAddr.GetPort() == tSrcSpyInfo.m_tSpyAddr.GetPort() || bNeglectSpyPort)
			)
		{
			bRet = TRUE;
			break;
		}
	}

	return bRet;
}


/*=============================================================================
    函 数 名： SaveSpySimCap
    功    能： 保存本级目的端能力集
    算法实现： 
    参    数： 
    返 回 值： void 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2010/09/14  6.3			pj                创建
=============================================================================*/
BOOL32 CConfSendSpyInfo::SaveSpySimCap( const TMt &tSpyMt, const TSimCapSet &tSimCap )
{
	for( u8 wLoop = 0; wLoop < MAXNUM_CONF_SPY; wLoop++ )
	{
		if( !m_cSpyMember[wLoop].m_tSpy.IsNull() && m_cSpyMember[wLoop].m_tSpy == tSpyMt )
		{
			//置成员
			m_cSpyMember[wLoop].m_tSimCapset = tSimCap;
			return TRUE;
		}
	}	
	return FALSE;	
}

/*====================================================================
    函数名      AddSpyChannlInfo
    功能        ：添加本地回传终端
    算法实现    ：
    引用全局变量：
    输入参数说明：CSendSpy &tSrcSpyInfo
    返回值说明  ：BOOL32 添加是否成功。
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CConfSendSpyInfo::AddSpyChannlInfo( CSendSpy &tSrcSpyInfo )
{
	// 如果已经在列表中
	u8 byLoop = 0;
	for( byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
	{
		if( m_cSpyMember[byLoop].m_tSpy == tSrcSpyInfo.m_tSpy )
		{
			m_cSpyMember[byLoop].m_tSpy = tSrcSpyInfo.m_tSpy;
			
			m_cSpyMember[byLoop].m_bySpyMode = tSrcSpyInfo.m_bySpyMode;
			m_cSpyMember[byLoop].m_tSpyAddr.SetPort( tSrcSpyInfo.m_tSpyAddr.GetPort() );
			return TRUE;
		}
	}
	// 否则保存相应的信息
	for( byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
	{
		if( m_cSpyMember[byLoop].m_tSpy.IsNull() )
		{
			m_cSpyMember[byLoop] = tSrcSpyInfo;
// 			if (m_wSpyNum < byLoop + 1)
// 			{
// 				m_wSpyNum = byLoop + 1;
// 			}
			return TRUE;
		}
	}
	// 否则已经达到回传上限
	return FALSE;
}


/*====================================================================
    函数名      FreeSpyChannlInfo
    功能        ：释放本地回传终端的SpyMode
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt &tMt 需要释放的终端
				  u8 bySpyMode 需要释放的mode
    返回值说明  ：BOOL32 添加是否成功。
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CConfSendSpyInfo::FreeSpyChannlInfo(const TMt &tMt, u8 bySpyMode)
{
	BOOL32 bRet = TRUE;
	u8 byLoop = 0;
	u16 wSpyNum = MAXNUM_CONF_SPY/*m_wSpyNum*/;
	for( byLoop = 0; byLoop < wSpyNum; byLoop++ )
	{
		if ( m_cSpyMember[byLoop].m_tSpy.IsNull())
		{
			continue;
		}
		if( m_cSpyMember[byLoop].m_tSpy == tMt )
		{
			if( bySpyMode == MODE_BOTH )
			{
				m_cSpyMember[byLoop].m_bySpyMode = MODE_NONE;
			}
			else if( bySpyMode == MODE_VIDEO )
			{
				if( m_cSpyMember[byLoop].m_bySpyMode == MODE_BOTH )
				{
					m_cSpyMember[byLoop].m_bySpyMode = MODE_AUDIO;
				}
				else if( m_cSpyMember[byLoop].m_bySpyMode == MODE_VIDEO)
				{
					m_cSpyMember[byLoop].m_bySpyMode = MODE_NONE;
				}
				else
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_SPY, " FreeSpyChannlInfo False !\n" );
					bRet = FALSE;
				}
			}
			else if( bySpyMode == MODE_AUDIO )
			{
				if( m_cSpyMember[byLoop].m_bySpyMode == MODE_BOTH )
				{
					m_cSpyMember[byLoop].m_bySpyMode = MODE_VIDEO;
				}
				else if( m_cSpyMember[byLoop].m_bySpyMode == MODE_AUDIO)
				{
					m_cSpyMember[byLoop].m_bySpyMode = MODE_NONE;
				}
				else
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_SPY, " FreeSpyChannlInfo False !\n" );
					bRet = FALSE;
				}
			}
			else
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_SPY, " FreeSpyChannlInfo False !\n" );
				bRet = FALSE;
			}

			if (bRet && m_cSpyMember[byLoop].m_bySpyMode == MODE_NONE)
			{
				m_cSpyMember[byLoop].Clear();

// 				if (m_wSpyNum == byLoop + 1)
// 				{
// 					--m_wSpyNum;
// 				}
			}
		}
	}
	return bRet;
}
////////////////////////
// End 下级会议使用
////////////////////////



////////////////////////
// 上级会议使用
////////////////////////
CConfRecvSpyInfo::CConfRecvSpyInfo()
{
	Clear();
}

/*====================================================================
    函数名      Clear
    功能        ：删除所有下级回传终端信息，如果有mana，可以释放掉chnnl
    算法实现    ：
    引用全局变量：
    输入参数说明：CMultiSpyMgr *pcMultiSpyMgr 回传通道管理类
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
void CConfRecvSpyInfo::Clear( CMultiSpyMgr *pcMultiSpyMgr )
{
	if (pcMultiSpyMgr != NULL)
	{
		u8 byChl = 0;
		u16 wSpyNum = MAXNUM_CONF_SPY/*min(GetSpyNum(), (MAXNUM_CONF_SPY - 1))*/;
		for(u16 wLoop = 0; wLoop < wSpyNum; wLoop ++)
		{
			if ( m_cSpyMember[wLoop].m_tSpyAddr.GetPort() != SPY_CHANNL_NULL &&
				m_cSpyMember[wLoop].m_tSpyAddr.GetPort() >= CASCADE_SPY_STARTPORT )
			{
				byChl = ( m_cSpyMember[wLoop].m_tSpyAddr.GetPort() - CASCADE_SPY_STARTPORT ) / PORTSPAN;
				pcMultiSpyMgr->ReleaseSpyChnnl( byChl );
			}
		}
	}

	memset( this, 0, sizeof(CConfRecvSpyInfo) );
}

/*
s16 CConfRecvSpyInfo::FindSpyMt(const TMt &tMt)
{
	for( u16 wLoop = 0; wLoop < min(GetSpyNum(), (MAXNUM_CONF_SPY - 1)); wLoop++ )
	{
		if( m_cSpyMember[wLoop].m_tSpy == tMt )
		{
			return wLoop;
		}
	}

	return -1;
}
*/

/*====================================================================
    函数名      ：GetFstSpyMtByMcuIdx
    功能        ：查找某个mcu下的首个终端
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wMcuIdx 要查找的终端的所属的mcuidx
				  TMt &tMt 找到的回传终端
    返回值说明  ：是否找到
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/08/25	4.6.2		周晶晶			Create
====================================================================*/
BOOL32 CConfRecvSpyInfo::GetFstSpyMtByMcuIdx( u16 wMcuIdx,TMt &tMt )
{	
	u16 wSpyNum = MAXNUM_CONF_SPY/*min(GetSpyNum(), (MAXNUM_CONF_SPY - 1))*/;
	for( u16 wLoop = 0; wLoop < wSpyNum; wLoop++ )
	{
		if( !m_cSpyMember[wLoop].m_tSpy.IsNull() &&
			m_cSpyMember[wLoop].m_tSpy.GetMcuId() == wMcuIdx 
			)
		{
			tMt = m_cSpyMember[wLoop].m_tSpy;
			return TRUE;
		}
	}
	return FALSE;
}
/*====================================================================
    函数名      FindSpyMt
    功能        ：查找对应的回传终端，并返回相应的Index
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt 终端
				  u8 bySpyMode 回传mode defult MODE_NONE，表示可以忽略mode
    返回值说明  ：s16 如果找到返回响应的Index，没有找到返回-1
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
s16 CConfRecvSpyInfo::FindSpyMt(const TMt &tMt, u8 bySpyMode)
{
	if (tMt.IsNull() || tMt.IsLocal())
	{
		return -1;
	}

	//如果是MODE_NONE，表示只需要匹配终端是否相等
	u16 wSpyNum = MAXNUM_CONF_SPY/*min(GetSpyNum(), (MAXNUM_CONF_SPY - 1))*/;
	if (bySpyMode == MODE_NONE)
	{
		for( u16 wLoop = 0; wLoop < wSpyNum; wLoop++ )
		{
			if( m_cSpyMember[wLoop].m_tSpy == tMt )
			{
				return wLoop;
			}
		}
	}
	else
	{
		for( u16 wLoop = 0; wLoop < wSpyNum; wLoop++ )
		{
			if (m_cSpyMember[wLoop].m_tSpy == tMt
				&& (m_cSpyMember[wLoop].m_bySpyMode == MODE_BOTH 
				|| m_cSpyMember[wLoop].m_bySpyMode == bySpyMode))
			{
				return wLoop;
			}
		}
	}

	return -1;
}

/*====================================================================
    函数名      IsMtInSpyMember
    功能        ：判断终端和对应的mode是否在回传通道中
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt 终端
				  u8 bySpyMode 回传mode defult MODE_NONE，表示可以忽略mode
    返回值说明  ：是否在回传通道中
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CConfRecvSpyInfo::IsMtInSpyMember(const TMt &tMt, u8 bySpyMode)
{
	return (-1 != FindSpyMt(tMt, bySpyMode));
}

/*
BOOL32 CConfRecvSpyInfo::IsMcuMtInSpyMember(const u8 byMcuId )
{
	for( u16 wLoop = 0; wLoop < min(GetSpyNum(), (MAXNUM_CONF_SPY - 1)); wLoop++ )
	{
		if( m_cSpyMember[wLoop].m_tSpy.GetMcuId() == byMcuId &&
			m_cSpyMember[wLoop].m_byVSpyDstNum != 0 &&
			m_cSpyMember[wLoop].m_byASpyDstNum != 0 )
		{
			return TRUE;
		}
	}
	return FALSE;
}
*/

/*
BOOL32 CConfRecvSpyInfo::IsMtInSpyMember(const TMt &tMt )
{
	return (-1 != FindSpyMt(tMt));
}
*/

/*====================================================================
    函数名      GetSpyMtBySpyPort
    功能        ：通过回传端口查找终端
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wSpyPort [IN]回传端口
				  TMt &tSrc [OUT] 回传终端
    返回值说明  ：是否在回传通道中
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// BOOL32 CConfRecvSpyInfo::GetSpyMtBySpyPort( u16 wSpyPort,TMt &tSrc )
// {
// 	u16 wSpyNum = MAXNUM_CONF_SPY/*min(GetSpyNum(), (MAXNUM_CONF_SPY - 1))*/;
// 	for( u16 wLoop = 0; wLoop < wSpyNum; wLoop++ )
// 	{
// 		if( m_cSpyMember[wLoop].m_tSpyAddr.GetPort() ==  wSpyPort ||
// 			(m_cSpyMember[wLoop].m_tSpyAddr.GetPort() + 2) ==  wSpyPort )
// 		{
// 			tSrc = m_cSpyMember[wLoop].m_tSpy;
// 			return TRUE;		
// 		}
// 	}
// 	return FALSE;
// }

/*====================================================================
    函数名      FreeSpyChannlInfoByMcuId
    功能        ：释放
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMcuId 下级mcuid
				  CMultiSpyMgr *pcMultiSpyMgr 通道管理类指针
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// void  CConfRecvSpyInfo::FreeSpyChannlInfoByMcuId( u16 wMcuIdx, CMultiSpyMgr *pcMultiSpyMgr)
// {
// 	u16 wSpyChnnl = 0;
// 
// 	if(pcMultiSpyMgr == NULL)
// 	{
// 		return;
// 	}
//     u16 wSpyNum = min(GetSpyNum(), (MAXNUM_CONF_SPY - 1));
// 	for( u16 wLoop = 0; wLoop < wSpyNum; wLoop++ )
// 	{
// 		if( m_cSpyMember[wLoop].m_tSpy.GetMcuId() == wMcuIdx )
// 		{
// 			// 正常释放多回传通道、资源
// 			if( m_cSpyMember[wLoop].m_tSpyAddr.GetPort() < MT_MCU_STARTPORT )
// 			{
// 				wSpyChnnl = (m_cSpyMember[wLoop].m_tSpyAddr.GetPort() - CASCADE_SPY_STARTPORT) / PORTSPAN;
// 				pcMultiSpyMgr->ReleaseSpyChnnl( wSpyChnnl );
// 			}
// 
// 			m_cSpyMember[wLoop].Clear();
// 		}
// 	}
// }

/*====================================================================
    函数名      GetSpyNum
    功能        ：获取当前CRecvSpy m_cSpyMember[MAXNUM_CONF_SPY]中最大占用num
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：u16 当然CRecvSpy m_cSpyMember[MAXNUM_CONF_SPY]中最大占用num，不一定是回传数
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// u16 CConfRecvSpyInfo::GetSpyNum()
// {
// 	return m_wSpyNum;
// }


//lukunpeng 2010/07/19 暂时无用函数注掉
/*
BOOL32 CConfRecvSpyInfo::IsUsedSpyMode(const TMt &tMt, u8 bySpyMode )
{
	s16 nIndex = 0;
	
	nIndex = FindSpyMt(tMt);
	
	if (nIndex == -1)
	{
		return FALSE;
	}

	CRecvSpy *pcSpyMember = &m_cSpyMember[nIndex];

	if( bySpyMode == MODE_BOTH )
	{
		if( (pcSpyMember->m_byASpyDstNum == 0)
			&& (pcSpyMember->m_byVSpyDstNum == 0) )
		{
			return FALSE;
		}
	}
	else if( bySpyMode == MODE_VIDEO )
	{
		if( pcSpyMember->m_byVSpyDstNum == 0)
		{
			return FALSE;
		}
	}
	else if( bySpyMode == MODE_AUDIO )
	{
		if( pcSpyMember->m_byASpyDstNum == 0)
		{
			return FALSE;
		}
	}
	else
	{

	}

	return FALSE;
}
*/

/*====================================================================
    函数名      GetRecvSpy
    功能        ：根据TMT获取相应的回传信息
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]终端信息
				  CRecvSpy &tSrcSpyInfo [OUT]此终端回传信息
    返回值说明  ：是否找到此TMT
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CConfRecvSpyInfo::GetRecvSpy(const TMt &tMt, CRecvSpy &tSrcSpyInfo )
{
	s16 nIndex = 0;

	nIndex = FindSpyMt(tMt);
	
	if (nIndex == -1)
	{
		return FALSE;
	}
	
	tSrcSpyInfo = m_cSpyMember[nIndex];

	return TRUE;
}

/*====================================================================
    函数名      ReleasePreAddRes
    功能        ：释放预占用标志
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]终端信息
				  
    返回值说明  ：是否找到此TMT
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/08/04	4.6			周晶晶			Create
====================================================================*/
BOOL32 CConfRecvSpyInfo::ReleasePreAddRes( const TMt &tMt,u32 &dwReleaseBW,s16& swChnnlID )
{
	s16 nIndex = 0;

	nIndex = FindSpyMt(tMt);
	
	if (nIndex == -1)
	{
		return FALSE;
	}
	
	if( TSpyStatus::WAIT_USE != m_cSpyMember[nIndex].m_byUseState )
	{
		return FALSE;
	}

	//此SpyMt的SpyMode目的数减一
	if (!DecSpyModeDst(nIndex, m_cSpyMember[nIndex].m_byPreAddMode,m_cSpyMember[nIndex].m_byPreAddDstNum))
	{
		return FALSE;
	}
	u8 byRelSpyMode = 0;
	//调整目的数改变后的相应Spymode，如果有释放，把释放的带宽返回。
	AdjustSpyMode(nIndex, dwReleaseBW, swChnnlID, byRelSpyMode);

	//有可释放预占用带宽时，表明需要调整预占用模式[7/31/2012 chendaiwei]
	if( dwReleaseBW != 0 )
	{
		if( byRelSpyMode == m_cSpyMember[nIndex].m_byPreAddMode)
		{
			if( -1 != swChnnlID )
			{
				m_cSpyMember[nIndex].m_byUseState = TSpyStatus::IDLE;		
			}
			
			m_cSpyMember[nIndex].m_byPreAddMode = 0;
			m_cSpyMember[nIndex].m_byPreAddDstNum = 0;	
		}
		else if( MODE_BOTH == m_cSpyMember[nIndex].m_byPreAddMode && MODE_VIDEO == byRelSpyMode )
		{
			m_cSpyMember[nIndex].m_byPreAddMode = MODE_AUDIO;
		}
		else if ( MODE_BOTH == m_cSpyMember[nIndex].m_byPreAddMode && MODE_AUDIO == byRelSpyMode )
		{
			m_cSpyMember[nIndex].m_byPreAddMode = MODE_VIDEO;
		}
		else
		{
			//nothing to do
		}
	}

	return TRUE;
}

/*====================================================================
    函数名        SetSpyBackRtcpAddr
    功能        ：设置为下级会议分配的回传通道的视频RTCP地址
    算法实现    ：
    引用全局变量：
    输入参数说明：s16 swSpyIndex[in]: 回传通道的索引
	              TTransportAddr tVideoRtcpAddr[in]:视频RTCP信息
				  
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期         版本     修改人        修改内容
	2010/10/24				倪志俊	       Create
====================================================================*/
void CConfRecvSpyInfo::SetSpyBackVidRtcpAddr(s16 swSpyIndex, u8 bySpyMode,
										  TTransportAddr tVideoRtcpAddr)
{
	if (swSpyIndex >= MAXNUM_CONF_SPY || swSpyIndex < 0)
	{
		return ;
	}
	
	if(MODE_VIDEO == bySpyMode || MODE_BOTH == bySpyMode)
	{
		m_cSpyMember[swSpyIndex].SetVidSpyBackRtcpAddr(tVideoRtcpAddr);
	}
}

/*====================================================================
    函数名        SetSpyBackRtcpAddr
    功能        ：设置为下级会议分配的回传通道的音频RTCP地址
    算法实现    ：
    引用全局变量：
    输入参数说明：s16 swSpyIndex[in]: 回传通道的索引
	              TTransportAddr tAudioRtcpAddr[in]:音频RTCP信息
				  
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期         版本     修改人        修改内容
	2010/10/24				倪志俊	       Create
====================================================================*/
void CConfRecvSpyInfo::SetSpyBackAudRtcpAddr(s16 swSpyIndex, u8 bySpyMode,
										  TTransportAddr tAudioRtcpAddr)
{
	if (swSpyIndex >= MAXNUM_CONF_SPY || swSpyIndex < 0)
	{
		return ;
	}
	
	if(MODE_AUDIO == bySpyMode || MODE_BOTH == bySpyMode)
	{
		m_cSpyMember[swSpyIndex].SetAudSpyBackRtcpAddr(tAudioRtcpAddr);
	}
}

/*====================================================================
    函数名      GetSpyBackVidRtcpAddr
    功能        :得到下级为其下级会议分配的RTCP地址
    算法实现    ：
    引用全局变量：
    输入参数说明：s16 swSpyIndex[in]:  回传通道的索引
	              TTransportAddr tVideoRtcpAddr[out]:视频RTCP信息
				  
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/12/24				倪志俊   	  Create
====================================================================*/
void CConfRecvSpyInfo::GetSpyBackVidRtcpAddr(s16 swSpyIndex, u8 bySpyMode, TTransportAddr &tVideoRtcpAddr)
{
	if (swSpyIndex >= MAXNUM_CONF_SPY || swSpyIndex < 0)
	{
		return ;
	}

	if(MODE_VIDEO == bySpyMode || MODE_BOTH == bySpyMode)
	{
		tVideoRtcpAddr = m_cSpyMember[swSpyIndex].GetVidSpyBackRtcpAddr();
	}
}

/*====================================================================
    函数名      GetSpyBackVidRtcpAddr
    功能        :得到下级为其下级会议分配的RTCP地址
    算法实现    ：
    引用全局变量：
    输入参数说明：s16 swSpyIndex[in]:  回传通道的索引
	              TTransportAddr tAudRtcpAddr[out]:音频RTCP信息
				  
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/12/24				倪志俊   	  Create
====================================================================*/
void CConfRecvSpyInfo::GetSpyBackAudRtcpAddr(s16 swSpyIndex, u8 bySpyMode, TTransportAddr& tAudRtcpAddr)
{
	if (swSpyIndex >= MAXNUM_CONF_SPY || swSpyIndex < 0)
	{
		return ;
	}

	if(MODE_AUDIO == bySpyMode || MODE_BOTH == bySpyMode)
	{
		tAudRtcpAddr = m_cSpyMember[swSpyIndex].GetAudSpyBackRtcpAddr();
	}
}

/*====================================================================
    函数名      ClearPreAdd
    功能        ：清楚预占用标志
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]终端信息
				  
    返回值说明  ：是否找到此TMT
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/08/04	4.6			周晶晶			Create
====================================================================*/
BOOL32 CConfRecvSpyInfo::ModifyUseState( const TMt &tMt,u8 byState )
{
	if( byState > TSpyStatus::WAIT_USE )
	{
		return FALSE;
	}

	s16 nIndex = 0;

	nIndex = FindSpyMt(tMt);
	
	if (nIndex == -1)
	{
		return FALSE;
	}

	m_cSpyMember[nIndex].m_byUseState = byState;
	if( byState != TSpyStatus::WAIT_USE )
	{
		m_cSpyMember[nIndex].m_byPreAddMode = 0;
		m_cSpyMember[nIndex].m_byPreAddDstNum = 0;
	}

	return TRUE;
	
	
}

BOOL32 CConfRecvSpyInfo::ModifyUseState( s16 swSpyIndex,u8 byState )
{
	if( byState > TSpyStatus::WAIT_USE )
	{
		return FALSE;
	}

	if (swSpyIndex == -1 || swSpyIndex >= MAXNUM_CONF_SPY )
	{
		return FALSE;
	}

	//CRecvSpy *pcSpyMember = &m_cSpyMember[swSpyIndex];

	m_cSpyMember[swSpyIndex].m_byUseState = byState;
	if( byState != TSpyStatus::WAIT_USE )
	{
		m_cSpyMember[swSpyIndex].m_byPreAddMode = 0;
		m_cSpyMember[swSpyIndex].m_byPreAddDstNum = 0;
	}

	return TRUE;

}
/*====================================================================
    函数名      LeftOnceToFree
    功能        ：根据TMT和回传Mode获得可释放带宽和可释放通道Index
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]终端信息
				  u8 bySpyMode [IN]回传mode
				  u32 &dwCanReleaseBW [OUT]可释放带宽
				  s16& swCanRelIndex [OUT]可释放通道的Index
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
void CConfRecvSpyInfo::LeftOnceToFree(const TMt &tMt, u8 bySpyMode, u32 &dwCanReleaseBW, s16& swCanRelIndex)
{
	s16 nIndex = 0;

	nIndex = FindSpyMt(tMt);

	swCanRelIndex = -1;
	
	if (nIndex == -1)
	{
		return;
	}
	
	CRecvSpy *pcSpyMember = &m_cSpyMember[nIndex];


	u8 byASpyDstNum = pcSpyMember->m_byASpyDstNum;
	u8 byVSpyDstNum = pcSpyMember->m_byVSpyDstNum;
	
	if( bySpyMode == MODE_BOTH )
	{
		if( (pcSpyMember->m_byASpyDstNum <= 1)
			&& (pcSpyMember->m_byVSpyDstNum <= 1) )
		{
			dwCanReleaseBW += pcSpyMember->m_dwVidBW + pcSpyMember->m_dwAudBW;
			byASpyDstNum = 0;
			byVSpyDstNum = 0;
		}
	}
	else if( bySpyMode == MODE_VIDEO )
	{
		if( pcSpyMember->m_byVSpyDstNum <= 1)
		{
			dwCanReleaseBW += pcSpyMember->m_dwVidBW;
			byVSpyDstNum = 0;
		}
	}
	else if( bySpyMode == MODE_AUDIO )
	{
		if( pcSpyMember->m_byASpyDstNum <= 1)
		{
			dwCanReleaseBW += pcSpyMember->m_dwAudBW;
			byASpyDstNum = 0;
		}
	}
	else
	{
		
	}

	//如果音视频目的数都是零，代表可释放该通道
	if (byASpyDstNum == 0 && byVSpyDstNum == 0)
	{
		swCanRelIndex = nIndex;
	}
	
	return;
}

/*====================================================================
    函数名      ：IsCanFree
    功能        ：根据TMT和回传Mode获得可释放带宽和可释放通道Index
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]终端信息
				  u8 bySpyMode [IN]回传mode
				  u8 byVideoDstNum [IN]在释放范围内的视频目的数
				  u8 byAudioDstNum [IN]在释放范围内的音频目的数
				  u32 &dwCanReleaseBW [OUT]可释放带宽
				  s16& swCanRelIndex [OUT]可释放通道的Index
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
void CConfRecvSpyInfo::IsCanFree( const TMt &tMt, u8 bySpyMode, 
							   u8 byVideoDstNum, u8 byAudioDstNum, 
							   u32 &dwCanReleaseBW, s16& swCanRelIndex )
{
	s16 nIndex = 0;

	nIndex = FindSpyMt(tMt);

	swCanRelIndex = -1;
	
	if (nIndex == -1)
	{
		return;
	}
	
	CRecvSpy *pcSpyMember = &m_cSpyMember[nIndex];


	u8 byASpyDstNum = pcSpyMember->m_byASpyDstNum;
	u8 byVSpyDstNum = pcSpyMember->m_byVSpyDstNum;
	
	if( bySpyMode == MODE_BOTH )
	{
		if( (pcSpyMember->m_byASpyDstNum <= byAudioDstNum)
			&& (pcSpyMember->m_byVSpyDstNum <= byVideoDstNum) )
		{
			dwCanReleaseBW += pcSpyMember->m_dwVidBW + pcSpyMember->m_dwAudBW;
			byASpyDstNum = 0;
			byVSpyDstNum = 0;
		}
	}
	else if( bySpyMode == MODE_VIDEO )
	{
		if( pcSpyMember->m_byVSpyDstNum <= byVideoDstNum)
		{
			dwCanReleaseBW += pcSpyMember->m_dwVidBW;
			byVSpyDstNum = 0;
		}
	}
	else if( bySpyMode == MODE_AUDIO )
	{
		if( pcSpyMember->m_byASpyDstNum <= byAudioDstNum)
		{
			dwCanReleaseBW += pcSpyMember->m_dwAudBW;
			byASpyDstNum = 0;
		}
	}
	else
	{
		
	}

	//如果音视频目的数都是零，代表可释放该通道
	if (byASpyDstNum == 0 && byVSpyDstNum == 0)
	{
		swCanRelIndex = nIndex;
	}
	
	return;
}

/*=============================================================================
    函 数 名： AddSpyChnnlInfo
    功    能： 添加回传通道信息
    算法实现： 
    参    数： const TMt &tMt	回传终端
			   u16 SpyStartPort	回传端口
			   BOOL32 bIsPreAdd 是否预占用
    返 回 值： void 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2010/06/10  6.3			lukunpeng                创建
	2010/08/05	6.3			周晶晶					修改(增加预占用参数)
=============================================================================*/
BOOL32 CConfRecvSpyInfo::AddSpyChnnlInfo(const TMt &tMt, u16 SpyStartPort, s16 &swIndex,BOOL32 bIsPreAdd/* = FALSE*/)
{
	swIndex = -1;

	for( u8 wLoop = 0; wLoop < MAXNUM_CONF_SPY; wLoop++ )
	{
		if( m_cSpyMember[wLoop].m_tSpy.IsNull() )
		{
			//置成员
			m_cSpyMember[wLoop].m_tSpy = tMt;
			m_cSpyMember[wLoop].m_tSpyAddr.SetPort( SpyStartPort );
			m_cSpyMember[wLoop].m_byUseState = bIsPreAdd ? TSpyStatus::WAIT_USE : TSpyStatus::NORMAL;

// 			if (m_wSpyNum <= wLoop + 1)
// 			{
// 				m_wSpyNum = wLoop + 1;
// 			}

			swIndex = wLoop;
			return TRUE;
		}
	}

	return FALSE;
}


/*=============================================================================
    函 数 名： SaveSpySimCap
    功    能： 保存本级目的端能力集
    算法实现： 
    参    数： 
    返 回 值： void 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2010/09/14  6.3			pj                创建
=============================================================================*/
BOOL32 CConfRecvSpyInfo::SaveSpySimCap( const TMt &tSpyMt, const TSimCapSet &tSimCap )
{
	for( u8 wLoop = 0; wLoop < MAXNUM_CONF_SPY; wLoop++ )
	{
		if( !m_cSpyMember[wLoop].m_tSpy.IsNull() && m_cSpyMember[wLoop].m_tSpy == tSpyMt )
		{
			//置成员
			m_cSpyMember[wLoop].m_tSimCapset = tSimCap;
			return TRUE;
		}
	}
	
	return FALSE;	
}

/*=============================================================================
    函 数 名： GetSpySimCap
    功    能： 获取本级目的端能力集
    算法实现： 
    参    数： 
    返 回 值： void 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2011/01/21  4.6			xl						创建
=============================================================================*/
BOOL32 CConfRecvSpyInfo::GetSpySimCap( const TMt &tSpyMt, TSimCapSet &tSimCap ) const
{
	for( u8 wLoop = 0; wLoop < MAXNUM_CONF_SPY; wLoop++ )
	{
		if( !m_cSpyMember[wLoop].m_tSpy.IsNull() && m_cSpyMember[wLoop].m_tSpy == tSpyMt )
		{
			//置成员
			tSimCap = m_cSpyMember[wLoop].m_tSimCapset;
			return TRUE;
		}
	}	
	return FALSE;	
}
/*=============================================================================
    函 数 名： RemoveSpyMode
    功    能： 删除此终端的回传mode，返回响应的释放带宽
    算法实现： 
    参    数： const TMt &tMt	回传终端
			   u8 bySpyMode		回传mode
			   u32& dwReleaseBW 可释放带宽
    返 回 值： void 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2010/06/10  6.3			lukunpeng                创建
=============================================================================*/
BOOL32 CConfRecvSpyInfo::RemoveSpyMode(const TMt &tMt, u8 bySpyMode, u32& dwReleaseBW, s16& swChnnlID, u8& byRelSpyMode)
{
	dwReleaseBW = 0;

	s16 nIndex = 0;
	
	nIndex = FindSpyMt(tMt);
	
	if (nIndex == -1)
	{
		return FALSE;
	}

	if (!ClearSpyModeDst(nIndex, bySpyMode))
	{
		return FALSE;
	}
	

	AdjustSpyMode(nIndex, dwReleaseBW, swChnnlID, byRelSpyMode);

	return TRUE;
}

/*====================================================================
    函数名      DecAndAdjustSpyMode
    功能        ：根据终端及回传mode减计数，并且当计数为0后调整当前的mode，
				返回可释放带宽，可释放通道及释放的回传mode。
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]终端信息
				  u8 bySpyMode [IN]回传mode
				  u32 &dwReleaseBW [OUT]可释放带宽
				  s16& swChnnlID [OUT]可释放通道
				  u8& byRelSpyMode 释放的spymode
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CConfRecvSpyInfo::DecAndAdjustSpyMode(const TMt &tMt, u8 bySpyMode, u32& dwReleaseBW, s16& swChnnlID, u8& byRelSpyMode)
{
	dwReleaseBW = 0;
	swChnnlID = -1;
	byRelSpyMode = MODE_NONE;
	
	s16 nIndex = 0;
	
	//找到此SpyMt的Index
	nIndex = FindSpyMt(tMt);
	
	if (nIndex == -1)
	{
		return FALSE;
	}
	
	//CRecvSpy *pcSpyMember = &m_cSpyMember[nIndex];
	

	//此SpyMt的SpyMode目的数减一
	if (!DecSpyModeDst(nIndex, bySpyMode))
	{
		return FALSE;
	}
	
	//调整目的数改变后的相应Spymode，如果有释放，把释放的带宽返回。
	AdjustSpyMode(nIndex, dwReleaseBW, swChnnlID, byRelSpyMode);
	
	return TRUE;
}

/*====================================================================
    函数名      AdjustSpyMode
    功能        ：根据终端调整当前的mode，
				返回可释放带宽，可释放通道及释放的回传mode。
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]终端信息
				  u32 &dwReleaseBW [OUT]可释放带宽
				  s16& swChnnlID [OUT]可释放通道
				  u8& byRelSpyMode 释放的spymode
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
void CConfRecvSpyInfo::AdjustSpyMode(const TMt &tMt, u32 &dwReleaseBW, s16& swChnnlID, u8& byRelSpyMode)
{
	dwReleaseBW = 0;
	swChnnlID = -1;
	byRelSpyMode = MODE_NONE;

	s16 nIndex = 0;
	nIndex = FindSpyMt(tMt);
	if (nIndex == -1)
	{
		return;
	}

	AdjustSpyMode(nIndex, dwReleaseBW, swChnnlID, byRelSpyMode);

	return;
}

/*====================================================================
    函数名      IncSpyModeDst
    功能        ：根据终端和spymode增加计数
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]终端信息
				  u8 bySpyMode [IN]回传mode
				  u8 byDstNum [IN]计数
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// BOOL32 CConfRecvSpyInfo::IncSpyModeDst(const TMt &tMt, u8 bySpyMode, u8 byDstNum, BOOL32 bIsPreAdd )
// {
// 	s16 nIndex = 0;
// 	
// 	nIndex = FindSpyMt(tMt);
// 	
// 	if (nIndex == -1)
// 	{
// 		return FALSE;
// 	}
// 
// 	return IncSpyModeDst(nIndex, bySpyMode, byDstNum, bIsPreAdd);
// }
/*====================================================================
    函数名      DecSpyModeDst
    功能        ：根据终端和spymode减少计数
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt [IN]终端信息
				  u8 bySpyMode [IN]回传mode
				  u8 byDstNum [IN]计数
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
// BOOL32 CConfRecvSpyInfo::DecSpyModeDst(const TMt &tMt, u8 bySpyMode, u8 byDstNum)
// {
// 	s16 nIndex = 0;
// 	
// 	nIndex = FindSpyMt(tMt);
// 	
// 	if (nIndex == -1)
// 	{
// 		return FALSE;
// 	}
// 
// 	return DecSpyModeDst(nIndex, bySpyMode, byDstNum);
// }


/*====================================================================
    函数名      ReplaceSpy
    功能        ：根据索引替换掉终端
    算法实现    ：
    引用全局变量：
    输入参数说明：s16 swSpyIndex 回传信息索引
				  const TMt &tMt 变更后的终端
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
void CConfRecvSpyInfo::ReplaceSpy(s16 swSpyIndex, const TMt &tMt)
{
	if (swSpyIndex >= MAXNUM_CONF_SPY || swSpyIndex < 0)
	{
		return;
	}

	CRecvSpy *pcSpyMember = &m_cSpyMember[swSpyIndex];

	//注意，需要之前的Port信息。
	//u16 wPort = pcSpyMember->m_tSpyAddr.GetPort();
	pcSpyMember->Clear();

	pcSpyMember->m_tSpy = tMt;
}

/*====================================================================
    函数名      AdjustSpyMode
    功能        ：根据终端调整当前的mode，
				返回可释放带宽，可释放通道及释放的回传mode。
    算法实现    ：
    引用全局变量：
    输入参数说明：s16 swSpyIndex 回传信息索引
				  u32 &dwReleaseBW [OUT]可释放带宽
				  s16& swChnnlID [OUT]可释放通道
				  u8& byRelSpyMode 释放的spymode
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
void CConfRecvSpyInfo::AdjustSpyMode(s16 swSpyIndex, u32 &dwReleaseBW, s16& swChnnlID, u8& byRelSpyMode)
{
	dwReleaseBW = 0;
	swChnnlID = -1;
	byRelSpyMode = MODE_NONE;

	if (swSpyIndex >= MAXNUM_CONF_SPY || swSpyIndex < 0)
	{
		return;
	}

	CRecvSpy *pcSpyMember = &m_cSpyMember[swSpyIndex];

	if (pcSpyMember->m_byVSpyDstNum == 0)
	{
		if( pcSpyMember->m_bySpyMode == MODE_BOTH)
		{
			pcSpyMember->m_bySpyMode = MODE_AUDIO;
			dwReleaseBW += pcSpyMember->m_dwVidBW;
			pcSpyMember->m_dwVidBW = 0;
			byRelSpyMode = MODE_VIDEO;
		}
		else if (pcSpyMember->m_bySpyMode == MODE_VIDEO)
		{
			pcSpyMember->m_bySpyMode = MODE_NONE;
			dwReleaseBW += pcSpyMember->m_dwVidBW;
			pcSpyMember->m_dwVidBW = 0;
			byRelSpyMode = MODE_VIDEO;
		}
		else
		{

		}
	}

	if (pcSpyMember->m_byASpyDstNum == 0)
	{
		if( pcSpyMember->m_bySpyMode == MODE_BOTH)
		{
			pcSpyMember->m_bySpyMode = MODE_VIDEO;
			dwReleaseBW += pcSpyMember->m_dwAudBW;
			pcSpyMember->m_dwAudBW = 0;

			if (byRelSpyMode != MODE_NONE)
			{
				byRelSpyMode = MODE_BOTH;
			}
			else
			{
				byRelSpyMode = MODE_AUDIO;
			}
		}
		else if (pcSpyMember->m_bySpyMode == MODE_AUDIO)
		{
			pcSpyMember->m_bySpyMode = MODE_NONE;
			dwReleaseBW += pcSpyMember->m_dwAudBW;
			pcSpyMember->m_dwAudBW = 0;
			if (byRelSpyMode != MODE_NONE)
			{
				byRelSpyMode = MODE_BOTH;
			}
			else
			{
				byRelSpyMode = MODE_AUDIO;
			}
		}
		else
		{
			
		}
	}


	//如果发现当前的SpyMode为NONE,直接删掉此回传源
	if (pcSpyMember->m_bySpyMode == MODE_NONE)
	{
		swChnnlID = (pcSpyMember->m_tSpyAddr.GetPort() - CASCADE_SPY_STARTPORT) / PORTSPAN;

		//直接清空此回传源信息
		pcSpyMember->Clear();

		//如果swSpyIndex + 1 > m_wSpyNum，这种情况不允许发生
		//可以在此加异常log
		
// 		if (swSpyIndex + 1 == m_wSpyNum)
// 		{
// 			--m_wSpyNum;
// 		}
	}
}

/*====================================================================
    函数名      GetRecvSpy
    功能        ：根据索引获取当前回传信息
    算法实现    ：
    引用全局变量：s16 swSpyIndex 回传索引
				  CRecvSpy &tSrcSpyInfo 相应的回传信息
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CConfRecvSpyInfo::GetRecvSpy(s16 swSpyIndex, CRecvSpy &tSrcSpyInfo )
{
	if (swSpyIndex >= MAXNUM_CONF_SPY || swSpyIndex < 0)
	{
		return FALSE;
	}

	tSrcSpyInfo = m_cSpyMember[swSpyIndex];

	return TRUE;
}

/*====================================================================
    函数名      AddSpyMode
    功能        ：根据索引增加相应的回传mode
    算法实现    ：
    引用全局变量：s16 swSpyIndex 回传索引
				  u8 bySpyMode 回传mode
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CConfRecvSpyInfo::AddSpyMode(s16 swSpyIndex, u8 bySpyMode, BOOL32 bIsPreAdd/* = FALSE*/)
{
	if (swSpyIndex >= MAXNUM_CONF_SPY || swSpyIndex < 0)
	{
		return FALSE;
	}

	//如果SpyMode是NONE，添加有误，返回FALSE
	if (bySpyMode == MODE_NONE)
	{
		return FALSE;
	}

	CRecvSpy *pcSpyMember = &m_cSpyMember[swSpyIndex];

	//如果已经有此SpyMode，返回FALSE
	if ((pcSpyMember->m_bySpyMode & bySpyMode) != 0 && pcSpyMember->m_bySpyMode > bySpyMode)
	{
		return FALSE;
	}

	if (pcSpyMember->m_bySpyMode == MODE_NONE)
	{
		pcSpyMember->m_bySpyMode = bySpyMode;
	}
	else if ((pcSpyMember->m_bySpyMode & bySpyMode) == 0)
	{
		pcSpyMember->m_bySpyMode = MODE_BOTH;
	}
	else if (pcSpyMember->m_bySpyMode < bySpyMode)
	{
		pcSpyMember->m_bySpyMode = MODE_BOTH;
	}
	else
	{

	}

	if( bIsPreAdd )
	{
		pcSpyMember->m_byPreAddMode = bySpyMode;
		//20110601 zjl 这里没必要设置m_byUseState = WAIT_USE,可考虑删除
		//在分配回传端口时已设置，接口AddSpyChnnlInfo,
		pcSpyMember->m_byUseState = TSpyStatus::WAIT_USE;
	}
	return TRUE;
}

/*====================================================================
    函数名      IncSpyModeDst
    功能        ：根据索引和spymode增加计数
    算法实现    ：
    引用全局变量：
    输入参数说明：s16 swSpyIndex 回传信息索引
				  u8 bySpyMode [IN]回传mode
				  s16 swDstNum [IN]计数
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CConfRecvSpyInfo::IncSpyModeDst(s16 swSpyIndex, u8 bySpyMode, s16 swDstNum/* = 1*/,BOOL32 bIsPreAdd/* = FALSE*/)
{
	if (swSpyIndex >= MAXNUM_CONF_SPY || swSpyIndex < 0)
	{
		return FALSE;
	}
	
	CRecvSpy *pcSpyMember = &m_cSpyMember[swSpyIndex];

	s16 swCalcDstNum = 0;

	if (bySpyMode == MODE_BOTH || bySpyMode == MODE_AUDIO)
	{
		swCalcDstNum = (s16)pcSpyMember->m_byASpyDstNum + swDstNum;

		if (swCalcDstNum < 0)
		{
			pcSpyMember->m_byASpyDstNum = 0;
		}
		else
		{
			pcSpyMember->m_byASpyDstNum = (u8)swCalcDstNum;
		}
	}

	if (bySpyMode == MODE_BOTH || bySpyMode == MODE_VIDEO)
	{
		swCalcDstNum = (s16)pcSpyMember->m_byVSpyDstNum + swDstNum;

		if (swCalcDstNum < 0)
		{
			pcSpyMember->m_byVSpyDstNum = 0;
		}
		else
		{
			pcSpyMember->m_byVSpyDstNum = (u8)swCalcDstNum;
		}
	}

	if( bIsPreAdd )
	{
		pcSpyMember->m_byPreAddDstNum = s8(swDstNum);
		pcSpyMember->m_byUseState = TSpyStatus::WAIT_USE;
	}

	LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_SPY,  "IncSpyModeDst Index: %d, SpyMode:%d swDstNum:%d VidDst:%d AudDst:%d\n", swSpyIndex, bySpyMode, swDstNum, pcSpyMember->m_byVSpyDstNum, pcSpyMember->m_byASpyDstNum);

	return TRUE;
}

/*====================================================================
    函数名      DecSpyModeDst
    功能        ：根据索引和spymode减少计数
    算法实现    ：
    引用全局变量：
    输入参数说明：s16 swSpyIndex 回传信息索引
				  u8 bySpyMode [IN]回传mode
				  s16 swDstNum[IN]计数
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CConfRecvSpyInfo::DecSpyModeDst(s16 swSpyIndex, u8 bySpyMode, s16 swDstNum)
{
	return IncSpyModeDst(swSpyIndex, bySpyMode, -1 * swDstNum);
}

/*====================================================================
    函数名      ModifySpyModeBW
    功能        ：根据索引和Spymode修改相应的音视频带宽
    算法实现    ：
    引用全局变量：
    输入参数说明：s16 swSpyIndex 回传信息索引
				  u8 bySpyMode [IN]回传mode
				  u32 dwVidBW 视频带宽
				  u32 dwAudBW 音频带宽
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CConfRecvSpyInfo::ModifySpyModeBW(s16 swSpyIndex, u8 bySpyMode, u32 dwVidBW, u32 dwAudBW)
{
	if (swSpyIndex >= MAXNUM_CONF_SPY || swSpyIndex < 0)
	{
		return FALSE;
	}
	
	CRecvSpy *pcSpyMember = &m_cSpyMember[swSpyIndex];

	//检验bySpyMode的合法性
	if (0 == (bySpyMode & pcSpyMember->m_bySpyMode) || pcSpyMember->m_bySpyMode < bySpyMode)
	{
		return FALSE;
	}

	if (bySpyMode == MODE_BOTH || bySpyMode == MODE_VIDEO)
	{
		pcSpyMember->m_dwVidBW = dwVidBW;
	}

	if (bySpyMode == MODE_BOTH || bySpyMode == MODE_AUDIO)
	{
		pcSpyMember->m_dwAudBW = dwAudBW;
	}

	return TRUE;
}

/*====================================================================
    函数名      FreeSpyModeBW
    功能        ：根据索引释放相应mode，并返回带宽
    算法实现    ：
    引用全局变量：
    输入参数说明：s16 swSpyIndex 回传信息索引
				  u8 bySpyMode [IN]回传mode
				  u32 &dwReleaseBW[OUT]返回释放带宽
    返回值说明  ：BOOL32 是否释放成功
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CConfRecvSpyInfo::FreeSpyModeBW(s16 swSpyIndex, u8 bySpyMode, u32 &dwReleaseBW)
{
	if (swSpyIndex >= MAXNUM_CONF_SPY || swSpyIndex < 0)
	{
		return FALSE;
	}
	
	CRecvSpy *pcSpyMember = &m_cSpyMember[swSpyIndex];

	//检验bySpyMode的合法性
	if (0 == (bySpyMode & pcSpyMember->m_bySpyMode) || pcSpyMember->m_bySpyMode < bySpyMode)
	{
		return FALSE;
	}

	if (bySpyMode == MODE_BOTH || bySpyMode == MODE_VIDEO)
	{
		dwReleaseBW += pcSpyMember->m_dwVidBW;
		pcSpyMember->m_dwVidBW = 0;
	}
	
	if (bySpyMode == MODE_BOTH || bySpyMode == MODE_AUDIO)
	{
		dwReleaseBW += pcSpyMember->m_dwAudBW;
		pcSpyMember->m_dwAudBW = 0;
	}

	return TRUE;

}

/*====================================================================
    函数名      ClearSpyModeDst
    功能        ：根据索引清除相应mode的目的数
    算法实现    ：
    引用全局变量：
    输入参数说明：s16 swSpyIndex 回传信息索引
				  u8 bySpyMode [IN]回传mode
    返回值说明  ：BOOL32 是否清除成功
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CConfRecvSpyInfo::ClearSpyModeDst(s16 swSpyIndex, u8 bySpyMode)
{
	if (swSpyIndex >= MAXNUM_CONF_SPY || swSpyIndex < 0)
	{
		return FALSE;
	}
	
	CRecvSpy *pcSpyMember = &m_cSpyMember[swSpyIndex];

	if (bySpyMode == MODE_BOTH || bySpyMode == MODE_VIDEO)
	{
		pcSpyMember->m_byVSpyDstNum = 0;
	}
	
	if (bySpyMode == MODE_BOTH || bySpyMode == MODE_AUDIO)
	{
		pcSpyMember->m_byASpyDstNum = 0;
	}

	return TRUE;
}

/*====================================================================
    函数名      GetSpyMemberInfo
    功能        ：根据索引返回回传信息
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wIndex  回传信息索引
    返回值说明  ：const CRecvSpy* 返回回传信息的指针
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
const CRecvSpy* CConfRecvSpyInfo::GetSpyMemberInfo( u16 wIndex )
{
/*lint -save -esym(1536,CConfSendSpyInfo::m_cSpyMember)*/
	if (wIndex >= MAXNUM_CONF_SPY)
	{
		return NULL;
	}

	return &m_cSpyMember[wIndex];
/*lint -restore*/
}


/*
BOOL32 CConfRecvSpyInfo::FreeSpyChannlInfo(const TMt &tMt, u8 bySpyMode, BOOL32 bForce )
{
	CMultiSpyMgr *cMultiSpyMgr = g_cMcuVcApp.GetCMultiSpyMgr();

	for( u8 byLoop = 0; byLoop < MAXNUM_CONF_SPY; byLoop++ )
	{
		if( m_cSpyMember[byLoop].m_tSpy == tMt )
		{
			// 若是使用的61000+ 通道，则释放该回传通道
			if( m_cSpyMember[byLoop].m_wSpyStartPort >= MT_MCU_STARTPORT )
			{
				m_cSpyMember[byLoop].m_tSpy.SetNull();
				m_cSpyMember[byLoop].m_wSpyStartPort = SPY_CHANNL_NULL;
				m_cSpyMember[byLoop].m_bySpyMode = MODE_NONE;
				m_cSpyMember[byLoop].m_dwTotalBW = 0;

				return TRUE;
			}
			
			// 正常释放多回传通道、资源
			u16 wSpyChnnl = (m_cSpyMember[byLoop].m_wSpyStartPort - CASCADE_SPY_STARTPORT) / PORTSPAN;

			if( MODE_NONE == m_cSpyMember[byLoop].m_bySpyMode )
			{
				cMultiSpyMgr->ReleaseSpyChnnl( wSpyChnnl );
				m_cSpyMember[byLoop].m_tSpy.SetNull();
				m_cSpyMember[byLoop].m_wSpyStartPort = SPY_CHANNL_NULL;
				m_cSpyMember[byLoop].m_bySpyMode = MODE_NONE;
				m_cSpyMember[byLoop].m_dwTotalBW = 0;
				return TRUE;
			}

			if( bySpyMode == MODE_BOTH )
			{
				if( bForce == TRUE)  // 强制释放
				{
					cMultiSpyMgr->ReleaseSpyChnnl( wSpyChnnl );
					m_cSpyMember[byLoop].m_tSpy.SetNull();
					m_cSpyMember[byLoop].m_wSpyStartPort = SPY_CHANNL_NULL;
					m_cSpyMember[byLoop].m_bySpyMode = MODE_NONE;
				    m_cSpyMember[byLoop].m_dwTotalBW = 0;
					return TRUE;
				}

				// 确认没有人在使用回传源了
				if( (m_cSpyMember[byLoop].m_byASpyDstNum != 0)
					|| (m_cSpyMember[byLoop].m_byVSpyDstNum != 0) )
				{
					return FALSE;
				}
				cMultiSpyMgr->ReleaseSpyChnnl( wSpyChnnl );
				// m_dwRemainSpyBW += m_cSpyMember[byLoop].m_dwTotalBW;
				m_cSpyMember[byLoop].m_tSpy.SetNull();
				m_cSpyMember[byLoop].m_wSpyStartPort = SPY_CHANNL_NULL;
				m_cSpyMember[byLoop].m_bySpyMode = MODE_NONE;
				m_cSpyMember[byLoop].m_dwTotalBW = 0;
				return TRUE;
			}

			if( bySpyMode == MODE_VIDEO )
			{
				if( bForce == TRUE && m_cSpyMember[byLoop].m_bySpyMode == MODE_BOTH ) // 强制释放
				{
					m_cSpyMember[byLoop].m_bySpyMode = MODE_AUDIO;
					m_cSpyMember[byLoop].m_byVSpyDstNum = 0;
					return TRUE;
				}
				if( bForce == TRUE && m_cSpyMember[byLoop].m_bySpyMode == MODE_VIDEO ) // 强制释放
				{
					m_cSpyMember[byLoop].m_bySpyMode = MODE_NONE;
					m_cSpyMember[byLoop].m_byASpyDstNum = 0;
					m_cSpyMember[byLoop].m_byVSpyDstNum = 0;
					return TRUE;
				}
				if( (m_cSpyMember[byLoop].m_byVSpyDstNum != 0) )
				{
					return FALSE;
				}
				return TRUE;
			}

			if( bySpyMode == MODE_AUDIO )
			{
				if( bForce == TRUE && m_cSpyMember[byLoop].m_bySpyMode == MODE_BOTH ) // 强制释放
				{
					m_cSpyMember[byLoop].m_bySpyMode = MODE_VIDEO;
					m_cSpyMember[byLoop].m_byASpyDstNum = 0;
					return TRUE;
				}
				if( bForce == TRUE && m_cSpyMember[byLoop].m_bySpyMode == MODE_AUDIO ) // 强制释放
				{
					m_cSpyMember[byLoop].m_bySpyMode = MODE_NONE;
					m_cSpyMember[byLoop].m_byASpyDstNum = 0;
					m_cSpyMember[byLoop].m_byVSpyDstNum = 0;
					return TRUE;
				}
				if( (m_cSpyMember[byLoop].m_byASpyDstNum != 0) )
				{
					return FALSE;
				}
				return TRUE;
			}
		}
	}
	return FALSE;
}
*/
////////////////////////
// End 上级会议使用
////////////////////////


///////////////////////////////
// 多回传管理类 CMultiSpyMgr
///////////////////////////////


CMultiSpyMgr::CMultiSpyMgr(void)
{
	Init();
}
CMultiSpyMgr::~CMultiSpyMgr(void)
{
	if (m_hSpyRW != NULL)
	{
		OspSemDelete(m_hSpyRW);
	}
}

void CMultiSpyMgr::Init( void )
{
	memset( this, 0, sizeof(CMultiSpyMgr) );
	OspSemBCreate(&m_hSpyRW);
}

/*====================================================================
    函数名      ：AssignSpyChnnl
    功能        ：占用空闲的mcu回传通道
    算法实现    ：
    引用全局变量：
    输入参数说明：[IN/OUT]wChnnlIdx: 返回空闲的通道索引
    返回值说明  ：TRUE:获取到空闲得通道索引  FALSE:无空闲的通道索引
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	10/01/05    4.5         彭杰           创建
====================================================================*/
BOOL32 CMultiSpyMgr::AssignSpyChnnl( u16 &wChnnlIdx )
{
	BOOL32 bRet = FALSE;

	if (m_hSpyRW != NULL)
	{
		OspSemTake(m_hSpyRW);
	}

	for( u16 wChnlIdx = 0; wChnlIdx < MAXNUM_ACCOMMODATE_SPY; wChnlIdx++ )
	{
		if( m_byIsMultiSpy[wChnlIdx] == 0 )
		{
			wChnnlIdx = wChnlIdx;
			m_byIsMultiSpy[wChnlIdx] = 1;
			bRet = TRUE;
			break;
		}
	}

	if (m_hSpyRW != NULL)
	{
		OspSemGive(m_hSpyRW);
	}
	
	return bRet;
}

/*====================================================================
    函数名      ：ReuseSpyChnnl
    功能        ：重用此回传通道
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	10/07/28    4.6			陆昆朋           创建
====================================================================*/
BOOL32 CMultiSpyMgr::ReuseSpyChnnl( u16 wChnnlIdx)
{
	BOOL32 bRet = FALSE;
	if( wChnnlIdx < MAXNUM_ACCOMMODATE_SPY )
	{
		if (m_hSpyRW != NULL)
		{
			OspSemTake(m_hSpyRW);
		}

 		if (m_byIsMultiSpy[wChnnlIdx] != 0)
 		{
 			++m_byIsMultiSpy[wChnnlIdx];
 		}
		
		bRet = TRUE;

		if (m_hSpyRW != NULL)
		{
			OspSemGive(m_hSpyRW);
		}
	}

	return bRet;

}

/*====================================================================
    函数名      ：ReleaseSpyChnnl
    功能        ：释放对应的回传通道
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	10/01/05    4.5         彭杰           创建
====================================================================*/
void CMultiSpyMgr::ReleaseSpyChnnl( u16 wChnnlIdx)
{
	if(wChnnlIdx < MAXNUM_ACCOMMODATE_SPY )
	{
		if (m_hSpyRW != NULL)
		{
			OspSemTake(m_hSpyRW);
		}

		if (m_byIsMultiSpy[wChnnlIdx] > 0)
		{
			--m_byIsMultiSpy[wChnnlIdx];
		}

		if (m_hSpyRW != NULL)
		{
			OspSemGive(m_hSpyRW);
		}
	}
}


/*====================================================================
    函数名         GetMSMultiSpy
    功能        ：主备获取倒换多回传带宽路数信息
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	11/11/19    4.6         周嘉麟           创建
====================================================================*/
u16 CMultiSpyMgr::GetMSMultiSpy(u8 *pbyBuf)
{
	if (NULL == pbyBuf)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_SPY, "[GetMSMultiSpy] pbyBuf is null!\n");
		return 0;
	}
	memcpy(pbyBuf, m_byIsMultiSpy, sizeof(m_byIsMultiSpy));
	return sizeof(m_byIsMultiSpy);
}

/*====================================================================
    函数名         SetMSMultiSpy
    功能        ：主备保存多回传带宽路数信息
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	11/11/19    4.6         周嘉麟           创建
====================================================================*/
u16 CMultiSpyMgr::SetMSMultiSpy(u8 *pbyBuf)
{
	if (NULL == pbyBuf)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_SPY, "[SetMSMultiSpy] pbyBuf is null!\n");
		return 0;
	}
	memcpy(m_byIsMultiSpy, pbyBuf, sizeof(m_byIsMultiSpy));
	return sizeof(m_byIsMultiSpy);
}
//////////////////////
// End CMultiSpyMgr
//////////////////////

//////////////////////
// 会控监控通道管理类
//////////////////////
CMcChnnlInfo::CMcChnnlInfo()
{
	Clear();
}

void   CMcChnnlInfo::Clear( void )
{
	memset( this, 0, sizeof(CMcChnnlInfo) );
}

/*====================================================================
    函数名      SetMcChnnlMode
    功能        ：设置会控通道mode
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMode 当前mode
    返回值说明  ：是否设置成功
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CMcChnnlInfo::SetMcChnnlMode( u8 byMode )
{
	if( byMode != MODE_NONE)
	{
    	m_byMode = byMode;
		return TRUE;
	}
	return FALSE;
}

/*====================================================================
    函数名      GetMcChnnlMode
    功能        ：获取会控通道mode
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：u8 当前mode
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
u8  CMcChnnlInfo::GetMcChnnlMode( void )
{
	return m_byMode;
}

/*====================================================================
    函数名      SetMcSrc
    功能        ：设置通道对应的源终端
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt &tmt 对应的终端
    返回值说明  ：是否设置成功
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CMcChnnlInfo::SetMcSrc( TMt &tmt )
{
	if( !tmt.IsNull())
	{
     	m_tSrc = tmt;
		return TRUE;
	}
	return FALSE;
}

/*====================================================================
    函数名      GetMcSrc
    功能        ：获取通道对应的源终端
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：TMt 返回的终端
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
TMt  CMcChnnlInfo::GetMcSrc( void )
{
	return m_tSrc;
}

CMcChnMgr::CMcChnMgr()
{
	Clear();
}

void CMcChnMgr::Clear()
{
	memset( this, 0, sizeof(CMcChnMgr) );
}

/*====================================================================
    函数名      FreeMcChnnl
    功能        ：释放对应的通道信息
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byChnnl [IN] 对应的通道
    返回值说明  ：是否释放成功
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			lukunpeng		Create
====================================================================*/
BOOL32 CMcChnMgr::FreeMcChnnl( u8 byChnnl )
{
	if( byChnnl < MAXNUM_MC_CHANNL )
	{
		m_cMcChnnl[byChnnl].Clear();
	}

	return TRUE;
}


/*====================================================================
    函数名        GetHduChnNumAcd2Eqp
    功能        ：根据hdu外设信息获取其通道数
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	10/01/05    4.5         彭杰           创建
====================================================================*/
u8 CMcuVcData::GetHduChnNumAcd2Eqp(const TEqp tEqp)
{
	if (tEqp.IsNull())
	{	
		return 0;
	}
	
	TPeriEqpStatus tStatus;
	if (!GetPeriEqpStatus(tEqp.GetEqpId(), &tStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_HDU, "[GetHduChnNumAcd2Eqp] GetPeriEqpStatus--EqpId:%d failed!\n", tEqp.GetEqpId());
		return 0;
	}

	u8 byHduChnNum = 0;

	if(tStatus.GetEqpType()==EQP_TYPE_HDU)
	{
		u8 byHduSubType = HDU_SUBTYPE_HDU_M;
		if(g_cMcuAgent.GetHduSubTypeByEqpId(tEqp.GetEqpId(),byHduSubType))
		{
			switch (byHduSubType)
			{
			case HDU_SUBTYPE_HDU_M:
			case HDU_SUBTYPE_HDU_L:
			case HDU_SUBTYPE_HDU2:
			case HDU_SUBTYPE_HDU2_L:
			case HDU_SUBTYPE_HDU2_S:
				byHduChnNum = MAXNUM_HDU_CHANNEL;
				break;
			case HDU_SUBTYPE_HDU_H:
				byHduChnNum = MAXNUM_HDU_H_CHANNEL;
				break;
			default:
				LogPrint(LOG_LVL_ERROR, MID_MCU_HDU, "[GetHduChnNumAcd2Eqp] unexpected hdutype :%d!\n", tStatus.GetEqpType());
				break;
			}
		}
	}

	return byHduChnNum;
}

/*====================================================================
函数名        RestoreEncArray
功能        ：恢复BAS 分段能力
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/09/05  4.7         倪志俊			创建
====================================================================*/
void CMpu2BasChn::RestoreEncArray()
{
	if ( m_wMaxEncAbility > 0 &&  m_wMaxEncAbility<=MPU2_BASCHN_MAXENCABILITY )
	{
		SetEncAbility( m_wMaxEncAbility );
	}
	else
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CMpu2BasChn::RestoreEncArray]m_wMaxEncAbility:%d error\n",m_wMaxEncAbility);
	}
	return;
}

/*====================================================================
函数名        SetEncAbility
功能        ：设置BAS编码总能力和分段能力
算法实现    ：
引用全局变量：
输入参数说明： u16 wEncAbility 编码总能力
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/09/05  4.7         倪志俊			创建
====================================================================*/
void CMpu2BasChn::SetEncAbility( u16 wEncAbility )
{
	m_wMaxEncAbility = wEncAbility;
	memset(m_awEncArray,0,sizeof(m_awEncArray));
	u16 wNum = wEncAbility/MPU2_BASCHN_DIVISION_ABILITY;
	if ( wNum > MPU2_BASCHN_ENCARRAY_NUM )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CMpu2BasChn::SetEncArray]nNum:%d is more than totalnum:%d\n",
			wNum,MPU2_BASCHN_ENCARRAY_NUM
			);
		return ;
	}
	
	u8 byLoop =0;
	for ( byLoop = 0; byLoop<wNum; byLoop++ )
	{
		m_awEncArray[byLoop]=MPU2_BASCHN_DIVISION_ABILITY;
	}
	
	u16 wLeft = wEncAbility%MPU2_BASCHN_DIVISION_ABILITY;
	if ( wLeft > 0 && byLoop < (MPU2_BASCHN_ENCARRAY_NUM-1)  )
	{
		m_awEncArray[byLoop] = wLeft;
	}
	
	return;
}

/*====================================================================
函数名        SetChnAbility
功能        ：对通道能力进行设置
算法实现    ：
引用全局变量：
输入参数说明：u8 byChnId 通道ID
			  u8 byEqpType 通道类型
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
void CMpu2BasChn::SetChnAbility(u8 byChnId, u8 byEqpType)
{
	//设置解码能力
	SetDecAbility(emDecSD);
	SetDecAbility(emDecHD);
	SetDecAbility(emDecHighFps);
	SetDecAbility(emDecH261);
	SetDecAbility(emDecHp);
	//设置编码能力
	switch (byEqpType)
	{
	case TYPE_MPU2_BASIC:
		{
			if (byChnId == 0)
			{
				SetEncNum(MPU2_BAS_BASIC_MVOUTPUT);
				SetOtherEncNum(MPU2_BAS_BASIC_MV_OTHERNUM);
				SetEncAbility(1500);
			}
			else if(byChnId == 1)
			{
				SetEncNum(MPU2_BAS_BASIC_DSOUTPUT);
				SetOtherEncNum(MPU2_BAS_BASIC_DS_OTHERNUM);
				SetEncAbility(1500);
			}
			else
			{
				SetEncNum(MPU2_BAS_BASIC_SELOUTPUT);
				SetOtherEncNum(MPU2_BAS_BASIC_SEL_OTHERNUM);
				SetEncAbility(1000);
			}
		}
		break;
	case TYPE_MPU2_ENHANCED:
		{
			if (byChnId == 0)
			{
				SetEncNum(MPU2_BAS_ENHACNED_MVOUTPUT);
				SetOtherEncNum(MPU2_BAS_ENHACNED_MV_OTHERNUM);
				SetEncAbility(3000);
			}
			else if(byChnId == 1)
			{
				SetEncNum(MPU2_BAS_ENHACNED_DSOUTPUT);
				SetOtherEncNum(MPU2_BAS_ENHACNED_DS_OTHERNUM);
				SetEncAbility(3000);
			}
			else
			{
				SetEncNum(MPU2_BAS_ENHACNED_SELOUTPUT);
				SetOtherEncNum(MPU2_BAS_ENHACNED_SEL_OTHERNUM);
				SetEncAbility(1000);
			}
		}
		break;
	default:
		{
			LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CMpu2BasChn::SetChnAbility]byEqpType:%d is illegal!\n", byEqpType);
		}
		break;
	}
	return;
}


/*====================================================================
函数名        CalculateLeftEncAbility
功能        ：计算通道剩余编码能力
算法实现    ：
引用全局变量：
输入参数说明：u16 &wLeftEncAbility 剩余编码能力			
			  u8 &wLeftEncNum      剩余编码路数（含other，即剩余总路数）
			  u8 &wOtherLeftEncNum 剩余other编码路数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
BOOL32 CMpu2BasChn::CalculateLeftEncAbility(u16 &wLeftEncAbility, u8 &wLeftEncNum, u8 &wOtherLeftEncNum)
{
	if ( GetBas().IsNull() )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CalculateLeftEncAbility] bas is Null\n");
		return FALSE;
	}

	u8 byOutNum = 0;
	THDAdaptParam atParam[MAXNUM_BASOUTCHN];
	if(!g_cMcuVcApp.GetBasOutPutParam(GetBas(), GetChnId(), byOutNum, atParam))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CalculateLeftEncAbility] GetBasOutPutParam--><EqpId:%d, ChnId> failed!\n", 
				 GetBas().GetEqpId(), GetChnId()
				 );
		return FALSE;
	}
	
	if ( byOutNum == 0 )
	{
		return TRUE;
	}

	u16 wTempAbility = 0;
	u8  wTempEncNum = 0;
	for ( u8 byIdx =0; byIdx < byOutNum; byIdx++  )
	{
		if ( atParam[byIdx].IsNull() )
		{
			continue;
		}
		wTempEncNum++;
		TVideoStreamCap tCap( atParam[byIdx].GetVidType(), GetResByWH(atParam[byIdx].GetWidth(),atParam[byIdx].GetHeight()), 
							  atParam[byIdx].GetFrameRate(), (emProfileAttrb)atParam[byIdx].GetProfileType(), atParam[byIdx].GetBitrate()
							);
		if ( INVALID_RESOUCEUNIT_VALUE != GetResourceUnitAcd2Cap(tCap) )
		{
			wTempAbility += GetResourceUnitAcd2Cap(tCap);
		}
		else
		{
			if (  (atParam[byIdx].GetVidType() != MEDIA_TYPE_H264 &&
				   atParam[byIdx].GetVidType() != MEDIA_TYPE_NULL
				  ) ||
				  (atParam[byIdx].GetVidType() == MEDIA_TYPE_H264 &&
				   GetResByWH( atParam[byIdx].GetWidth(), atParam[byIdx].GetHeight() ) == VIDEO_FORMAT_XGA
				  ) 
			  )
			{
				wOtherLeftEncNum--;
			}
		}
	}
	wLeftEncAbility = m_wMaxEncAbility - wTempAbility;
	wLeftEncNum		= byOutNum - wTempEncNum;
	return TRUE;
}

/*====================================================================
函数名        IsNeedVicpOccupy
功能        ：检查能力集是否能用VICP计算
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/09/03  4.7         倪志俊			创建
====================================================================*/
BOOL32 CMpu2BasChn::IsNeedVicpOccupy(const TVideoStreamCap &tCapSet)
{
	if (  ( tCapSet.GetMediaType() == MEDIA_TYPE_NULL ) 
		||
		( tCapSet.GetMediaType() == MEDIA_TYPE_H264 &&
		tCapSet.GetResolution() == VIDEO_FORMAT_XGA
		)
		||
		tCapSet.GetMediaType()!= MEDIA_TYPE_H264
		||
		INVALID_RESOUCEUNIT_VALUE == GetResourceUnitAcd2Cap(tCapSet) 
		)
	{
		return FALSE;
	}
	
	return TRUE;
}

/*====================================================================
函数名        OccupyCapByEncVal
功能        ：按照某个编码VICP能力，来占用BAS能力
算法实现    ：
引用全局变量：
输入参数说明：[IN]u16 wEncVal 最大编码能力
			  [IN][OUT]TNeedBasResData &tNeedBasData 所需编码，占用完成返回
			  [IN][OUT]u8 &byLeftEncNum		剩余编码总路数，占用完成返回
			  [IN][OUT]u8 &byLeftEncOtherNum 剩余编码other路数，占用完成返回
			  [IN][OUT]u8 *abyRecord		 记录已经占用编码在tNeedBasData能力集数组中的下标
返回值说明  ：占用成功返回TRUE,并通过tNeedBasData返回剩余能力
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/09/03  4.7         倪志俊			创建
====================================================================*/
u16 CMpu2BasChn::OccupyCapByEncVal(u16 wEncVal, TNeedVidAdaptData &tNeedBasData, u8 &byLeftEncNum, u8 &byLeftEncOtherNum,u8 *abyRecord)
{
	if ( tNeedBasData.m_byRealEncNum >  MAX_CONF_BAS_ADAPT_NUM )
	{
		return 0;
	}

	if ( (wEncVal == 0 && byLeftEncOtherNum ==0) || 
		 (byLeftEncNum ==0 && byLeftEncOtherNum ==0 )||
		tNeedBasData.m_byRealEncNum == 0 
	   )
	{
		return 0;
	}

	u8 byStartRecordPos =0;		//记录abyRecord没有记录值的位置
	for ( byStartRecordPos =0 ; byStartRecordPos <MAX_CONF_BAS_ADAPT_NUM; byStartRecordPos ++  )
	{
		if ( abyRecord[byStartRecordPos] == 0xFF )
		{
			break;
		}
	}
	u8 byTempLoop = byStartRecordPos;

	u16 wAggregateVal = 0;						//累加总和
	u8 byVicpNum = 0;							//记录被占用的能力集的个数
	u8 byOtherNum = 0;							//记录被占用的Other个数
	
	for (u8 byIdx = 0; byIdx <MAX_CONF_BAS_ADAPT_NUM; byIdx++ )
	{
		if ( byStartRecordPos >=MAX_CONF_BAS_ADAPT_NUM  )
		{
			return 0;
		}

		//计算other
		if ( !IsNeedVicpOccupy( tNeedBasData.m_atSimCapSet[byIdx] ) )
		{
			//other与H264 XGA
			if (  (tNeedBasData.m_atSimCapSet[byIdx].GetMediaType() != MEDIA_TYPE_H264 &&
					tNeedBasData.m_atSimCapSet[byIdx].GetMediaType() != MEDIA_TYPE_NULL
				   ) ||
				  (tNeedBasData.m_atSimCapSet[byIdx].GetMediaType() == MEDIA_TYPE_H264 &&
					tNeedBasData.m_atSimCapSet[byIdx].GetResolution() == VIDEO_FORMAT_XGA
				  ) 
				)
			{
				if ( byOtherNum < byLeftEncOtherNum )
				{
					abyRecord[byStartRecordPos] =byIdx;
					byOtherNum++;
					byStartRecordPos++;
				}
			}
			continue;
		}

		//计算vicp
		u16 wIdxUnit = GetResourceUnitAcd2Cap( tNeedBasData.m_atSimCapSet[byIdx] );
		if ( wAggregateVal+ wIdxUnit > wEncVal  )
		{
			continue;	
		}
		else
		{
			if ( byLeftEncNum-byLeftEncOtherNum >byVicpNum )
			{
				wAggregateVal +=wIdxUnit;
				abyRecord[byStartRecordPos] =byIdx;
				byStartRecordPos++;
				byVicpNum++;
			}
		}
	}

	//计算剩余编码路数
	u8 byOccupiedNum = byVicpNum +byOtherNum;
	byLeftEncNum -= byOccupiedNum;
	byLeftEncOtherNum -= byOtherNum;

	//清除所占用能力
	for ( byStartRecordPos =byTempLoop ; byStartRecordPos < (byTempLoop+byOccupiedNum); byStartRecordPos ++  )
	{
		if ( abyRecord[byStartRecordPos] != 0xFF )
		{	
			tNeedBasData.m_atSimCapSet[abyRecord[byStartRecordPos]].Clear();
			tNeedBasData.m_byRealEncNum --;
		}
	}

	return wAggregateVal;
}

/*====================================================================
函数名        IsBasChnSupportNeeds
功能        ：是否支持某种能力
算法实现    ：
引用全局变量：
输入参数说明：[IN][OUT]TNeedBasResData &tNeedBasData
返回值说明  ：支持编解码返回TRUE,并返回剩余所需能力
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
BOOL32 CMpu2BasChn::IsBasChnSupportNeeds(TNeedVidAdaptData &tNeedBasData, TVideoStreamCap *ptOccpiedResData)
{
	if ( !IsSupportDecParam(tNeedBasData.m_byDecNeedRes) )
	{
		LogPrint(LOG_LVL_WARNING,MID_MCU_BAS,"[CMpu2BasChn::IsBasChnSupportNeeds]bas:%d-%d not support dec!\n", GetBas().GetEqpId(), GetChnId());
		return FALSE;
	}

	TNeedVidAdaptData tTempBasResData;		//临时保存
	memcpy(&tTempBasResData,&tNeedBasData,sizeof(TNeedVidAdaptData));

	//计算通道当前剩余能力,目前主要是选看业务会产生通道能力减少
	u16 wLeftChnEncAbility = m_wMaxEncAbility;
	u8  wLeftChnEncNum     = GetEncNum();
	u8	wLeftChnOtherEncNum = GetOtherEncNum();
	CalculateLeftEncAbility(wLeftChnEncAbility,wLeftChnEncNum,wLeftChnOtherEncNum);
	//校验返回值
	if ( wLeftChnEncAbility > m_wMaxEncAbility ||
		 wLeftChnEncNum > GetEncNum() ||
		 wLeftChnOtherEncNum > MAX_OTHER_ENC_NUM
		)
	{
		LogPrint( LOG_LVL_ERROR, MID_MCU_BAS, "[CMpu2BasChn::IsBasChnSupportNeeds]wLeftChnEncAbility:%d,wLeftChnEncNum:%d,wLeftChnOtherEncNum:%d are illegal!\n",
					wLeftChnEncAbility,
					wLeftChnEncNum,
					wLeftChnOtherEncNum
				);
		return FALSE;
	}

	u8 abyRecord[MAX_CONF_BAS_ADAPT_NUM];	//记录所预占能力集的下标
	u8 byLoop =0;
	for ( byLoop =0 ; byLoop <MAX_CONF_BAS_ADAPT_NUM; byLoop ++  )
	{
		abyRecord[byLoop] = 0xFF;
	}

	//预占通道
	for ( byLoop = 0; byLoop<MPU2_BASCHN_ENCARRAY_NUM; byLoop++ )
	{
		u16 byOccupiedVicp = OccupyCapByEncVal(m_awEncArray[byLoop],tNeedBasData,wLeftChnEncNum,wLeftChnOtherEncNum,abyRecord);
		if ( m_awEncArray[byLoop]>=byOccupiedVicp )
		{
			m_awEncArray[byLoop] -= byOccupiedVicp;
		}
		else
		{
			LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CMpu2BasChn::IsBasChnSupportNeeds]chn-%d-%d,byOccupiedVicp:%d byLoop:%d\n",
					GetBas().GetEqpId(), GetChnId(), byOccupiedVicp,byLoop
					);
		}
	}
	
	BOOL32 bIsOccpuiedChn = FALSE;		//是否在此通道上预占到能力
	//返回预占到的能力
	for ( byLoop =0 ; byLoop <MAX_CONF_BAS_ADAPT_NUM; byLoop++  )
	{
		if ( abyRecord[byLoop]!= 0xFF )
		{
			bIsOccpuiedChn = TRUE;
			ptOccpiedResData[byLoop] = tTempBasResData.m_atSimCapSet[abyRecord[byLoop]];
		}
	}

	if (  FALSE == bIsOccpuiedChn  )
	{
		memcpy(&tNeedBasData,&tTempBasResData,sizeof(TNeedVidAdaptData));
		return FALSE;
	}

	TVideoStreamCap  atLeftSimCap[MAX_CONF_BAS_ADAPT_NUM];
	u8 byLeftIdx = 0;
	for ( byLoop =0 ; byLoop<MAX_CONF_BAS_ADAPT_NUM; byLoop++ )
	{
		if ( tNeedBasData.m_atSimCapSet[byLoop].GetMediaType() != MEDIA_TYPE_NULL )
		{
			atLeftSimCap[byLeftIdx] = tNeedBasData.m_atSimCapSet[byLoop];
			byLeftIdx++;
		}
	}
	memcpy( tNeedBasData.m_atSimCapSet, atLeftSimCap, sizeof(atLeftSimCap));

	return TRUE;
}

/*====================================================================
函数名        GetMaxEncAbility
功能        ：获得最大编码能力
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
u16 CMpu2BasChn::GetMaxEncAbility()
{
	return m_wMaxEncAbility;
}

/*====================================================================
函数名        Print
功能        ：打印通道信息
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
void CMpu2BasChn::Print()
{
	StaticLog("-------------BAS ChnInfo as follows----------\n");
	StaticLog("EqpId:%d\n", GetBas().GetEqpId());
	StaticLog("ChnId:%d\n",GetChnId());
	StaticLog("MeidaMode:%d\n",GetMediaMode());
	StaticLog("Src<McuId:%d, MtId:%d>\n",GetSrc().GetMcuId(), GetSrc().GetMtId());
	StaticLog("Reserved:%d\n", IsReserved());
	StaticLog("Online:%d\n", IsOnLine());
	StaticLog("EncNum:%d\n", GetEncNum());
	StaticLog("EncOtherNum:%d\n", GetOtherEncNum());
	StaticLog("MaxEncAbility:%d\n", m_wMaxEncAbility);
	u8 byLoop = 0;
	for ( byLoop =0 ; byLoop<MPU2_BASCHN_ENCARRAY_NUM; byLoop ++ )
	{
		StaticLog("ArrayIdx:%d EncAbility:%d\n", byLoop,m_awEncArray[byLoop]);
	}
	//StaticLog("CurEncAbility:%d\n", m_wCurEncAbility);

}


/*====================================================================
函数名        SetAdaptParam
功能        ：普通刷参
算法实现    ：
引用全局变量：
输入参数说明：THDAdaptParam &tAdaptParam BAS参数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
BOOL32 CMpu2BasChn::SetAdaptParam(THDAdaptParam &tAdaptParam)
{
	if ( tAdaptParam.IsNull() )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CMpu2BasChn::SetBasAdaptParam] tHDParm is null!\n");
		return FALSE;
	}
	
	if (  tAdaptParam.GetVidType() == MEDIA_TYPE_H264 &&
		(GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) == VIDEO_FORMAT_4CIF ||
		GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) == VIDEO_FORMAT_CIF
		)
		)
	{
		tAdaptParam.SetFrameRate(25);
		LogPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[CMpu2BasChn::SetBasAdaptParam] set frame to 25!\n");
	}

	if (  tAdaptParam.GetVidType() == MEDIA_TYPE_H264 &&
		  GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) == VIDEO_FORMAT_XGA &&
		  tAdaptParam.GetFrameRate() != 5
		)
	{
		tAdaptParam.SetFrameRate(5);
		LogPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[CMpu2BasChn::SetBasAdaptParam] h264 xga set frame to 5!\n");
	}

	u8 byChnId = GetChnId();
	TEqp tEqp  = GetBas();
	
	if ( tEqp.IsNull() )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CMpu2BasChn::SetBasAdaptParam] tEqp is null!\n");
		return FALSE;
	}
	
	TPeriEqpStatus tStatus;
	if (!g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CMpu2BasChn::SetBasAdaptParam] GetPeriEqpStatus failed! EqpId:%d !\n", 
			tEqp.GetEqpId());
		return FALSE;
	}

	THDBasVidChnStatus *ptVidChn = NULL;
	for ( u8 byOutIdx = 0; byOutIdx < GetEncNum(); byOutIdx++ )
	{
		ptVidChn = tStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnId);
		if ( NULL == ptVidChn )
		{
			continue;
		}

		if ( !ptVidChn->GetOutputVidParam(byOutIdx)->IsNull() || 
			 !ptVidChn->IsReserved()
			)
		{
			LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[CMpu2BasChn::SetBasAdaptParam]mpu2bas<ChnId:%d, OutIdx:%d> AdaptParam is not null or chn not reserved!\n", 
				byChnId, byOutIdx);
			continue;
		}
		else
		{
			if( ptVidChn->GetOutputVidParam(byOutIdx)->IsNull() )
			{
				ptVidChn->SetOutputVidParam(tAdaptParam, byOutIdx);
				tStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.SetVidChnStatus(*ptVidChn, byChnId);
				g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
				return TRUE;
			}
		}
	}

	return FALSE;
}

/*====================================================================
函数名        SetAdaptParamForcely
功能        ：强制刷参
算法实现    ：
引用全局变量：
输入参数说明：THDAdaptParam &tAdaptParam BAS参数
			   u8 byOutIdx				  输出idx
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
BOOL32 CMpu2BasChn::SetAdaptParamForcely(THDAdaptParam &tAdaptParam, u8 byOutIdx)
{
	u8 byChnId = GetChnId();
	TEqp tEqp  = GetBas();
	if ( tAdaptParam.IsNull() )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CMpu2BasChn::SetBasAdaptParam] tHDParm is null, TBas:%d-%d!\n",
				tEqp.GetEqpId(), byChnId
				);
		return FALSE;
	}
	
	if (  tAdaptParam.GetVidType() == MEDIA_TYPE_H264 &&
		(GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) == VIDEO_FORMAT_4CIF ||
		GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) == VIDEO_FORMAT_CIF
		)
		)
	{
		tAdaptParam.SetFrameRate(25);
		LogPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[CMpu2BasChn::SetBasAdaptParam] set frame to 25!\n");
	}

	if ( byOutIdx >= GetEncNum() )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CMpu2BasChn::SetBasAdaptParam] byOutIdx is illegal! TBas:%d-%d\n",
				tEqp.GetEqpId(), byChnId
				);
		return FALSE;
	}


	TPeriEqpStatus tStatus;
	if (!g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CMpu2BasChn::SetAdaptParamForcely] GetPeriEqpStatus failed! EqpId:%d !\n", 
				tEqp.GetEqpId()
				);
		return FALSE;
	}

	THDBasVidChnStatus *ptVidChn = tStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnId);
	if ( NULL == ptVidChn )
	{
		return FALSE;
	}

	ptVidChn->SetOutputVidParam(tAdaptParam, byOutIdx);
	tStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.SetVidChnStatus(*ptVidChn, byChnId);
	g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
	return TRUE;
}


/*====================================================================
函数名        StartAdapt
功能        ：
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
BOOL32 CMpu2BasChn::StartAdapt(const TBasAdaptParamExt &tBasParamExt, CConfId &cConfId)
{
	if (MEDIA_TYPE_NULL == tBasParamExt.m_byBasVidDectPT && MEDIA_TYPE_NULL == tBasParamExt.m_byBasAudDecPT )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CMpu2BasChn::StartAdapt]m_byBasVidDectPT and m_byBasAudDecPT are NULL!\n");
		return FALSE;
	}
	
	TEqp  tEqp = GetBas();
	u8	  byChnId = GetChnId();

	//1.获取适配参数
	u8 byOutNum = 0;
	THDAdaptParam atParam[MAXNUM_BASOUTCHN];
	if(!g_cMcuVcApp.GetBasOutPutParam(tEqp, byChnId, byOutNum, atParam))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CMpu2BasChn::StartAdapt] GetBasOutPutParam--><EqpId:%d, ChnId> failed!\n", tEqp.GetEqpId(), byChnId);
		return FALSE;
	}

	//2.1获取通道媒体模式
	u8 byMode = GetMediaMode();
	if (MODE_NONE == byMode || MODE_BOTH == byMode)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CMpu2BasChn::StartAdapt] GetChnMode failed!\n");
		return FALSE;
	}

	//2.2 新增MPU2，如果某一路编码，没有对应接收终端，那么就把该路编码码率设置成0
	u16 wCount = ((unsigned int)1<<byOutNum) - 1;
	u16 wRealCount = 0;
	CMcuVcInst *pVcInst = g_cMcuVcApp.GetConfInstHandle( tEqp.GetConfIdx() ); 
	if ( pVcInst != NULL)
	{
		//只针对广播BAS通道做循环遍历处理
		if ( CHN_ADPMODE_BRD == pVcInst->GetBasGrpType( tEqp, byChnId ) )
		{
			BOOL32		bIsFindBasOutIdx = FALSE;
			TBasOutInfo tOutInfo;
			for (u8 byMtIdx = 1; byMtIdx <= MAXNUM_CONF_MT; byMtIdx++)
			{
				TMt tBasSrc = GetSrc();
				if (!tBasSrc.IsNull()&& 
					pVcInst->FindBasChn2BrdForMtExt(tBasSrc,byMtIdx,GetMediaMode(),tOutInfo) &&
					tOutInfo.m_tBasEqp == tEqp &&
					tOutInfo.m_byChnId == byChnId
					)
				{
					wRealCount|= ((unsigned int)1<<tOutInfo.m_byOutIdx);
					if( wRealCount == wCount )
					{
						break;
					}
				}	
			}
		}
		else
		{
			for (u8 byOutLoop= 0; byOutLoop < byOutNum; byOutLoop++)
			{
				wRealCount = wCount; 
			}
		}
	}
	else
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CMpu2BasChn::StartAdapt] teqp:%d chnd:%d ConfIdx:%d pVcInst is NUll!\n",
				tEqp.GetEqpId(),byChnId,tEqp.GetConfIdx()
				);
	}


	//3.1 下参
	BOOL32 bStateReady = g_cMcuVcApp.GetBasChnStatus(tEqp, byChnId) == BASCHN_STATE_READY? TRUE:FALSE;
	CServMsg cServMsg;
	cServMsg.SetMsgBody();
	u8 byIdx =0;
	for (byIdx= 0; byIdx < byOutNum; byIdx++)
	{	
		cServMsg.CatMsgBody((u8*)&atParam[byIdx], sizeof(THDAdaptParam));
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[CMpu2BasChn::StartAdapt] Set HDbas param as: EqpId:%d, ChnId:%d, OutIdx:%d, Media:%d, Res:%d, BR:%d, FR:%d, BasDecPT:%d, BasAudDecPT:%d!\n",
			tEqp.GetEqpId(), byChnId, byIdx, atParam[byIdx].GetVidType(), 
			GetResByWH(atParam[byIdx].GetWidth(), atParam[byIdx].GetHeight()), 
			atParam[byIdx].GetBitrate(), atParam[byIdx].GetFrameRate(), 
			tBasParamExt.m_byBasVidDectPT, tBasParamExt.m_byBasAudDecPT);
	}	

	//3.2 比较源能力和编码能力，下适当参数给mpu2
	TLogicalChannel tSrcLogicChn = tBasParamExt.m_tSrcLgcChn;
	LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[CMpu2BasChn::StartAdapt]tSrcLogicChn,VidType:%d-VidFPS:%d-Res:%d\n",
			tSrcLogicChn.GetChannelType(),
			tSrcLogicChn.GetChanVidFPS(),
			tSrcLogicChn.GetVideoFormat()
			);
	THDAdaptParam atSpecialtParam[MAXNUM_BASOUTCHN];
	u16 wWidth =0;
	u16 wHeight = 0;
	u8 byRealSpecialFrameRate = 0;
	u8 byRealSrcFrameRate = 0;
	for (byIdx = 0; byIdx < byOutNum; byIdx++)
	{	
		atSpecialtParam[byIdx] = atParam[byIdx];
		if ( !atParam[byIdx].IsNull()&&
			 atParam[byIdx].GetVidType() != 0 &&
			 tSrcLogicChn.GetChannelType() != MEDIA_TYPE_NULL&&
			 tSrcLogicChn.GetChanVidFPS() >0 &&
			 tSrcLogicChn.GetVideoFormat()>0
			)
		{
			//如果不存在终端收该路编码，那么码率设置成0
			if ( (wRealCount & ((unsigned int)1<<byIdx) ) == 0 )
			{
				atSpecialtParam[byIdx].SetBitRate(0);
				LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[CMpu2BasChn::StartAdapt]force bas:%d-%d-%d biterate to 0!\n",tEqp.GetEqpId(), byChnId, byIdx);
			}
			//适配录像不切文件，故非适配录像对分辨率采取特殊处理,录像切文件：格式、分辨率不同会导致 
			if ( FALSE == tBasParamExt.m_bIsSpecialChn )
			{
				if ( atParam[byIdx].GetVidType()!= MEDIA_TYPE_H264 )
				{
					byRealSpecialFrameRate = FrameRateMac2Real(atParam[byIdx].GetFrameRate());
				}
				else
				{
					byRealSpecialFrameRate = atParam[byIdx].GetFrameRate();
				}
				
				if ( tSrcLogicChn.GetChannelType()!= MEDIA_TYPE_H264 )
				{
					byRealSrcFrameRate = FrameRateMac2Real(tSrcLogicChn.GetChanVidFPS());
				}
				else
				{
					byRealSrcFrameRate = tSrcLogicChn.GetChanVidFPS();
				}
				
				if ( byRealSpecialFrameRate > byRealSrcFrameRate )
				{
					if (  atParam[byIdx].GetVidType()!= MEDIA_TYPE_H264 )
					{
						atSpecialtParam[byIdx].SetFrameRate( tSrcLogicChn.GetChanVidFPS() );
					}
					else
					{
						atSpecialtParam[byIdx].SetFrameRate( byRealSrcFrameRate );
					}		
				}
				
				
				if (  tSrcLogicChn.GetVideoFormat() == VIDEO_FORMAT_UXGA  && 
					GetResByWH( atParam[byIdx].GetWidth(), atParam[byIdx].GetHeight() ) == VIDEO_FORMAT_HD1080					
					)
				{
					LogPrint( LOG_LVL_DETAIL,MID_MCU_BAS,"[CMpu2BasChn::StartAdapt]UGA to 1080 no need change\n");
				}
				else
				{
					if( tSrcLogicChn.GetVideoFormat() == VIDEO_FORMAT_AUTO  && tSrcLogicChn.GetChannelType() == MEDIA_TYPE_MP4 )
					{
						GetWHByRes( GetAutoResByBitrate( tSrcLogicChn.GetVideoFormat(),tSrcLogicChn.GetFlowControl() ),wWidth,wHeight );						
					}
					else
					{
						GetWHByRes( tSrcLogicChn.GetVideoFormat(), wWidth,wHeight );						
					}
					if ( (atParam[byIdx].GetWidth())* (atParam[byIdx].GetHeight() )> wWidth* wHeight)
					{
						atSpecialtParam[byIdx].SetResolution(wWidth,wHeight);
					}
					
				}
			}
		}

		cServMsg.CatMsgBody((u8*)&atSpecialtParam[byIdx], sizeof(THDAdaptParam));
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[CMpu2BasChn::StartAdapt] Set HDbas Specialparam as: EqpId:%d, ChnId:%d, OutIdx:%d, Media:%d, Res:%d, FR:%d,RealBiteRate:%d!\n",
			tEqp.GetEqpId(), byChnId, byIdx, atSpecialtParam[byIdx].GetVidType(), 
			GetResByWH(atSpecialtParam[byIdx].GetWidth(), atSpecialtParam[byIdx].GetHeight()), 
			atSpecialtParam[byIdx].GetFrameRate(),
			atSpecialtParam[byIdx].GetBitrate()
			);
	}	

	//3.3 加密参数
	cServMsg.CatMsgBody( (u8*)&tBasParamExt.m_tEncrypt, sizeof(TMediaEncrypt));
	

	//3.4 TDoublePayload tDVPayload;
	cServMsg.CatMsgBody( (u8*)&tBasParamExt.m_tDVPayload, sizeof(TDoublePayload) );

	//3.5 通道号
	cServMsg.SetChnIndex( byChnId );
	
	//3.6 唇音同步解码类型
	if (MEDIA_TYPE_NULL != tBasParamExt.m_byBasAudDecPT)
	{
		cServMsg.CatMsgBody((u8*)&tBasParamExt.m_byBasAudDecPT, sizeof(u8));
	}

	//3.7 发送开启适配消息
	if (bStateReady)
	{
		SendMsgToBas(  MCU_HDBAS_STARTADAPT_REQ, cServMsg, cConfId );
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[ChangeAdapt] BAS.%d Chn.%d: MCU_HDBAS_STARTADAPT_REQ!\n", 
			tEqp.GetEqpId(), byChnId);
	}
	else
	{
		SendMsgToBas( MCU_HDBAS_SETADAPTPARAM_CMD, cServMsg,cConfId);
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[ChangeAdapt] BAS.%d Chn.%d: MCU_HDBAS_SETADAPTPARAM_CMD!\n", 
				 tEqp.GetEqpId(), byChnId
				 );
	}

	//3.6 更新通道状态
	if (bStateReady)
	{
		g_cMcuVcApp.UpdateBasChnStatus(tEqp, byChnId, BASCHN_STATE_WAITSTART);
	}

	return TRUE;
}

/*====================================================================
函数名        StopAdapt
功能        ：
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
BOOL32 CMpu2BasChn::StopAdapt(CConfId &cConfId)
{
	if (GetBas().IsNull())
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CMpu2BasChn::StopAdapt] tBas is null!\n");
		return FALSE;
	}
	
	LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[CMpu2BasChn::StopAdapt] conf:%d tEqp:%d!,chnId:%d\n", GetBas().GetConfIdx(), GetBas().GetEqpId(), GetChnId());
	
	CServMsg cServMsg;
    cServMsg.SetChnIndex(GetChnId());
	SendMsgToBas(MCU_HDBAS_STOPADAPT_REQ, cServMsg,cConfId);
	g_cMcuVcApp.UpdateBasChnStatus(GetBas(), GetChnId(), BASCHN_STATE_READY);
	return TRUE;
}

/*====================================================================
函数名        SetEncAbility
功能        ：设置编码能力
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
void COldBasChn::SetEncAbility(u8 byEncIdx, u16 wEncAbility)
{
	if (byEncIdx >= GetEncNum())
	{
		OspPrintf(TRUE, FALSE, "[SetEncAbility] byEncIdx:%d is unexpected!\n");
		return;
	}
	m_awEncAbility[byEncIdx] |= (u16)((unsigned int)1 << wEncAbility);
}

/*====================================================================
函数名        SetChnAbility
功能        ：根据通道号和外设类型设置通道能力
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
void COldBasChn::SetChnAbility(u8 byEqpType)
{
	switch (byEqpType)
	{
	case TYPE_MPU:
		{		
			SetEncNum(MAXNUM_MPU_VOUTPUT);

			SetDecAbility(emDecSD);
			SetDecAbility(emDecHD);

			SetEncAbility(0, emHD1080p);
			SetEncAbility(0, emHD720p);
			SetEncAbility(0, em4Cif);
			SetEncAbility(0, emSXGA);
			SetEncAbility(0, emXGA);
			SetEncAbility(1, emCif);				
			SetEncAbility(1, emOther);
		//	SetEncAbility(1, emH263plus);
		}
		break;
	case TYPE_MPU_H:
		{
			SetEncNum(MAXNUM_MPU_H_VOUTPUT);

			SetDecAbility(emDecSD);
			SetDecAbility(emDecHD);
			SetDecAbility(emDecHighFps);

			SetEncAbility(0, emHD1080pHighFps);
			SetEncAbility(0, emHD1080p);
			SetEncAbility(0, emHD720pHighFps);
			SetEncAbility(0, emHD720p);
			SetEncAbility(0, emSXGA);
			SetEncAbility(0, emXGA);
			SetEncAbility(1, emHD720p);
			SetEncAbility(2, em4Cif);
			SetEncAbility(3, emCif);
			SetEncAbility(4, emOther);
//			SetEncAbility(4, emH263plus);
			SetEncAbility(4, em4Cif);
			SetEncAbility(4, emCif);
			SetEncAbility(5, emOther);
//			SetEncAbility(5, emH263plus);
			SetEncAbility(5, em4Cif);
			SetEncAbility(5, emCif);
		}
		break;
	case TYPE_MAU_NORMAL:
		{
			SetEncNum(MAXNUM_MAU_VOUTPUT);
			
			SetDecAbility(emDecSD);
			SetDecAbility(emDecHD);

			SetEncAbility(0, emHD1080p);
			SetEncAbility(0, emHD720p);
			SetEncAbility(0, em4Cif);
			SetEncAbility(0, emSXGA);
			SetEncAbility(0, emXGA);
			SetEncAbility(1, emCif);
			SetEncAbility(1, emOther);
//			SetEncAbility(1, emH263plus);
		}
		break;
	case TYPE_MAU_H263PLUS:
		{
			SetEncNum(MAXNUM_MAU_H263P_VOUTPUT);

			SetDecAbility(emDecSD);
			SetDecAbility(emDecHD);

//			SetEncAbility(0, emH263plus);
			SetEncAbility(0, em4Cif);
			SetEncAbility(0, emCif);
			SetEncAbility(0, emOther);
		}
		break;
	default:
		LogPrint( LOG_LVL_ERROR, MID_MCU_BAS, "[COldBasChn::SetChnAbility] unexpected HDBas Type:%d!\n", byEqpType);
		break;
	}
	return;
}
/*====================================================================
函数名        SetChnAbilityByChnTpye
功能        ：根据通道类型设置通道能力
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
void COldBasChn::SetChnAbilityByChnTpye(u8 byChnType)
{
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
	switch (byChnType)
	{
	case BAS_8KECHN_MV:
		{
			SetEncNum(MAXNUM_8KEBAS_VOUTPUT);
			
			SetDecAbility(emDecSD);
			SetDecAbility(emDecHD);
			SetDecAbility(emDecH261);
			
			SetEncAbility(0,emHD720p);
			SetEncAbility(0, em4Cif);
			SetEncAbility(0, emCif);
			SetEncAbility(0, emOther);	
			SetEncAbility(1, em4Cif);
			SetEncAbility(1, emCif);
			SetEncAbility(1, emOther);
			SetEncAbility(2, emCif);
			SetEncAbility(2, emOther);
			SetEncAbility(3, emOther);
		}
		break;
	case BAS_8KECHN_DS:
		{
			SetEncNum(2);
			
			SetDecAbility(emDecSD);
			SetDecAbility(emDecHD);
			
			SetEncAbility(0, emCif);
			SetEncAbility(0, emXGA);	
			SetEncAbility(0, emOther);
			SetEncAbility(1, emXGA);	
			SetEncAbility(1, emOther);	
		}
		break;
	case BAS_8KECHN_SEL:
		{
			SetEncNum(1);

			SetDecAbility(emDecSD);
			SetDecAbility(emDecH261);
			SetEncAbility(0, em4Cif);	
			SetEncAbility(0, emCif);
			SetEncAbility(0, emOther);
		}
		break;
	case BAS_8KHCHN_MV:
		{
			SetEncNum(MAXNUM_8KHBAS_VOUTPUT);
			
			SetDecAbility(emDecSD);
			SetDecAbility(emDecHD);
			SetDecAbility(emDecHighFps);
			SetDecAbility(emDecH261);
			SetDecAbility(emDecHp);
			
			//[nizhijun 2012/03/29]8kh支持720 30 HP
			SetEncAbility(0,emHD1080p);
			SetEncAbility(0,emHD720pHighProfile);
			SetEncAbility(0,emHD720p);
			SetEncAbility(0, em4Cif);
			SetEncAbility(0, emCif);
			SetEncAbility(0, emOther);
			SetEncAbility(1,emHD720p);
			SetEncAbility(1, em4Cif);
			SetEncAbility(1, emCif);
			SetEncAbility(1, emOther);
			SetEncAbility(2, em4Cif);
			SetEncAbility(2, emCif);
			SetEncAbility(2, emOther);
			SetEncAbility(3, emCif);
			SetEncAbility(3, emOther);
			SetEncAbility(4, emOther);
		}
		break;
	case BAS_8KHCHN_DS:
		{
			SetEncNum(MAXNUM_8KHBAS_DS_VOUTPUT);
			
			SetDecAbility(emDecSD);
			SetDecAbility(emDecHD);
			SetDecAbility(emDecHp);
			
			SetEncAbility(0, emCif);
			SetEncAbility(0, emXGA);	
			SetEncAbility(0, emOther);				
			SetEncAbility(1, emXGA);	
			SetEncAbility(1, emOther);	
		}
		break;
	case BAS_8KHCHN_SEL:
		{
			SetEncNum(MAXNUM_8KHBAS_SEL_VOUTPUT);
			
			SetDecAbility(emDecSD);
			SetDecAbility(emDecH261);
			SetEncAbility(0, em4Cif);	
			SetEncAbility(0, emCif);
			SetEncAbility(0, emOther);
		}
		break;
	case BAS_8KICHN0:
		{
			SetEncNum(MAXNUM_8KIVIDBAS_CHN0_OUTPUT);

			SetDecAbility(emDecSD);
			SetDecAbility(emDecHD);
			SetDecAbility(emDecHighFps);
			SetDecAbility(emDecH261);
			SetDecAbility(emDecHp);
			
			SetEncAbility(0, emHD1080pHighProfile);	
			SetEncAbility(0, emHD1080pHighFps);	
			SetEncAbility(0, emHD1080p);	
			SetEncAbility(0, emHD720pHighProfile);
			SetEncAbility(0, emHD720pHighFps);
			SetEncAbility(0, emHD720p);	
			SetEncAbility(0, em4Cif);	
			SetEncAbility(0, emCif);
			SetEncAbility(0, emOther);

			SetEncAbility(1, emHD720pHighProfile);	
			SetEncAbility(1, emHD720p);	
			SetEncAbility(1, em4Cif);	
			SetEncAbility(1, emCif);
			SetEncAbility(1, emOther);
			
			SetEncAbility(2, em4Cif);	
			SetEncAbility(2, emCif);
			SetEncAbility(2, emOther);
			
			SetEncAbility(3, emCif);
			SetEncAbility(3, emOther);

			SetEncAbility(4, emOther);

		}
		break;
	case BAS_8KICHN1:
		{
			SetEncNum(MAXNUM_8KIVIDBAS_CHN1_OUTPUT);

			SetDecAbility(emDecSD);
			SetDecAbility(emDecHD);
			SetDecAbility(emDecHighFps);
			SetDecAbility(emDecH261);
			SetDecAbility(emDecHp);
			
			SetEncAbility(0, emSXGA);
			SetEncAbility(0, emHD720p);
			SetEncAbility(0, emXGA);
			SetEncAbility(0, em4Cif);	
			SetEncAbility(0, emCif);
			SetEncAbility(0, emOther);

			SetEncAbility(1, emXGA);
			SetEncAbility(1, emOther);
		}
		break;
	case BAS_8KICHN2:
		{
			SetEncNum(MAXNUM_8KIVIDBAS_CHN2_OUTPUT);

			SetDecAbility(emDecSD);
			SetDecAbility(emDecHD);
			SetDecAbility(emDecHighFps);
			SetDecAbility(emDecH261);
			SetDecAbility(emDecHp);

			//SetEncAbility(0, emHD720pHighProfile);
			//SetEncAbility(0, emHD720p);
			SetEncAbility(0, em4Cif);
			SetEncAbility(0, emCif);
			SetEncAbility(0, emOther);
		}
		break;
	default:
		{
			LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[COldBasChn::SetChnAbilityByChnTpye]byChnType:%d is illegal\n",byChnType);
		}
		break;
	}
#else
	SetEncNum(MAXNUM_VPU_VAOUTPUT);
	if(ADAPT_TYPE_AUD == byChnType)
	{
		m_byEqpType = emVpuAudType;
		SetDecAbility(emDecAud);

		SetEncAbility(0, emAudType);
	}
	else if (ADAPT_TYPE_VID == byChnType)
	{
		SetDecAbility(emDecSD);
	
		SetEncAbility(0, em4Cif);
		SetEncAbility(0, emCif);			
		SetEncAbility(0, emOther);
	}
	else
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[COldBasChn::SetChnAbilityByChnTpye]byChnType:%d is illegal\n",byChnType);
	}
#endif
	return;
}

/*====================================================================
函数名        ChangeEncAbilityToIdx
功能        ：将编码能力转换成idx表示
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
BOOL32 COldBasChn::GetOtherCap(TVideoStreamCap *patSimCap, u8 byNum, TVideoStreamCap *patOtherCap, u8 byOtherNum)
{
	u8 byStartPos = 0;
	for ( u8 byIdx = 0 ; byIdx < byNum; byIdx++)
	{
		if ( patSimCap[byIdx].GetMediaType() == MEDIA_TYPE_NULL )
		{
			continue;
		}

		if ( patSimCap[byIdx].GetMediaType() != MEDIA_TYPE_NULL &&
			 patSimCap[byIdx].GetMediaType() != MEDIA_TYPE_H264 	
			)
		{
			if ( byStartPos>=byOtherNum )
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[COldBasChn::GetOtherIdx]more than otheridx!\n");
				return FALSE;
			}
			patOtherCap[byStartPos] = patSimCap[byIdx];
			byStartPos++;
		}
	}

	return TRUE;
}

/*====================================================================
函数名        ChangeEncAbilityToCap
功能        ：将编码能力转换成Cap表示
算法实现    ：
引用全局变量：
输入参数说明：[IN]u16 wEncAbility		位表示的会议能力
			  [IN]u8 *pbyEncIdx         H264的位记录的idx值
			  [IN]u8 *pbyEncNum         主要给other使用，记录other编码路数
			  [IN]u8 byOccupiedOtherNum  主要给other使用，记录通道已经使用的other个数
			  [IN][OUT]TNeedBasResData &tNeedBasData	适配数据
返回值说明  ：转换成功，返回true，并返回剩余的适配数据
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
BOOL32 COldBasChn::ChangeEncAbilityToCap(u16 wEncAbility,  u8 *pbyEncIdx, u8 *pbyEncNum,
										 u8 byOccupiedOtherNum, TNeedVidAdaptData &tNeedBasData)
{
	u8 byStartPos = 0;
	u16 awTempIdx[MAX_CONF_BAS_ADAPT_NUM]={0};
	TVideoStreamCap	atSimCapSet[MAX_CONF_BAS_ADAPT_NUM];
	u8	byLeftEncNum= 0;
	for (u8 byemEnIdx = emHD1080pHighProfile; byemEnIdx >= emXGA; byemEnIdx--)
	{
		if ( byStartPos >=MAX_CONF_BAS_ADAPT_NUM )
		{
			return FALSE;
		}

		u16 wTempEnAbility = wEncAbility;
		BOOL32 bResult = (wTempEnAbility &= (u16)((unsigned int)1<< byemEnIdx));
		if (bResult)
		{
			switch (byemEnIdx)
			{
			case emXGA:
				{
					atSimCapSet[byStartPos] = tNeedBasData.m_atSimCapSet[ pbyEncIdx[emXGA] ];
					byStartPos++;
					byLeftEncNum++;
				}
				break;
			case emSXGA:
				{
					atSimCapSet[byStartPos] = tNeedBasData.m_atSimCapSet[ pbyEncIdx[emSXGA] ];
					byStartPos++;
					byLeftEncNum++;
				}
				break;
			case emOther:	
				{
					//other剩余的idx获得
					TVideoStreamCap atTempOtherCap[MAX_OTHER_ENC_NUM]; //目前最多两路other
					if ( pbyEncNum[emOther]>0 )
					{
						if (!GetOtherCap(tNeedBasData.m_atSimCapSet, tNeedBasData.m_byRealEncNum, atTempOtherCap, MAX_OTHER_ENC_NUM) )
						{
							return FALSE;
						}
					}
					
					if ( byOccupiedOtherNum>0 && byOccupiedOtherNum<=MAX_OTHER_ENC_NUM )
					{
						for (u8 byIdx = byOccupiedOtherNum; byIdx >0 ; byIdx-- )
						{
							atTempOtherCap[byIdx-1].Clear();
						}
					}
					
					for ( u8 byStart =0 ; byStart <MAX_OTHER_ENC_NUM; byStart++ )
					{
						if ( atTempOtherCap[byStart].GetMediaType() != MEDIA_TYPE_NULL)
						{
							atSimCapSet[byStartPos] =  atTempOtherCap[byStart];
							byStartPos++;
							byLeftEncNum++;
						}
					}

				}
				break;
			case emCif:
				{
					atSimCapSet[byStartPos] = tNeedBasData.m_atSimCapSet[ pbyEncIdx[emCif] ];
					byStartPos++;
					byLeftEncNum++;
				}
				break;
			case em4Cif:
				{
					atSimCapSet[byStartPos] = tNeedBasData.m_atSimCapSet[ pbyEncIdx[em4Cif] ];
					byStartPos++;
					byLeftEncNum++;
				}
				break;
			case emHD720p:
				{
					atSimCapSet[byStartPos] = tNeedBasData.m_atSimCapSet[ pbyEncIdx[emHD720p] ];
					byStartPos++;
					byLeftEncNum++;
				}
				break;
			case emHD720pHighFps:
				{
					atSimCapSet[byStartPos] = tNeedBasData.m_atSimCapSet[ pbyEncIdx[emHD720pHighFps] ];
					byStartPos++;
					byLeftEncNum++;
				}
				break;
			//[nizhijun 2012/03/29]8kh支持720 30 HP
			case emHD720pHighProfile:
				{
					atSimCapSet[byStartPos] = tNeedBasData.m_atSimCapSet[ pbyEncIdx[emHD720pHighProfile] ];
					byStartPos++;
					byLeftEncNum++;
				}
				break;
			case emHD1080pHighProfile:
				{
					atSimCapSet[byStartPos] = tNeedBasData.m_atSimCapSet[ pbyEncIdx[emHD1080pHighProfile] ];
					byStartPos++;
					byLeftEncNum++;
				}
				break;
			case emHD1080p:
				{
					atSimCapSet[byStartPos] = tNeedBasData.m_atSimCapSet[ pbyEncIdx[emHD1080p] ];
					byStartPos++;
					byLeftEncNum++;
				}
				break;
			case emHD1080pHighFps:
				{
					atSimCapSet[byStartPos] = tNeedBasData.m_atSimCapSet[ pbyEncIdx[emHD1080pHighFps] ];
					byStartPos++;
					byLeftEncNum++;
				}
				break;
			default:
				{
					LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[ChangeEncAbilityToIdx]byemEnIdx:%d is illegal!\n", byemEnIdx);
					return FALSE;
				}
			}
		}
	}
	
	tNeedBasData.m_byRealEncNum = byLeftEncNum;
	memcpy(tNeedBasData.m_atSimCapSet, atSimCapSet, sizeof(atSimCapSet));
	return TRUE;
}

/*====================================================================
函数名        ChangeIdxToEncAbility
功能        ：将idx转换成编码能力表示
算法实现    ：
引用全局变量：
输入参数说明：const TSimCapSet *aptSimCapSet 能力集数组
			  u8 byCapSetNum				 能力集数组个数
			  u16 &wEncAbility				 位表示的老通道能力
			  u8 *pbyEncNum					记录统一编码个数
			  u8 *pbyH264EncIdx				记录h264编码的在能力集数组中的idx
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
BOOL32 COldBasChn::ChangeCapToEncAbility(const TVideoStreamCap *aptSimCapSet, u8 byCapSetNum, u16 &wEncAbility,u8 *pbyEncNum, u8 *pbyH264EncIdx)
{
	for ( u8 byIdx = 0 ; byIdx < byCapSetNum; byIdx++)
	{
		if ( aptSimCapSet[byIdx].GetMediaType() == MEDIA_TYPE_NULL )
		{
			continue;
		}

		if ( aptSimCapSet[byIdx].IsSupportHP() &&
			 m_byEqpType != em8KHType && em8KIType != m_byEqpType
			)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ChangeCapToEncAbility]error::oldbaschn get hp ability!\n");
			return FALSE;
		}

		if ( aptSimCapSet[byIdx].GetMediaType() == MEDIA_TYPE_H264 )
		{
			switch ( aptSimCapSet[byIdx].GetResolution() )
			{
			case VIDEO_FORMAT_HD1080:
				{
					if (  aptSimCapSet[byIdx].GetH264ProfileAttrb() == emBpAttrb )
					{
						if ( aptSimCapSet[byIdx].GetUserDefFrameRate() == 60 ||
							aptSimCapSet[byIdx].GetUserDefFrameRate() == 50
							)
						{
							wEncAbility |= (u16)1 << COldBasChn::emHD1080pHighFps;
							pbyEncNum[COldBasChn::emHD1080pHighFps] += 1;
							pbyH264EncIdx[COldBasChn::emHD1080pHighFps] = byIdx;
						}
						else
						{
							wEncAbility |= (u16)1 << COldBasChn::emHD1080p;
							pbyEncNum[COldBasChn::emHD1080p] += 1;
							pbyH264EncIdx[COldBasChn::emHD1080p] = byIdx;
						}
					}
					else
					{
						//LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[ChangeCapToEncAbility]1080 hp error!\n");
						//return FALSE;
						wEncAbility |= (u16)1 << COldBasChn::emHD1080pHighProfile;
						pbyEncNum[COldBasChn::emHD1080pHighProfile] += 1;
						pbyH264EncIdx[COldBasChn::emHD1080pHighProfile] = byIdx;
					}
				}
				break;
			case VIDEO_FORMAT_HD720:
				{
					if ( ( m_byEqpType == em8KHType || m_byEqpType == em8KIType ) &&
						 aptSimCapSet[byIdx].GetH264ProfileAttrb() == emHpAttrb
						)
					{
						/*if ( aptSimCapSet[byIdx].GetUserDefFrameRate() == 30 ||
							aptSimCapSet[byIdx].GetUserDefFrameRate() == 25
							)
						{*/
							wEncAbility |= (u16)1 << COldBasChn::emHD720pHighProfile;
							pbyEncNum[COldBasChn::emHD720pHighProfile] += 1;
							pbyH264EncIdx[COldBasChn::emHD720pHighProfile] = byIdx;
						/*}
						else
						{
							LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[ChangeCapToEncAbility]720 60 hp error!\n");
							return FALSE;
						}*/
					}		
					else
					{
						if ( aptSimCapSet[byIdx].GetUserDefFrameRate() == 60 ||
							 aptSimCapSet[byIdx].GetUserDefFrameRate() == 50
							)
						{
							wEncAbility |= (u16)1 << COldBasChn::emHD720pHighFps;
							pbyEncNum[COldBasChn::emHD720pHighFps] += 1;
							pbyH264EncIdx[COldBasChn::emHD720pHighFps] = byIdx;
						}
						else
						{
							wEncAbility |= (u16)1 << COldBasChn::emHD720p;
							pbyEncNum[COldBasChn::emHD720p] += 1;
							pbyH264EncIdx[COldBasChn::emHD720p] = byIdx;
						}
					}
				}
				break;
			case VIDEO_FORMAT_4CIF:
				{
					wEncAbility |= (u16)1 << COldBasChn::em4Cif;
					pbyEncNum[COldBasChn::em4Cif] += 1;
					pbyH264EncIdx[COldBasChn::em4Cif] = byIdx;
				}
				break;
			case VIDEO_FORMAT_CIF:
				{
					wEncAbility |= (u16)1 << COldBasChn::emCif;
					pbyEncNum[COldBasChn::emCif] += 1;
					pbyH264EncIdx[COldBasChn::emCif] = byIdx;
				}
				break;
			case VIDEO_FORMAT_XGA:
				{
					wEncAbility |= (u16)1 << COldBasChn::emXGA;
					pbyEncNum[COldBasChn::emXGA] += 1;
					pbyH264EncIdx[COldBasChn::emXGA] = byIdx;
				}
				break;
			case VIDEO_FORMAT_SXGA:
				{
					wEncAbility |= (u16)1 << COldBasChn::emSXGA;
					pbyEncNum[COldBasChn::emSXGA] += 1;
					pbyH264EncIdx[COldBasChn::emSXGA] = byIdx;
				}
				break;
			default:
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS,"[ChangeCapToEncAbility]res:%d is illegal\n",aptSimCapSet[byIdx].GetResolution());
					return FALSE;
				}
			}
		}
		else if ( aptSimCapSet[byIdx].GetMediaType() != MEDIA_TYPE_NULL &&
				  aptSimCapSet[byIdx].GetMediaType() != MEDIA_TYPE_H264 	
				)
		{
			wEncAbility |= (u16)1 << COldBasChn::emOther;
			pbyEncNum[COldBasChn::emOther] += 1;
			//other不进行idx记录，通过另外的方式获得idx记录
			//pbyEncNum[COldBasChn::emOther] = byIdx;
		}
	}
	
	return TRUE;
}

void COldBasChn::NPlusSetAttr(u8 byChnType, BOOL32 bIsHDBas,BOOL32 bIsVPU /* = FALSE */)
{
	memset(m_awEncAbility,0,sizeof(m_awEncAbility));	
	m_byEqpType = emOtherType;		//初始化为other，如果是8KH 或者8KG 会再赋值
	if ( bIsHDBas )
	{
		SetChnAbility(byChnType);
	}
	else
	{
		if ( bIsVPU )
		{
			SetEncNum(MAXNUM_VPU_VAOUTPUT);
			if(ADAPT_TYPE_AUD == byChnType)
			{
				m_byEqpType = emVpuAudType;
				SetDecAbility(emDecAud);
				
				SetEncAbility(0, emAudType);
			}
			else if (ADAPT_TYPE_VID == byChnType)
			{
				SetDecAbility(emDecSD);
				
				SetEncAbility(0, em4Cif);
				SetEncAbility(0, emCif);			
				SetEncAbility(0, emOther);
			}
			else
			{
				LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[COldBasChn::SetChnAbilityByChnTpye]byChnType:%d is illegal\n",byChnType);
			}
		}
		else
		{
			switch (byChnType)
			{
				case BAS_8KECHN_MV:
				{
					SetEncNum(MAXNUM_8KEBAS_VOUTPUT);
					
					SetDecAbility(emDecSD);
					SetDecAbility(emDecH261);
					SetDecAbility(emDecHD);
					
					SetEncAbility(0,emHD720p);
					SetEncAbility(0, em4Cif);
					SetEncAbility(0, emCif);
					SetEncAbility(0, emOther);	
					SetEncAbility(1, em4Cif);
					SetEncAbility(1, emCif);
					SetEncAbility(1, emOther);
					SetEncAbility(2, emCif);
					SetEncAbility(2, emOther);
					SetEncAbility(3, emOther);
					m_byEqpType = em8KGType;
				}
				break;
				case BAS_8KECHN_DS:
				{
					SetEncNum(2);
					
					SetDecAbility(emDecSD);
					SetDecAbility(emDecHD);
					
					SetEncAbility(0, emXGA);	
					SetEncAbility(0, emOther);				
					SetEncAbility(1, emXGA);	
					SetEncAbility(1, emOther);	
					m_byEqpType = em8KGType;
				}
				break;
				case BAS_8KECHN_SEL:
				{
					SetEncNum(1);

					SetDecAbility(emDecSD);
					SetDecAbility(emDecH261);
					SetEncAbility(0, em4Cif);	
					SetEncAbility(0, emCif);
					SetEncAbility(0, emOther);
					m_byEqpType = em8KGType;
				}
				break;
				case BAS_8KHCHN_MV:
				{
					SetEncNum(MAXNUM_8KHBAS_VOUTPUT);
					
					SetDecAbility(emDecSD);
					SetDecAbility(emDecHD);
					SetDecAbility(emDecHighFps);
					SetDecAbility(emDecH261);
					SetDecAbility(emDecHp);
					
					//[nizhijun 2012/03/29]8kh支持720 30 HP
					SetEncAbility(0,emHD1080p);
					SetEncAbility(0,emHD720pHighProfile);
					SetEncAbility(0,emHD720p);
					SetEncAbility(0, em4Cif);
					SetEncAbility(0, emCif);
					SetEncAbility(0, emOther);
					SetEncAbility(1,emHD720p);
					SetEncAbility(1, em4Cif);
					SetEncAbility(1, emCif);
					SetEncAbility(1, emOther);
					SetEncAbility(2, em4Cif);
					SetEncAbility(2, emCif);
					SetEncAbility(2, emOther);
					SetEncAbility(3, emCif);
					SetEncAbility(3, emOther);
					SetEncAbility(4, emOther);
					m_byEqpType = em8KHType;
				}
				break;
				case BAS_8KHCHN_DS:
				{
					SetEncNum(MAXNUM_8KHBAS_DS_VOUTPUT);
					
					SetDecAbility(emDecSD);
					SetDecAbility(emDecHD);
					SetDecAbility(emDecHp);
					
					SetEncAbility(0, emXGA);	
					SetEncAbility(0, emOther);				
					SetEncAbility(1, emXGA);	
					SetEncAbility(1, emOther);	
					m_byEqpType = em8KHType;
				}
				break;
				case BAS_8KHCHN_SEL:
				{
					SetEncNum(MAXNUM_8KHBAS_SEL_VOUTPUT);
					
					SetDecAbility(emDecSD);
					SetDecAbility(emDecH261);
					SetEncAbility(0, em4Cif);	
					SetEncAbility(0, emCif);
					SetEncAbility(0, emOther);
					m_byEqpType = em8KHType;
				}
				break;
				case BAS_8KICHN0:
					{
						SetEncNum( MAXNUM_8KIVIDBAS_CHN0_OUTPUT );
					
						SetDecAbility(emDecSD);
						SetDecAbility(emDecHD);
						SetDecAbility(emDecHighFps);
						SetDecAbility(emDecH261);
						SetDecAbility(emDecHp);
						
						SetEncAbility(0, emHD1080pHighProfile);	
						SetEncAbility(0, emHD1080pHighFps);	
						SetEncAbility(0, emHD1080p);	
						SetEncAbility(0, emHD720pHighProfile);
						SetEncAbility(0, emHD720pHighFps);
						SetEncAbility(0, emHD720p);	
						SetEncAbility(0, em4Cif);	
						SetEncAbility(0, emCif);
						SetEncAbility(0, emOther);

						SetEncAbility(1, emHD720pHighProfile);	
						SetEncAbility(1, emHD720p);	
						SetEncAbility(1, em4Cif);	
						SetEncAbility(1, emCif);
						SetEncAbility(1, emOther);
						
						SetEncAbility(2, em4Cif);	
						SetEncAbility(2, emCif);
						SetEncAbility(2, emOther);
						
						SetEncAbility(3, emCif);
						SetEncAbility(3, emOther);

						SetEncAbility(4, emOther);
						
						m_byEqpType = em8KIType;
					}
					break;
				case BAS_8KICHN1:
					{
						SetEncNum( MAXNUM_8KIVIDBAS_CHN1_OUTPUT );
					
						SetDecAbility(emDecSD);
						SetDecAbility(emDecHD);
						SetDecAbility(emDecHighFps);
						SetDecAbility(emDecH261);
						SetDecAbility(emDecHp);
						
						SetEncAbility(0, emSXGA);	
						SetEncAbility(0, emHD720p);
						SetEncAbility(0, emXGA);
						SetEncAbility(0, em4Cif);	
						SetEncAbility(0, emCif);
						SetEncAbility(0, emOther);

						SetEncAbility(1, emXGA);
						SetEncAbility(1, emOther);	

						m_byEqpType = em8KIType;
					}
					break;
				case BAS_8KICHN2:
					{
						SetEncNum( MAXNUM_8KIVIDBAS_CHN2_OUTPUT );
					
						SetDecAbility(emDecSD);
						SetDecAbility(emDecHD);
						SetDecAbility(emDecHighFps);
						SetDecAbility(emDecH261);
						SetDecAbility(emDecHp);

						//SetEncAbility(0, emHD720pHighProfile);
						//SetEncAbility(0, emHD720p);
						SetEncAbility(0, em4Cif);
						SetEncAbility(0, emCif);
						SetEncAbility(0, emOther);		

						m_byEqpType = em8KIType;
					}
					break;
				default:
				{
					LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[COldBasChn::SetChnAbilityByChnTpye]byChnType:%d is illegal\n",byChnType);
				}
				break;
			}
		}
	}
}

/*====================================================================
函数名        COldBasChn
功能        ：老BAS通道构造，设置编解码能力
算法实现    ：
引用全局变量：
输入参数说明：u8 byEqpType     外设类型
		      u8 byChnType     8KE需要使用的通道类型
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
COldBasChn::COldBasChn(const TEqp &tEqp, u8 byChnId,TPeriEqpStatus &tBasStatus)
{
	m_adwLastVCUTick = 0;
	memset(m_awEncAbility,0,sizeof(m_awEncAbility));	
	m_byEqpType = emOtherType;		//初始化为other，如果是8KH 或者8KG 会再赋值

	SetBas(tEqp);
	SetChnId(byChnId);

	u8 byHDBasType = tBasStatus.m_tStatus.tHdBas.GetEqpType();
	THDBasVidChnStatus *ptVidChnStatus = NULL;
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if (g_cMcuAgent.IsEqpBasHD(tEqp.GetEqpId()))
#endif
	{
		switch (byHDBasType)
		{
		case TYPE_MPU:
		case TYPE_MPU_H:
		case TYPE_MAU_NORMAL:
		case TYPE_MAU_H263PLUS:
			{
				SetChnAbility(byHDBasType);
			}
			break;
		case TYPE_8KE_BAS:
			{
				m_byEqpType = em8KGType;
				ptVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0);
				if ( ptVidChnStatus != NULL )
				{
					u8 byChnType = ptVidChnStatus->GetType();
					SetChnAbilityByChnTpye(byChnType);
				}
			}
			break;
		case TYPE_8KH_BAS:
			{
				m_byEqpType = em8KHType;
				ptVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0);
				if ( ptVidChnStatus != NULL )
				{
					u8 byChnType = ptVidChnStatus->GetType();
					SetChnAbilityByChnTpye(byChnType);
				}
			}
			break;
		case TYPE_8KI_VID_BAS:
			{
				m_byEqpType = em8KIType;
				ptVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.t8kiBas.GetVidChnStatus(0);
				if ( ptVidChnStatus != NULL )
				{
					u8 byChnType = ptVidChnStatus->GetType();
					SetChnAbilityByChnTpye(byChnType);
				}
			}
			break;
		default:
			{
				LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[COldBasChn]byHDBasType:%d is illegal\n",byHDBasType);
			}
			break;
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else//标清适配器 
	{
		u8 byChnType = tBasStatus.m_tStatus.tBas.tChnnl[byChnId].GetChannelType();
		SetChnAbilityByChnTpye(byChnType);
	}
#endif	
}

/*====================================================================
函数名        CalculateLeftEncAbility
功能        ：计算剩余能力
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
// BOOL32 COldBasChn::CalculateLeftEncAbility(u16 **m_awEncAbility, u8 &wLeftEncNum)
// {
// 	return TRUE;
// }

/*====================================================================
函数名        IsBasChnSupportNeeds
功能        ：是否支持所需能力
算法实现    ：
引用全局变量：
输入参数说明：[in][out]TNeedBasResData &tNeedBasData 所需编码数据
返回值说明  ：支持编解码返回TRUE，并返回剩余编码数据
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
/*lint -save -e850*/
BOOL32 COldBasChn::IsBasChnSupportNeeds(TNeedVidAdaptData &tNeedBasData, TVideoStreamCap *ptOccpiedResData)
{
	//8000H的双流通道只给双流适配使用
	if ( m_byEqpType == em8KHType || m_byEqpType == em8KGType || m_byEqpType == em8KIType )
	{
		if ( tNeedBasData.m_byMediaMode == MODE_VIDEO &&
			IsSupportEncParam(0,emXGA)
			)
		{
			return FALSE;
		}
		
		//[nizhijun 2012/04/12] 8KH与8KG 双流H263+ XGA会占用到选看通道
		//故此处做一下特殊处理，为了判断起来简单点，正好利用目前8KH与8KG适配通道的特点，
		//由于目前8KG与8KG 只有双流适配通道有两出，故对于非两出的通道，一律返回FALSE
		if ( tNeedBasData.m_byMediaMode == MODE_SECVIDEO &&
			GetEncNum() != 2
			)
		{
			return FALSE;
		}
	}
	//mpu不支持h261格式的编解码，故在此处判断需要适配编码能力中是否有H261
	else
	{
		for ( u8 byTempLoop =0; byTempLoop<tNeedBasData.m_byRealEncNum; byTempLoop++ )
		{
			if ( tNeedBasData.m_atSimCapSet[byTempLoop].GetMediaType() == MEDIA_TYPE_H261 )
			{
				return FALSE;
			}
		}
	}



	if ( !IsSupportDecParam(tNeedBasData.m_byDecNeedRes) )
	{
		LogPrint(LOG_LVL_WARNING,MID_MCU_BAS,"[COldBasChn::IsBasChnSupportNeeds]bas:%d-%d not support dec!\n", GetBas().GetEqpId(), GetChnId());
		return FALSE;
	}

	//音频适配处理
	u8 byTempDecAud = tNeedBasData.m_byDecNeedRes;
	BOOL32 bResult = (byTempDecAud &= (u8)(1 <<COldBasChn::emDecAud));
	if (  bResult )
	{
		if ( !IsSupportEncParam(0, emAudType) )
		{
			return FALSE;
		}
		tNeedBasData.m_byRealEncNum = 0;
		return TRUE;
	}

	//视频适配处理
	u16 wReqEncAbility = 0;
	u8  abyEncNum[emHD1080pHighProfile+1] = {0};
	u8  abyH264EncIdx[emHD1080pHighProfile+1] = {0};		//记录264的idx，以便从wReqEncAbility转换成idx时恢复
	if ( !ChangeCapToEncAbility(tNeedBasData.m_atSimCapSet, tNeedBasData.m_byRealEncNum, wReqEncAbility, abyEncNum,abyH264EncIdx) )
	{
		return FALSE;
	}

	if ( wReqEncAbility == 0 )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[COldBasChn::IsBasChnSupportNeeds]ChangeCapToEncAbility failed!\n");
		return FALSE;
	}
	
	BOOL32 abExistHighFps1080 = FALSE;				//记录所在通道是否存在1080高帧率输出
	u8	   byOtherOccupyNum = 0;

	//检查该通道输出的参数,为选看占用时，使用
	u8 byOutNum = 0;
	THDAdaptParam atParam[MAXNUM_BASOUTCHN];
	memset(atParam,0,sizeof(atParam));
	if(!g_cMcuVcApp.GetBasOutPutParam(GetBas(), GetChnId(), byOutNum, atParam))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsBasChnSupportNeeds] GetBasOutPutParam--><EqpId:%d, ChnId:%d> failed!\n", 
				 GetBas().GetEqpId(), GetChnId()
				);
		//这里不return false，因为N+1，主板重新开会申请时，备板需要用这个接口判断是否主板可备份是， 会使用到这个接口，
		//return FALSE;
	}
	
	//由于mpu-h前四出只能有一路高帧率编码，故此处记录下前四出是否已经有编码，方便下面判断
	//通过解码能力判断是否mpu-h，8000A老BAS通道只有mpu-h是支持解码高帧率的
	BOOL32 bExistEncParam = FALSE;
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	u8 byTempDec = (u8)1 <<CBasChn::emDecHighFps;
	if ( IsSupportDecParam(byTempDec) && GetEncNum() ==MAXNUM_MPU_H_VOUTPUT )
	{	
		for ( u8 byOutIdx=0 ; byOutIdx<(MAXNUM_MPU_H_VOUTPUT-2); byOutIdx ++)
		{
			if (  !atParam[byOutIdx].IsNull()  )
			{
				bExistEncParam = TRUE;
				break;
			}
		}
	}
#endif

	BOOL32 abEncIdxOcuppyed[MAXNUM_BASOUTCHN]; //记录被占用的编码输出索引
	memset(abEncIdxOcuppyed, 0, sizeof(abEncIdxOcuppyed));	
	BOOL32 abOtherIdxUsed[MAX_CONF_BAS_ADAPT_NUM];		//记录已使用的other能力集索引idx
	memset(abOtherIdxUsed, 0, sizeof(abOtherIdxUsed));	
	u8 bySimCapSetIdx = 0;
	for (u8 byemEnIdx = emHD1080pHighProfile; byemEnIdx >= emXGA; byemEnIdx--)
	{
		//越界检查
		if ( bySimCapSetIdx >= MAX_CONF_BAS_ADAPT_NUM )
		{
			return FALSE;
		}

		u16 wTmpReqEncAbility = wReqEncAbility;
		BOOL32 bReqResult = (wTmpReqEncAbility &= (u16)((unsigned int)1<< byemEnIdx));
		if (bReqResult)
		{
			if ( byemEnIdx == emHD720p &&
				!abExistHighFps1080 &&
				GetEncNum() == 6 && //老通道中只有mpu-2有六路编码
				IsSupportEncParam(1,byemEnIdx)&& 
				!abEncIdxOcuppyed[1]//编码未被占用
				)
			{
				abEncIdxOcuppyed[1] = TRUE;
				abyEncNum[byemEnIdx] --;
				if(abyEncNum[byemEnIdx] == 0)
				{	
					wReqEncAbility ^= (u16)((unsigned int)1<< byemEnIdx);
				}	
				else
				{
					byemEnIdx ++;
				}
				
				bySimCapSetIdx++;
				ptOccpiedResData[bySimCapSetIdx] = tNeedBasData.m_atSimCapSet[abyH264EncIdx[byemEnIdx]];
				continue;
			}
			
			
			for (u8 byEncIdx = 0; byEncIdx < GetEncNum(); byEncIdx++)
			{
				//越界检查
				if ( bySimCapSetIdx >= MAX_CONF_BAS_ADAPT_NUM )
				{
					return FALSE;
				}

				if (  !atParam[byEncIdx].IsNull())
				{
					continue;
				}

				//如果前四出已经存在编码，那么要求编码高帧率是不行的
				if (  byemEnIdx == COldBasChn::emHD1080pHighFps &&
					  TRUE == bExistEncParam  &&
					  byEncIdx < (MAXNUM_MPU_H_VOUTPUT-2)
					)
				{
					continue;
				}

				if ( IsSupportEncParam(byEncIdx, byemEnIdx) && 
					!abEncIdxOcuppyed[byEncIdx]//编码未被占用
				   )
				{	
					u8	 byTempDecAbility = tNeedBasData.m_byDecNeedRes;
					BOOL32 bDecResult =	(byTempDecAbility &= (u8)(1 <<emDecHighFps));
					if ( bDecResult )
					{
						if ( byemEnIdx == COldBasChn::emHD1080pHighFps )
						{
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
							abExistHighFps1080 = TRUE;
#endif
						}
						else if( byemEnIdx == COldBasChn::emHD1080p ||
								 byemEnIdx == COldBasChn::emHD720p  ||
								 byemEnIdx == COldBasChn::emHD720pHighFps
								)
						{
							if( abExistHighFps1080 )
							{
								break;
							}
						}			
						else if( byemEnIdx == COldBasChn::em4Cif )
						{
							if( abExistHighFps1080
								&& (byEncIdx == 2 || byEncIdx == 4)
							  )
							{
								continue;
							}
						}
						else if( byemEnIdx == COldBasChn::emCif )
						{
							if(abExistHighFps1080 && byEncIdx == 3 )
							{
								continue;
							}	
						}
					}

					abEncIdxOcuppyed[byEncIdx] = TRUE;
					if ( byemEnIdx != emOther )
					{
						ptOccpiedResData[bySimCapSetIdx] = tNeedBasData.m_atSimCapSet[abyH264EncIdx[byemEnIdx]];
					}
					else
					{
						byOtherOccupyNum++;
						for (u8 byLoop = 0 ; byLoop < MAX_CONF_BAS_ADAPT_NUM; byLoop++ )
						{
							if ( tNeedBasData.m_atSimCapSet[byLoop].GetMediaType() != MEDIA_TYPE_NULL &&
								 tNeedBasData.m_atSimCapSet[byLoop].GetMediaType() != MEDIA_TYPE_H264 &&
								 abOtherIdxUsed[byLoop] == FALSE
								)
							{
								ptOccpiedResData[bySimCapSetIdx] = tNeedBasData.m_atSimCapSet[byLoop];
								abOtherIdxUsed[byLoop] = TRUE;
								break;
							}
						}
					
					}

					//如果当前会议需要同一类编码出多路，则不砍能力集，继续匹配,一般other出现该种情况
					abyEncNum[byemEnIdx] --;
					if(abyEncNum[byemEnIdx] == 0)
					{	
						wReqEncAbility ^= (u16)((unsigned int)1<< byemEnIdx);
					}	
					else
					{
						byemEnIdx ++;
					}
					
					bySimCapSetIdx++;
					break;
				}
			}
		}
	}	

	//匹配成功，清空所需能力
	if ( wReqEncAbility == 0 )
	{
		tNeedBasData.m_byRealEncNum = 0;
		memcpy(ptOccpiedResData,tNeedBasData.m_atSimCapSet,sizeof(tNeedBasData.m_atSimCapSet));
	}
	//能力还有剩余，计算剩余能力
	else
	{
		if ( !ChangeEncAbilityToCap(wReqEncAbility, abyH264EncIdx, abyEncNum, byOtherOccupyNum, tNeedBasData) )
		{
			LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[IsBasChnSupportNeeds]ChangeEncAbilityToIdx failed,eqp:%d-chn:%d\n",
					GetBas().GetEqpId(), GetChnId()
					);
			return FALSE;
		}
	}
	return TRUE;
}
/*lint -restore*/

/*====================================================================
函数名        GetMaxEncAbility
功能        ：获得通道最大编码能力
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
u16 COldBasChn::GetMaxEncAbility()
{
	u16 wMaxEncAbility = 0;
	for (u8 byEncIdx = 0; byEncIdx < MAXNUM_BASOUTCHN; byEncIdx++)
	{
		wMaxEncAbility = max(wMaxEncAbility, m_awEncAbility[byEncIdx]);
	}
	return wMaxEncAbility;
}

/*====================================================================
函数名        Print
功能        ：打印老通道信息
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
void COldBasChn::Print()
{
	StaticLog("-------------BAS ChnInfo as follows----------\n");
	StaticLog("EqpId:%d\n", GetBas().GetEqpId());
	StaticLog("ChnId:%d\n",GetChnId());
	StaticLog("MeidaMode:%d\n",GetMediaMode());
	StaticLog("Src<McuId:%d, MtId:%d>\n",GetSrc().GetMcuId(), GetSrc().GetMtId());
	StaticLog("Reserved:%d\n", IsReserved());
	StaticLog("Online:%d\n", IsOnLine());
	StaticLog("EncNum:%d\n", GetEncNum());
	for (u8 byEncIdx = 0; byEncIdx < GetEncNum(); byEncIdx++)
	{
		StaticLog("EncChn:%d -----SupportAbility\n\t  1080HighProfile::%s, HighFps:%s, HD1080:%s, 720pHighProfile:%s, 720pHighFps:%s, 720:%s, 4Cif:%s, Cif:%s, Other:%s, XGA:%s, SXGA:%s, AudType:%s\n",
			byEncIdx,
			IsSupportEncParam(byEncIdx, emHD1080pHighProfile) ?    "√":"×",
			IsSupportEncParam(byEncIdx, emHD1080pHighFps) ?    "√":"×",
			IsSupportEncParam(byEncIdx, emHD1080p) ?    "√":"×",
			IsSupportEncParam(byEncIdx, emHD720pHighProfile) ?    "√":"×",
			IsSupportEncParam(byEncIdx, emHD720pHighFps) ?    "√":"×",
			IsSupportEncParam(byEncIdx, emHD720p) ?    "√":"×",
			IsSupportEncParam(byEncIdx, em4Cif) ?      "√":"×",
			IsSupportEncParam(byEncIdx, emCif) ?       "√":"×",
			IsSupportEncParam(byEncIdx, emOther) ?     "√":"×",
			IsSupportEncParam(byEncIdx, emXGA) ?       "√":"×",
			IsSupportEncParam(byEncIdx, emSXGA) ?      "√":"×",
			IsSupportEncParam(byEncIdx, emAudType) ?   "√":"×"
			);
	}
}

/*====================================================================
函数名        SetAdaptParam
功能        ：普通下参接口，找到对应的输出通道，如果为空则下参成功
算法实现    ：
引用全局变量：
输入参数说明：THDAdaptParam* ptAdaptParam 参数数组地址
			  u8 byNum					  参数个数
返回值说明  ：下参成功返回TRUE,失败返回FALSE
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
BOOL32 COldBasChn::SetAdaptParam(THDAdaptParam &tAdaptParam)
{
	if ( tAdaptParam.IsNull() )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[COldBasChn::SetBasAdaptParam] tHDParm is null!\n");
		return FALSE;
	}

	if (  tAdaptParam.GetVidType() == MEDIA_TYPE_H264 &&
		(GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) == VIDEO_FORMAT_4CIF ||
		GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) == VIDEO_FORMAT_CIF
		)
		)
	{
		tAdaptParam.SetFrameRate(25);
		LogPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[COldBasChn::SetBasAdaptParam] set frame to 25!\n");
	}

	if (  tAdaptParam.GetVidType() == MEDIA_TYPE_H264 &&
		GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) == VIDEO_FORMAT_XGA &&
		tAdaptParam.GetFrameRate() != 5
		)
	{
		tAdaptParam.SetFrameRate(5);
		LogPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[COldBasChn::SetBasAdaptParam] h264 xga set frame to 5!\n");
	}

	u8 byChnId = GetChnId();
	TEqp tEqp  = GetBas();

	if ( tEqp.IsNull() )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[COldBasChn::SetBasAdaptParam] tEqp is null!\n");
		return FALSE;
	}

	TPeriEqpStatus tStatus;
	if (!g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[COldBasChn::SetBasAdaptParam] GetPeriEqpStatus failed! EqpId:%d !\n", 
				 tEqp.GetEqpId());
		return FALSE;
	}

#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if (g_cMcuAgent.IsEqpBasHD(tEqp.GetEqpId()))
#endif	
	{
		u8 byOutIdx = 0;
		u8 byHDBasType = tStatus.m_tStatus.tHdBas.GetEqpType();
		
		THDBasVidChnStatus tVidChn;
		memset(&tVidChn, 0, sizeof(tVidChn));

		switch (byHDBasType)
		{
		case TYPE_MAU_NORMAL:
		case TYPE_MPU:
			{
				if (TYPE_MAU_NORMAL == byHDBasType)
				{
					if ( NULL == tStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnId) )
					{
						return FALSE;
					}
					tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnId);
				}
				else
				{
					if ( NULL == tStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId) )
					{
						return FALSE;
					}
					tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId);
				}
				
				if (MEDIA_TYPE_H264 != tAdaptParam.GetVidType() ||
					( MEDIA_TYPE_H264 == tAdaptParam.GetVidType() &&
					  VIDEO_FORMAT_CIF == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight())
						)
					)
				{
					 byOutIdx = 1;
				}
				else
				{
					 byOutIdx = 0;
				}

				if ( !tVidChn.GetOutputVidParam(byOutIdx)->IsNull() || 
					 !tVidChn.IsReserved() 
					)
				{
					LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[COldBasChn::SetBasAdaptParam] Mau<ChnId:%d, OutIdx:%d> AdaptParam is not null chn or not reserved!\n", 
													   byChnId, byOutIdx);
					return FALSE;
				}
				
				tVidChn.SetOutputVidParam(tAdaptParam, byOutIdx);
				if (TYPE_MAU_NORMAL == byHDBasType)
				{
					tStatus.m_tStatus.tHdBas.tStatus.tMauBas.SetVidChnStatus(tVidChn, byChnId);
				}
				else
				{
					tStatus.m_tStatus.tHdBas.tStatus.tMpuBas.SetVidChnStatus(tVidChn, byChnId);
				}
				g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
			}
			break;
		case TYPE_MPU_H:
			{
				if ( NULL == tStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId) )
				{
					return FALSE;
				}
				tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId);
				//tos只能编一路1080-60fps, 其余挂空
				THDAdaptParam tHD1080Param = *tVidChn.GetOutputVidParam(0);
				BOOL32 bHD108060FpsExists = FALSE;
				if (VIDEO_FORMAT_HD1080 == GetResByWH(tHD1080Param.GetWidth(), tHD1080Param.GetHeight())
					&& tHD1080Param.GetFrameRate() >= 50)
				{
					bHD108060FpsExists = TRUE;
				}

				//对于1080p-60fps反向判断tos上是否有h264编码(前4路为高清)
				BOOL32 bH264InTos = FALSE;
				for (byOutIdx = 0; byOutIdx < 4; byOutIdx++)
				{
					if (MEDIA_TYPE_H264 == tVidChn.GetOutputVidParam(byOutIdx)->GetVidType())
					{
						bH264InTos = TRUE;
						break;
					}
				}

				u8 byRes = GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight());
				byOutIdx = 0;
				//tos 如果有编码是1080_50/60fps时则只设dsp
				if (!bHD108060FpsExists)
				{			
					//1.1080 30/40fps
					//2.720
					//3.4cif
					//4.cif
					//5.other1
					//6.other2//dsp上优先用other2
					if (MEDIA_TYPE_H264 == tAdaptParam.GetVidType())
					{
						switch (byRes)
						{
						case VIDEO_FORMAT_HD1080:
						case VIDEO_FORMAT_SVGA:
						case VIDEO_FORMAT_VGA:
						case VIDEO_FORMAT_XGA:
						case VIDEO_FORMAT_SXGA:
						case VIDEO_FORMAT_UXGA:
							{
								byOutIdx = 0;
								if (bH264InTos 
									&& VIDEO_FORMAT_HD1080 == byRes 
									&& tAdaptParam.GetFrameRate() >= 50)//tos上已有h264编码，无法设置1080-50/60fps
								{
									return FALSE;
								}
							}				
							break;
						case VIDEO_FORMAT_HD720://zjl[20100610] 底层调整，如果是720p_50/60fps则从索引0编码
							if (tAdaptParam.GetFrameRate() >= 50)
							{
								byOutIdx = 0;
							}
							else
							{
								byOutIdx = 1;
							}						
							break;
						case VIDEO_FORMAT_4CIF:
							byOutIdx = 2;
							break;
						case VIDEO_FORMAT_CIF:
							byOutIdx = 3;										
							break;
						default:
							LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[COldBasChn::SetBasAdaptParam] can not set Param<MediaType:%d, Res:%d> because unexpected res!\n",
													tAdaptParam.GetVidType(), byRes);				
							return FALSE;								
						}	
					}	
					else
					{
						if ( tVidChn.GetOutputVidParam(5)->IsNull() )
						{
							byOutIdx = 5;
						}
						else if ( tVidChn.GetOutputVidParam(4)->IsNull() )
						{
							byOutIdx = 4;
						} 
						else
						{
							LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[COldBasChn::SetBasAdaptParam] can not set Param<MediaType:%d, Res:%d> because out4/out5 has been ocuppied!\n", 
								tAdaptParam.GetVidType(), byRes);
							return FALSE;
						}
					}
				}
				else
				{
					//1.1080 50/60fps
					//2.挂空
					//3.挂空
					//4.挂空
					//5.4cif/cif/other
					//6.4cif/cif/other
					//优先选other2
					if (!IsResG(byRes, VIDEO_FORMAT_4CIF))
					{
						u8 byVidCodeType = tAdaptParam.GetVidType();
						if ( tVidChn.GetOutputVidParam(5)->IsNull() ) 
						{
							byOutIdx = 5;
						}
						else if( tVidChn.GetOutputVidParam(4)->IsNull() )
						{
							byOutIdx = 4;
						}
						else
						{
							LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[COldBasChn::SetBasAdaptParam] can not set Param<MediaType:%d, Res:%d> because out4/out5 has been ocuppied!\n", 
															   tAdaptParam.GetVidType(), byRes);
							return FALSE;
						}
					}
					else if (VIDEO_FORMAT_HD1080 == byRes)
					{
						byOutIdx = 0;
					}
					else
					{
						LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[COldBasChn::SetBasAdaptParam] can not set Param<MediaType:%d, Res:%d> because first out is 1080/50/60fps!\n", 
															tAdaptParam.GetVidType(), byRes);
						return FALSE;
					}				
				}

				if ( !tVidChn.GetOutputVidParam(byOutIdx)->IsNull() || 
					 !tVidChn.IsReserved() 
				   )
				{
					LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[COldBasChn::SetBasAdaptParam] Mpu_H<ChnId:%d, OutIdx:%d> AdaptParam is not null or chn not reserved!\n", 
						byChnId, byOutIdx);
					return FALSE;
				}
				else
				{
					//H264-4Cif/Cif 帧率保护
					//当前如果没有与会终端是4Cif或Cif时，帧率不会往下刷，这里要保护下,否则给mpu会有问题
					if (MEDIA_TYPE_H264 == tAdaptParam.GetVidType() &&
						   (VIDEO_FORMAT_4CIF == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) ||
						     VIDEO_FORMAT_CIF == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight())
						      ) &&
						 tAdaptParam.GetFrameRate() >= 50)
					{
						 tAdaptParam.SetFrameRate(tAdaptParam.GetFrameRate()/2);
					}

					//[2011/09/20/zhangli]第4、5两路other输出如果一样就不再下参
					if (byOutIdx == 4 && !tVidChn.GetOutputVidParam(5)->IsNull())
					{
						if (tAdaptParam.GetVidType() == tVidChn.GetOutputVidParam(5)->GetVidType()
							&& (tAdaptParam.GetVidActiveType() == MEDIA_TYPE_NULL
								|| tVidChn.GetOutputVidParam(5)->GetVidActiveType() == MEDIA_TYPE_NULL
								|| tAdaptParam.GetVidActiveType() == tVidChn.GetOutputVidParam(5)->GetVidActiveType())
							&& (tAdaptParam.GetAudType() == MEDIA_TYPE_NULL 
								|| tVidChn.GetOutputVidParam(5)->GetAudType() == MEDIA_TYPE_NULL 
								|| tAdaptParam.GetAudType() == tVidChn.GetOutputVidParam(5)->GetAudType())
							&& tAdaptParam.GetWidth() == tVidChn.GetOutputVidParam(5)->GetWidth()
							&& tAdaptParam.GetHeight() == tVidChn.GetOutputVidParam(5)->GetHeight())
						{
							return TRUE;
						}
					}

					if (byOutIdx == 5 && !tVidChn.GetOutputVidParam(4)->IsNull())
					{
						if (tAdaptParam.GetVidType() == tVidChn.GetOutputVidParam(4)->GetVidType()
							&& (tAdaptParam.GetVidActiveType() == MEDIA_TYPE_NULL
								|| tVidChn.GetOutputVidParam(4)->GetVidActiveType() == MEDIA_TYPE_NULL
								|| tAdaptParam.GetVidActiveType() == tVidChn.GetOutputVidParam(4)->GetVidActiveType())
							&& (tAdaptParam.GetAudType() == MEDIA_TYPE_NULL 
								|| tVidChn.GetOutputVidParam(4)->GetAudType() == MEDIA_TYPE_NULL 
								|| tAdaptParam.GetAudType() == tVidChn.GetOutputVidParam(4)->GetAudType())
							&& tAdaptParam.GetWidth() == tVidChn.GetOutputVidParam(4)->GetWidth()
							&& tAdaptParam.GetHeight() == tVidChn.GetOutputVidParam(4)->GetHeight())
						{
							return TRUE;
						}
					}

					tVidChn.SetOutputVidParam(tAdaptParam, byOutIdx);	
					tStatus.m_tStatus.tHdBas.tStatus.tMpuBas.SetVidChnStatus(tVidChn, byChnId);
					g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
				}		
			}
			break;
		case TYPE_MAU_H263PLUS://只有双流？？？
			{
				if ( NULL == tStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(byChnId) )
				{
					return FALSE;
				}
				tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(byChnId);
				byOutIdx = 0;
				if ( !tVidChn.GetOutputVidParam(byOutIdx)->IsNull() ||
					 !tVidChn.IsReserved()
				   )
				{
					LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[COldBasChn::SetBasAdaptParam] MauH263p<ChnId:%d, OutIdx:%d> AdaptParam is not null or chn not reserved!\n", 
																byChnId, byOutIdx);
					return FALSE;
				}
				else
				{
					tVidChn.SetOutputVidParam(tAdaptParam, byOutIdx);
					tStatus.m_tStatus.tHdBas.tStatus.tMauBas.SetDVidChnStatus(tVidChn, byChnId);
					g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
				}
			}		
			break;
		case TYPE_8KE_BAS:
			{
				if ( NULL == tStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0) )
				{
					return FALSE;
				}
				tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0);
				u8 byOutNum = 0;
				BOOL32 bSetOK = FALSE;
				switch (tVidChn.GetType())
				{
				case BAS_8KECHN_MV:
					byOutNum = 4;
					break;
				case BAS_8KECHN_DS:
					 byOutNum = 3;
					break;
				case BAS_8KECHN_SEL:
					 byOutNum = 1;
					break;
				default:
					return FALSE;
				}
				for ( byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
				{
					if ( !tVidChn.GetOutputVidParam(byOutIdx)->IsNull() || 
						 !tVidChn.IsReserved()
						)
					{
						LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[COldBasChn::SetBasAdaptParam] 8kebas<ChnId:%d, OutIdx:%d> AdaptParam is not null or chn not reserved!\n", 
							byChnId, byOutIdx);
						continue;
					}
					else
					{
						if (GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) > VIDEO_FORMAT_HD720)
						{
							return FALSE;
						}

						//[2011/09/20/zhangli]根据8ke广播bas各通道能力加一些限制
						if (tVidChn.GetType() == BAS_8KECHN_MV && tAdaptParam.GetVidType() == MEDIA_TYPE_H264)
						{
							if (VIDEO_FORMAT_HD720 == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) && byOutIdx > 0)
							{
								return FALSE;
							}
							else if (VIDEO_FORMAT_4CIF == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) && byOutIdx > 1)
							{
								return FALSE;
							}
							else if (VIDEO_FORMAT_CIF == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) && byOutIdx > 2)
							{
								return FALSE;
							}
						}
						else if (tVidChn.GetType() == BAS_8KECHN_SEL)
						{
							if (GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) > VIDEO_FORMAT_4CIF)
							{
								return FALSE;
							}
						}

						if( tVidChn.GetOutputVidParam(byOutIdx)->IsNull() )
						{
							//bSetOK = TRUE;
							tVidChn.SetOutputVidParam(tAdaptParam, byOutIdx);
							tStatus.m_tStatus.tHdBas.tStatus.t8keBas.SetVidChnStatus(tVidChn, 0);
							g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
							return TRUE;
						}
					}
				}	
				if (!bSetOK)
				{
					return FALSE;
				}
			}
			break;
		case TYPE_8KH_BAS:
			{
				if ( NULL == tStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0) )
				{
					return FALSE;
				}
				tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0);
				u8 byOutNum = 0;
				BOOL32 bSetOK = FALSE;
				switch (tVidChn.GetType())
				{
				case BAS_8KHCHN_MV:
					byOutNum = 5;
					break;
				case BAS_8KHCHN_DS:
					byOutNum = 2;
					break;
				case BAS_8KHCHN_SEL:
					byOutNum = 1;
					break;
				default:
					return FALSE;
				}
				for ( byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
				{
					if ( !tVidChn.GetOutputVidParam(byOutIdx)->IsNull() || 
						!tVidChn.IsReserved()
						)
					{
						LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[COldBasChn::SetBasAdaptParam] 8khbas<ChnId:%d, OutIdx:%d> AdaptParam is not null or chn not reserved!\n", 
							byChnId, byOutIdx);
						continue;
					}
					else
					{	
						//[2011/09/20/zhangli]根据8ke广播bas各通道能力加一些限制
						if (tVidChn.GetType() == BAS_8KHCHN_MV && tAdaptParam.GetVidType() == MEDIA_TYPE_H264)
						{
							if (VIDEO_FORMAT_HD1080 == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) && byOutIdx > 0)
							{
								return FALSE;
							}
							if (VIDEO_FORMAT_HD720 == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) && byOutIdx > 1)
							{
								return FALSE;
							}
							else if (VIDEO_FORMAT_4CIF == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) && byOutIdx > 2)
							{
								return FALSE;
							}
							else if (VIDEO_FORMAT_CIF == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) && byOutIdx > 3)
							{
								return FALSE;
							}
						}
						else if ( tVidChn.GetType() == BAS_8KHCHN_SEL)
						{
							if (GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) > VIDEO_FORMAT_4CIF)
							{
								return FALSE;
							}
							tAdaptParam.SetProfileType(emBpAttrb);
						}
						else if ( tVidChn.GetType() == BAS_8KHCHN_DS )
						{
							tAdaptParam.SetProfileType(emBpAttrb);
						}
						
						if( tVidChn.GetOutputVidParam(byOutIdx)->IsNull() )
						{
							//如果是1080P 60编码，帧率需要减半
							if ( byOutIdx == 0 &&
								tAdaptParam.GetVidType() == MEDIA_TYPE_H264 &&
								 VIDEO_FORMAT_HD1080 == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) &&
								 (tAdaptParam.GetFrameRate() == 60 || tAdaptParam.GetFrameRate() == 50)
							   )
							{
								tAdaptParam.SetFrameRate( tAdaptParam.GetFrameRate()/2 );
							}

							//如果720P 60编码，看一下第一路编码中是否存在1080P，存在720则帧率减半
							if ( byOutIdx == 2 &&
								tAdaptParam.GetVidType() == MEDIA_TYPE_H264 &&
								VIDEO_FORMAT_HD720== GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) &&
								(tAdaptParam.GetFrameRate() == 60 || tAdaptParam.GetFrameRate() == 50)
								)
							{
								if (  !tVidChn.GetOutputVidParam(0)->IsNull() )
								{
									THDAdaptParam tTempParam = *tVidChn.GetOutputVidParam(0);
									if ( VIDEO_FORMAT_HD1080 == GetResByWH(tTempParam.GetWidth(), tTempParam.GetHeight())  )
									{
										tAdaptParam.SetFrameRate( tAdaptParam.GetFrameRate()/2 );
									}
								}
							}

							//bSetOK = TRUE;
							tVidChn.SetOutputVidParam(tAdaptParam, byOutIdx);
							tStatus.m_tStatus.tHdBas.tStatus.t8khBas.SetVidChnStatus(tVidChn, 0);
							g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
							return TRUE;
						}
					}
				}	
				if (!bSetOK)
				{
					return FALSE;
				}
			}
			break;
		case TYPE_8KI_VID_BAS:
			{
				if ( NULL == tStatus.m_tStatus.tHdBas.tStatus.t8kiBas.GetVidChnStatus(0) )
				{
					return FALSE;
				}
				tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.t8kiBas.GetVidChnStatus(0);
				u8 byOutNum = 0;
				BOOL32 bSetOK = FALSE;
				switch (tVidChn.GetType())
				{
				case BAS_8KICHN0:
					byOutNum = 5;
					break;
				case BAS_8KICHN1:
					byOutNum = 2;
					break;
				case BAS_8KICHN2:
					byOutNum = 1;
					break;
				default:
					return FALSE;
				}
				for ( byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
				{
					if ( !tVidChn.GetOutputVidParam(byOutIdx)->IsNull() || 
						!tVidChn.IsReserved()
						)
					{
						LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[COldBasChn::SetBasAdaptParam] 8khbas<ChnId:%d, OutIdx:%d> AdaptParam is not null or chn not reserved!\n", 
							byChnId, byOutIdx);
						continue;
					}
					else
					{	
						//[2011/09/20/zhangli]根据8ke广播bas各通道能力加一些限制
						if (tVidChn.GetType() == BAS_8KICHN0 && tAdaptParam.GetVidType() == MEDIA_TYPE_H264)
						{
							if (VIDEO_FORMAT_HD1080 == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) && byOutIdx > 0)
							{
								return FALSE;
							}
							if (VIDEO_FORMAT_HD720 == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) && byOutIdx > 1)
							{
								return FALSE;
							}
							else if (VIDEO_FORMAT_4CIF == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) && byOutIdx > 2)
							{
								return FALSE;
							}
							else if (VIDEO_FORMAT_CIF == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) && byOutIdx > 3)
							{
								return FALSE;
							}
						}
						else if ( tVidChn.GetType() == BAS_8KICHN2 )
						{
							if (GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) > VIDEO_FORMAT_4CIF)
							{
								return FALSE;
							}							
						}						
						
						if( tVidChn.GetOutputVidParam(byOutIdx)->IsNull() )
						{
							//如果是1080P 60编码，帧率需要减半
							if ( byOutIdx == 0 &&
								tAdaptParam.GetVidType() == MEDIA_TYPE_H264 &&
								 VIDEO_FORMAT_HD1080 == GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) &&
								 (tAdaptParam.GetFrameRate() == 60 || tAdaptParam.GetFrameRate() == 50)
							   )
							{
								tAdaptParam.SetFrameRate( tAdaptParam.GetFrameRate()/2 );
							}

							//如果720P 60编码，看一下第一路编码中是否存在1080P，存在720则帧率减半
							if ( byOutIdx == 2 &&
								tAdaptParam.GetVidType() == MEDIA_TYPE_H264 &&
								VIDEO_FORMAT_HD720== GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) &&
								(tAdaptParam.GetFrameRate() == 60 || tAdaptParam.GetFrameRate() == 50)
								)
							{
								if (  !tVidChn.GetOutputVidParam(0)->IsNull() )
								{
									THDAdaptParam tTempParam = *tVidChn.GetOutputVidParam(0);
									if ( VIDEO_FORMAT_HD1080 == GetResByWH(tTempParam.GetWidth(), tTempParam.GetHeight())  )
									{
										tAdaptParam.SetFrameRate( tAdaptParam.GetFrameRate()/2 );
									}
								}
							}

							//bSetOK = TRUE;
							tVidChn.SetOutputVidParam(tAdaptParam, byOutIdx);
							tStatus.m_tStatus.tHdBas.tStatus.t8khBas.SetVidChnStatus(tVidChn, 0);
							g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
							return TRUE;
						}
					}
				}	
				if (!bSetOK)
				{
					return FALSE;
				}
			}
			break;
		default:
			LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[SetBasAdaptParam] unexpected basType:%d!\n", byHDBasType);
			return FALSE;
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else//目前只有vpu
	{
		if (ADAPT_TYPE_AUD == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetChannelType())
		{
			if (MEDIA_TYPE_NULL == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetAudType() ||
				0 == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetAudType() 
				)
			{
				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetVidType(MEDIA_TYPE_NULL);
				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudType(tAdaptParam.GetAudType());
				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudActiveType(tAdaptParam.GetAudActiveType());
				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetBitRate(tAdaptParam.GetBitrate());
				g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
			}	
			else
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[SetBasAdaptParam] Audbas<EqpId:%d, ChnId:%d>'s param is not null!\n", tEqp.GetEqpId(), byChnId);
				return FALSE;
			}
		}
		else if(ADAPT_TYPE_VID == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetChannelType())
		{
			if(MEDIA_TYPE_NULL == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetVidType() ||
				0 == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetVidType()
			  )
			{
				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudType(MEDIA_TYPE_NULL);
				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudActiveType(tAdaptParam.GetAudActiveType());
				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetVidType(tAdaptParam.GetVidType());
				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetVidActiveType(tAdaptParam.GetVidActiveType());
				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetBitRate(tAdaptParam.GetBitrate());
				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetResolution(tAdaptParam.GetWidth(), tAdaptParam.GetHeight());
				g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
			}
			else
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[SetBasAdaptParam] Vidbas<EqpId:%d, ChnId:%d>'s param is not null!\n", tEqp.GetEqpId(), byChnId);
				return FALSE;
			}
		}
	}
#endif
	return TRUE;
}

/*====================================================================
函数名        SetAdaptParamForcely
功能        ：强制下参
算法实现    ：
引用全局变量：
输入参数说明：THDAdaptParam &ptAdaptParam 参数信息
			  u8 byOutIdx				  输出通道号
返回值说明  ：下参成功返回TRUE,失败返回FALSE
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
BOOL32 COldBasChn::SetAdaptParamForcely(THDAdaptParam &tAdaptParam, u8 byOutIdx)
{
	if ( byOutIdx >= GetEncNum() )
	{
		return FALSE;
	}
	
	u8 byChnId = GetChnId();
	TEqp tEqp  = GetBas();
	if ( tAdaptParam.IsNull() )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CMpu2BasChn::SetBasAdaptParam] tHDParm is null, TBas:%d-%d!\n",
			tEqp.GetEqpId(), byChnId
			);
		return FALSE;
	}
	
	if (  tAdaptParam.GetVidType() == MEDIA_TYPE_H264 &&
		(GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) == VIDEO_FORMAT_4CIF ||
		 GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) == VIDEO_FORMAT_CIF
		)
		)
	{
		tAdaptParam.SetFrameRate(25);
		LogPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[CMpu2BasChn::SetBasAdaptParam] set frame to 25!\n");
	}

	TPeriEqpStatus tStatus;
	if (!g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CMpu2BasChn::SetAdaptParamForcely] GetPeriEqpStatus failed! EqpId:%d !\n", 
			tEqp.GetEqpId()
			);
		return FALSE;
	}
	
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if (g_cMcuAgent.IsEqpBasHD(tEqp.GetEqpId()))
#endif	
	{
		u8 byHDBasType = tStatus.m_tStatus.tHdBas.GetEqpType();
		THDBasVidChnStatus tVidChn;
		memset(&tVidChn, 0, sizeof(tVidChn));

		switch (byHDBasType)
		{
		case TYPE_MAU_NORMAL:
		case TYPE_MAU_H263PLUS:
			{
				if ( NULL == tStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnId) )
				{
					return FALSE;
				}
				tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnId);
				tVidChn.SetOutputVidParam(tAdaptParam, byOutIdx);
				tStatus.m_tStatus.tHdBas.tStatus.tMauBas.SetVidChnStatus(tVidChn, byChnId);
			    g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);	
			}
			break;
		case TYPE_MPU_H:
		case TYPE_MPU:
			{			
				if ( NULL == tStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId) )
				{
					return FALSE;
				}
				tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId);
				tVidChn.SetOutputVidParam(tAdaptParam, byOutIdx);
				tStatus.m_tStatus.tHdBas.tStatus.tMpuBas.SetVidChnStatus(tVidChn, byChnId);
			    g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);	
			}
			break;
		case TYPE_8KE_BAS:
			{
				if ( NULL == tStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(byChnId) )
				{
					return FALSE;
				}
				tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(byChnId);
				//8KE强刷的时候加限制,如果选看通道要强刷的参数大于4CIF，则强刷成4CIF下参
				if (tVidChn.GetType() == BAS_8KECHN_SEL && tAdaptParam.GetVidType() == MEDIA_TYPE_H264)
				{
					if (GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) > VIDEO_FORMAT_4CIF)
					{
						u8 byNewRes = VIDEO_FORMAT_4CIF;
						u16 wNewWidth = 0;
						u16 wNewHeight = 0;
						GetWHByRes(byNewRes,wNewWidth,wNewHeight);
						tAdaptParam.SetResolution(wNewWidth,wNewHeight);
					}
				}
				tVidChn.SetOutputVidParam(tAdaptParam, byOutIdx);
				tStatus.m_tStatus.tHdBas.tStatus.t8keBas.SetVidChnStatus(tVidChn, byChnId);
			    g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);	
			}
			break;
		case TYPE_8KH_BAS:
			{
				if ( NULL == tStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(byChnId) )
				{
					return FALSE;
				}
				tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(byChnId);
				//8KH强刷的时候加限制,如果选看通道要强刷的参数大于4CIF，则强刷成4CIF下参
				if (tVidChn.GetType() == BAS_8KHCHN_SEL && tAdaptParam.GetVidType() == MEDIA_TYPE_H264)
				{
					if (GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) > VIDEO_FORMAT_4CIF)
					{
						u8 byNewRes = VIDEO_FORMAT_4CIF;
						u16 wNewWidth = 0;
						u16 wNewHeight = 0;
						GetWHByRes(byNewRes,wNewWidth,wNewHeight);
						tAdaptParam.SetResolution(wNewWidth,wNewHeight);
					}
					tAdaptParam.SetProfileType(emBpAttrb);
				}
				else if ( tVidChn.GetType() == BAS_8KHCHN_DS )
				{
					tAdaptParam.SetProfileType(emBpAttrb);
				}

				tVidChn.SetOutputVidParam(tAdaptParam, byOutIdx);
				tStatus.m_tStatus.tHdBas.tStatus.t8khBas.SetVidChnStatus(tVidChn, byChnId);
				g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);	
			}
			break;
		case TYPE_8KI_VID_BAS:
			{
				if ( NULL == tStatus.m_tStatus.tHdBas.tStatus.t8kiBas.GetVidChnStatus(byChnId) )
				{
					return FALSE;
				}
				tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(byChnId);
				//8KI强刷的时候加限制,如果选看通道要强刷的参数大于4CIF，则强刷成4CIF下参
				if (tVidChn.GetType() == BAS_8KICHN2 && tAdaptParam.GetVidType() == MEDIA_TYPE_H264)
				{
					if (GetResByWH(tAdaptParam.GetWidth(), tAdaptParam.GetHeight()) > VIDEO_FORMAT_4CIF)
					{
						u8 byNewRes = VIDEO_FORMAT_4CIF;
						u16 wNewWidth = 0;
						u16 wNewHeight = 0;
						GetWHByRes(byNewRes,wNewWidth,wNewHeight);
						tAdaptParam.SetResolution(wNewWidth,wNewHeight);
					}					
				}				

				tVidChn.SetOutputVidParam(tAdaptParam, byOutIdx);
				tStatus.m_tStatus.tHdBas.tStatus.t8khBas.SetVidChnStatus(tVidChn, byChnId);
				g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);	
			}
			break;
		default:
			LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[SetBasAdaptParam] unexpected basType:%d!\n", byHDBasType);
			return FALSE;
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else//目前只有vpu
	{
		if (ADAPT_TYPE_AUD == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetChannelType())
		{
			tStatus.m_tStatus.tBas.tChnnl[byChnId].SetVidType(MEDIA_TYPE_NULL);
			tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudType(tAdaptParam.GetAudType());
			tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudActiveType(tAdaptParam.GetAudActiveType());
			tStatus.m_tStatus.tBas.tChnnl[byChnId].SetBitRate(tAdaptParam.GetBitrate());
			g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
		}
		else if(ADAPT_TYPE_VID == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetChannelType())
		{
			tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudType(MEDIA_TYPE_NULL);
			tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudActiveType(tAdaptParam.GetAudActiveType());
			tStatus.m_tStatus.tBas.tChnnl[byChnId].SetVidType(tAdaptParam.GetVidType());
			tStatus.m_tStatus.tBas.tChnnl[byChnId].SetVidActiveType(tAdaptParam.GetVidActiveType());
			tStatus.m_tStatus.tBas.tChnnl[byChnId].SetBitRate(tAdaptParam.GetBitrate());
			tStatus.m_tStatus.tBas.tChnnl[byChnId].SetResolution(tAdaptParam.GetWidth(), tAdaptParam.GetHeight());
			g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
		}
	}
#endif
	return TRUE;
}

/*====================================================================
函数名        StartAdapt
功能        ：强制下参
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：下参成功返回TRUE,失败返回FALSE
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
BOOL32 COldBasChn::StartAdapt(const TBasAdaptParamExt &tBasParamExt,CConfId &cConfId)
{
	if (MEDIA_TYPE_NULL == tBasParamExt.m_byBasVidDectPT && MEDIA_TYPE_NULL == tBasParamExt.m_byBasAudDecPT )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[COldBasChn::StartAdapt]m_byBasVidDectPT and m_byBasAudDecPT are NULL!\n");
		return FALSE;
	}
	
	TEqp  tEqp = GetBas();
	u8	  byChnId = GetChnId();
	
	//1.获取适配参数
	u8 byOutNum = 0;
	THDAdaptParam atParam[MAXNUM_BASOUTCHN];
	if(!g_cMcuVcApp.GetBasOutPutParam(tEqp, byChnId, byOutNum, atParam))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[COldBasChn::StartAdapt] GetBasOutPutParam--><EqpId:%d, ChnId> failed!\n", tEqp.GetEqpId(), byChnId);
		return FALSE;
	}
	
	//2.获取通道媒体模式
	u8 byMode = GetMediaMode();
	if (MODE_NONE == byMode || MODE_BOTH == byMode)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[COldBasChn::StartAdapt] GetChnMode failed!\n");
		return FALSE;
	}
	
	BOOL32 bStateReady = g_cMcuVcApp.GetBasChnStatus(tEqp, byChnId) == BASCHN_STATE_READY? TRUE:FALSE;
		
	//发消息区分高标清适配器
	TLogicalChannel tSrcLgcChn = tBasParamExt.m_tSrcLgcChn;
	CServMsg cServMsg;
	TVideoStreamCap tSrcCap;
	TVideoStreamCap tDstCap;
	if ( FALSE == tBasParamExt.m_bIsSpecialChn )
	{
		//源能力组织
		tSrcCap.SetMediaType( tSrcLgcChn.GetChannelType() );
		tSrcCap.SetResolution( tSrcLgcChn.GetVideoFormat() );
		if ( tSrcLgcChn.GetChannelType() != MEDIA_TYPE_H264 )
		{
			tSrcCap.SetFrameRate(tSrcLgcChn.GetChanVidFPS());
		}
		else
		{
			tSrcCap.SetUserDefFrameRate( tSrcLgcChn.GetChanVidFPS() );
		}
		tSrcCap.SetMaxBitRate( tSrcLgcChn.GetFlowControl() );
		tSrcCap.SetH264ProfileAttrb( tSrcLgcChn.GetProfileAttrb() );
	}
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
	cServMsg.SetMsgBody();
	for (u8 byIdx = 0; byIdx < byOutNum; byIdx++)
	{			
		//对于源能力小于编码能力，按照源能力来下参
		if ( FALSE == tBasParamExt.m_bIsSpecialChn &&
			!atParam[byIdx].IsNull() &&
			GetMediaMode() == MODE_VIDEO
			)
		{
			//目的能力组织
			tDstCap.SetMediaType( atParam[byIdx].GetVidType() );
			tDstCap.SetResolution( GetResByWH( atParam[byIdx].GetWidth(),  atParam[byIdx].GetHeight() ) );
			if ( atParam[byIdx].GetVidType() != MEDIA_TYPE_H264 )
			{
				tDstCap.SetFrameRate(atParam[byIdx].GetFrameRate());
			}
			else
			{
				tDstCap.SetUserDefFrameRate( atParam[byIdx].GetFrameRate() );
			}
			tDstCap.SetMaxBitRate( atParam[byIdx].GetBitrate() );
			if ( atParam[byIdx].GetProfileType() == 1 )
			{
				tDstCap.SetH264ProfileAttrb(emHpAttrb);
			}
			else
			{
				tDstCap.SetH264ProfileAttrb(emBpAttrb);
			}

			if ( IsNeedAdjustCapBySrc(tSrcCap,tDstCap) &&
				 IsSupportEncCap(tDstCap,byIdx)
				)
			{
				u8 byNewFramRat = 0;
				if ( tDstCap.GetMediaType() != MEDIA_TYPE_H264 )
				{
					byNewFramRat = atParam[byIdx].GetFrameRate();
				}
				else
				{
					byNewFramRat = tDstCap.GetUserDefFrameRate();
				}

				u8 byNewRes = tDstCap.GetResolution();

				LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[COldBasChn::StartAdapt] adjust HDbas param as: EqpId:%d, ChnId:%d, OutIdx:%d, from FR:%d to NewFR:%d, res:%d to newres:%d!\n",
						tEqp.GetEqpId(), byChnId, byIdx,
						atParam[byIdx].GetFrameRate(),
						byNewFramRat,
						GetResByWH(atParam[byIdx].GetWidth(), atParam[byIdx].GetHeight()), 
						byNewRes
					);
				atParam[byIdx].SetFrameRate(byNewFramRat);
				u16 wWidth = 0;
				u16 wHeight = 0;
				GetWHByRes(byNewRes,wWidth,wHeight);
				atParam[byIdx].SetResolution(wWidth,wHeight);
			}
		}
		cServMsg.CatMsgBody((u8*)&atParam[byIdx], sizeof(THDAdaptParam));
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[COldBasChn::StartAdapt] Set HDbas param as: EqpId:%d, ChnId:%d, OutIdx:%d, Media:%d, Res:%d, BR:%d, FR:%d, BasDecPT:%d, BasAudDecPT:%d!\n",
			tEqp.GetEqpId(), byChnId, byIdx, atParam[byIdx].GetVidType(), 
			GetResByWH(atParam[byIdx].GetWidth(), atParam[byIdx].GetHeight()), 
			atParam[byIdx].GetBitrate(), atParam[byIdx].GetFrameRate(), 
			tBasParamExt.m_byBasVidDectPT, tBasParamExt.m_byBasAudDecPT);
	}	
	
	cServMsg.CatMsgBody( (u8*)&tBasParamExt.m_tEncrypt, sizeof(TMediaEncrypt));
	
	//TDoublePayload tDVPayload;
	cServMsg.CatMsgBody( (u8*)&tBasParamExt.m_tDVPayload, sizeof(TDoublePayload) );

	cServMsg.CatMsgBody((u8*)&tBasParamExt.m_byIsRcvH264DependInMark, sizeof(u8));
	
	cServMsg.SetChnIndex( byChnId );
	
	//if (MEDIA_TYPE_NULL != tBasParamExt.m_byBasAudDecPT)
	//{
	//	cServMsg.CatMsgBody((u8*)&tBasParamExt.m_byBasAudDecPT, sizeof(u8));
	//}
	
	if (bStateReady)
	{	
		SendMsgToBas( MCU_BAS_STARTADAPT_REQ, cServMsg,cConfId );
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[COldBasChn::StartAdapt] BAS.%d Chn.%d: MCU_HDBAS_STARTADAPT_REQ!\n", 
			tEqp.GetEqpId(), byChnId
			);	
	}
	else
	{
		SendMsgToBas(  MCU_BAS_SETADAPTPARAM_CMD, cServMsg,cConfId );
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[COldBasChn::StartAdapt] BAS.%d Chn.%d: MCU_HDBAS_SETADAPTPARAM_CMD!\n", 
			tEqp.GetEqpId(), byChnId
			);
	}
#else
	//MPU
	if ( g_cMcuAgent.IsEqpBasHD(tEqp.GetEqpId()) )
	{
		cServMsg.SetMsgBody();
		for (u8 byIdx = 0; byIdx < byOutNum; byIdx++)
		{		
			if ( FALSE == tBasParamExt.m_bIsSpecialChn &&
				!atParam[byIdx].IsNull() 
				)
			{
				//目的能力组织
				tDstCap.SetMediaType( atParam[byIdx].GetVidType() );
				tDstCap.SetResolution( GetResByWH( atParam[byIdx].GetWidth(),  atParam[byIdx].GetHeight() ) );
				if ( atParam[byIdx].GetVidType() != MEDIA_TYPE_H264 )
				{
					tDstCap.SetFrameRate(atParam[byIdx].GetFrameRate());
				}
				else
				{
					tDstCap.SetUserDefFrameRate( atParam[byIdx].GetFrameRate() );
				}
				tDstCap.SetMaxBitRate( atParam[byIdx].GetBitrate() );
				if ( atParam[byIdx].GetProfileType() == 1 )
				{
					tDstCap.SetH264ProfileAttrb(emHpAttrb);
				}
				else
				{
					tDstCap.SetH264ProfileAttrb(emBpAttrb);
				}

				//比较源能力和目的能力
				if ( IsNeedAdjustCapBySrc(tSrcCap,tDstCap) )
				{
					//判断是否支持新的能力，如果不支持，则分辨率往上升一级
					while( !IsSupportEncCap(tDstCap,byIdx) )
					{
						u8 bySrcRes = GetUpStandRes(tDstCap.GetResolution());
						if ( bySrcRes == VIDEO_FORMAT_INVALID )
						{
							break;
						}
						tDstCap.SetResolution( bySrcRes );
					}

					u8 byNewFramRat = 0;
					if ( tDstCap.GetMediaType() != MEDIA_TYPE_H264 )
					{
						byNewFramRat = atParam[byIdx].GetFrameRate();
					}
					else
					{
						byNewFramRat = tDstCap.GetUserDefFrameRate();
					}

					//帧率改变修改帧率
					if ( byNewFramRat != atParam[byIdx].GetFrameRate() )
					{
						LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[COldBasChn::StartAdapt] adjust HDbas param as: EqpId:%d, ChnId:%d, OutIdx:%d, from FR:%d to NewFR:%d!\n",
							tEqp.GetEqpId(), byChnId, byIdx,
							atParam[byIdx].GetFrameRate(),
							byNewFramRat
							);
						atParam[byIdx].SetFrameRate(byNewFramRat);
					}
					
					//分辨率变小设置分辨率
					u8 byNewRes = tDstCap.GetResolution();	
					u16 wNewWidth = 0;
					u16 wNewHeight = 0;
					GetWHByRes(byNewRes,wNewWidth,wNewHeight);
					if ( byNewRes!= VIDEO_FORMAT_INVALID &&
						wNewWidth*wNewHeight < atParam[byIdx].GetWidth()*atParam[byIdx].GetHeight()  
						)
					{
						LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[COldBasChn::StartAdapt] adjust HDbas param as: EqpId:%d, ChnId:%d, OutIdx:%d, res:%d to newres:%d!\n",
							tEqp.GetEqpId(), byChnId, byIdx,
							GetResByWH( atParam[byIdx].GetWidth(),atParam[byIdx].GetHeight() ), 
							byNewRes
						);
						atParam[byIdx].SetResolution(wNewWidth,wNewHeight);
					}
				}
			}
		
			cServMsg.CatMsgBody((u8*)&atParam[byIdx], sizeof(THDAdaptParam));
			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[COldBasChn::StartAdapt] Set HDbas param as: EqpId:%d, ChnId:%d, OutIdx:%d, Media:%d, Res:%d, BR:%d, FR:%d, BasDecPT:%d, BasAudDecPT:%d!\n",
				tEqp.GetEqpId(), byChnId, byIdx, atParam[byIdx].GetVidType(), 
				GetResByWH(atParam[byIdx].GetWidth(), atParam[byIdx].GetHeight()), 
				atParam[byIdx].GetBitrate(), atParam[byIdx].GetFrameRate(), 
				tBasParamExt.m_byBasVidDectPT, tBasParamExt.m_byBasAudDecPT);
		}	
		
		cServMsg.CatMsgBody( (u8*)&tBasParamExt.m_tEncrypt, sizeof(TMediaEncrypt));
	
		//TDoublePayload tDVPayload;
		cServMsg.CatMsgBody( (u8*)&tBasParamExt.m_tDVPayload, sizeof(TDoublePayload) );

		cServMsg.SetChnIndex( byChnId );
		
		if (MEDIA_TYPE_NULL != tBasParamExt.m_byBasAudDecPT)
		{
			cServMsg.CatMsgBody((u8*)&tBasParamExt.m_byBasAudDecPT, sizeof(u8));
		}
		
		if (bStateReady)
		{
			SendMsgToBas( MCU_HDBAS_STARTADAPT_REQ, cServMsg,cConfId );
			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[COldBasChn::StartAdapt] BAS.%d Chn.%d: MCU_HDBAS_STARTADAPT_REQ!\n", 
					 tEqp.GetEqpId(), byChnId
					 );	
		}
		else
		{
			SendMsgToBas(  MCU_HDBAS_SETADAPTPARAM_CMD, cServMsg,cConfId );
			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[COldBasChn::StartAdapt] BAS.%d Chn.%d: MCU_HDBAS_SETADAPTPARAM_CMD!\n", 
					 tEqp.GetEqpId(), byChnId
					);
		}
	}
	//vpu
	else
	{	
		TMediaEncrypt tEncrypt = tBasParamExt.m_tEncrypt;
		//vpu 对于加密才需要转成activepl
		if (CONF_ENCRYPTMODE_NONE == tEncrypt.GetEncryptMode())
		{
			atParam[0].SetAudActiveType(atParam[0].GetAudType());
			atParam[0].SetVidActiveType(atParam[0].GetVidType());
		}
	
		//转换成标清参数
		TAdaptParam tSDParam;
		tSDParam.SetAudActiveType(atParam[0].GetAudActiveType());
		tSDParam.SetAudType(atParam[0].GetAudType());
		tSDParam.SetBitRate(atParam[0].GetBitrate());
		tSDParam.SetIsNeedByPrs(atParam[0].IsNeedbyPrs());
		tSDParam.SetResolution(atParam[0].GetWidth(), atParam[0].GetHeight());
		tSDParam.SetVidActiveType(atParam[0].GetVidActiveType());
		tSDParam.SetVidType(atParam[0].GetVidType());			
		
		cServMsg.SetChnIndex(byChnId);
		cServMsg.SetMsgBody((u8 *)&tSDParam, sizeof(TAdaptParam));
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[COldBasChn::StartAdapt] Set bas param as: EqpId:%d, ChnId:%d, OutIdx:%d, Media:%d, Res:%d, BR:%d, BasDecPT:%d, BasAudDecPT:%d!\n",
			tEqp.GetEqpId(), byChnId, 0, tSDParam.GetVidType(), 
			GetResByWH(tSDParam.GetWidth(), tSDParam.GetHeight()), 
			tSDParam.GetBitrate(), tBasParamExt.m_byBasVidDectPT, tBasParamExt.m_byBasAudDecPT);
		
		cServMsg.CatMsgBody((u8 *)&tBasParamExt.m_tEncrypt, sizeof(TMediaEncrypt));		//vedio
		cServMsg.CatMsgBody((u8 *)&tBasParamExt.m_tDVPayload, sizeof(TDoublePayload)); //dvideopaload
		cServMsg.CatMsgBody((u8 *)&tBasParamExt.m_tEncrypt, sizeof(TMediaEncrypt));     //audio
		cServMsg.CatMsgBody((u8 *)&tBasParamExt.m_tDAPayload, sizeof(TDoublePayload)); //dApayload 
		cServMsg.CatMsgBody((u8 *)&tBasParamExt.m_tCapSupportEx, sizeof(TCapSupportEx));	//FECType
		if (bStateReady)
		{
			SendMsgToBas(MCU_BAS_STARTADAPT_REQ, cServMsg,cConfId);
		}
		else
		{
			SendMsgToBas(MCU_BAS_SETADAPTPARAM_CMD, cServMsg,cConfId);
		}
	}

#endif
	//更新通道状态
	if (bStateReady)
	{
		g_cMcuVcApp.UpdateBasChnStatus(tEqp, byChnId, BASCHN_STATE_WAITSTART);
	}
	return TRUE;
}

/*====================================================================
函数名        StopAdapt
功能        ：强制下参
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：下参成功返回TRUE,失败返回FALSE
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
BOOL32 COldBasChn::StopAdapt(CConfId &cConfId)
{
	if (GetBas().IsNull())
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[COldBasChn::StopAdapt] tBas is null!\n");
		return FALSE;
	}
	
	LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[COldBasChn::StopAdapt] conf:%d tEqp:%d!,chnId:%d\n", GetBas().GetConfIdx(), GetBas().GetEqpId(), GetChnId());

	CServMsg cServMsg;
    cServMsg.SetChnIndex(GetChnId());
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
	SendMsgToBas(MCU_BAS_STOPADAPT_REQ, cServMsg,cConfId);
#else	
	if (g_cMcuAgent.IsEqpBasHD(GetBas().GetEqpId()))	
	{
		SendMsgToBas(MCU_HDBAS_STOPADAPT_REQ, cServMsg,cConfId);	
	}
	else
	{
		SendMsgToBas(MCU_BAS_STOPADAPT_REQ, cServMsg,cConfId);
	}
#endif
	g_cMcuVcApp.UpdateBasChnStatus(GetBas(), GetChnId(), BASCHN_STATE_READY);
	return TRUE;
}

/*====================================================================
函数名        IsBasChnSupportAudNeeds
功能        ：判断通道是否支持所需音频能力
算法实现    ：
引用全局变量：
输入参数说明：TNeedAudAdaptData &tNeedAudData 所需能力集
			  TAudioTypeDesc *ptOccpiedResData 返回预占的能力集，如果选看会传NULL
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/12  4.7         倪志俊			创建
====================================================================*/
BOOL32 COldBasChn::IsBasChnSupportAudNeeds(TNeedAudAdaptData &tNeedAudData, TAudioTypeDesc *ptOccpiedResData/*= NULL*/, BOOL32 bIsCheckChn /*= TRUE*/)
{
	//判断是否VPU的音频模式
	if ( m_byEqpType != emVpuAudType )
	{
		return FALSE;
	}
	
	//判断是否参数为空
	TEqp tEqp = GetBas();
	u8 byChnId = GetChnId();

	TPeriEqpStatus tStatus;
	if (!g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[COldBasChn::IsBasChnSupportAudNeeds] GetPeriEqpStatus failed! EqpId:%d !\n", 
			tEqp.GetEqpId());
		return FALSE;
	}
	
	if (ADAPT_TYPE_AUD == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetChannelType())
	{
		if (MEDIA_TYPE_NULL == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetAudType() ||
			0 == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetAudType() 
			)
		{
			//vpu 默认支持一路音频编码
			tNeedAudData.m_byNeedAudEncNum --;
			if ( ptOccpiedResData != NULL )
			{
				ptOccpiedResData[0] = tNeedAudData.m_atAudTypeDesc[0];
			}
			return TRUE;
		}	
	}
	return FALSE;
}

/*====================================================================
函数名        SetAudAdaptParam
功能        ：下参
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/12  4.7         倪志俊			创建
====================================================================*/
BOOL32 COldBasChn::SetAudAdaptParam(TAudAdaptParam &tAudParam)
{
	if ( m_byEqpType != emVpuAudType )
	{
		return FALSE;
	}

	TEqp tEqp = GetBas();
	u8 byChnId = GetChnId();

	TPeriEqpStatus tStatus;
	if (!g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[COldBasChn::SetAudAdaptParam] GetPeriEqpStatus failed! EqpId:%d !\n", 
			tEqp.GetEqpId());
		return FALSE;
	}

	if (ADAPT_TYPE_AUD == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetChannelType())
	{
		if (MEDIA_TYPE_NULL == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetAudType() ||
			0 == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetAudType() 
			)
		{
			tStatus.m_tStatus.tBas.tChnnl[byChnId].SetVidType(MEDIA_TYPE_NULL);
			tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudType(tAudParam.GetAudCodeType());
			tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudActiveType(tAudParam.GetAudActiveType());
			tStatus.m_tStatus.tBas.tChnnl[byChnId].SetBitRate(0);
			g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
		}	
		else
		{
			LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[COldBasChn::SetAudAdaptParam] Audbas<EqpId:%d, ChnId:%d>'s param is not null!\n", tEqp.GetEqpId(), byChnId);
			return FALSE;
		}

		return TRUE;
	}
	return FALSE;
}

/*====================================================================
函数名        SetAudAdaptParamForcely
功能        ：下参
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/12  4.7         倪志俊			创建
====================================================================*/
BOOL32 COldBasChn::SetAudAdaptParamForcely(TAudAdaptParam &tAudParam, u8 byOutIdx)
{
	if ( m_byEqpType != emVpuAudType )
	{
		return FALSE;
	}

	TEqp tEqp = GetBas();
	u8 byChnId = GetChnId();

	TPeriEqpStatus tStatus;
	if (!g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[COldBasChn::SetAudAdaptParamForcely] GetPeriEqpStatus failed! EqpId:%d byOutIdx:%d!\n", 
			tEqp.GetEqpId(),byOutIdx);
		return FALSE;
	}

	if (ADAPT_TYPE_AUD == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetChannelType())
	{
		tStatus.m_tStatus.tBas.tChnnl[byChnId].SetVidType(MEDIA_TYPE_NULL);
		tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudType(tAudParam.GetAudCodeType());
		tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudActiveType(tAudParam.GetAudActiveType());
		tStatus.m_tStatus.tBas.tChnnl[byChnId].SetBitRate(0);
		g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
		return TRUE;
	}
	return FALSE;
}

/*====================================================================
函数名        IsSupportEncCap
功能        ：某一路是否支持编码
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：下参成功返回TRUE,失败返回FALSE
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/09/07  4.7         倪志俊			创建
====================================================================*/
BOOL32 COldBasChn::IsSupportEncCap(const TVideoStreamCap &tSimCap, u8 byEncIdx)
{
	if (byEncIdx >= MAXNUM_BASOUTCHN)
	{
		OspPrintf(TRUE, FALSE, "[COldBasChn::IsSupportEncCap] byEncIdx:%d is unexpected!\n",byEncIdx);
		return FALSE;
	}
	
	u16 wEncAbility = 0;
	if ( tSimCap.GetMediaType() == MEDIA_TYPE_H264 )
	{
		switch ( tSimCap.GetResolution() )
		{
		case VIDEO_FORMAT_HD1080:
			{
				if (  tSimCap.GetH264ProfileAttrb() == emBpAttrb )
				{
					if ( tSimCap.GetUserDefFrameRate() == 60 ||
						tSimCap.GetUserDefFrameRate() == 50
						)
					{
						wEncAbility = (u16)COldBasChn::emHD1080pHighFps;
					}
					else
					{
						wEncAbility = (u16)COldBasChn::emHD1080p;
					}
				}
				else
				{		
					if ( m_byEqpType == em8KIType )
					{
						wEncAbility = (u16)COldBasChn::emHD1080pHighProfile;
					}
				}
			}
			break;
		case VIDEO_FORMAT_HD720:
			{
				if ( m_byEqpType == em8KHType &&
					tSimCap.GetH264ProfileAttrb() == emHpAttrb
					)
				{
					if ( tSimCap.GetUserDefFrameRate() == 30 ||
						tSimCap.GetUserDefFrameRate() == 25
						)
					{
						wEncAbility = (u16)COldBasChn::emHD720pHighProfile;
					}
				}		
				else
				{
					if ( tSimCap.GetUserDefFrameRate() == 60 ||
						tSimCap.GetUserDefFrameRate() == 50
						)
					{
						wEncAbility = (u16)COldBasChn::emHD720pHighFps;
					}
					else
					{
						wEncAbility = (u16)COldBasChn::emHD720p;
					}
				}
			}
			break;
		case VIDEO_FORMAT_4CIF:
			{
				wEncAbility = (u16)COldBasChn::em4Cif;
			}
			break;
		case VIDEO_FORMAT_CIF:
			{
				wEncAbility = (u16)COldBasChn::emCif;
			}
			break;
		case VIDEO_FORMAT_XGA:
			{
				wEncAbility = (u16)COldBasChn::emXGA;
			}
			break;
		case VIDEO_FORMAT_SXGA:
			{
				wEncAbility = (u16)COldBasChn::emSXGA;
			}
			break;
		default:
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS,"[IsSupportEncCap]res:%d is illegal\n",tSimCap.GetResolution());
			}
			break;
		}
	}
	else if ( tSimCap.GetMediaType() != MEDIA_TYPE_NULL &&
			  tSimCap.GetMediaType() != MEDIA_TYPE_H264 	
			)
	{
		wEncAbility = (u16)COldBasChn::emOther;
	}

	if ( wEncAbility == 0 )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[COldBasChn::IsSupportEncCap]wReqEncAbility failed!\n");
		return FALSE;
	}
	
	return IsSupportEncParam(byEncIdx,wEncAbility);
}

/*====================================================================
函数名        SetDecAbility
功能        ：设置解码能力
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/15  4.7         倪志俊			创建
====================================================================*/
void CAudBasChn::SetDecAbility(u8 byDecAbility)
{
	m_dwAudDecAbility |= (u32)1 <<byDecAbility; 
}

/*====================================================================
函数名        SetEncAbility
功能        ：设置编码能力
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/15  4.7         倪志俊			创建
====================================================================*/
void CAudBasChn::SetEncAbility(u8 byEncAbility)
{
	m_dwAudEncAbility |= (u32)1 <<byEncAbility; 
}

/*====================================================================
函数名        IsSupportDecAndEnc
功能        ：判断是否支持参数pabyAbility所携带的能力
算法实现    ：
引用全局变量：
输入参数说明：u8 *pabyAbility 能力数组
			  u8 byNum       数组元素个数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/15  4.7         倪志俊			创建
====================================================================*/
BOOL32 CAudBasChn::IsSupportDecAndEnc(u8 *pabyAbility, u8 byNum)
{
	u32 dwTempAbility =0;
	for ( 	u8 byIdx = 0; byIdx<byNum; byIdx++ )
	{
		dwTempAbility =0;
		dwTempAbility |= (u32)1<<pabyAbility[byIdx];
		if ( ( m_dwAudDecAbility&dwTempAbility ) == 0 ||
			( m_dwAudEncAbility&dwTempAbility ) == 0
			)
		{
			return FALSE;
		}
		
	}
	
	return TRUE;
}

/*====================================================================
函数名        ChangeAudCapToAbility
功能        ：将TAudioTypeDesc能力集改成宏定义描述
算法实现    ：
引用全局变量：
输入参数说明：TAudioTypeDesc *aptAudTypeDesc 能力集数组
			  u8 &byRealNum     数组元素个数，返回真实的编码个数
			  u8 *pabyAbility	新的能力描述数组
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/15  4.7         倪志俊			创建
====================================================================*/
void CAudBasChn::ChangeAudCapToAbility( const TAudioTypeDesc * const aptAudTypeDesc, u8 &byRealNum, u8 *pabyAbility)
{
	u8 byNum = byRealNum;
    byRealNum = 0;
	for ( u8 byIdx = 0; byIdx<byNum; byIdx++ )
	{
		if ( aptAudTypeDesc[byIdx].GetAudioMediaType() != MEDIA_TYPE_NULL )
		{
			switch ( aptAudTypeDesc[byIdx].GetAudioMediaType() )
			{
			case MEDIA_TYPE_PCMU:
				{
					pabyAbility[byIdx] = emG711ULAW;
					byRealNum++;
				}
				break;
			case MEDIA_TYPE_PCMA:
				{
					pabyAbility[byIdx] = emG711ALAW;
					byRealNum++;
				}
				break;
			case MEDIA_TYPE_MP3:
				{
					pabyAbility[byIdx] = emMp3;
					byRealNum++;
				}
				break;
			case MEDIA_TYPE_G719:
				{
					pabyAbility[byIdx] = emG719;
					byRealNum++;
				}
				break;
			case MEDIA_TYPE_G722:
				{
					pabyAbility[byIdx] = emG722;
					byRealNum++;
				}
				break;
			case MEDIA_TYPE_G728:
				{
					pabyAbility[byIdx] = emG728;
					byRealNum++;
				}
				break;
			case MEDIA_TYPE_G729:
				{
					pabyAbility[byIdx] = emG729;
					byRealNum++;
				}
				break;
			case MEDIA_TYPE_G7221C:
				{
					pabyAbility[byIdx] = emG7221POLYCOM;
					byRealNum++;
				}
				break;
			case MEDIA_TYPE_AACLC:
				{
					if ( aptAudTypeDesc[byIdx].GetAudioTrackNum() == 1 )
					{
						pabyAbility[byIdx] = emAACLC;	
						byRealNum++;
					}
					else if ( aptAudTypeDesc[byIdx].GetAudioTrackNum() == 2 )
					{
						pabyAbility[byIdx] = emAACLCDouble;	
						byRealNum++;
					}
					else
					{
						pabyAbility[byIdx] = emHigh;	
					}
					
				}
				break;
			case MEDIA_TYPE_AACLD:
				{
					if ( aptAudTypeDesc[byIdx].GetAudioTrackNum() == 1 )
					{
						pabyAbility[byIdx] = emAACLD;	
						byRealNum++;
					}
					else if ( aptAudTypeDesc[byIdx].GetAudioTrackNum() == 2 )
					{
						pabyAbility[byIdx] = emAACLDDouble;	
						byRealNum++;
					}
					else
					{
						pabyAbility[byIdx] = emHigh;	
					}
				}
				break;
			default:
				{
					pabyAbility[byIdx] = emHigh;
				}
				break;
			}
		}
	}
}

/*====================================================================
函数名        SetChnAbility
功能        ：设置通道能力属性
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/08/05  4.7.2       周晶晶			创建
====================================================================*/
void C8KIAudBasChn::SetChnAbility()
{
	SetEncNum(MAXNUM_8KIAUDBAS_OUTPUT);
	SetDecAbility(emMp3);
	SetDecAbility(emG722);
	SetDecAbility(emG711ULAW);
	SetDecAbility(emG711ALAW);
	SetDecAbility(emG729);
	SetDecAbility(emG728);
	SetDecAbility(emG7221POLYCOM);
	SetDecAbility(emG719);
	SetDecAbility(emAACLC);
	SetDecAbility(emAACLD);
	SetDecAbility(emAACLCDouble);
	SetDecAbility(emAACLDDouble);
	
	SetEncAbility(emMp3);
	SetEncAbility(emG722);
	SetEncAbility(emG711ULAW);
	SetEncAbility(emG711ALAW);
	SetEncAbility(emG729);
	SetEncAbility(emG728);
	SetEncAbility(emG7221POLYCOM);
	SetEncAbility(emG719);
	SetEncAbility(emAACLC);
	SetEncAbility(emAACLD);
	SetEncAbility(emAACLCDouble);
	SetEncAbility(emAACLDDouble);	
}


/*====================================================================
函数名        SetChnAbility
功能        ：设置通道能力属性
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/15  4.7         倪志俊			创建
====================================================================*/
void CApu2BasChn::SetChnAbility()
{
	SetEncNum(MAXNUM_APU2BAS_OUTCHN);
	SetDecAbility(emMp3);
	SetDecAbility(emG722);
	SetDecAbility(emG711ULAW);
	SetDecAbility(emG711ALAW);
	SetDecAbility(emG729);
	SetDecAbility(emG728);
	SetDecAbility(emG7221POLYCOM);
	SetDecAbility(emG719);
	SetDecAbility(emAACLC);
	SetDecAbility(emAACLD);
	SetDecAbility(emAACLCDouble);
	SetDecAbility(emAACLDDouble);
	
	SetEncAbility(emMp3);
	SetEncAbility(emG722);
	SetEncAbility(emG711ULAW);
	SetEncAbility(emG711ALAW);
	SetEncAbility(emG729);
	SetEncAbility(emG728);
	SetEncAbility(emG7221POLYCOM);
	SetEncAbility(emG719);
	SetEncAbility(emAACLC);
	SetEncAbility(emAACLD);
	SetEncAbility(emAACLCDouble);
	SetEncAbility(emAACLDDouble);	
}

/*====================================================================
函数名        GetLeftEncNum
功能        ：获得当前剩余的编码输出路数
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/15  4.7         倪志俊			创建
====================================================================*/
u8 CAudBasChn::GetLeftEncNum()
{
	u8 byOutNum = 0;
	TAudAdaptParam atParam[MAXNUM_BASOUTCHN];
	if(!g_cMcuVcApp.GetAudBasOutPutParam(GetBas(), GetChnId(), byOutNum, atParam))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetLeftEncNum] GetBasOutPutParam--><EqpId:%d, ChnId> failed!\n", 
			GetBas().GetEqpId(), GetChnId()
			);
		return FALSE;
	}
	
	if ( byOutNum == 0 )
	{
		return 0;
	}
	
	u8  wTempEncNum = 0;
	for ( u8 byIdx =0; byIdx < byOutNum; byIdx++  )
	{
		if ( atParam[byIdx].IsNull() )
		{
			continue;
		}
		wTempEncNum++;
	}

	return (byOutNum - wTempEncNum);
}

/*====================================================================
函数名        IsBasChnSupportAudNeeds
功能        ：判断通道是否支持所需能力
算法实现    ：
引用全局变量：
输入参数说明：TNeedAudAdaptData &tNeedBasData 所需能力
			  TAudioTypeDesc *ptOccpiedResData 返回预占的能力，选看为NULL，不需要返回预占的能力
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/15  4.7         倪志俊			创建
====================================================================*/
BOOL32 CAudBasChn::IsBasChnSupportAudNeeds(TNeedAudAdaptData &tNeedBasData, 
										   TAudioTypeDesc *ptOccpiedResData/* = NULL */,
										    BOOL32 bIsCheckChn /*= TRUE*/) 
{
	if ( bIsCheckChn && GetBas().IsNull() )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsBasChnSupportAudNeeds] bas is Null\n");
		return FALSE;
	}
	
	u8 abyEncDesc[MAXNUM_CONF_AUDIOTYPE];
	u8 byRealNum = MAXNUM_CONF_AUDIOTYPE;
	ChangeAudCapToAbility(tNeedBasData.m_atAudTypeDesc,byRealNum,abyEncDesc);
	
	if ( !IsSupportDecAndEnc( abyEncDesc, byRealNum) )
	{
		return FALSE;
	}
	
	u8 byLeftEncNum = 0;
	if( bIsCheckChn )
	{
		byLeftEncNum = GetLeftEncNum();
	}
	else
	{
		byLeftEncNum = GetEncNum();
	}
	
	
	if ( byLeftEncNum >0 && byLeftEncNum <= GetEncNum() )
	{
		//剩下的编码路数大于等于所要求的编码路数，直接砍去
		if ( byLeftEncNum >= tNeedBasData.m_byNeedAudEncNum )
		{
			if ( ptOccpiedResData != NULL )
			{
				memcpy( ptOccpiedResData,tNeedBasData.m_atAudTypeDesc, sizeof(TAudioTypeDesc)*(tNeedBasData.m_byNeedAudEncNum) );
			}
			memset(&tNeedBasData,0,sizeof(TNeedAudAdaptData));
		}
		//剩下的编码路数小于所要求的编码路数，循环计算
		else
		{
			u8 byStartPos = tNeedBasData.m_byNeedAudEncNum -1;
			u8 byLeftNeedEncNum = tNeedBasData.m_byNeedAudEncNum - byLeftEncNum;   //剩余所需编码路数
			for ( u8 byIdx = byStartPos; byIdx >byLeftNeedEncNum-1; byIdx --   )
			{
				if ( ptOccpiedResData != NULL )
				{
					memcpy(ptOccpiedResData,&(tNeedBasData.m_atAudTypeDesc[byIdx]), sizeof(TAudioTypeDesc));
				}
				tNeedBasData.m_atAudTypeDesc[byIdx].Clear();
				tNeedBasData.m_byNeedAudEncNum--;
				if ( ptOccpiedResData != NULL )
				{
					ptOccpiedResData++;
				}
			}       
		}
		return TRUE;
	}
	
	return FALSE;
}

/*====================================================================
函数名        SetAudAdaptParam
功能        ：下参
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/15  4.7         倪志俊			创建
====================================================================*/
BOOL32 CAudBasChn::SetAudAdaptParam(TAudAdaptParam &tAdaptParam)
{
	u8 byChnId = GetChnId();
    TEqp tEqp  = GetBas();
    
    if ( tEqp.IsNull() )
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CAudBasChn::SetAudAdaptParam] tEqp is null!\n");
        return FALSE;
    }
    
    TPeriEqpStatus tStatus;
    if (!g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tStatus))
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CAudBasChn::SetAudAdaptParam] GetPeriEqpStatus failed! EqpId:%d !\n", 
            tEqp.GetEqpId());
        return FALSE;
    }
	
    TAudBasChnStatus *ptAudChnStatus = NULL;
    for ( u8 byOutIdx = 0; byOutIdx < GetEncNum(); byOutIdx++ )
    {
        u8 byAudType = tStatus.m_tStatus.tAudBas.GetEqpType();

		if( TYPE_APU2_BAS == byAudType )
		{
			ptAudChnStatus = tStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.GetAudChnStatus(byChnId);
		}
		else if( TYPE_8KI_AUD_BAS == byAudType )
		{
			ptAudChnStatus = tStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChnId);
		}
		else
		{
			LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[CAudBasChn::SetAudAdaptParam]audbas<ChnId:%d, OutIdx:%d> type.%d err!\n", 
                byChnId, byOutIdx,byAudType);
			continue;
		}
        if ( NULL == ptAudChnStatus )
        {
            continue;
        }
        
        if ( !ptAudChnStatus->GetOutputAudParam(byOutIdx)->IsNull() || 
            !ptAudChnStatus->IsReserved()
            )
        {
            LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[CAudBasChn::SetAudAdaptParam]apu2bas<ChnId:%d, OutIdx:%d> AdaptParam is not null or chn not reserved!\n", 
                byChnId, byOutIdx);
            continue;
        }
        else
        {
            if( ptAudChnStatus->GetOutputAudParam(byOutIdx)->IsNull() )
            {
                ptAudChnStatus->SetOutputAudParam(tAdaptParam, byOutIdx);
				if( TYPE_APU2_BAS == byAudType )
				{
					tStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.SetAudChnStatus(*ptAudChnStatus,byChnId);
				}
				else if( TYPE_8KI_AUD_BAS == byAudType )
				{
					tStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.SetAudChnStatus(*ptAudChnStatus,byChnId);
				}
                g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
                return TRUE;
            }
        }
    }
	
    return FALSE;

}

/*====================================================================
函数名        SetAudAdaptParamForcely
功能        ：强行给某一输出下参
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/15  4.7         倪志俊			创建
====================================================================*/
BOOL32 CAudBasChn::SetAudAdaptParamForcely(TAudAdaptParam &tAudParam, u8 byOutIdx)
{
	u8 byChnId = GetChnId();
    TEqp tEqp  = GetBas();
    
    if ( tEqp.IsNull() )
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CAudBasChn::SetAudAdpatParamForcely] tEqp is null!\n");
        return FALSE;
    }
    
    TPeriEqpStatus tStatus;
    if (!g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tStatus))
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CAudBasChn::SetAudAdpatParamForcely] GetPeriEqpStatus failed! EqpId:%d !\n", 
            tEqp.GetEqpId());
        return FALSE;
    }
    
	TAudBasChnStatus *ptAudChnStatus = NULL;
	u8 byAudType = tStatus.m_tStatus.tAudBas.GetEqpType();
	if( TYPE_APU2_BAS == byAudType )
	{
		ptAudChnStatus = tStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.GetAudChnStatus(byChnId);
	}
	else if( TYPE_8KI_AUD_BAS == byAudType )
	{
		ptAudChnStatus = tStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChnId);
	}
	else
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CAudBasChn::SetAudAdpatParamForcely] EqpId:%d byChnId.%d type.%s err !\n", 
            tEqp.GetEqpId(),byChnId,byAudType );
        return FALSE;
	}
	
    if ( NULL != ptAudChnStatus )
    {
        ptAudChnStatus->SetOutputAudParam(tAudParam, byOutIdx);
        if( TYPE_APU2_BAS == byAudType )
		{
			tStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.SetAudChnStatus(*ptAudChnStatus,byChnId);
		}
		else if( TYPE_8KI_AUD_BAS == byAudType )
		{
			tStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.SetAudChnStatus(*ptAudChnStatus,byChnId);
		}
        g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
        return TRUE;
    }
	
    return FALSE;

}

/*====================================================================
函数名        StartAdapt
功能        ：开启适配
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/15  4.7         倪志俊			创建
====================================================================*/
BOOL32 CAudBasChn::StartAdapt(const TBasAdaptParamExt &tBasParamExt,CConfId &cConfId)
{
	if (MEDIA_TYPE_NULL == tBasParamExt.m_byBasAudDecPT )
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CAudBasChn::StartAdapt]m_byBasAudDecPT are NULL!\n");
        return FALSE;
    }
    
    TEqp  tEqp = GetBas();
    u8    byChnId = GetChnId();
    
    //1.获取适配参数
    u8 byOutNum = 0;
    TAudAdaptParam atParam[MAXNUM_BASOUTCHN];
    if(!g_cMcuVcApp.GetAudBasOutPutParam(tEqp, byChnId, byOutNum, atParam))
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CAudBasChn::StartAdapt] GetAudBasOutPutParam--><EqpId:%d, ChnId> failed!\n", tEqp.GetEqpId(), byChnId);
        return FALSE;
    }
    
    //2.获取通道媒体模式
    u8 byMode = GetMediaMode();
    if (MODE_AUDIO != byMode )
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CAudBasChn::StartAdapt] GetChnMode failed!\n");
        return FALSE;
    }
    
    //3.1  组织参数
    BOOL32 bStateReady = g_cMcuVcApp.GetBasChnStatus(tEqp, byChnId) == BASCHN_STATE_READY? TRUE:FALSE;
    
    CServMsg cServMsg;
    cServMsg.SetMsgBody();
    u8 byIdx =0;
    for (byIdx= 0; byIdx < byOutNum; byIdx++)
    {   
        cServMsg.CatMsgBody((u8*)&atParam[byIdx], sizeof(TAudAdaptParam));
        LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[CAudBasChn::StartAdapt] Set APU2bas param as: EqpId:%d, ChnId:%d, OutIdx:%d, Media:%d,ACTIVE:%d,TrackNum:%d!\n",
            tEqp.GetEqpId(), byChnId, byIdx, 
            atParam[byIdx].GetAudCodeType(), atParam[byIdx].GetAudActiveType(), atParam[byIdx].GetTrackNum()
            );
    }   
	
    //3.2 加密参数
    cServMsg.CatMsgBody( (u8*)&tBasParamExt.m_tEncrypt, sizeof(TMediaEncrypt));
    
	
    //3.3 TAudioCapInfo
	TDoublePayload tTempPayLoad = tBasParamExt.m_tDAPayload;
	TLogicalChannel tSrcLogicChn = tBasParamExt.m_tSrcLgcChn;
	TAudioCapInfo tAudCapInfo;
	tAudCapInfo.SetAudioMediaType( tTempPayLoad.GetRealPayLoad() );
	tAudCapInfo.SetActivePayLoad( tTempPayLoad.GetActivePayload() );
	tAudCapInfo.SetAudioTrackNum( tSrcLogicChn.GetAudioTrackNum() );
    cServMsg.CatMsgBody( (u8*)&tAudCapInfo, sizeof(TAudioCapInfo) );
	
	u8 bySampleRate = AAC_SAMPLE_FRQ_32;
	cServMsg.CatMsgBody((u8*)&bySampleRate, sizeof(u8));

    //3.4 通道号
    cServMsg.SetChnIndex( byChnId );
	
	
    //3.5 发送开启适配消息
    if (bStateReady)
    {
        SendMsgToBas(  MCU_BAS_STARTADAPT_REQ, cServMsg, cConfId );
        LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[CAudBasChn::StartAdapt] BAS.%d Chn.%d: MCU_BAS_STARTADAPT_REQ!\n", 
            tEqp.GetEqpId(), byChnId);
    }
    else
    {
        SendMsgToBas( MCU_BAS_CHANGEAUDPARAM_REQ, cServMsg,cConfId);
        LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[CAudBasChn::StartAdapt] BAS.%d Chn.%d: MCU_BAS_SETADAPTPARAM_CMD!\n", 
			tEqp.GetEqpId(), byChnId
			);
    }
	
    //3.6 更新通道状态
    if (bStateReady)
    {
        g_cMcuVcApp.UpdateBasChnStatus(tEqp, byChnId, BASCHN_STATE_WAITSTART);
    }
	
    return TRUE;

}

/*====================================================================
函数名        StopAdapt
功能        ：停止适配
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/15  4.7         倪志俊			创建
====================================================================*/
BOOL32 CAudBasChn::StopAdapt(CConfId &cConfId)
{
	if (GetBas().IsNull())
    {
        LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CAudBasChn::StopAdapt] tBas is null!\n");
        return FALSE;
    }
    
    LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[CAudBasChn::StopAdapt] conf:%d tEqp:%d!,chnId:%d\n", GetBas().GetConfIdx(), GetBas().GetEqpId(), GetChnId());
    
    CServMsg cServMsg;
    cServMsg.SetChnIndex(GetChnId());
    SendMsgToBas(MCU_BAS_STOPADAPT_REQ, cServMsg,cConfId);
    g_cMcuVcApp.UpdateBasChnStatus(GetBas(), GetChnId(), BASCHN_STATE_READY);   
	
    return TRUE;

}

/*====================================================================
函数名        Print
功能        ：打印
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/15  4.7         倪志俊			创建
====================================================================*/
void CApu2BasChn::Print()
{

	StaticLog("-------------APU2 BAS ChnInfo as follows----------\n");
	StaticLog("EqpId:%d\n", GetBas().GetEqpId());
	StaticLog("ChnId:%d\n",GetChnId());
	StaticLog("MeidaMode:%d\n",GetMediaMode());
	StaticLog("Src<McuId:%d, MtId:%d>\n",GetSrc().GetMcuId(), GetSrc().GetMtId());
	StaticLog("Reserved:%d\n", IsReserved());
	StaticLog("Online:%d\n", IsOnLine());
	StaticLog("EncNum:%d\n", GetEncNum());
}

void C8KIAudBasChn::Print()
{
	StaticLog("-------------8KI Aud BAS ChnInfo as follows----------\n");
	StaticLog("EqpId:%d\n", GetBas().GetEqpId());
	StaticLog("ChnId:%d\n",GetChnId());
	StaticLog("MeidaMode:%d\n",GetMediaMode());
	StaticLog("Src<McuId:%d, MtId:%d>\n",GetSrc().GetMcuId(), GetSrc().GetMtId());
	StaticLog("Reserved:%d\n", IsReserved());
	StaticLog("Online:%d\n", IsOnLine());
	StaticLog("EncNum:%d\n", GetEncNum());
}

/*====================================================================
函数名        GetOneIdleSuitableBasChn
功能        ：获得一个空闲通道
算法实现    ：此算法依赖于前面链表排序必须准确,具体见CBasChnListMgr::AddBasChnBySort
引用全局变量：
输入参数说明：[in][OUT]TNeedBasResData *tLeftReqResData 会议BAS 数据
			  [OUT]TNeedBasResData &tLeftReqResData	占用的数据
返回值说明  ：获得一个空闲的BAS通道,获得成功返回通道，并返回剩余能力
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/19  4.7         倪志俊			创建
====================================================================*/
CBasChn* CBasChnListMgr::GetOneIdleSuitableBasChn(TNeedVidAdaptData &tLeftReqResData, TVideoStreamCap *ptOccpiedResData,u8 byResDataNum)
{
	if (  NULL == m_pHeadNode  )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetOneIdleSuitableBasChn]m_pHeadNode is NULL\n");
		return NULL;
	}
	
	CBasChnNode *ptTmpNode = m_pHeadNode;		
	CBasChnNode *pSubSuitableNode = NULL;		//记录次优的BAS通道
	TNeedVidAdaptData tTempLeftData;				//记录次优通道使用后，剩余能力
	TNeedVidAdaptData tTempNeedData;				//临时保存BAS所需资源数据
	memcpy( &tTempNeedData, &tLeftReqResData, sizeof(TNeedVidAdaptData) );

	u8 byOccupiedNum = 0;
	while( ptTmpNode )
	{
		CBasChn *pTmpBasChn = ptTmpNode->GetBasChnData();
		if ( NULL == pTmpBasChn )
		{
			ptTmpNode = ptTmpNode->GetNext();
			continue;
		}

		
		if ( g_cMcuVcApp.GetBasChnStatus( pTmpBasChn->GetBas(), pTmpBasChn->GetChnId() ) != BASCHN_STATE_READY )
		{
			ptTmpNode = ptTmpNode->GetNext();	
			continue;
		}

		if (!pTmpBasChn->IsOnLine() )
		{
			ptTmpNode = ptTmpNode->GetNext();	
			continue;
		}

		if ( pTmpBasChn->IsReserved() )
		{
			ptTmpNode = ptTmpNode->GetNext();	
			continue;
		}
		
		if ( pTmpBasChn->IsBasChnSupportNeeds(tLeftReqResData,ptOccpiedResData) )
		{	
			//根据已占去的编码路数，对ptOccpiedResData多余的元素进行初始化
			byOccupiedNum = tTempNeedData.m_byRealEncNum - tLeftReqResData.m_byRealEncNum;
			if ( byOccupiedNum>0 && byOccupiedNum<byResDataNum)
			{
				for ( u8 byLoop =byOccupiedNum; byLoop<byResDataNum; byLoop++ )
				{
					ptOccpiedResData[byLoop].Clear();
				}
			}

			if ( pSubSuitableNode != NULL )
			{
				CBasChn *pRestoreChn = pSubSuitableNode->GetBasChnData();
				if ( pRestoreChn != NULL )
				{
					pRestoreChn->RestoreEncArray();
				}
			}
			
			//找能力最优的通道，找不到先记录该通道，以便找不到时可以使用次优通道
			if (tLeftReqResData.m_byRealEncNum ==0 )
			{
				pTmpBasChn->SetIsReserved(TRUE);
				pTmpBasChn->SetMediaMode(tLeftReqResData.m_byMediaMode);
				return pTmpBasChn;		//返回最优通道
			}
			else
			{
				pSubSuitableNode = ptTmpNode;	//记录次优通道
				memcpy( &tTempLeftData,&tLeftReqResData,   sizeof(TNeedVidAdaptData) );	//记录次优剩余数据
				memcpy( &tLeftReqResData, &tTempNeedData, sizeof(TNeedVidAdaptData) );	//恢复数据继续查找
			}

		}
		ptTmpNode = ptTmpNode->GetNext();		 
	}

	//判断是否有次优通道可使用
	if ( pSubSuitableNode != NULL)
	{
		CBasChn *pSubSuitableBasChn = pSubSuitableNode->GetBasChnData();
		if (  pSubSuitableBasChn != NULL)
		{
			pSubSuitableNode->GetBasChnData()->SetIsReserved(TRUE);		   //预占
			pSubSuitableNode->GetBasChnData()->SetMediaMode(tLeftReqResData.m_byMediaMode);
			memcpy( &tLeftReqResData, &tTempLeftData, sizeof(TNeedVidAdaptData) );	//返回剩余数据
			return pSubSuitableBasChn;			//返回通道
		}
	}
	
	memcpy( &tLeftReqResData, &tTempNeedData, sizeof(TNeedVidAdaptData) );	//恢复数据
	return NULL;
}

/*====================================================================
函数名        GetOneIdleSuitableAudBasChn
功能        ：获得一个空闲通道
算法实现    ：此算法依赖于前面链表排序必须准确,具体见CBasChnListMgr::AddBasChnBySort
引用全局变量：
输入参数说明：[in][OUT]TNeedBasResData *tLeftReqResData 会议BAS 数据
			  [OUT]TNeedBasResData &tLeftReqResData	占用的数据
返回值说明  ：获得一个空闲的BAS通道,获得成功返回通道，并返回剩余能力
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/19  4.7         倪志俊			创建
====================================================================*/
CBasChn* CBasChnListMgr::GetOneIdleSuitableAudBasChn(TNeedAudAdaptData &tLeftReqResData, TAudioTypeDesc *ptOccpiedResData)
{
	if (  NULL == m_pHeadNode  )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetOneIdleSuitableAudBasChn]m_pHeadNode is NULL\n");
		return NULL;
	}
	
	CBasChnNode *ptTmpNode = m_pHeadNode;		
	CBasChnNode *pSubSuitableNode = NULL;		//记录次优的BAS通道
	TNeedAudAdaptData tTempLeftData;				//记录次优通道使用后，剩余能力
	TNeedAudAdaptData tTempNeedData;				//临时保存BAS所需资源数据
	memcpy( &tTempNeedData, &tLeftReqResData, sizeof(TNeedAudAdaptData) );

	while( ptTmpNode )
	{
		CBasChn *pTmpBasChn = ptTmpNode->GetBasChnData();
		if ( NULL == pTmpBasChn )
		{
			ptTmpNode = ptTmpNode->GetNext();
			continue;
		}

		if ( g_cMcuVcApp.GetBasChnStatus( pTmpBasChn->GetBas(), pTmpBasChn->GetChnId() ) != BASCHN_STATE_READY )
		{
			ptTmpNode = ptTmpNode->GetNext();	
			continue;
		}

		if (!pTmpBasChn->IsOnLine() )
		{
			ptTmpNode = ptTmpNode->GetNext();	
			continue;
		}

		if ( pTmpBasChn->IsReserved() )
		{
			ptTmpNode = ptTmpNode->GetNext();	
			continue;
		}
		
		if ( pTmpBasChn->IsBasChnSupportAudNeeds(tLeftReqResData,ptOccpiedResData) )
		{
			//找能力最优的通道，找不到先记录该通道，以便找不到时可以使用次优通道
			if (tLeftReqResData.m_byNeedAudEncNum ==0 )
			{
				pTmpBasChn->SetIsReserved(TRUE);
				pTmpBasChn->SetMediaMode(MODE_AUDIO);
				return pTmpBasChn;		//返回最优通道
			}
			else
			{
				pSubSuitableNode = ptTmpNode;	//记录次优通道
				memcpy( &tTempLeftData,&tLeftReqResData,   sizeof(TNeedAudAdaptData) );	//记录次优剩余数据
				memcpy( &tLeftReqResData, &tTempNeedData, sizeof(TNeedAudAdaptData) );	//恢复数据继续查找
			}

		}
		ptTmpNode = ptTmpNode->GetNext();		 
	}

	//判断是否有次优通道可使用
	if ( pSubSuitableNode != NULL)
	{
		CBasChn *pSubSuitableBasChn = pSubSuitableNode->GetBasChnData();
		if (  pSubSuitableBasChn != NULL)
		{
			pSubSuitableNode->GetBasChnData()->SetIsReserved(TRUE);		   //预占
			pSubSuitableNode->GetBasChnData()->SetMediaMode(MODE_AUDIO);
			memcpy( &tLeftReqResData, &tTempLeftData, sizeof(TNeedAudAdaptData) );	//返回剩余数据
			return pSubSuitableBasChn;			//返回通道
		}
	}
	
	memcpy( &tLeftReqResData, &tTempNeedData, sizeof(TNeedAudAdaptData) );	//恢复数据
	return NULL;
}


/*====================================================================
函数名        GetBasChnsForAudBrd
功能        ：为广播音频获得BAS通道数据
算法实现    ：
引用全局变量：
输入参数说明：TNeedVidAdaptData *ptReqResData 所需编解码能力
			  const CBasChannel *pcBasChn BAS通道结点
			  CBasChn **ptBasConfNeed		返回预占通道指针数组
			  TBasChnCapData *ptBasChnParam 返回预占通道对应的参数数组
			  u8 &byRetNum					 返回预占通道个数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/12  4.7         倪志俊			创建
====================================================================*/
BOOL32 CBasChnListMgr::GetBasChnsForAudBrd(TNeedAudAdaptData *ptReqAudData, CBasChn **ptBasConfNeed, TBasChnCapData *ptBasChnCapData, u8 &byRetNum)
{
	//编码路数为0，说明不需要适配
	if ( ptReqAudData->m_byNeedAudEncNum == 0 )
	{
		return TRUE;
	}

	if ( NULL == m_pHeadNode )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[GetBasChnForVidBrd]m_pHeadNode is NULL\n");
		return FALSE;
	}

	if ( NULL == ptReqAudData )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[GetBasChnForVidBrd]ptReqAudData is NULL\n");
		return FALSE;
	}
	
	TNeedAudAdaptData	tTempLeftNeedData;
	memcpy( &tTempLeftNeedData, ptReqAudData, sizeof(TNeedAudAdaptData) );
	u8	byStartPos = 0;				//通道的计算偏移起始
	CBasChn *pCBasChn = NULL;	
	TAudioTypeDesc atOccpiedSimCapSet[MAXNUM_CONF_AUDIOTYPE];
	while(tTempLeftNeedData.m_byNeedAudEncNum)
	{
		pCBasChn = GetOneIdleSuitableAudBasChn(tTempLeftNeedData,atOccpiedSimCapSet);
		if ( pCBasChn != NULL  && ptReqAudData->m_byNeedAudEncNum > tTempLeftNeedData.m_byNeedAudEncNum)
		{
			if ( byStartPos >= MAXNUM_PERIEQP )
			{
				LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[GetBasChnsForAudBrd]byStartPos:%d is illegal\n",
						 byStartPos);
				return FALSE;
			}
			
			ptBasConfNeed[byStartPos] = pCBasChn;
			u8 byOccupyEncNum = ptReqAudData->m_byNeedAudEncNum - tTempLeftNeedData.m_byNeedAudEncNum;
			for ( u8 byLoop = 0; byLoop< MAXNUM_CONF_AUDIOTYPE ; byLoop ++)
			{
				ptBasChnCapData[byStartPos].atBasChnCap[byLoop].SetAudCapSet( atOccpiedSimCapSet[byLoop] );
			}
			byStartPos++;
			LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[GetBasChnsForAudBrd]get chn%d-%d for aud all encNum:%d leftNum:%d\n",
					 pCBasChn->GetBas().GetEqpId(), pCBasChn->GetChnId(), 
					 ptReqAudData->m_byNeedAudEncNum, tTempLeftNeedData.m_byNeedAudEncNum
					 );
		}
		else
		{
			return FALSE;
		}
	}
	byRetNum = byStartPos;
	return TRUE;
}

/*====================================================================
函数名        GetBasChnForVidBrd
功能        ：为广播视频获得BAS通道数据
算法实现    ：
引用全局变量：
输入参数说明：const CBasChannel *pcBasChn BAS通道结点
			  CBasChn **ptBasConfNeed		返回预占通道指针数组
			  TBasChnIdxParam *ptBasChnParam 返回预占通道对应的参数数组
			  u8 &byRetNum					 返回预占通道个数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/19  4.7         倪志俊			创建
====================================================================*/
BOOL32 CBasChnListMgr::GetBasChnsForVidBrd(TNeedVidAdaptData *ptReqResData, CBasChn **ptBasConfNeed, TBasChnCapData *ptBasChnCapData, u8 &byRetNum)
{
	//编码路数为0，说明不需要适配
	if ( ptReqResData->m_byRealEncNum == 0 )
	{
		return TRUE;
	}

	if ( NULL == m_pHeadNode )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[GetBasChnForVidBrd]m_pHeadNode is NULL\n");
		return FALSE;
	}

	if ( NULL == ptReqResData )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[GetBasChnForVidBrd]ptReqResData is NULL\n");
		return FALSE;
	}
	
	TNeedVidAdaptData	tTempLeftNeedData;
	memcpy( &tTempLeftNeedData, ptReqResData, sizeof(TNeedVidAdaptData) );
	u8	byStartPos = 0;				//通道的计算偏移起始
	CBasChn *pCBasChn = NULL;	
	while(tTempLeftNeedData.m_byRealEncNum)
	{
		TVideoStreamCap atOccpiedSimCapSet[MAX_CONF_BAS_ADAPT_NUM];
		pCBasChn = GetOneIdleSuitableBasChn(tTempLeftNeedData,atOccpiedSimCapSet,MAX_CONF_BAS_ADAPT_NUM);
		if ( pCBasChn != NULL  && ptReqResData->m_byRealEncNum > tTempLeftNeedData.m_byRealEncNum)
		{
			if ( byStartPos >= MAXNUM_PERIEQP )
			{
				LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[GetBasChnForVidBrd]byStartPos:%d is illegal\n",
						 byStartPos);
				return FALSE;
			}
			
			ptBasConfNeed[byStartPos] = pCBasChn;
			for ( u8 byLoop = 0; byLoop< MAX_CONF_BAS_ADAPT_NUM ; byLoop ++)
			{
				ptBasChnCapData[byStartPos].atBasChnCap[byLoop].SetVidepCapSet( atOccpiedSimCapSet[byLoop] );
			}
			byStartPos++;
			LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[GetBasChnsForBrd]get chn%d-%d for mode:%d all encNum:%d leftNum:%d\n",
					 pCBasChn->GetBas().GetEqpId(), pCBasChn->GetChnId(), 
					 ptReqResData->m_byMediaMode,ptReqResData->m_byRealEncNum, tTempLeftNeedData.m_byRealEncNum
					 );
		}
		else
		{
			return FALSE;
		}
	}
	byRetNum = byStartPos;
	return TRUE;
}

/*====================================================================
函数名        AddBasChnBySort
功能        ：对BAS通道进行排序后添加
算法实现    ：解码能力小的放链表前面，如果解码能力一样，则比较编码能力，编码能力小的置前
引用全局变量：
输入参数说明：CBasChannel *pcBasChn   BAS通道
返回值说明  ：插入成功返回TRUE
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
BOOL32 CBasChnListMgr::AddBasChnBySort(CBasChn *pcBasChn)
{
	if (NULL == pcBasChn)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[AddBasChnBySort] pcBasChn is null!\n");
		return FALSE;
	}

	if (pcBasChn->GetBas().IsNull())
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[AddBasChnBySort] tBas is null!\n");
		return FALSE;
	}

	// 无视pclint对ptNewNode的内存未释放的检查
	/*lint -save -esym(593,pcNewNode)*/
	CBasChnNode *pcNewNode = new CBasChnNode;
	/*lint -restore*/
	if (NULL ==  pcNewNode)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[AddBasChnBySort] pcNewNode new failed\n");
		return FALSE;
	}

	pcNewNode->SetBasChnData(pcBasChn);
	pcNewNode->SetLast(NULL);
	pcNewNode->SetNext(NULL);
	
	//链表不存在
	if (!m_pHeadNode)
	{
		m_pHeadNode = pcNewNode;
	}
	else
	{
		CBasChnNode *pcTmpNode = m_pHeadNode;
		while (pcTmpNode)
		{
			CBasChn *pTmpBasChn = pcTmpNode->GetBasChnData();
			if ( NULL == pTmpBasChn  )
			{
				pcTmpNode = pcTmpNode->GetNext();	
				continue;
			}

			//a.当前结点解码能力等于新结点，则比较编码能力
			if ( pTmpBasChn->GetMaxDecAbility() == pcBasChn->GetMaxDecAbility() )
			{		
				//新结点编码能力小则插入当前结点之前
				if (pTmpBasChn->GetMaxEncAbility() > pcBasChn->GetMaxEncAbility())
				{
					CBasChnNode *pcTmpLast = pcTmpNode->GetLast();
					//插入当前结点前面
					if (pcTmpLast) 
					{
						pcTmpLast->SetNext(pcNewNode);
						
						pcNewNode->SetLast(pcTmpLast);
						pcNewNode->SetNext(pcTmpNode);

						pcTmpNode->SetLast(pcNewNode);
						break;
					}
					//插入当前结点前面，
					else
					{
						pcNewNode->SetNext(pcTmpNode);
						pcTmpNode->SetLast(pcNewNode);
						m_pHeadNode = pcNewNode;
						break;
					}				
				}
				//新结点编码能力大，则放于当前结点之后
				else
				{
					//当前结点之后没有结点，则插入成尾结点
					if (!pcTmpNode->GetNext())
					{
						pcTmpNode->SetNext(pcNewNode);
						pcNewNode->SetLast(pcTmpNode);
						break;
					}
					//当前结点之后有结点，继续遍历
					else
					{
						pcTmpNode = pcTmpNode->GetNext();
					}
				}
			}
			//b.当前结点解码能力大于插入结点,将新结点添加到当前结点前面
			else if (  pTmpBasChn->GetMaxDecAbility() > pcBasChn->GetMaxDecAbility() )
			{
				CBasChnNode *pcTmpLast = pcTmpNode->GetLast();
				if (pcTmpLast)
				{
					pcTmpLast->SetNext(pcNewNode);

					pcNewNode->SetLast(pcTmpLast);
					pcNewNode->SetNext(pcTmpNode);

					pcTmpNode->SetLast(pcNewNode);
					break;
				}
				else
				{
					pcNewNode->SetNext(pcTmpNode);
					pcTmpNode->SetLast(pcNewNode);
					m_pHeadNode = pcNewNode;
					break;
				}		
			}
			//c.当前结点解码能力小于插入结点,将新结点添加到当前结点之后
			else
			{
				//当前结点之后没有结点，则插入成尾结点
				if (!pcTmpNode->GetNext())
				{
					pcTmpNode->SetNext(pcNewNode);
					pcNewNode->SetLast(pcTmpNode);
					break;
				}
				//当前结点之后有结点，继续遍历
				else
				{
					pcTmpNode = pcTmpNode->GetNext();
				}
			}
		}

		// [7/25/2011 liuxu] 防止插入失败导致内存泄露
		if ( !pcNewNode->GetNext() && !pcNewNode->GetLast())
		{
			delete pcNewNode;
			pcNewNode = NULL;
			return FALSE;
		}
	}
	return TRUE;
}


/*====================================================================
函数名        InsertChn
功能        ：增加适配通道结点
算法实现    ：
引用全局变量：
输入参数说明：[in]const TEqp &tEqp BAS外设
			  [in]u8 byChnId       BAS通道号
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
2011/12/14  4.7         倪志俊			修改
====================================================================*/
BOOL32 CBasChnListMgr::InsertBasChn(const TEqp &tEqp, u8 byChnId)
{
	if ( tEqp.IsNull() )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[InsertBasChn] tEqp is null!\n");
		return FALSE;
	}
	
	TPeriEqpStatus tBasStatus;
	if ( !g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tBasStatus) )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[InsertBasChn] GetPeriEqpStatus failed!\n");
		return FALSE;
	}
	// 无视pclint对ptBasChnData的内存未释放的检查
	/*lint -save -esym(429,pcBasChnData)*/		
	CBasChn *pcBasChnData = NULL;
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if (g_cMcuAgent.IsEqpBasHD(tEqp.GetEqpId()))
#endif
	{
		u8 byHDBasType = tBasStatus.m_tStatus.tHdBas.GetEqpType();
		switch (byHDBasType)
		{
		case TYPE_MPU:
		case TYPE_MPU_H:
		case TYPE_MAU_NORMAL:
		case TYPE_MAU_H263PLUS:
		case TYPE_8KE_BAS:
		case TYPE_8KH_BAS:
		case TYPE_8KI_VID_BAS:
			{
				pcBasChnData = new	COldBasChn(tEqp,byChnId,tBasStatus);
				if ( NULL == pcBasChnData )
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[InsertBasChn] new BasChn failed!\n");
				}
			}
			break;
		case TYPE_MPU2_BASIC:
		case TYPE_MPU2_ENHANCED:
			{
				pcBasChnData = new	CMpu2BasChn(tEqp,byChnId,byHDBasType);
				if ( NULL == pcBasChnData )
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[InsertBasChn] new BasChn failed!\n");
				}
			}
			break;
		default:
			if( tBasStatus.m_tStatus.tAudBas.GetEqpType() == TYPE_8KI_AUD_BAS )
			{
				pcBasChnData = new	C8KIAudBasChn(tEqp,byChnId);
				if ( NULL == pcBasChnData )
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[InsertBasChn] new C8KIAudBasChn failed!\n");
				}
			}
			else
			{
				LogPrint( LOG_LVL_ERROR, MID_MCU_BAS, "[InsertBasChn] unexpected HDBas Type:%d!\n", byHDBasType);
			}
			break;
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else if ( g_cMcuAgent.IsEqpBasAud(tEqp.GetEqpId()) )
	{
		u8 byAudBasType = tBasStatus.m_tStatus.tAudBas.GetEqpType();
		switch (byAudBasType)
		{
		case TYPE_APU2_BAS:
			{
				pcBasChnData = new	CApu2BasChn(tEqp,byChnId);
				if ( NULL == pcBasChnData )
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[InsertBasChn] new CApu2BasChn failed!\n");
				}
			}
			break;
		default:
			{
				LogPrint( LOG_LVL_ERROR, MID_MCU_BAS, "[InsertBasChn] unexpected AudBas Type:%d!\n", byAudBasType);
			}
			break;
		}
	}
	else//标清适配器 
	{
		pcBasChnData = new	COldBasChn(tEqp,byChnId,tBasStatus);
		LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[InsertBasChn]new VPU chn\n");
		if ( NULL == pcBasChnData )
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[InsertBasChn] new BasChn failed!\n");
		}
	}
#endif

	if ( NULL == pcBasChnData )
	{
		return FALSE;
	}

	//在线状态依赖TPeriEqpStatus
	TPeriEqpStatus tStatus;
	if ( g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tStatus) )
	{
		pcBasChnData->SetIsOnLine(tStatus.m_byOnline);
	}
	else
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[InsertBasChn] GetPeriEqpStatus:%d failed!\n",tEqp.GetEqpId());
		return FALSE;
	}


	if ( !AddBasChnBySort(pcBasChnData) )
	{
		delete pcBasChnData;
 		pcBasChnData = NULL;
		return FALSE;
	}

	

	return TRUE;
	// 恢复pclint对pcBasChnData的429错误检查
	/*lint -restore*/
}

/*==============================================================
函数名        IsNodeExist
功能        ：结点是否存在
算法实现    ：
引用全局变量：
输入参数说明：TEqp     tEqp  外设信息
			  u8    byChnId  通道号
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CBasChnListMgr::IsNodeExist(const TEqp &tEqp, u8 byChnId, BOOL32 bIsCanSetOnlineState/* = FALSE*/)								
{
	if (tEqp.IsNull())
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsNodeExist] tEqp  is null!\n");
		return FALSE;
	}
	
	//头结点有效
	if (!m_pHeadNode)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsNodeExist] Can not find headnode!\n");
		return FALSE;
	}
	
	CBasChnNode *ptTmpNode = m_pHeadNode;
	while (ptTmpNode)
	{
		CBasChn *pTmpBasChn = ptTmpNode->GetBasChnData();
		if ( NULL == pTmpBasChn )
		{
			ptTmpNode = ptTmpNode->GetNext();	
			continue;
		}

		if(tEqp  == pTmpBasChn->GetBas() &&
		   byChnId == pTmpBasChn->GetChnId())
		{
			if( bIsCanSetOnlineState )
			{
				pTmpBasChn->SetIsOnLine(TRUE);
			}			
			return TRUE;
		}
		ptTmpNode = ptTmpNode->GetNext();
	}
	return FALSE;
}	

/*==============================================================
函数名        GetBasChnAddr
功能        ：获得结点对应的BAS通道地址
算法实现    ：
引用全局变量：
输入参数说明：TEqp     tEqp  外设信息
			  u8    byChnId  通道号
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/03/29   4.7         倪志俊          创建
====================================================================*/
CBasChn* CBasChnListMgr::GetBasChnAddr(const TEqp &tEqp, u8 byChnId)
{
	if (tEqp.IsNull())
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsNodeExist] tEqp  is null!\n");
		return NULL;
	}
	
	//头结点有效
	if (!m_pHeadNode)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsNodeExist] Can not find headnode!\n");
		return NULL;
	}
	
	CBasChnNode *ptTmpNode = m_pHeadNode;
	while (ptTmpNode)
	{
		CBasChn *pTmpBasChn = ptTmpNode->GetBasChnData();
		if ( NULL == pTmpBasChn )
		{
			ptTmpNode = ptTmpNode->GetNext();	
			continue;
		}
		
		if(tEqp  == pTmpBasChn->GetBas() &&
			byChnId == pTmpBasChn->GetChnId())
		{		
			return pTmpBasChn;
		}
		ptTmpNode = ptTmpNode->GetNext();
	}
	return NULL;
}


/*====================================================================
函数名        SetBasChnOnLine
功能        ：设置bas结点在线
算法实现    ：
引用全局变量：
输入参数说明： u8	  byEqpId  外设ID
			   BOOL32 bOnLine  在线状态
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
void CBasChnListMgr::SetBasOnLine(u8 byEqpId, BOOL32 bOnLine)
{
	if (!m_pHeadNode)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[SetBasChnOnLine] m_pHeadNode is null!\n");
		return;
	}
	CBasChnNode *ptTmpNode = m_pHeadNode;
	while(ptTmpNode)
	{
		CBasChn *pTmpBasChn = ptTmpNode->GetBasChnData();
		if ( NULL == pTmpBasChn )
		{
			ptTmpNode = ptTmpNode->GetNext();	
			continue;
		}

		if (pTmpBasChn->GetBas().GetEqpId() == byEqpId)
		{
			pTmpBasChn->SetIsOnLine(bOnLine);
		}
		ptTmpNode = ptTmpNode->GetNext();
	}
	return;
}

/*====================================================================
函数名        CheckBasEnoughForConfReq
功能        ：校验空闲资源是否满足会议
算法实现    ：
引用全局变量：
输入参数说明：
			  [in]TNeedBasResData *ptReqResData		所需编解码数组指针
			  [in]emBasResDataType emMeidaTypeNum	编解码数组个数，目前一共三个，一次：视频、双流、音频
			  [out]CBasChn **ptBasConfNeed			返回所需编码通道指针数组
			  [out]TBasChnIdxParam *ptBasChnParam	返回所需编码通道对应的参数信息
返回值说明  ：成功获得返回TRUE，失败返回FALSE
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30     4.6        周嘉麟          创建
2011/12/16	 4.7		倪志俊			重写
====================================================================*/
BOOL32 CBasChnListMgr::CheckBasEnoughForReq(TNeedVidAdaptData *ptReqResData,
											TNeedAudAdaptData *pReqAudResource,
											CBasChn **ptConfNeedChns,  TBasChnCapData *ptBasChnCapData,
											u16 &wErrorCode
											)
{
	if ( NULL == ptReqResData )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CheckBasEnoughForReq]ptReqResData is NULL\n");
		return FALSE;
	}
	
	if ( NULL == ptConfNeedChns)
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CheckBasEnoughForReq]ptBasConfNeed is NULL\n");
		return FALSE;
	}

	if ( NULL == ptBasChnCapData )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CheckBasEnoughForReq]ptBasChnParam is NULL\n");
		return FALSE;
	}

	if ( NULL == pReqAudResource )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CheckBasEnoughForReq]pReqAudResource is NULL\n");
		return FALSE;
	}

	BOOL32	bIsOccupyOk = FALSE;

	//获得音频通道预占
	u8		byOccupyAudNum = 0;		//记录已经预占的音频通道个数
	bIsOccupyOk = GetBasChnsForAudBrd(pReqAudResource,&ptConfNeedChns[0],&ptBasChnCapData[0],byOccupyAudNum);
	if ( bIsOccupyOk && byOccupyAudNum >MAXNUM_PERIEQP  )
	{
		bIsOccupyOk = FALSE;
	}

	if ( !bIsOccupyOk  )
	{
		for (u8 byLoop = 0; byLoop < MAXNUM_PERIEQP; byLoop++)
		{
			if ( ptConfNeedChns[byLoop])
			{
				ptConfNeedChns[byLoop]->SetIsReserved(FALSE);
			}
		}
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CheckBasEnoughForReq]GetBasChnsForAudBrd failed!\n");
		wErrorCode = ERR_MCU_NOENOUGH_AUDBAS_CONF;
		return FALSE;
	}
	else
	{
		LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[CheckBasEnoughForReq]GetBasChnsForAudBrd byOccupyAudNum:%d!\n",byOccupyAudNum);
	}

	wErrorCode = ERR_MCU_NOENOUGH_HDBAS_CONF;
	//获得视频BAS通道
	if ( byOccupyAudNum == MAXNUM_PERIEQP )
	{
		if (  ptReqResData[emMODE_VIDEO].m_byRealEncNum >0 || ptReqResData[emMODE_SECVIDEO].m_byRealEncNum> 0)
		{
			LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CheckBasEnoughForReq]limited conf baschn!\n");
			return FALSE;
		}
		else
		{
			return TRUE;
		}
	}

	u8       byOccupyNum = byOccupyAudNum;
	u8		byIdx =0;
	for ( byIdx = 0; byIdx < emMODE_END; byIdx++ )
	{
		u8 byTempNum = 0;
		//目前一个会议视频、音频、双流加起来不会超过MAXNUM_PERIEQP
		//故GetBasChnsForVidBrd暂时没有加越界保护
		if ( GetBasChnsForVidBrd(	&ptReqResData[byIdx],
									&(ptConfNeedChns[byOccupyNum]),
									&(ptBasChnCapData[byOccupyNum]),
									byTempNum
		 						) 
			)
		{ 
			byOccupyNum += byTempNum;
			if (  byOccupyNum >= MAXNUM_PERIEQP )
			{
				LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CheckBasEnoughForReq]byStartPos:%d is illegal\n");
				bIsOccupyOk = FALSE;
				break;
			}
			bIsOccupyOk = TRUE;
		}
		else
		{
			bIsOccupyOk = FALSE;
			break;
		}
	}
	
	//预占不成功，释放可能已经预占的视频通道，bIsResvered = False
	if (!bIsOccupyOk)
	{
		for (u8 byLoop = byOccupyAudNum; byLoop < MAXNUM_PERIEQP; byLoop++)
		{
			if ( ptConfNeedChns[byLoop])
			{
				ptConfNeedChns[byLoop]->SetIsReserved(FALSE);
			}
		}
		//return FALSE;	//这里先不return，下面试一次双流双other预占在前
	}
	else
	{
		return TRUE;
	}

	//新增，判断是否双流存在双other，如果存在按照双流预占来试一次
	//1、先判断主流是否是双other，如果是，则没必要再进行双流预占在前
	bIsOccupyOk = FALSE;
	byOccupyNum = byOccupyAudNum;
	u8 byOtherNum = 0;
	for( byIdx =0 ; byIdx< ptReqResData[emMODE_VIDEO].m_byRealEncNum; byIdx++  )
	{
		if ( ptReqResData[emMODE_VIDEO].m_atSimCapSet[byIdx].GetMediaType() != MEDIA_TYPE_NULL &&
			 ptReqResData[emMODE_VIDEO].m_atSimCapSet[byIdx].GetMediaType() != MEDIA_TYPE_H264 
			)
		{
			byOtherNum++;
		}
	}
	
	if ( byOtherNum >=2 )
	{
		for (u8 byLoop = 0; byLoop < MAXNUM_PERIEQP; byLoop++)
		{
			if ( ptConfNeedChns[byLoop])
			{
				ptConfNeedChns[byLoop]->SetIsReserved(FALSE);
			}
		}
		LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[CheckBasEnoughForReq]main stream other num is:%d, no need to reverse!\n",byOtherNum);
		return FALSE;
	}
	else
	{
		for( byIdx =0 ; byIdx< ptReqResData[emMODE_SECVIDEO].m_byRealEncNum; byIdx++  )
		{
			if ( ptReqResData[emMODE_VIDEO].m_atSimCapSet[byIdx].GetMediaType() != MEDIA_TYPE_NULL &&  
				 ( 	ptReqResData[emMODE_SECVIDEO].m_atSimCapSet[byIdx].GetMediaType() != MEDIA_TYPE_H264 ||
					(ptReqResData[emMODE_SECVIDEO].m_atSimCapSet[byIdx].GetMediaType() == MEDIA_TYPE_H264 &&
					ptReqResData[emMODE_SECVIDEO].m_atSimCapSet[byIdx].GetMediaType() == VIDEO_FORMAT_XGA
					)
				 )
			   )
			{
				byOtherNum++;
			}
		}
		
		//如果双流的other数大于等于2，那么先按双流预占
		if ( byOtherNum>=2)
		{
			LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[CheckBasEnoughForReq]ds stream other num is:%d, need to reverse!\n",byOtherNum);
			for ( u8 chLoop = emMODE_END; chLoop >0; chLoop-- )
			{
				u8 byTempNum = 0;
				if ( GetBasChnsForVidBrd(	&ptReqResData[chLoop-1],
					&(ptConfNeedChns[byOccupyNum]),
					&(ptBasChnCapData[byOccupyNum]),
					byTempNum
					) 
					)
				{ 
					byOccupyNum += byTempNum;
					if (  byOccupyNum >= MAXNUM_PERIEQP )
					{
						LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CheckBasEnoughForReq]byStartPos:%d is illegal\n");
						bIsOccupyOk = FALSE;
						break;
					}
					bIsOccupyOk = TRUE;
				}
				else
				{
					LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CheckBasEnoughForReq]chLoop:%d get chn failed\n",chLoop-1);
					bIsOccupyOk = FALSE;
					break;
				}
			}
			
			//预占不成功，释放可能已经预占的通道，bIsResvered = False
			if (!bIsOccupyOk)
			{
				for (u8 byLoop = 0; byLoop < MAXNUM_PERIEQP; byLoop++)
				{
					if ( ptConfNeedChns[byLoop])
					{
						ptConfNeedChns[byLoop]->SetIsReserved(FALSE);
					}
				}
				LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CheckBasEnoughForReq]bas chn is not enough\n");
				return FALSE;
			}
			else
			{
				return TRUE;
			}
		}
	}

	//预占失败返回FALSE,并释放
	for (u8 byLoop = 0; byLoop < MAXNUM_PERIEQP; byLoop++)
	{
		if ( ptConfNeedChns[byLoop])
		{
			ptConfNeedChns[byLoop]->SetIsReserved(FALSE);
		}
	}
	return FALSE;
}

/*====================================================================
函数名        GetSuitableBasChnForAudSel
功能        ：根据解码和编码的能力要求获取
算法实现    ：
引用全局变量：
输入参数说明：TNeedAudAdaptData &tNeedBasData 所需编码能力
			  CBasChn **ppcBasChnData 返回预占的通道地址
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/14  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CBasChnListMgr::GetSuitableBasChnForAudSel(TNeedAudAdaptData &tNeedBasData, CBasChn **ppcBasChnData)
{
	if (  NULL == ppcBasChnData )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[GetSuitableBasChnForAudSel]ppcBasChnData is NULL!\n");
		return FALSE;
	}
	
	//获取头结点
	if (!m_pHeadNode)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetSuitableBasChnForAudSel]Can find headnode!\n");
		return FALSE;
	}
	
	TNeedAudAdaptData tTempNeedData;
	memcpy(&tTempNeedData, &tNeedBasData, sizeof(TNeedAudAdaptData));
	
	CBasChnNode *ptTmpNode = m_pHeadNode;
	while(ptTmpNode)
	{
		CBasChn *pTmpBasChn = ptTmpNode->GetBasChnData();
		if ( NULL == pTmpBasChn )
		{
			ptTmpNode = ptTmpNode->GetNext();	
			continue;
		}
		
		if ( g_cMcuVcApp.GetBasChnStatus( pTmpBasChn->GetBas(), pTmpBasChn->GetChnId() ) != BASCHN_STATE_READY )
		{
			ptTmpNode = ptTmpNode->GetNext();	
			continue;
		}
		
		//在线未预留
		if (pTmpBasChn->IsOnLine() && 
			!pTmpBasChn->IsReserved())
		{
			//编解码符合
			if(	pTmpBasChn->IsBasChnSupportAudNeeds(tTempNeedData) )
			{
				if ( tTempNeedData.m_byNeedAudEncNum == 0 )
				{
					*ppcBasChnData = ptTmpNode->GetBasChnData();
					return TRUE;
				}
			}
		}
		ptTmpNode = ptTmpNode->GetNext();
	}
	
	return FALSE;
}

/*====================================================================
函数名        GetSuitableBasChnForVidSel
功能        ：根据解码和编码的能力要求获取
算法实现    ：
引用全局变量：
输入参数说明：u8 byReqDecAbility 要求解码能力
			  u8 byReqEncAbility 要求编码能力
			  u8 &byEqpId		 返回外设Id
			  u8 &byChnId		 返回通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/20  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CBasChnListMgr::GetSuitableBasChnForVidSel(TNeedVidAdaptData &tNeedBasData, CBasChn **ppcBasChnData, TBasChnCapData *ptBasChnParam)
{
	if (  NULL == ppcBasChnData ||
		  NULL == ptBasChnParam 
		)
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[GetIdleBasChnForSel]ppcBasChnData or ptBasChnParam is NULL!\n");
		return FALSE;
	}
	
	//获取头结点
	if (!m_pHeadNode)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetIdleBasChnForSel]Can find headnode!\n");
		return FALSE;
	}
	
	TNeedVidAdaptData tTempNeedData;
	memcpy(&tTempNeedData, &tNeedBasData, sizeof(TNeedVidAdaptData));
	
	CBasChnNode *ptTmpNode = m_pHeadNode;
	TVideoStreamCap	atOccpiedSimCapSet[MAX_CONF_BAS_ADAPT_NUM];
	while(ptTmpNode)
	{
		CBasChn *pTmpBasChn = ptTmpNode->GetBasChnData();
		if ( NULL == pTmpBasChn )
		{
			ptTmpNode = ptTmpNode->GetNext();	
			continue;
		}
		
		if ( g_cMcuVcApp.GetBasChnStatus( pTmpBasChn->GetBas(), pTmpBasChn->GetChnId() ) != BASCHN_STATE_READY )
		{
			ptTmpNode = ptTmpNode->GetNext();	
			continue;
		}

		//在线未预留
		if (pTmpBasChn->IsOnLine() && 
			!pTmpBasChn->IsReserved())
		{
			//编解码符合
			if(	pTmpBasChn->IsBasChnSupportNeeds(tTempNeedData,atOccpiedSimCapSet) )
			{
				if ( tTempNeedData.m_byRealEncNum == 0 )
				{
					*ppcBasChnData = ptTmpNode->GetBasChnData();
					for ( u8 byLoop = 0; byLoop< MAX_CONF_BAS_ADAPT_NUM ; byLoop ++)
					{
						ptBasChnParam->atBasChnCap[byLoop].SetVidepCapSet( atOccpiedSimCapSet[byLoop] );
					}
					return TRUE;
				}
				else
				{
					memcpy(&tTempNeedData, &tNeedBasData, sizeof(TNeedVidAdaptData));
				}
			}
		}
		ptTmpNode = ptTmpNode->GetNext();
	}

	return FALSE;
}


/*====================================================================
函数名        OcuppyChnNode
功能			占用结点
算法实现    ：
引用全局变量：
输入参数说明： u8 byEqpId  外设Id
			   u8 byChnId  通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30     4.6        周嘉麟          创建
====================================================================*/
BOOL32 CBasChnListMgr::OcuppyBasChn(u8 byEqpId, u8 byChnId)
{
	if (byEqpId < BASID_MIN || byEqpId > BASID_MAX)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS,"[OcuppyChnNode] BasEqpId<%d> is unexpected!\n", byEqpId);
		return FALSE;
	}
	
	if (!m_pHeadNode)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[OcuppyBasChn] m_pHeadNode is null!\n");
		return FALSE;
	}
	
	CBasChnNode *ptTmpNode = m_pHeadNode;
	while(ptTmpNode)
	{
		CBasChn *pTmpBasChn = ptTmpNode->GetBasChnData();
		if ( NULL == pTmpBasChn )
		{
			ptTmpNode = ptTmpNode->GetNext();
			continue;
		}

		if (!pTmpBasChn->IsOnLine() || pTmpBasChn->IsReserved())
		{
			ptTmpNode = ptTmpNode->GetNext();
			continue;
		}

		if(pTmpBasChn->GetBas().GetEqpId() == byEqpId &&
			pTmpBasChn->GetChnId() == byChnId	)
		{
			pTmpBasChn->SetIsReserved(TRUE);
			return TRUE;
		}
		ptTmpNode = ptTmpNode->GetNext();
	}
	return FALSE;
}

/*====================================================================
函数名         ReleaseBasChn
功能        ：释放链表通道结点
算法实现    ：
引用全局变量：
输入参数说明： u8 byEqpId  外设Id
			   u8 byChnId  通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30     4.6        周嘉麟          创建
====================================================================*/
BOOL32 CBasChnListMgr:: ReleaseBasChn(u8 byEqpId, u8 byChnId)
{	
	if (byEqpId < BASID_MIN || byEqpId > BASID_MAX)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] BasEqpId<%d> is unexpected!\n", byEqpId);
		return FALSE;
	}
	
	if (!m_pHeadNode)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] m_pHeadNode is null!\n");
		return FALSE;
	}
	
	CBasChnNode *ptTmpNode = m_pHeadNode;
	while(ptTmpNode)
	{
		CBasChn *pTmpBasChn = ptTmpNode->GetBasChnData();
		if ( NULL == pTmpBasChn )
		{
			ptTmpNode = ptTmpNode->GetNext();
			continue;
		}

		if( pTmpBasChn->GetBas().GetEqpId() == byEqpId &&
			pTmpBasChn->GetChnId() == byChnId	)
		{
			TEqp tNullEqp;
			tNullEqp.SetNull();
			pTmpBasChn->SetSrc(tNullEqp);
			pTmpBasChn->SetIsReserved(FALSE);
			return TRUE;
		}
		ptTmpNode = ptTmpNode->GetNext();
	}
	return FALSE;
}	


/*====================================================================
函数名        GetBasChnFrontOutPutNum
功能        ：获得某个通道在该通道所在外设上，前面通道的输出总数
算法实现    ：
引用全局变量：
输入参数说明：[in]const TEqp &tEqp BAS外设
			  [in]u8 byChnId       BAS通道号
			  [out]u8 &byOutNum	   该通道的输出数
			  [out]u8 &byFrontOutNum 前面的输出总数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/14  4.7         倪志俊			创建
====================================================================*/
BOOL32 CBasChnListMgr::GetBasChnFrontOutPutNum(const TEqp &tEqp, u8 byChnId,  u8 &byOutNum, u8 &byFrontOutNum)
{
	if ( tEqp.IsNull() )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[GetBasChnFrontOutPutNum] tEqp is null!\n");
		return FALSE;
	}
	
	CBasChnNode *ptTmpNode = m_pHeadNode;
	u8 byTempOutNum = 0;
	while(ptTmpNode)
	{
		CBasChn *pTmpBasChn = ptTmpNode->GetBasChnData();
		if ( NULL == pTmpBasChn )
		{
			ptTmpNode = ptTmpNode->GetNext();
			continue;
		}

		if ( pTmpBasChn->GetBas().GetEqpId() == tEqp.GetEqpId() )
		{
			if ( pTmpBasChn->GetChnId() < byChnId  )
			{
				byTempOutNum += pTmpBasChn->GetEncNum();
			}

			if ( pTmpBasChn->GetChnId() == byChnId )
			{
				byOutNum = pTmpBasChn->GetEncNum();
			}
		}
		ptTmpNode = ptTmpNode->GetNext();
	}

	byFrontOutNum = byTempOutNum;
	return TRUE;
}

/*====================================================================
函数名          Print
功能        ：链表打印
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
void CBasChnListMgr::Print()
{
	if(!m_pHeadNode)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[Print] List is null!\n");
		return;
	}
	
	CBasChnNode *ptTmpNode = m_pHeadNode;
	while(ptTmpNode)
	{
		ptTmpNode->Print();
		ptTmpNode = ptTmpNode->GetNext();
	}
}

/*====================================================================
函数名               IsChnExist
功能        ：判断适配组内是否存在该通道
算法实现    ：
引用全局变量：
输入参数说明：	const TEqp &tEqp      外设信息
				u8		 byChnId	  通道Id
				u8		 &byArrayIdx  通道数组下标
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
2011/12/16  4.7         倪志俊			修改
====================================================================*/
BOOL32 TMcuBasChnGrp::IsChnExist(const TEqp &tEqp, u8 byChnId, u8 &byArrayIdx)
{
	for (u8 byIdx = 0; byIdx < MAXNUM_PERIEQP; byIdx++)
	{
		if ( m_atConfBasChn[byIdx].IsBasChnExist(tEqp, byChnId) )
		{
			byArrayIdx = byIdx;
			return TRUE;
		}
	}
	return FALSE;
}

/*====================================================================
函数名          AddChn
功能        : 添加组通道
算法实现    ：
引用全局变量：
输入参数说明： const TBasChnData &tBasChn  bas通道信息
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/01/04  4.7         倪志俊		  创建
====================================================================*/
BOOL32 TMcuBasChnGrp::AddChn(CBasChn * const pcBasChn, const  TBasChnCapData &tBasChnCapData, const CConfId &cConId)
{
	if ( NULL == pcBasChn )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[TMcuBasChnGrp::AddChn]pcBasChn is NULL!\n");
		return FALSE;
	}

	for ( u8 byIdx = 0; byIdx < MAXNUM_PERIEQP; byIdx++ )
	{
		CBasChn *pBasChn = m_atConfBasChn[byIdx].GetBasChn();
		
		if ( pBasChn != NULL )
		{
			continue;
		}

		if ( !m_atConfBasChn[byIdx].IsBasChnExist(pcBasChn->GetBas(), pcBasChn->GetChnId()) )
		{
			CConfBasChnData cConfBasChn(pcBasChn,tBasChnCapData,cConId);
			m_atConfBasChn[byIdx] = cConfBasChn;
			break;
		}
		else
		{
			LogPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[TMcuBasChnGrp::AddChn] Eqpid:%d -- ChnId:%d has existed!\n", 
				pcBasChn->GetBas().GetEqpId(), pcBasChn->GetChnId());
			break;
		}	
	}
	return TRUE;
}


/*====================================================================
函数名          ReMoveChn
功能        :   移除组通道
算法实现    ：
引用全局变量：
输入参数说明： const TEqp &tEqp
			   u8 byChnId
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 TMcuBasChnGrp::ReMoveChn(const TEqp &tEqp, u8 byChnId)
{
	BOOL32 bReMoveOK = FALSE;
	for (u8 byIdx = 0; byIdx < MAXNUM_PERIEQP; byIdx++)
	{
		if ( m_atConfBasChn[byIdx].IsBasChnExist(tEqp,byChnId) )
		{
			bReMoveOK = TRUE;
			m_atConfBasChn[byIdx].Clear();
			break;
		}
	}
	return bReMoveOK;
}
/*====================================================================
函数名				 GetChn
功能        : 获取匹配模式的适配通道
算法实现    ：
引用全局变量：
输入参数说明：u8		  &byNum  匹配模式的通道数
			  TBasChnData *ptChn  匹配模式的通道
			  u8	 byMediaMode  媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 TMcuBasChnGrp::GetChn(u8 &byNum, CBasChn **pcChn, u8 byMediaMode)
{
	byNum = 0;
	for (u8 byIdx = 0; byIdx < MAXNUM_PERIEQP; byIdx++)
	{
		CBasChn *pcBasChn = m_atConfBasChn[byIdx].GetBasChn();
		if ( NULL == pcBasChn )
		{
			continue;
		}

		if ( pcBasChn->GetMediaMode() == byMediaMode )
		{
			pcChn[byNum] = pcBasChn;
			byNum++;
		}
	}
	return byNum != 0;
}

/*====================================================================
函数名            GetAllChn
功能        ：获取适配组内所有通道
算法实现    ：
引用全局变量：
输入参数说明：u8		  &byNum  适配组内通道数
			  TBasChnData *ptChn  适配组内通道
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 TMcuBasChnGrp::GetAllChn(u8 &byNum, CBasChn **pcBasChn)
{
	byNum = 0;
	for (u8 byIdx = 0; byIdx < MAXNUM_PERIEQP; byIdx++)
	{
		CBasChn *pBasChn = m_atConfBasChn[byIdx].GetBasChn();
		if (NULL == pBasChn)
		{
			continue;
		}
		
		if ( pBasChn->GetBas().IsNull())
		{
			continue;
		}

		pcBasChn[byNum] = m_atConfBasChn[byIdx].GetBasChn();
		byNum ++;
	}
	return TRUE;
}

/*====================================================================
函数名        SetChnMode
功能        : 设置通道媒体模式
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 TMcuBasChnGrp::SetChnMode(const TEqp &tEqp, u8 byChnId, u8 byMediaMode, u8 byIdx)
{
	if ( m_atConfBasChn[byIdx].IsBasChnExist(tEqp,byChnId) )
	{
		CBasChn *pBasChn = m_atConfBasChn[byIdx].GetBasChn();
		if ( NULL != pBasChn )
		{
			pBasChn->SetMediaMode(byMediaMode);
			return FALSE;
		}
	}
	return FALSE;
}
/*====================================================================
函数名          GetChnMode
功能        : 获取通道媒体模式
算法实现    ：	
引用全局变量：
输入参数说明：const TEqp &tEqp 外设信息
			  u8     byChnId   通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
u8 TMcuBasChnGrp::GetChnMode(const TEqp &tEqp, u8 byChnId, u8 byIdx)
{
	if ( m_atConfBasChn[byIdx].IsBasChnExist(tEqp,byChnId) )
	{
		CBasChn *pBasChn = m_atConfBasChn[byIdx].GetBasChn();
		if ( NULL!=pBasChn )
		{
			return pBasChn->GetMediaMode();
		}
	}
	return 0;
}

/*====================================================================
函数名         SetChnSrc
功能        :设置通道源信息
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8    byChnId     通道Id
			  TMt   tSrc        源信息
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 TMcuBasChnGrp::SetChnSrc(const TEqp &tEqp, u8 byChnId, TMt tSrc, u8 byIdx)
{
	if ( m_atConfBasChn[byIdx].IsBasChnExist(tEqp,byChnId) )
	{
		CBasChn *pBasChn = m_atConfBasChn[byIdx].GetBasChn();
		if ( NULL != pBasChn )
		{
			pBasChn->SetSrc(tSrc);
			return TRUE;
		}
	}
	return FALSE;
}

/*====================================================================
函数名          GetChnSrc
功能        : 获取通道源信息
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8    byChnId     通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
TMt TMcuBasChnGrp::GetChnSrc(const TEqp &tEqp, u8 byChnId, u8 byIdx)
{
	TMt tSrc;
	tSrc.SetNull();
	if ( m_atConfBasChn[byIdx].IsBasChnExist(tEqp,byChnId) )
	{
		CBasChn *pBasChn = m_atConfBasChn[byIdx].GetBasChn();
		if ( NULL != pBasChn )
		{
			tSrc = pBasChn->GetSrc();
			return tSrc;
		}
	}
	return tSrc;
}

/*====================================================================
函数名      SetVcuTick
功能        : 设置tick
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8    byChnId     通道Id
			  u32   dwTick      tick数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 TMcuBasChnGrp::SetVcuTick(const TEqp &tEqp, u8 byChnId, u32 dwTick, u8 byIdx)
{
	if ( m_atConfBasChn[byIdx].IsBasChnExist(tEqp,byChnId) )
	{
		CBasChn *pBasChn = m_atConfBasChn[byIdx].GetBasChn();
		if ( NULL != pBasChn )
		{
			pBasChn->SetVcuTick(dwTick);
			return TRUE;
		}
	}
	return FALSE;
}

/*====================================================================
函数名          GetVcuTick
功能        :    获取tick
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8    byChnId     通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
u32 TMcuBasChnGrp::GetVcuTick(const TEqp &tEqp, u8 byChnId, u8 byIdx)
{
	if ( m_atConfBasChn[byIdx].IsBasChnExist(tEqp,byChnId) )
	{
		CBasChn *pBasChn = m_atConfBasChn[byIdx].GetBasChn();
		if ( NULL != pBasChn )
		{
			return	pBasChn->GetVcuTick();
		}
	}
	return 0;
}

/*====================================================================
函数名          GetBasResAudDataByEqp
功能        :    获得tDiscBas对应的参数
算法实现    ：
引用全局变量：
输入参数说明：[in]TEqp tDiscBas		 BAS外设
			  [out]TNeedAudAdaptData &tBasResData
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/13  4.7         倪志俊          创建
====================================================================*/
BOOL32 TMcuBasChnGrp::GetBasResAudDataByEqp(TEqp tDiscBas, TNeedAudAdaptData *patBasResData)
{
	u8 byAudStartPos = 0;
	for ( u8 byIdx =0; byIdx<MAXNUM_PERIEQP; byIdx++ )
	{
		CBasChn *pBasChn = m_atConfBasChn[byIdx].GetBasChn();
		
		if ( NULL == pBasChn )
		{
			continue;
		}
		
		if ( pBasChn->GetBas() == tDiscBas )
		{
			TBasChnCapData tTempChnCapData = m_atConfBasChn[byIdx].GetBasChnCapParam();
			
			if ( pBasChn->GetMediaMode() == MODE_AUDIO )
			{
				TAudioTypeDesc tTempAudCap;
				for ( u8 byLoop = 0; byLoop <MAX_CONF_BAS_ADAPT_NUM; byLoop++ )
				{	
					if ( tTempChnCapData.atBasChnCap[byLoop].GetAudCapSet(tTempAudCap) )
					{
						patBasResData->m_atAudTypeDesc[byAudStartPos] = tTempAudCap;
						patBasResData->m_byNeedAudEncNum++;
						byAudStartPos++;
					}	
				}
			}
		}
	}
	
	return TRUE;
}

/*====================================================================
函数名          GetBasResDataByEqp
功能        :    获取tick
算法实现    ：
引用全局变量：
输入参数说明：[in]TEqp tDiscBas		 BAS外设
			  [out]TNeedBasResData &tBasResData
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/29  4.7         倪志俊          创建
====================================================================*/
BOOL32 TMcuBasChnGrp::GetBasResDataByEqp(TEqp tDiscBas, TNeedVidAdaptData *patBasResData)
{
	u8 byVidStartPos = 0;
	u8 bySecVidStartPos = 0;
	u8 byAudStartPos = 0;
	for ( u8 byIdx =0; byIdx<MAXNUM_PERIEQP; byIdx++ )
	{
		CBasChn *pBasChn = m_atConfBasChn[byIdx].GetBasChn();

		if ( NULL == pBasChn )
		{
			continue;
		}

		if ( pBasChn->GetBas() == tDiscBas )
		{
			TBasChnCapData tTempChnCapData = m_atConfBasChn[byIdx].GetBasChnCapParam();
			if ( pBasChn->GetMediaMode() == MODE_VIDEO  )
			{
			   patBasResData[emMODE_VIDEO].m_byMediaMode = MODE_VIDEO;
			   TVideoStreamCap tTempVidCap;
			   for ( u8 byLoop = 0; byLoop <MAX_CONF_BAS_ADAPT_NUM; byLoop++ )
			   {
					if ( tTempChnCapData.atBasChnCap[byLoop].GetVideoCapSet(tTempVidCap) )
					{
						patBasResData[emMODE_VIDEO].m_atSimCapSet[byVidStartPos] = tTempVidCap;
						patBasResData[emMODE_VIDEO].m_byRealEncNum++;
						byVidStartPos++;
					}
				}
			}
			else if ( pBasChn->GetMediaMode() == MODE_SECVIDEO )
			{
				patBasResData[emMODE_SECVIDEO].m_byMediaMode = MODE_SECVIDEO;
				TVideoStreamCap tTempSecVidCap;
				for ( u8 byLoop = 0; byLoop < MAX_CONF_BAS_ADAPT_NUM; byLoop++ )
				{	
					if ( tTempChnCapData.atBasChnCap[byLoop].GetVideoCapSet(tTempSecVidCap) )
					{
						patBasResData[emMODE_SECVIDEO].m_atSimCapSet[bySecVidStartPos] = tTempSecVidCap;
						patBasResData[emMODE_SECVIDEO].m_byRealEncNum++;
						bySecVidStartPos++;
					}
				}
			}
// 			else if ( pBasChn->GetMediaMode() == MODE_AUDIO )
// 			{
// 				patBasResData[emMODE_AUDIO].m_byMediaMode = MODE_AUDIO;
// 				TAudioTypeDesc tTempAudCap;
// 				for ( u8 byLoop = 0; byLoop <MAX_CONF_BAS_ADAPT_NUM; byLoop++ )
// 				{	
// 					if ( tTempChnCapData.tSimCapSet[byLoop].GetAudCapSet(tTempAudCap) )
// 					{
// 						patBasResData[emMODE_AUDIO].m_atSimCapSet[byAudStartPos] = tTempAudCap;
// 						patBasResData[emMODE_AUDIO].m_byRealEncNum++;
// 						byAudStartPos++;
// 					}	
// 				}
// 			}
			else
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[TMcuBasChnGrp::GetBasResDataByEqp]mediamode:%d is illegal,chn:%d-%d\n",
						pBasChn->GetMediaMode(), pBasChn->GetBas().GetEqpId(), pBasChn->GetChnId()
						);
			}
		}
	}

	return TRUE;
}

/*====================================================================
函数名          Print
功能        ：  打印
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
void TMcuBasChnGrp::Print()
{
	for (u8 byIdx = 0; byIdx < MAXNUM_PERIEQP; byIdx++ )
	{
		CBasChn *pBasChn = m_atConfBasChn[byIdx].GetBasChn();

		if ( NULL == pBasChn )
		{
			continue;
		}

		TPeriEqpStatus tBasStatus;
		if (!g_cMcuVcApp.GetPeriEqpStatus(pBasChn->GetBas().GetEqpId(), &tBasStatus))
		{
			continue;
		}
		StaticLog( "EqpId:%d\n", pBasChn->GetBas().GetEqpId());
		StaticLog( "ChnId:%d\n", pBasChn->GetChnId());
		StaticLog( "MediaMode:%d\n", pBasChn->GetMediaMode());
		StaticLog( "ConfIdx:%d\n", pBasChn->GetBas().GetConfIdx());
		StaticLog( "SrcMt--<McuId:%d, MtId:%d>\n",pBasChn->GetSrc().GetMcuId(), pBasChn->GetSrc().GetMtId());
		THDBasVidChnStatus *ptVidChnStatus = NULL;
		TAudBasChnStatus *pAudChnStatus = NULL;
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
		if (g_cMcuAgent.IsEqpBasHD(pBasChn->GetBas().GetEqpId()))
#endif		
		{
			switch(tBasStatus.m_tStatus.tHdBas.GetEqpType())
			{
			case TYPE_MPU2_BASIC:
			case TYPE_MPU2_ENHANCED:
				{
					ptVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(pBasChn->GetChnId());
					if ( ptVidChnStatus != NULL )
					{
						ptVidChnStatus->PrintInfo();

						//MPU2 BAS实际参数打印
						StaticLog("-----------------------------<Real Bas AapatParam>-----------------------------\n");
						CMcuVcInst* pVcInst = g_cMcuVcApp.GetConfInstHandle(pBasChn->GetBas().GetConfIdx());
						if ( NULL == pVcInst )
						{
							StaticLog( "ConfIdx.%d is an unexist conf, try again ...\n", pBasChn->GetBas().GetConfIdx() );
							continue;
						}
						
						TMt tTempBasSrc = pBasChn->GetSrc();
						TEqp tBas = pBasChn->GetBas();
						u8   byChnId = pBasChn->GetChnId();
						u8 byOutNum = 0;
						THDAdaptParam atParam[MAXNUM_BASOUTCHN];
						if(!g_cMcuVcApp.GetBasOutPutParam(tBas, byChnId, byOutNum, atParam))
						{
							StaticLog("GetBasOutPutParam--><EqpId:%d, ChnId> failed!\n",tBas.GetEqpId(), byChnId);
							continue;
						}

						//新增MPU2，如果某一路编码，没有对应接收终端，那么就把该路编码码率设置成0
						u16 wCount = ((unsigned int)1<<byOutNum) - 1;
						u16 wRealCount = 0;
						//只针对广播BAS通道做循环遍历处理
						if ( CHN_ADPMODE_BRD == pVcInst->GetBasGrpType( tBas, byChnId ) )
						{
							BOOL32		bIsFindBasOutIdx = FALSE;
							TBasOutInfo tOutInfo;
							for (u8 byMtIdx = 1; byMtIdx <= MAXNUM_CONF_MT; byMtIdx++)
							{
								if (!tTempBasSrc.IsNull()&& 
									pVcInst->FindBasChn2BrdForMtExt(tTempBasSrc,byMtIdx,pBasChn->GetMediaMode(),tOutInfo) &&
									tOutInfo.m_tBasEqp == tBas &&
									tOutInfo.m_byChnId == byChnId
									)
								{
									wRealCount|= ((unsigned int)1<<tOutInfo.m_byOutIdx);
									if( wRealCount == wCount )
									{
										break;
									}
								}	
							}
						}
						else
						{
							for (u8 byOutLoop= 0; byOutLoop < byOutNum; byOutLoop++)
							{
								wRealCount = wCount; 
							}
						}
						
						TBasAdaptParamExt tParamExt;
						if ( !pVcInst->GetSrcRealAbility(tTempBasSrc,pBasChn->GetMediaMode(),tParamExt) )
						{
							StaticLog( "GetBasParamExt for src:%d-%d failed\n", tTempBasSrc.GetMcuId(), tTempBasSrc.GetMtId() );
							continue;
						}
						
						//判断是否适配录像的通道
						if ( pVcInst->IsBasChnForRecAdapt(tBas,byChnId) )
						{
							tParamExt.m_bIsSpecialChn = TRUE;
						}

						THDAdaptParam atSpecialtParam[MAXNUM_BASOUTCHN];
						u16 wWidth =0;
						u16 wHeight = 0;
						u8 byRealSpecialFrameRate = 0;
						u8 byRealSrcFrameRate = 0;
						for ( u8 byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
						{			
							if ( !atParam[byOutIdx].IsNull()&&
								tParamExt.m_tSrcLgcChn.GetChannelType() != MEDIA_TYPE_NULL&&
								tParamExt.m_tSrcLgcChn.GetChanVidFPS() >0 &&
								tParamExt.m_tSrcLgcChn.GetVideoFormat()>0
								)
							{
								atSpecialtParam[byOutIdx] = atParam[byOutIdx];
								if ( (wRealCount & ((unsigned int)1<<byOutIdx)) == 0 )
								{
									atSpecialtParam[byOutIdx].SetBitRate(0);
								}
								if ( FALSE == tParamExt.m_bIsSpecialChn )
								{
									if ( atParam[byOutIdx].GetVidType()!= MEDIA_TYPE_H264 )
									{
										byRealSpecialFrameRate = FrameRateMac2Real(atParam[byOutIdx].GetFrameRate());
									}
									else
									{
										byRealSpecialFrameRate = atParam[byOutIdx].GetFrameRate();
									}
									
									if ( tParamExt.m_tSrcLgcChn.GetChannelType()!= MEDIA_TYPE_H264 )
									{
										byRealSrcFrameRate = FrameRateMac2Real(tParamExt.m_tSrcLgcChn.GetChanVidFPS());
									}
									else
									{
										byRealSrcFrameRate = tParamExt.m_tSrcLgcChn.GetChanVidFPS();
									}
									
									if ( byRealSpecialFrameRate > byRealSrcFrameRate )
									{
										if (  atParam[byOutIdx].GetVidType()!= MEDIA_TYPE_H264 )
										{
											atSpecialtParam[byOutIdx].SetFrameRate( tParamExt.m_tSrcLgcChn.GetChanVidFPS() );
										}
										else
										{
											atSpecialtParam[byOutIdx].SetFrameRate( byRealSrcFrameRate );
										}		
									}
									
									if (  tParamExt.m_tSrcLgcChn.GetVideoFormat() == VIDEO_FORMAT_UXGA  && 
										GetResByWH( atParam[byOutIdx].GetWidth(), atParam[byOutIdx].GetHeight() ) == VIDEO_FORMAT_HD1080					
										)
									{
										atSpecialtParam[byOutIdx].SetResolution(atParam[byOutIdx].GetWidth(), atParam[byOutIdx].GetHeight());
									}
									else
									{
										if( tParamExt.m_tSrcLgcChn.GetVideoFormat() == VIDEO_FORMAT_AUTO  && tParamExt.m_tSrcLgcChn.GetChannelType() == MEDIA_TYPE_MP4 )
										{
											GetWHByRes( GetAutoResByBitrate( tParamExt.m_tSrcLgcChn.GetVideoFormat(),tParamExt.m_tSrcLgcChn.GetFlowControl() ),wWidth,wHeight );						
										}
										else
										{
											GetWHByRes( tParamExt.m_tSrcLgcChn.GetVideoFormat(), wWidth,wHeight );
										}
										
										if ( (atParam[byOutIdx].GetWidth())* (atParam[byOutIdx].GetHeight() )> wWidth* wHeight)
										{
											atSpecialtParam[byOutIdx].SetResolution(wWidth,wHeight);
										}
									}
									
									atSpecialtParam[byOutIdx].PrintHd();
								}
							}
						}
					}

				}
				break;
			case TYPE_MPU:
			case TYPE_MPU_H:
				{
					ptVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(pBasChn->GetChnId());
					if ( ptVidChnStatus != NULL )
					{
						ptVidChnStatus->PrintInfo();
					}
					
					//MPU BAS实际参数打印
					StaticLog("-----------------------------<Real Bas AapatParam>-----------------------------\n");
					CMcuVcInst* pVcInst = g_cMcuVcApp.GetConfInstHandle(pBasChn->GetBas().GetConfIdx());
					if ( NULL == pVcInst )
					{
						StaticLog( "ConfIdx.%d is an unexist conf, try again ...\n", pBasChn->GetBas().GetConfIdx() );
						continue;
					}
					
					TMt tTempBasSrc = pBasChn->GetSrc();
					TEqp tBas = pBasChn->GetBas();
					u8   byChnId = pBasChn->GetChnId();
					u8 byOutNum = 0;
					THDAdaptParam atParam[MAXNUM_BASOUTCHN];
					if(!g_cMcuVcApp.GetBasOutPutParam(tBas, byChnId, byOutNum, atParam))
					{
						StaticLog("GetBasOutPutParam--><EqpId:%d, ChnId> failed!\n",tBas.GetEqpId(), byChnId);
						continue;
					}

					TBasAdaptParamExt tParamExt;
					if ( !pVcInst->GetSrcRealAbility(tTempBasSrc,pBasChn->GetMediaMode(),tParamExt) )
					{
						StaticLog( "GetBasParamExt for src:%d-%d failed\n", tTempBasSrc.GetMcuId(), tTempBasSrc.GetMtId() );
						continue;
					}
					
					//判断是否适配录像的通道
					if ( pVcInst->IsBasChnForRecAdapt(tBas,byChnId) )
					{
						tParamExt.m_bIsSpecialChn = TRUE;
					}
					
					TLogicalChannel tSrcLgcChn =tParamExt.m_tSrcLgcChn;
					TVideoStreamCap tSrcCap;
					//源能力组织
					tSrcCap.SetMediaType( tSrcLgcChn.GetChannelType() );
					tSrcCap.SetResolution( tSrcLgcChn.GetVideoFormat() );
					if ( tSrcLgcChn.GetChannelType() != MEDIA_TYPE_H264 )
					{
						tSrcCap.SetFrameRate(tSrcLgcChn.GetChanVidFPS());
					}
					else
					{
						tSrcCap.SetUserDefFrameRate( tSrcLgcChn.GetChanVidFPS() );
					}
					tSrcCap.SetMaxBitRate( tSrcLgcChn.GetFlowControl() );
					tSrcCap.SetH264ProfileAttrb( tSrcLgcChn.GetProfileAttrb() );

					THDAdaptParam atSpecialtParam[MAXNUM_BASOUTCHN];
					u16 wWidth =0;
					u16 wHeight = 0;
					u8 byRealSpecialFrameRate = 0;
					u8 byRealSrcFrameRate = 0;
					TVideoStreamCap tDstCap;
					for ( u8 byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
					{			
						atSpecialtParam[byOutIdx] = atParam[byOutIdx];
						if ( !atSpecialtParam[byOutIdx].IsNull()&&
							tParamExt.m_tSrcLgcChn.GetChannelType() != MEDIA_TYPE_NULL&&
							tParamExt.m_tSrcLgcChn.GetChanVidFPS() >0 &&
							tParamExt.m_tSrcLgcChn.GetVideoFormat()>0
							)
						{
							//目的能力组织
							tDstCap.SetMediaType( atParam[byOutIdx].GetVidType() );
							tDstCap.SetResolution( GetResByWH( atParam[byOutIdx].GetWidth(),  atParam[byOutIdx].GetHeight() ) );
							if ( atParam[byOutIdx].GetVidType() != MEDIA_TYPE_H264 )
							{
								tDstCap.SetFrameRate(atParam[byOutIdx].GetFrameRate());
							}
							else
							{
								tDstCap.SetUserDefFrameRate( atParam[byOutIdx].GetFrameRate() );
							}
							tDstCap.SetMaxBitRate( atParam[byOutIdx].GetBitrate() );
							if ( atParam[byOutIdx].GetProfileType() == 1 )
							{
								tDstCap.SetH264ProfileAttrb(emHpAttrb);
							}
							else
							{
								tDstCap.SetH264ProfileAttrb(emBpAttrb);
							}
						
							if ( FALSE == tParamExt.m_bIsSpecialChn &&
								 IsNeedAdjustCapBySrc(tSrcCap,tDstCap)
								)
							{
								//判断是否支持新的能力，如果不支持，则分辨率往上升一级
								while( !pBasChn->IsSupportEncCap(tDstCap,byOutIdx) )
								{
									u8 bySrcRes = GetUpStandRes(tDstCap.GetResolution());
									if ( bySrcRes == VIDEO_FORMAT_INVALID )
									{
										break;
									}
									tDstCap.SetResolution( bySrcRes );
								}
								
								u8 byNewFramRat = 0;
								if ( tDstCap.GetMediaType() != MEDIA_TYPE_H264 )
								{
									byNewFramRat = atParam[byOutIdx].GetFrameRate();
								}
								else
								{
									byNewFramRat = tDstCap.GetUserDefFrameRate();
								}
								
								//帧率改变修改帧率
								if ( byNewFramRat != atParam[byOutIdx].GetFrameRate() )
								{
									atSpecialtParam[byOutIdx].SetFrameRate(byNewFramRat);
								}
								
								//分辨率变小设置分辨率
								u8 byNewRes = tDstCap.GetResolution();	
								u16 wNewWidth = 0;
								u16 wNewHeight = 0;
								GetWHByRes(byNewRes,wNewWidth,wNewHeight);
								if ( byNewRes!= VIDEO_FORMAT_INVALID &&
									wNewWidth*wNewHeight < atParam[byOutIdx].GetWidth()*atParam[byOutIdx].GetHeight()  
									)
								{
									atSpecialtParam[byOutIdx].SetResolution(wNewWidth,wNewHeight);
								}
							}
						}
						atSpecialtParam[byOutIdx].PrintHd();
					}
				}
				break;
			case TYPE_MAU_NORMAL:
			case TYPE_MAU_H263PLUS:
				{
					ptVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(pBasChn->GetChnId());
					if ( ptVidChnStatus != NULL )
					{
						ptVidChnStatus->PrintInfo();
					}
				}
				break;
			case TYPE_8KE_BAS:
			case TYPE_8KH_BAS:
			case TYPE_8KI_VID_BAS:
				{
					if (  tBasStatus.m_tStatus.tHdBas.GetEqpType() ==TYPE_8KE_BAS )
					{
						ptVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0);
					}
					else if( tBasStatus.m_tStatus.tHdBas.GetEqpType() ==TYPE_8KH_BAS )
					{
						ptVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0);
					}
					else if( tBasStatus.m_tStatus.tHdBas.GetEqpType() ==TYPE_8KI_VID_BAS )
					{
						ptVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.t8kiBas.GetVidChnStatus(0);
					}
			
					if ( ptVidChnStatus != NULL )
					{
						ptVidChnStatus->PrintInfo();
					}

					//实际参数打印
					StaticLog("-----------------------------<Real Bas AapatParam>-----------------------------\n");
					CMcuVcInst* pVcInst = g_cMcuVcApp.GetConfInstHandle(pBasChn->GetBas().GetConfIdx());
					if ( NULL == pVcInst )
					{
						StaticLog( "ConfIdx.%d is an unexist conf, try again ...\n", pBasChn->GetBas().GetConfIdx() );
						continue;
					}
					
					TMt tTempBasSrc = pBasChn->GetSrc();
					TEqp tBas = pBasChn->GetBas();
					u8   byChnId = pBasChn->GetChnId();
					u8 byOutNum = 0;
					THDAdaptParam atParam[MAXNUM_BASOUTCHN];
					if(!g_cMcuVcApp.GetBasOutPutParam(tBas, byChnId, byOutNum, atParam))
					{
						StaticLog("GetBasOutPutParam--><EqpId:%d, ChnId> failed!\n",tBas.GetEqpId(), byChnId);
						continue;
					}

					TBasAdaptParamExt tParamExt;
					if ( !pVcInst->GetSrcRealAbility(tTempBasSrc,pBasChn->GetMediaMode(),tParamExt) )
					{
						StaticLog( "GetBasParamExt for src:%d-%d failed\n", tTempBasSrc.GetMcuId(), tTempBasSrc.GetMtId() );
						continue;
					}
					
					//判断是否适配录像的通道
					if ( pVcInst->IsBasChnForRecAdapt(tBas,byChnId) )
					{
						tParamExt.m_bIsSpecialChn = TRUE;
					}
					
					TLogicalChannel tSrcLgcChn =tParamExt.m_tSrcLgcChn;
					TVideoStreamCap tSrcCap;
					//源能力组织
					tSrcCap.SetMediaType( tSrcLgcChn.GetChannelType() );
					tSrcCap.SetResolution( tSrcLgcChn.GetVideoFormat() );
					if ( tSrcLgcChn.GetChannelType() != MEDIA_TYPE_H264 )
					{
						tSrcCap.SetFrameRate(tSrcLgcChn.GetChanVidFPS());
					}
					else
					{
						tSrcCap.SetUserDefFrameRate( tSrcLgcChn.GetChanVidFPS() );
					}
					tSrcCap.SetMaxBitRate( tSrcLgcChn.GetFlowControl() );
					tSrcCap.SetH264ProfileAttrb( tSrcLgcChn.GetProfileAttrb() );

					THDAdaptParam atSpecialtParam[MAXNUM_BASOUTCHN];
					u16 wWidth =0;
					u16 wHeight = 0;
					u8 byRealSpecialFrameRate = 0;
					u8 byRealSrcFrameRate = 0;
					TVideoStreamCap tDstCap;
					for ( u8 byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
					{			
						atSpecialtParam[byOutIdx] = atParam[byOutIdx];
						if ( !atSpecialtParam[byOutIdx].IsNull()&&
							tParamExt.m_tSrcLgcChn.GetChannelType() != MEDIA_TYPE_NULL&&
							tParamExt.m_tSrcLgcChn.GetChanVidFPS() >0 &&
							tParamExt.m_tSrcLgcChn.GetVideoFormat()>0
							)
						{
							//目的能力组织
							tDstCap.SetMediaType( atParam[byOutIdx].GetVidType() );
							tDstCap.SetResolution( GetResByWH( atParam[byOutIdx].GetWidth(),  atParam[byOutIdx].GetHeight() ) );
							if ( atParam[byOutIdx].GetVidType() != MEDIA_TYPE_H264 )
							{
								tDstCap.SetFrameRate(atParam[byOutIdx].GetFrameRate());
							}
							else
							{
								tDstCap.SetUserDefFrameRate( atParam[byOutIdx].GetFrameRate() );
							}
							tDstCap.SetMaxBitRate( atParam[byOutIdx].GetBitrate() );
							if ( atParam[byOutIdx].GetProfileType() == 1 )
							{
								tDstCap.SetH264ProfileAttrb(emHpAttrb);
							}
							else
							{
								tDstCap.SetH264ProfileAttrb(emBpAttrb);
							}
						
							if ( FALSE == tParamExt.m_bIsSpecialChn &&
								 IsNeedAdjustCapBySrc(tSrcCap,tDstCap) &&
								 pBasChn->GetMediaMode() == MODE_VIDEO
								)
							{		
								u8 byNewFramRat = 0;
								if ( tDstCap.GetMediaType() != MEDIA_TYPE_H264 )
								{
									byNewFramRat = atParam[byOutIdx].GetFrameRate();
								}
								else
								{
									byNewFramRat = tDstCap.GetUserDefFrameRate();
								}
								
								//帧率改变修改帧率
								if ( byNewFramRat != atParam[byOutIdx].GetFrameRate() )
								{
									atSpecialtParam[byOutIdx].SetFrameRate(byNewFramRat);
								}
								
								//分辨率变小设置分辨率
								u8 byNewRes = tDstCap.GetResolution();	
								u16 wNewWidth = 0;
								u16 wNewHeight = 0;
								GetWHByRes(byNewRes,wNewWidth,wNewHeight);
								if ( byNewRes!= VIDEO_FORMAT_INVALID &&
									wNewWidth*wNewHeight < atParam[byOutIdx].GetWidth()*atParam[byOutIdx].GetHeight()  
									)
								{
									atSpecialtParam[byOutIdx].SetResolution(wNewWidth,wNewHeight);
								}
							}
							atSpecialtParam[byOutIdx].PrintHd();
						}
					}
				}
				break;
			default:
				
				break;
			}			
		}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
		else if ( g_cMcuAgent.IsEqpBasAud(pBasChn->GetBas().GetEqpId())  )
#endif
		{
			u8 byAudType = tBasStatus.m_tStatus.tAudBas.GetEqpType();
			//TAudBasChnStatus *pAudChnStatus;
			if (byAudType == TYPE_APU2_BAS || byAudType == TYPE_8KI_AUD_BAS )
			{
				if( byAudType == TYPE_APU2_BAS )
				{
					pAudChnStatus = tBasStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.GetAudChnStatus(pBasChn->GetChnId());
				}
				else
				{
					pAudChnStatus = tBasStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(pBasChn->GetChnId());
				}
				
				if ( pAudChnStatus != NULL )
				{
					pAudChnStatus->PrintInfo();
				}
			}
		}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
		else
		{
			tBasStatus.m_tStatus.tBas.tChnnl[pBasChn->GetChnId()].Print();
		}	
#endif	
	}
}
/*====================================================================
函数名         SetOutPutParam
功能        ：设置广播适配参数
算法实现    ：
引用全局变量：
输入参数说明：THDAdaptParam tParam 适配参数
			  u8	   byMediaMode 适配模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
// BOOL32 TMcuBasChnGrp::SetOutPutParam(const TConfInfo& tConfInfo ,THDAdaptParam tParam, u8 byMediaMode)
// { 
// 	BOOL32 bSetOK = FALSE;
// // 	if (tParam.IsNull())
// // 	{
// // 		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetOutPutAdaptParam] tParam is null!\n");
// // 		return FALSE;
// // 	}
// // 	
// // 	for (u8 byIdx = 0; byIdx < MAXNUM_PERIEQP; byIdx++)
// // 	{
// // 		if (m_atBasChn[byIdx].GetBas().IsNull())
// // 		{
// // 			continue;
// // 		}
// // 		if (m_atBasChn[byIdx].GetMediaMode() != byMediaMode)
// // 		{
// // 			continue;
// // 		}
// // 		//下适配参数
// // 		if(g_cMcuVcApp.SetBasAdaptParam(tConfInfo,
// // 										m_atBasChn[byIdx].GetBas(), 
// // 										m_atBasChn[byIdx].GetChnId(), 
// // 										tParam))
// // 		{
// // 			bSetOK = TRUE;
// // 			break;
// // 		}
// // 	}	
// 	return bSetOK;
// }

/*====================================================================
函数名        ClearAdaptParam
功能        ：清空广播适配参数
算法实现    ：
引用全局变量：
输入参数说明：u8 byMediaMode   媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
2011/12/22  4.7         倪志俊			修改
====================================================================*/
BOOL32 TMcuBasChnGrp::ClearAdaptParam(u8 byMediaMode)
{
	for (u8 byIdx = 0; byIdx < MAXNUM_PERIEQP; byIdx++)
	{
		CBasChn *pBasChn = m_atConfBasChn[byIdx].GetBasChn();
		if ( NULL == pBasChn)
		{
			continue;
		}

		if (pBasChn->GetBas().IsNull())
		{
			continue;
		}
		if (pBasChn->GetMediaMode() != byMediaMode)
		{
			continue;
		}
		g_cMcuVcApp.ClearAdaptParam(pBasChn->GetBas(), 
			pBasChn->GetChnId(),
			pBasChn->GetMediaMode());
	}
	return TRUE;
}

/*====================================================================
函数名        RefreshSpecialIdx
功能        ：对于单速双格式或者音频适配需要特殊处理来设置idx
算法实现    ：
引用全局变量：
输入参数说明：TSimCapSet &tSimCapSet 新的能力集
			 u8 byMediaMode   媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22	4.7			倪志俊		  创建
====================================================================*/
BOOL32	TMcuBasChnGrp::RefreshSpecialVidCap( TConfInfo &tConfInfo, TVideoStreamCap &tSimCapSet, u8 byMediaMode)
{
	u8 byIdx = 0;
	//通道中的能力是否与辅格式能力相同或者与主格式相同
	//因为单速双other格式或者双速紧凑的双other格式会根据源的能力动态刷参
	for ( byIdx =0; byIdx<MAXNUM_PERIEQP; byIdx++ )
	{
		CBasChn *pBasChn =  m_atConfBasChn[byIdx].GetBasChn();
		if ( NULL == pBasChn )
		{
			continue;
		}
		
		if ( pBasChn->GetMediaMode() != byMediaMode )
		{
			continue;
		}
		
		TBasChnCapData tTempBasCapData = m_atConfBasChn[byIdx].GetBasChnCapParam();
		
		TVideoStreamCap tTempVidCap;

		for ( u8 byLoop = 0; byLoop< MAX_CONF_BAS_ADAPT_NUM; byLoop++ )
		{
			if ( !tTempBasCapData.atBasChnCap[byLoop].GetVideoCapSet(tTempVidCap) )
			{
				continue;
			}
			
			if ( byMediaMode == MODE_VIDEO )
			{
				if ( tTempVidCap.GetMediaType() == tConfInfo.GetSecSimCapSet().GetVideoMediaType() &&
					 tTempVidCap.GetH264ProfileAttrb() == tConfInfo.GetSecSimCapSet().GetVideoProfileType()
					)
				{		
					if (  (tConfInfo.GetSecSimCapSet().GetVideoMediaType() == MEDIA_TYPE_MP4 &&
						   tConfInfo.GetSecSimCapSet().GetVideoResolution() == VIDEO_FORMAT_AUTO
						  ) ||
						  tTempVidCap.GetResolution() == tConfInfo.GetSecSimCapSet().GetVideoResolution()
						)
					{
						tTempBasCapData.atBasChnCap[byLoop].SetVidepCapSet(tSimCapSet);
						m_atConfBasChn[byIdx].SetBasChnCapParam(tTempBasCapData);
						return TRUE;
					}
				}
				else if ( tTempVidCap.GetMediaType() == tConfInfo.GetMainSimCapSet().GetVideoMediaType() &&
						 tTempVidCap.GetH264ProfileAttrb() == tConfInfo.GetMainSimCapSet().GetVideoProfileType()
						)
				{
					if (  (tConfInfo.GetMainSimCapSet().GetVideoMediaType() == MEDIA_TYPE_MP4 &&
						   tConfInfo.GetMainSimCapSet().GetVideoResolution() == VIDEO_FORMAT_AUTO
						  )||
						tTempVidCap.GetResolution() == tConfInfo.GetMainSimCapSet().GetVideoResolution()
						)
					{
						tTempBasCapData.atBasChnCap[byLoop].SetVidepCapSet(tSimCapSet);
						m_atConfBasChn[byIdx].SetBasChnCapParam(tTempBasCapData);
						return TRUE;
					}			
				}
			}
			else if ( byMediaMode == MODE_SECVIDEO )
			{
				if ( tTempVidCap.GetMediaType() == tConfInfo.GetCapSupportEx().GetSecDSType() &&
					 tTempVidCap.GetResolution() == tConfInfo.GetCapSupportEx().GetSecDSRes() &&
					 tTempVidCap.GetH264ProfileAttrb() == tConfInfo.GetCapSupportEx().GetSecDSVideoCap().GetH264ProfileAttrb()
					)
				{		
					tTempBasCapData.atBasChnCap[byLoop].SetVidepCapSet(tSimCapSet);
					m_atConfBasChn[byIdx].SetBasChnCapParam(tTempBasCapData);
					return TRUE;
				}
				else if ( tTempVidCap.GetMediaType() == tConfInfo.GetCapSupport().GetDStreamCapSet().GetMediaType() &&
						  tTempVidCap.GetResolution() ==  tConfInfo.GetCapSupport().GetDStreamCapSet().GetResolution() &&
						  tTempVidCap.GetH264ProfileAttrb() == tConfInfo.GetCapSupport().GetDStreamCapSet().GetH264ProfileAttrb()
						)
				{
					tTempBasCapData.atBasChnCap[byLoop].SetVidepCapSet(tSimCapSet);
					m_atConfBasChn[byIdx].SetBasChnCapParam(tTempBasCapData);
					return TRUE;
				}
			}
		}
	}

	return FALSE;
}

/*====================================================================
函数名        RefreshSpecialAudCap
功能        ：对于单速双格式或者音频适配需要特殊处理来设置idx
算法实现    ：
引用全局变量：
输入参数说明：TConfInfoEx &tConfInfoEx   会议勾选
			 TAudioTypeDesc tAudSrcCap   源能力
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/13	4.7			倪志俊		  创建
====================================================================*/
BOOL32	TMcuBasChnGrp::RefreshSpecialAudCap(TConfInfo &tConfInfo, TConfInfoEx &tConfInfoEx,TAudioTypeDesc &tAudSrcCap)
{
	if ( tAudSrcCap.GetAudioMediaType() == MEDIA_TYPE_NULL )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[TMcuBasChnGrp::RefreshSpecialAudCap]tAudSrcCap type is NULL!\n");
		return FALSE;
	}

	TAudioTypeDesc atRecordAudCap[MAXNUM_CONF_AUDIOTYPE];
	u8 byAudNum = tConfInfoEx.GetAudioTypeDesc(atRecordAudCap);
	
	if ( byAudNum < 2 )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[TMcuBasChnGrp::RefreshSpecialAudCap]byAudNum :%d no need aud adapt!\n",byAudNum);
		return FALSE;
	}

	u8 abyRecord[MAXNUM_CONF_AUDIOTYPE]={0}; //记录下对应的勾选能力集数组是否已经下参


	BOOL32 bIsNeedChange = FALSE;	//是否需要反向适配，改变参数
	CBasChn *pNeedChangeBasChn = NULL;		//需要改变参数的通道
	u8 byNeedChangeIdx = 0XFF;			//需要改变参数的通道id，m_atConfBasChn下标
	u8 byNeedChangeOutIdx = 0XFF;		//需要改变参数的通道对应的那一路输出

	TAudioTypeDesc tTempAudCap;
	u8 byIdx = 0;
	for ( byIdx =0; byIdx<MAXNUM_PERIEQP; byIdx++ )
	{
		CBasChn * pBasChn=  m_atConfBasChn[byIdx].GetBasChn();
		if ( NULL == pBasChn )
		{
			continue;
		}
		
		if ( pBasChn->GetMediaMode() != MODE_AUDIO )
		{
			continue;
		}
		
		TBasChnCapData tTempChnCapParam;
		tTempChnCapParam = m_atConfBasChn[byIdx].GetBasChnCapParam();
	
		//遍历参数数组
		u8 byInnerLoop = 0;	
		for ( byInnerLoop = 0; byInnerLoop<MAXNUM_CONF_AUDIOTYPE; byInnerLoop++ )
		{
			tTempAudCap.Clear();
			if ( tTempChnCapParam.atBasChnCap[byInnerLoop].GetAudCapSet(tTempAudCap) &&
				 tTempAudCap.GetAudioMediaType() != MEDIA_TYPE_NULL
				)
			{
				//判断源能力是否在下参参数中已经存在，如果存在，说明需要走反向适配
				if ( tAudSrcCap.GetAudioMediaType() == tTempAudCap.GetAudioMediaType() &&
					 tAudSrcCap.GetAudioTrackNum() == tTempAudCap.GetAudioTrackNum() 
					)
				{
					bIsNeedChange = TRUE;
					byNeedChangeIdx = byIdx;
					byNeedChangeOutIdx = byInnerLoop;
					pNeedChangeBasChn = pBasChn;
				}
				
				//记录一下已经出现过的能力集，以便反向适配下参时，刷一下没出现过的能力集
				u8 byRecordLoop = 0;
				for ( byRecordLoop= 0; byRecordLoop<MAXNUM_CONF_AUDIOTYPE; byRecordLoop++ )
				{
					if ( atRecordAudCap[byRecordLoop].GetAudioMediaType() == tTempAudCap.GetAudioMediaType() &&
						atRecordAudCap[byRecordLoop].GetAudioTrackNum() == tTempAudCap.GetAudioTrackNum()
						)
					{
						abyRecord[byRecordLoop] = 1;
					}
				}
			}
		}
	}

	//遍历完成，判断是否存在修要修改的参数
	if ( bIsNeedChange &&  pNeedChangeBasChn && (byNeedChangeIdx != 0XFF) && ( byNeedChangeOutIdx !=0XFF ) )
	{
		for ( byIdx=0; byIdx<MAXNUM_CONF_AUDIOTYPE; byIdx++  )
		{
			if ( abyRecord[byIdx] == 0)
			{
				break;
			}
		}

		TAudioTypeDesc tNewAudCap = atRecordAudCap[byIdx];

		//保存参数
		TBasChnCapData tTempChnCapParam = m_atConfBasChn[byNeedChangeIdx].GetBasChnCapParam();
		tTempChnCapParam.atBasChnCap[byNeedChangeOutIdx].SetAudCapSet( tNewAudCap );
		m_atConfBasChn[byNeedChangeIdx].SetBasChnCapParam(tTempChnCapParam);

		//下参
		TAudAdaptParam tParam;
		tParam.SetAudCodeType( tNewAudCap.GetAudioMediaType() );
		tParam.SetAudActiveType( GetActivePayload(tConfInfo, tNewAudCap.GetAudioMediaType()) );
		tParam.SetTrackNum( tNewAudCap.GetAudioTrackNum() );
		TConfAttrb tconfAttrb = tConfInfo.GetConfAttrb();
		tParam.SetIsNeedByPrs(tconfAttrb.IsResendLosePack());
		
		if ( !pNeedChangeBasChn->SetAudAdaptParamForcely(tParam,byNeedChangeOutIdx) )
		{
			LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[RefreshSpecialAudCap]SetAudAdaptParam:Type:%d Track:%d for chn-%d-%d error!\n",
				tParam.GetAudCodeType(),
				tParam.GetTrackNum(),
				pNeedChangeBasChn->GetBas().GetEqpId(),
				pNeedChangeBasChn->GetChnId()
				);
			return FALSE;
		}
	}

	return TRUE;
}

/*====================================================================
函数名        RefreshAllChnsParam
功能        ：
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22	4.7			倪志俊		  创建
====================================================================*/
BOOL32	TMcuBasChnGrp::RefreshAllChnsParam(TConfInfo &tConfInfo, u8 byMediaMode,u16 wBiteRate)
{
	for ( u8 byLoop = 0; byLoop < MAXNUM_PERIEQP; byLoop++ )
	{
		CBasChn *pBasChn = m_atConfBasChn[byLoop].GetBasChn();
		if ( NULL == pBasChn )
		{
			continue;
		}
		
		if ( byMediaMode != pBasChn->GetMediaMode() )
		{
			continue;
		}
		
		TBasChnCapData tChnEncCapData;
		tChnEncCapData = m_atConfBasChn[byLoop].GetBasChnCapParam();
		
		TVideoStreamCap tTempVidCap;
		TAudioTypeDesc  tTempAudCap;

		for ( u8 byIdx = 0; byIdx < MAX_CONF_BAS_ADAPT_NUM; byIdx++ )
		{
			if ( byMediaMode == MODE_AUDIO && tChnEncCapData.atBasChnCap[byIdx].GetAudCapSet(tTempAudCap) )
			{
				TAudAdaptParam tParam;
				tParam.SetAudCodeType( tTempAudCap.GetAudioMediaType() );
				tParam.SetAudActiveType( GetActivePayload(tConfInfo, tTempAudCap.GetAudioMediaType()) );
				tParam.SetTrackNum( tTempAudCap.GetAudioTrackNum() );
				TConfAttrb tconfAttrb = tConfInfo.GetConfAttrb();
				tParam.SetIsNeedByPrs(tconfAttrb.IsResendLosePack());

				if ( !pBasChn->SetAudAdaptParam(tParam) )
				{
					LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[RefreshAllChnsParam]SetAudAdaptParam:Type:%d Track:%d for chn-%d-%d error!\n",
							 tParam.GetAudCodeType(),
							 tParam.GetTrackNum(),
							 pBasChn->GetBas().GetEqpId(),
							 pBasChn->GetChnId()
							);
					return FALSE;
				}
			}
			else if( ( byMediaMode == MODE_VIDEO || byMediaMode == MODE_SECVIDEO) && 
				     tChnEncCapData.atBasChnCap[byIdx].GetVideoCapSet(tTempVidCap) 
					)
			{
				THDAdaptParam tParam;
				u16 wWidth, wHeight;
				tParam.SetVidType( tTempVidCap.GetMediaType() );
				tParam.SetVidActiveType( GetActivePL(tConfInfo, tTempVidCap.GetMediaType()) );
				TConfAttrb tconfAttrb = tConfInfo.GetConfAttrb();
				tParam.SetIsNeedByPrs(tconfAttrb.IsResendLosePack());

				u8 byEncRes = tTempVidCap.GetResolution();
				if ( tTempVidCap.GetMediaType() == MEDIA_TYPE_MP4 )
				{
					if( tTempVidCap.GetResolution() == VIDEO_FORMAT_16CIF )
					{
						byEncRes = VIDEO_FORMAT_4CIF;
					}
					else if( tTempVidCap.GetResolution() == VIDEO_FORMAT_AUTO )
					{
						byEncRes = GetAutoResByBitrate(  tTempVidCap.GetResolution(), tConfInfo.GetBitRate());
					}
				}

				//4CIF 和 CIF帧率做保护
				u8 byFrameRate = tTempVidCap.GetUserDefFrameRate();
				if (  tTempVidCap.GetResolution() == VIDEO_FORMAT_4CIF ||
					  tTempVidCap.GetResolution() == VIDEO_FORMAT_CIF
					)
				{
					if ( byFrameRate == 60 || byFrameRate == 50 )
					{
						byFrameRate = byFrameRate/2;
					}
				}

				GetWHByRes(byEncRes, wWidth,wHeight);
				tParam.SetResolution( wWidth, wHeight );
				tParam.SetBitRate( wBiteRate );
				tParam.SetFrameRate( byFrameRate );
				tParam.SetProfileType( (u8)tTempVidCap.GetH264ProfileAttrb() );

				if ( !pBasChn->SetAdaptParam(tParam) )
				{
					LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[RefreshAllChnsParam]SetAdapatParam:MediaType:%d-Res:%d-ProfieType:%d-Frame:%d-BitRate%d for chn-%d-%d error!\n",
							tParam.GetVidType(),
							byEncRes,
							tParam.GetProfileType(),
							tParam.GetFrameRate(),
							tParam.GetBitrate(),
							pBasChn->GetBas().GetEqpId(),
							pBasChn->GetChnId()
							);
					return FALSE;
				}
			}
		
		}
	}

	return TRUE;
}

/*====================================================================
函数名        FindBacChnForBrd
功能        ：
算法实现    ：
引用全局变量：
输入参数说明：const TSimCapSet &tSimCapSet  所需编码能力集
			  TBasOutInfo &tOutInfo			返回获得编码输出相关信息
			  u8 byMediaMode				媒体类型
			  BOOL32 bIsExactMatch		    是否严格匹配查找
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22	4.7			倪志俊		  创建
====================================================================*/
BOOL32	TMcuBasChnGrp::FindBasChnForVidBrd(const TVideoStreamCap &tSimCapSet,TBasOutInfo &tOutInfo,u8 byMediaMode,BOOL32 bIsExactMatch /* = FALSE */)
{
	TBasOutInfo tTempOutInfo;		//最适合的通道
	tTempOutInfo.m_tBasEqp.SetNull();
	TBasOutInfo tSubTempOutInfo;	//可接受的通道
	tSubTempOutInfo.m_tBasEqp.SetNull();
	TBasOutInfo tFrameTempOutInfo;	//帧率最后通道
	tFrameTempOutInfo.m_tBasEqp.SetNull();
	
	u8 byLastRes = 0;	//保存上次的分辨率
	u8 byLastFrameRate = 0;	//保存上次的帧率，SXGA目前支持多帧率勾选，故要找最优
	u8 bySubLastRes = 0; //保存可接受通道的分辨率
	
	//对于双流接收能力为VGA或者SVGA的，目前只有XGA适配编码，故使用XGA打给他
	BOOL32 bIsUseXGAReturn = FALSE;
	if ( byMediaMode == MODE_SECVIDEO &&
		 (tSimCapSet.GetResolution() == VIDEO_FORMAT_VGA ||
		 tSimCapSet.GetResolution() == VIDEO_FORMAT_SVGA)
		)
	{
		bIsUseXGAReturn = TRUE;
	}

	for ( u8 byLoop = 0; byLoop < MAXNUM_PERIEQP; byLoop++ )
	{
		CBasChn	*pBasChn = m_atConfBasChn[byLoop].GetBasChn();
		if ( NULL == pBasChn )
		{
			continue;
		}
		
		if ( pBasChn->GetMediaMode() != byMediaMode )
		{
			continue;
		}

		THDAdaptParam atParam[MAXNUM_BASOUTCHN];
		u8			  byOutNum;
		if( !g_cMcuVcApp.GetBasOutPutParam(pBasChn->GetBas(), pBasChn->GetChnId(),byOutNum, atParam) )
		{
			continue;
		}

		u8			  byFrontOutNum = 0;
		if ( !g_cMcuVcApp.GetBasChnFrontOutPutNum(pBasChn->GetBas(), pBasChn->GetChnId(),byOutNum,byFrontOutNum) )
		{
			continue;
		}

		for (u8 byOut = 0; byOut < byOutNum; byOut++)
		{
			if (MODE_VIDEO == byMediaMode || MODE_SECVIDEO == byMediaMode)
			{
				if (tSimCapSet.GetMediaType() == atParam[byOut].GetVidType())
				{	
					if ( byMediaMode == MODE_SECVIDEO &&
						 GetResByWH( atParam[byOut].GetWidth(),atParam[byOut].GetHeight() ) == VIDEO_FORMAT_XGA &&
						 TRUE == bIsUseXGAReturn
						)
					{
						tOutInfo.m_tBasEqp     = pBasChn->GetBas();
						tOutInfo.m_byChnId  = pBasChn->GetChnId();
						tOutInfo.m_byOutIdx = byOut;
						tOutInfo.m_byOutNum = byOutNum;
						tOutInfo.m_byFrontOutNum = byFrontOutNum;
						LogPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[FindBasChnForBrd] find xga format chnl,LogChn:RES-%d,chnid-%d,outid-%d\n",
							tSimCapSet.GetResolution(), pBasChn->GetChnId(), byOut
							);
							return TRUE;
					}


					//适配参数和目的接收格式均为mp4不匹配分辨率(mp4编码既具有唯一性，同时模糊处理mp4_auto匹配)
					if (MEDIA_TYPE_MP4 == tSimCapSet.GetMediaType() && MEDIA_TYPE_MP4 == atParam[byOut].GetVidType())
					{
						// deal with mp4 16cif
						u8 byParamRes = GetResByWH(atParam[byOut].GetWidth(), atParam[byOut].GetHeight());
						
						//1.接收终端能力MP4 16CIF    接收通道参数为4CIF(因为对于接受能力是16CIF的终端，取4CIF编码)
						//2.接收终端能力MP4 4CIF/CIF 接收通道参数分辨率必须一致
						//3.接收终端能力MP4 AUTO     接收通道参数分辨率按会议码率做相应匹配
						if( ( VIDEO_FORMAT_16CIF == tSimCapSet.GetResolution() && VIDEO_FORMAT_4CIF == byParamRes ) ||
							( VIDEO_FORMAT_AUTO != tSimCapSet.GetResolution() &&  tSimCapSet.GetResolution() == byParamRes) ||
							(
								VIDEO_FORMAT_AUTO == tSimCapSet.GetResolution() 
								//[nizhijun 20120705]对于MP4 AUTO使用模糊匹配方式，为了让MP4 AUTO能够根据码率调整分辨
								//&&byParamRes == GetAutoResByBitrate(tSimCapSet.GetVideoResolution(), tSimCapSet.GetVideoMaxBitRate())
							)
						  )
						{
							tOutInfo.m_tBasEqp     = pBasChn->GetBas();
							tOutInfo.m_byChnId  = pBasChn->GetChnId();
							tOutInfo.m_byOutIdx = byOut;
							tOutInfo.m_byOutNum = byOutNum;
							tOutInfo.m_byFrontOutNum = byFrontOutNum;
							LogPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[FindBasChnForBrd] find mp4 format chnl,LogChn:RES-%d,chnid-%d,outid-%d\n",
									tSimCapSet.GetResolution(), pBasChn->GetChnId(), byOut
									 );
							return TRUE;
						}
					}
					//匹配分辨率和profile类型
					else if ( tSimCapSet.GetResolution() == GetResByWH(atParam[byOut].GetWidth(), atParam[byOut].GetHeight()) &&
							 tSimCapSet.GetH264ProfileAttrb() == atParam[byOut].GetProfileType()
							)
					{
						//帧率大于参数，则直接返回，小于则记录下，如果到最后没找到对应通道，则返回临时记录的通道
						if ( tSimCapSet.GetUserDefFrameRate() == atParam[byOut].GetFrameRate() )
						{
							tOutInfo.m_tBasEqp     = pBasChn->GetBas();
							tOutInfo.m_byChnId  = pBasChn->GetChnId();
							tOutInfo.m_byOutIdx = byOut;
							tOutInfo.m_byOutNum = byOutNum;
							tOutInfo.m_byFrontOutNum = byFrontOutNum;
							return TRUE;
						}
						else if ( tSimCapSet.GetUserDefFrameRate() > atParam[byOut].GetFrameRate() )
						{
							if (  atParam[byOut].GetFrameRate() > byLastFrameRate )
							{
								byLastFrameRate = atParam[byOut].GetFrameRate();
								tFrameTempOutInfo.m_tBasEqp  = pBasChn->GetBas();
								tFrameTempOutInfo.m_byChnId  = pBasChn->GetChnId();
								tFrameTempOutInfo.m_byOutIdx = byOut;
								tFrameTempOutInfo.m_byOutNum = byOutNum;
								tFrameTempOutInfo.m_byFrontOutNum = byFrontOutNum;
							}
						}
						else
						{
							tTempOutInfo.m_tBasEqp     = pBasChn->GetBas();
							tTempOutInfo.m_byChnId  = pBasChn->GetChnId();
							tTempOutInfo.m_byOutIdx = byOut;
							tTempOutInfo.m_byOutNum = byOutNum;
							tTempOutInfo.m_byFrontOutNum = byFrontOutNum;
						}
					}
					else if (!bIsExactMatch && 
							 IsResGE( tSimCapSet.GetResolution(), GetResByWH(atParam[byOut].GetWidth(), atParam[byOut].GetHeight()) ) &&
							 tSimCapSet.GetH264ProfileAttrb() == atParam[byOut].GetProfileType() 
							 )
					{
						//分辨率取大
						if ( GetResByWH(atParam[byOut].GetWidth(), atParam[byOut].GetHeight()) > byLastRes )
						{
							byLastRes = GetResByWH(atParam[byOut].GetWidth(), atParam[byOut].GetHeight());
							tTempOutInfo.m_tBasEqp     = pBasChn->GetBas();
							tTempOutInfo.m_byChnId  = pBasChn->GetChnId();
							tTempOutInfo.m_byOutIdx = byOut;
							tTempOutInfo.m_byOutNum = byOutNum;
							tTempOutInfo.m_byFrontOutNum = byFrontOutNum;
						}								
					}
					//看一下是否有分辨率满足，但profieltype 不满足的情况，如果有记录下来
					else if (!bIsExactMatch && 
							 IsResGE( tSimCapSet.GetResolution(), GetResByWH(atParam[byOut].GetWidth(), atParam[byOut].GetHeight()) ) &&
							 tSimCapSet.GetH264ProfileAttrb() > atParam[byOut].GetProfileType() )
					{
						//分辨率取大
						if ( GetResByWH(atParam[byOut].GetWidth(), atParam[byOut].GetHeight()) > bySubLastRes )
						{
							bySubLastRes = GetResByWH(atParam[byOut].GetWidth(), atParam[byOut].GetHeight());
							tSubTempOutInfo.m_tBasEqp     = pBasChn->GetBas();
							tSubTempOutInfo.m_byChnId  = pBasChn->GetChnId();
							tSubTempOutInfo.m_byOutIdx = byOut;
							tSubTempOutInfo.m_byOutNum = byOutNum;
							tSubTempOutInfo.m_byFrontOutNum = byFrontOutNum;
						}		
					}
				}
			}
		}
	}
	
	if ( !tFrameTempOutInfo.m_tBasEqp.IsNull() )
	{
		tOutInfo.m_tBasEqp  = tFrameTempOutInfo.m_tBasEqp;
		tOutInfo.m_byChnId  = tFrameTempOutInfo.m_byChnId;
		tOutInfo.m_byOutIdx = tFrameTempOutInfo.m_byOutIdx;
		tOutInfo.m_byOutNum = tFrameTempOutInfo.m_byOutNum;
		tOutInfo.m_byFrontOutNum = tFrameTempOutInfo.m_byFrontOutNum;
		return TRUE;
	}
	else if ( !tTempOutInfo.m_tBasEqp.IsNull() )
	{
		tOutInfo.m_tBasEqp     = tTempOutInfo.m_tBasEqp;
		tOutInfo.m_byChnId  = tTempOutInfo.m_byChnId;
		tOutInfo.m_byOutIdx = tTempOutInfo.m_byOutIdx;
		tOutInfo.m_byOutNum = tTempOutInfo.m_byOutNum;
		tOutInfo.m_byFrontOutNum = tTempOutInfo.m_byFrontOutNum;
		return TRUE;
	
	}
	else if ( !tSubTempOutInfo.m_tBasEqp.IsNull() )
	{
		tOutInfo.m_tBasEqp     = tSubTempOutInfo.m_tBasEqp;
		tOutInfo.m_byChnId  = tSubTempOutInfo.m_byChnId;
		tOutInfo.m_byOutIdx = tSubTempOutInfo.m_byOutIdx;
		tOutInfo.m_byOutNum = tSubTempOutInfo.m_byOutNum;
		tOutInfo.m_byFrontOutNum = tSubTempOutInfo.m_byFrontOutNum;
		return TRUE;
	}

	return FALSE;
}

/*====================================================================
函数名        FindBasChnForAudBrd
功能        ：
算法实现    ：
引用全局变量：
输入参数说明：const TAudioTypeDesc &tAudCap  所需编码能力集
			  TBasOutInfo &tOutInfo			返回获得编码输出相关信息
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/13	4.7			倪志俊		  创建
====================================================================*/
BOOL32	TMcuBasChnGrp::FindBasChnForAudBrd(const TAudioTypeDesc &tAudCap, TBasOutInfo &tOutInfo)
{
	for ( u8 byLoop = 0; byLoop < MAXNUM_PERIEQP; byLoop++ )
	{
		CBasChn	*pBasChn = m_atConfBasChn[byLoop].GetBasChn();
		if ( NULL == pBasChn )
		{
			continue;
		}
		
		if ( pBasChn->GetMediaMode() != MODE_AUDIO )
		{
			continue;
		}
		
		TAudAdaptParam atParam[MAXNUM_BASOUTCHN];
		u8			  byOutNum;
		if( !g_cMcuVcApp.GetAudBasOutPutParam(pBasChn->GetBas(), pBasChn->GetChnId(),byOutNum, atParam) )
		{
			continue;
		}
		
		u8			  byFrontOutNum = 0;
		if ( !g_cMcuVcApp.GetBasChnFrontOutPutNum(pBasChn->GetBas(), pBasChn->GetChnId(),byOutNum,byFrontOutNum) )
		{
			continue;
		}
		
		for (u8 byOut = 0; byOut < byOutNum; byOut++)
		{
			if ( tAudCap.GetAudioMediaType() == atParam[byOut].GetAudCodeType() &&
				tAudCap.GetAudioTrackNum() == atParam[byOut].GetTrackNum()
				)
			{
				tOutInfo.m_tBasEqp  = pBasChn->GetBas();
				tOutInfo.m_byChnId  = pBasChn->GetChnId();
				tOutInfo.m_byOutIdx = byOut;
				tOutInfo.m_byOutNum = byOutNum;
				tOutInfo.m_byFrontOutNum = byFrontOutNum;
				return TRUE;
			}
		}
	}
	
	return FALSE;
}


/*====================================================================
函数名        RefreshBasParambyOut
功能        ：
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22	4.7			倪志俊		  创建
====================================================================*/
BOOL32	TMcuBasChnGrp::RefreshBasParambyOut(TBasOutInfo &tBasOutInfo, THDAdaptParam &tBasParam)
{
	for ( u8 byLoop = 0; byLoop < MAXNUM_PERIEQP; byLoop++ )
	{
		CBasChn *pBasChn = m_atConfBasChn[byLoop].GetBasChn();
		if ( NULL == pBasChn )
		{
			continue;
		}

		if ( pBasChn->GetBas() == tBasOutInfo.m_tBasEqp &&
			 pBasChn->GetChnId() == tBasOutInfo.m_byChnId &&
			 pBasChn->GetEncNum() >= (tBasOutInfo.m_byOutIdx+1)
			)
		{
			return pBasChn->SetAdaptParamForcely(tBasParam,tBasOutInfo.m_byOutIdx);
		}

	}

	return FALSE;
}

/*====================================================================
函数名        StartAdapt
功能        ：
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22	4.7			倪志俊		  创建
====================================================================*/
BOOL32	TMcuBasChnGrp::StartAdapt(const TEqp &tEqp, u8 byChnId,TBasAdaptParamExt &tBasParamExt, u8 byIdx)
{
	if ( m_atConfBasChn[byIdx].IsBasChnExist(tEqp,byChnId) )
	{
		return m_atConfBasChn[byIdx].StartAdapt(tBasParamExt);
	}

	return FALSE;	
}

/*====================================================================
函数名        StopAllChnsAdapt
功能        ：
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp BAS外设
			  u8 byChnId		通道号
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22	4.7			倪志俊		  创建
====================================================================*/
BOOL32	TMcuBasChnGrp::StopAdapt(const TEqp &tEqp,u8 byChnId, BOOL32 bIsSelChn /*= FALSE*/)
{
	for ( u8 byIdx = 0 ;byIdx<MAXNUM_PERIEQP; byIdx++ )
	{
		if ( m_atConfBasChn[byIdx].IsBasChnExist(tEqp,byChnId) )
		{
			if ( bIsSelChn )
			{
				CBasChn *pBasChn = m_atConfBasChn[byIdx].GetBasChn();
				if ( NULL != pBasChn  )
				{
					pBasChn->RestoreEncArray();
				}
			}

			return	m_atConfBasChn[byIdx].StopAdapt();
		}
	}

	return FALSE;
}

/*====================================================================
函数名        SetSelChnParam
功能        ：设置选看通道参数
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp BAS外设
			  u8 byChnId		通道号
			  u8 byMediaMode  媒体类型
			  THDAdaptParam &tBasParam BAS参数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22	4.7			倪志俊		  创建
====================================================================*/
BOOL32	TMcuBasChnGrp::SetSelChnParam(const TEqp &tEqp, u8 byChnId, u8 byMediaMode, THDAdaptParam &tBasParam)
{
	for ( u8 byIdx = 0; byIdx<MAXNUM_PERIEQP; byIdx++ )
	{
		if ( m_atConfBasChn[byIdx].IsBasChnExist(tEqp,byChnId) )
		{
			CBasChn *pBasChn = m_atConfBasChn[byIdx].GetBasChn();
			if ( NULL != pBasChn &&
				pBasChn->GetMediaMode() == byMediaMode
				)
			{
				return pBasChn->SetAdaptParam(tBasParam);
			}
		}
	}
	return FALSE;
}

/*====================================================================
函数名        SetSelAudChnParam
功能        ：设置选看通道参数
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp BAS外设
u8 byChnId		通道号
TAudAdaptParam &tBasParam BAS参数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/14	4.7			倪志俊		  创建
====================================================================*/
BOOL32	TMcuBasChnGrp::SetSelAudChnParam(const TEqp &tEqp, u8 byChnId, TAudAdaptParam &tBasParam)
{
	for ( u8 byIdx = 0; byIdx<MAXNUM_PERIEQP; byIdx++ )
	{
		if ( m_atConfBasChn[byIdx].IsBasChnExist(tEqp,byChnId) )
		{
			CBasChn *pBasChn = m_atConfBasChn[byIdx].GetBasChn();
			if ( NULL != pBasChn &&
				pBasChn->GetMediaMode() == MODE_AUDIO
				)
			{
				return pBasChn->SetAudAdaptParam(tBasParam);
			}
		}
	}
	return FALSE;
}

/*====================================================================
函数名        AddBasSelChnParam
功能        ：选看查找可用通道时严格比较分辨率
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp BAS外设
			  u8 byChnId	   通道号
			  const TBasChnIdxParam &tBasChnIdxParam idx记录
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22	4.7			倪志俊		  创建
====================================================================*/
BOOL32	TMcuBasChnGrp::AddBasSelChnParam(const TEqp &tEqp, u8 byChnId, const  TBasChnCapData &tBasChnCapData)
{
	for ( u8 byIdx = 0; byIdx<MAXNUM_PERIEQP; byIdx++ )
	{
		if ( m_atConfBasChn[byIdx].IsBasChnExist(tEqp,byChnId) )
		{
			TBasChnCapData tTempEncCapData = m_atConfBasChn[byIdx].GetBasChnCapParam();
			u8 byLoop = 0;
			BOOL32 bFindPos = FALSE;
			for ( byLoop =0; byLoop < MAXNUM_PERIEQP; byLoop++ )
			{
				if ( tTempEncCapData.atBasChnCap[byLoop].IsNull())
				{
					bFindPos = TRUE;
					break;
				}
			}

			if ( bFindPos )
			{
				memcpy( &tTempEncCapData.atBasChnCap[byLoop],tBasChnCapData.atBasChnCap, sizeof(TBasChnCap)*(MAX_CONF_BAS_ADAPT_NUM-byLoop) );
				m_atConfBasChn[byIdx].SetBasChnCapParam(tTempEncCapData);
				return TRUE;
			}
		}
	}
	return FALSE;
}

/*====================================================================
函数名        ResignBasChn
功能        ：
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/03/29 	4.7			倪志俊		  创建
====================================================================*/
void TMcuBasChnGrp::ResignBasChn()
{
	for ( u8 byLoop = 0; byLoop < MAXNUM_PERIEQP; byLoop++ )
	{
		m_atConfBasChn[byLoop].ResignBasChnAddr();
	}
}

/*====================================================================
函数名        FindBacChnForSel
功能        ：选看查找可用通道时严格比较分辨率
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22	4.7			倪志俊		  创建
====================================================================*/
BOOL32	TMcuBasChnGrp::FindBasChnForVidSel(TMt &tSrc,const TVideoStreamCap &tSimCapSet,TBasOutInfo &tOutInfo,u8 byMediaMode)
{
	TBasOutInfo tTempOutInfo;
	for ( u8 byLoop = 0; byLoop < MAXNUM_PERIEQP; byLoop++ )
	{
		CBasChn	*pBasChn = m_atConfBasChn[byLoop].GetBasChn();
		if ( NULL == pBasChn )
		{
			continue;
		}
		
		if ( !(pBasChn->GetSrc() ==tSrc)  )
		{
			continue;
		}

		if ( pBasChn->GetMediaMode() != byMediaMode )
		{
			continue;
		}

		THDAdaptParam atParam[MAXNUM_BASOUTCHN];
		u8 byCurrOutNum = 0;
		//获取适配参数
		if(!g_cMcuVcApp.GetBasOutPutParam(pBasChn->GetBas(), pBasChn->GetChnId(), byCurrOutNum, atParam))
		{
			continue;
		}

		//获取前面通道的输出通道数
		u8			  byFrontOutNum = 0;
		if ( !g_cMcuVcApp.GetBasChnFrontOutPutNum(pBasChn->GetBas(), pBasChn->GetChnId(),byCurrOutNum,byFrontOutNum) )
		{
			continue;
		}
	
		u8 byLastRes = 0;
		//选看除了MP4都严格比较分辨率、profietype、帧率，没有获得，将会在占用新通道时，去查找是否有同源可用通道
		for (u8 byOut = 0; byOut < byCurrOutNum; byOut++)
		{
			if (MODE_VIDEO == byMediaMode || MODE_SECVIDEO == byMediaMode)
			{
				if (tSimCapSet.GetMediaType() == atParam[byOut].GetVidType())
				{
					//适配参数和目的接收格式均为mp4不匹配分辨率(mp4编码既具有唯一性，同时模糊处理mp4_auto匹配)
					if (MEDIA_TYPE_MP4 == tSimCapSet.GetMediaType()  && MEDIA_TYPE_MP4 == atParam[byOut].GetVidType())
					{
						tOutInfo.m_tBasEqp     = pBasChn->GetBas();
						tOutInfo.m_byChnId = pBasChn->GetChnId();
						tOutInfo.m_byOutIdx = byOut;
						tOutInfo.m_byOutNum = byCurrOutNum;
						tOutInfo.m_byFrontOutNum = byFrontOutNum;
						return TRUE;
					}
					else if ( tSimCapSet.GetResolution() == GetResByWH(atParam[byOut].GetWidth(), atParam[byOut].GetHeight()) &&
							  tSimCapSet.GetUserDefFrameRate() == atParam[byOut].GetFrameRate()
							)
					{
						//非264格式，Pfofile属性为BP
						if ( tSimCapSet.GetH264ProfileAttrb() == atParam[byOut].GetProfileType() )
						{						
							tOutInfo.m_tBasEqp     = pBasChn->GetBas();
							tOutInfo.m_byChnId = pBasChn->GetChnId();
							tOutInfo.m_byOutIdx = byOut;
							tOutInfo.m_byOutNum = byCurrOutNum;
							tOutInfo.m_byFrontOutNum = byFrontOutNum;
							return TRUE;
						}
						else
						{
							if ( tSimCapSet.GetH264ProfileAttrb() > atParam[byOut].GetProfileType() )
							{
								byLastRes = GetResByWH(atParam[byOut].GetWidth(), atParam[byOut].GetHeight());
								tTempOutInfo.m_tBasEqp  = pBasChn->GetBas();
								tTempOutInfo.m_byChnId  = pBasChn->GetChnId();
								tTempOutInfo.m_byOutIdx = byOut;
								tTempOutInfo.m_byOutNum = byCurrOutNum;
								tTempOutInfo.m_byFrontOutNum = byFrontOutNum;
							}
						}
					}
					else if (  IsResGE( tSimCapSet.GetResolution(),GetResByWH(atParam[byOut].GetWidth(), atParam[byOut].GetHeight()) )
								&& tSimCapSet.GetUserDefFrameRate() >=atParam[byOut].GetFrameRate()
								&& tSimCapSet.GetH264ProfileAttrb() >=atParam[byOut].GetProfileType()
							 )
					{
						//分辨率取大
						if ( GetResByWH(atParam[byOut].GetWidth(), atParam[byOut].GetHeight()) > byLastRes )
						{
							byLastRes = GetResByWH(atParam[byOut].GetWidth(), atParam[byOut].GetHeight());
							tTempOutInfo.m_tBasEqp  = pBasChn->GetBas();
							tTempOutInfo.m_byChnId  = pBasChn->GetChnId();
							tTempOutInfo.m_byOutIdx = byOut;
							tTempOutInfo.m_byOutNum = byCurrOutNum;
							tTempOutInfo.m_byFrontOutNum = byFrontOutNum;
						}			
					}
				}
			}
		}
	}

	if ( !tTempOutInfo.m_tBasEqp.IsNull() )
	{
		tOutInfo.m_tBasEqp  = tTempOutInfo.m_tBasEqp ;
		tOutInfo.m_byChnId = tTempOutInfo.m_byChnId;
		tOutInfo.m_byOutIdx = tTempOutInfo.m_byOutIdx;
		tOutInfo.m_byOutNum = tTempOutInfo.m_byOutNum;
		tOutInfo.m_byFrontOutNum = tTempOutInfo.m_byFrontOutNum;
		return TRUE;
	}

	return FALSE;
}

/*====================================================================
函数名        FindBasChnForAudSel
功能        ：选看查找可用通道时严格比较分辨率
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/14	4.7			倪志俊		  创建
====================================================================*/
BOOL32	TMcuBasChnGrp::FindBasChnForAudSel(TMt &tSrc,const TAudioTypeDesc &tAudCap,TBasOutInfo &tOutInfo)
{
	for ( u8 byLoop = 0; byLoop < MAXNUM_PERIEQP; byLoop++ )
	{
		CBasChn	*pBasChn = m_atConfBasChn[byLoop].GetBasChn();
		if ( NULL == pBasChn )
		{
			continue;
		}
		
		if ( !(pBasChn->GetSrc() ==tSrc)  )
		{
			continue;
		}
		
		if ( pBasChn->GetMediaMode() != MODE_AUDIO )
		{
			continue;
		}
		
		TAudAdaptParam atParam[MAXNUM_BASOUTCHN];
		u8 byCurrOutNum = 0;
		//获取适配参数
		if(!g_cMcuVcApp.GetAudBasOutPutParam(pBasChn->GetBas(), pBasChn->GetChnId(), byCurrOutNum, atParam))
		{
			continue;
		}
		
		//获取前面通道的输出通道数
		u8			  byFrontOutNum = 0;
		if ( !g_cMcuVcApp.GetBasChnFrontOutPutNum(pBasChn->GetBas(), pBasChn->GetChnId(),byCurrOutNum,byFrontOutNum) )
		{
			continue;
		}
		
		u8 byLastRes = 0;
		for (u8 byOut = 0; byOut < byCurrOutNum; byOut++)
		{
			if (atParam[byOut].GetAudCodeType() != MEDIA_TYPE_NULL && 
				tAudCap.GetAudioMediaType() == atParam[byOut].GetAudCodeType() &&
				tAudCap.GetAudioTrackNum() == atParam[byOut].GetTrackNum()
				)
			{
				tOutInfo.m_tBasEqp  = pBasChn->GetBas();
				tOutInfo.m_byChnId = pBasChn->GetChnId();
				tOutInfo.m_byOutIdx = byOut;
				tOutInfo.m_byOutNum = byCurrOutNum;
				tOutInfo.m_byFrontOutNum = byFrontOutNum;
				return TRUE;
			}
		}
	}
	
	return FALSE;
}

/*====================================================================
函数名		   RefreshSpecialCapForBasBrd
功能        ： 
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuBasMgr::RefreshSpecialCapForVidBrd(TConfInfo &tConfInfo, TVideoStreamCap &tSimCapSet, u8 byMediaMode)
{
	return m_tBrdChn.RefreshSpecialVidCap(tConfInfo, tSimCapSet, byMediaMode );
}

/*====================================================================
函数名		   RefreshSpecialCapForAudBrd
功能        ： 
算法实现    ：
引用全局变量：
输入参数说明：TConfInfoEx &tConfInfoEx   会议勾选
TAudioTypeDesc tAudSrcCap   源能力
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuBasMgr::RefreshSpecialCapForAudBrd(TConfInfo &tConfInfo, TConfInfoEx &tConfInfoEx,TAudioTypeDesc &tAudSrcCap)
{
	return m_tBrdChn.RefreshSpecialAudCap(tConfInfo,tConfInfoEx, tAudSrcCap);
}

/*====================================================================
函数名		   RefreshBrdParam
功能        ： 
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuBasMgr::RefreshBrdParam(TConfInfo &tConfInfo, u8 byMediaMode,u16 wBiteRate)
{
	if ( byMediaMode != MODE_AUDIO &&
		 byMediaMode != MODE_VIDEO &&
		 byMediaMode != MODE_SECVIDEO
		)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CMcuBasMgr::RefreshBrdParam]byMediaMode:%d is illegal!\n");
		return FALSE;
	}

	return m_tBrdChn.RefreshAllChnsParam(tConfInfo, byMediaMode,wBiteRate);	
}

/*====================================================================
函数名		   StartBasAdapt
功能        ： 
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuBasMgr::StartBasAdapt(const TEqp &tEqp,u8 byChnId, TBasAdaptParamExt &tBasParamExt)
{
	u8 byIdx = 0;
	if ( m_tBrdChn.IsChnExist(tEqp,byChnId,byIdx) )
	{
		return m_tBrdChn.StartAdapt(tEqp,byChnId,tBasParamExt,byIdx);
	}
	else if ( m_tSelChn.IsChnExist(tEqp,byChnId,byIdx) )
	{
		return m_tSelChn.StartAdapt(tEqp,byChnId,tBasParamExt,byIdx);
	}

	return FALSE;
}

/*====================================================================
函数名		   StopBasSelAdapt
功能        ： 
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuBasMgr::StopBasAdapt(const TEqp &tEqp, u8 byChnId)
{
	if ( m_tBrdChn.StopAdapt(tEqp,byChnId) )
	{
		return TRUE;
	}
	else if (m_tSelChn.StopAdapt(tEqp,byChnId,TRUE))
	{
		return TRUE;
	}

	return FALSE;
}

/*====================================================================
函数名		   GetBasChnOutputNum
功能        ： 获得BAS输出通道数
算法实现    ：
引用全局变量：
输入参数说明：[in]TEqp tDiscBas		 BAS外设
			  [out]TNeedBasResData &tBasResData
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuBasMgr::GetBasResDataByEqp(TEqp tDiscBas, TNeedVidAdaptData *patBasResData)
{
	//目前只备份广播通道
	return m_tBrdChn.GetBasResDataByEqp(tDiscBas,patBasResData);
}

/*====================================================================
函数名		   GetBasResAudDataByEqp
功能        ： 获得BAS输出通道数
算法实现    ：
引用全局变量：
输入参数说明：[in]TEqp tDiscBas		 BAS外设
			  [out]TNeedVidAdaptData &tBasResData
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuBasMgr::GetBasResAudDataByEqp(TEqp tDiscBas, TNeedAudAdaptData *patBasResData)
{
	//目前只备份广播通道
	return m_tBrdChn.GetBasResAudDataByEqp(tDiscBas,patBasResData);
}

/*====================================================================
函数名		   ResignBasChn
功能        ： 主备重新分配BASCHN
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7			倪志俊		  创建
====================================================================*/
void CMcuBasMgr::ResignBasChn()
{
	m_tBrdChn.ResignBasChn();
	m_tSelChn.ResignBasChn();
}

/*====================================================================
函数名		   FindBasChnByCapForBrd
功能        ： 
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuBasMgr::FindBasChnByCapForVidBrd(const TVideoStreamCap &tSimCapSet, u8 byMediaMode, TBasOutInfo &tBasChnInfo, BOOL32 bIsExactMatch /* = FALSE */)
{
	return m_tBrdChn.FindBasChnForVidBrd(tSimCapSet,tBasChnInfo,byMediaMode,bIsExactMatch);
}

/*====================================================================
函数名		   FindBasChnByCapForAudBrd
功能        ： 
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/13  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuBasMgr::FindBasChnByCapForAudBrd(const TAudioTypeDesc &tAudCap, TBasOutInfo &tBasChnInfo)
{
	return m_tBrdChn.FindBasChnForAudBrd(tAudCap,tBasChnInfo);
}

/*====================================================================
函数名		   FindBasChnByCapForSel
功能        ： 
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuBasMgr::FindBasChnByVidCapForSel(TMt &tSrc,const TVideoStreamCap &tSimCapSet, u8 byMediaMode, TBasOutInfo &tBasChnInfo)
{
	return m_tSelChn.FindBasChnForVidSel(tSrc,tSimCapSet,tBasChnInfo,byMediaMode);
}

/*====================================================================
函数名		   FindBasChnByAudCapForSel
功能        ： 
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/14  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuBasMgr::FindBasChnByAudCapForSel(TMt &tSrc,const TAudioTypeDesc &tAudCap, TBasOutInfo &tBasChnInfo)
{
	return m_tSelChn.FindBasChnForAudSel(tSrc,tAudCap,tBasChnInfo);
}

/*====================================================================
函数名		   SetSelAudChnParam
功能        ： 选看通道下参
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/14  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuBasMgr::SetSelAudChnParam(const TEqp &tEqp, u8 byChnId, TAudAdaptParam &tBasParam)
{
	return m_tSelChn.SetSelAudChnParam(tEqp,byChnId,tBasParam);
}

/*====================================================================
函数名		   SetSelChnParam
功能        ： 选看通道下参
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuBasMgr::SetSelChnParam(const TEqp &tEqp, u8 byChnId, u8 byMediaMode, THDAdaptParam &tBasParam)
{
	return m_tSelChn.SetSelChnParam(tEqp,byChnId,byMediaMode,tBasParam);
}

/*====================================================================
函数名		   GetAllBrdChn
功能        ： 获得所有选看通道
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuBasMgr::GetAllSelChn(u8 &byNum, CBasChn **pcBasChn)
{
	return m_tSelChn.GetAllChn(byNum,pcBasChn);
}

/*====================================================================
函数名		   RefreshBasParambyOut
功能        ： 对通道某一出更新参数
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuBasMgr::RefreshBasParambyOut(TBasOutInfo &tBasOutInfo, THDAdaptParam &tBasParam)
{
	if (  m_tBrdChn.RefreshBasParambyOut(tBasOutInfo,tBasParam) )
	{
		return TRUE;
	}
	else
	{
		return m_tSelChn.RefreshBasParambyOut(tBasOutInfo,tBasParam);
	}
}


/*====================================================================
函数名		   AssignBrdChn
功能        ：分配广播bas通道
算法实现    ：
引用全局变量：
输入参数说明：TBasChnData atBasChn[] 广播预留的适配通道
			  u8	byChnNum		 适配通道数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuBasMgr::AssignBrdChn(CBasChn **aptBasChn,  TBasChnCapData *patBasChnCapData, u8 byChnNum, const CConfId &cConId)
{
	if ( NULL == aptBasChn )
	{
		return FALSE;
	}

	for (u8 byChnIdx = 0; byChnIdx < byChnNum; byChnIdx++)
	{
		if ( NULL == aptBasChn[byChnIdx] )
		{
			continue;
		}
		if (aptBasChn[byChnIdx]->GetBas().IsNull())
		{
			continue;
		}
		m_tBrdChn.AddChn(aptBasChn[byChnIdx],patBasChnCapData[byChnIdx],cConId);	
	}			
	return TRUE;
}

/*====================================================================
函数名		   AssignSelChn
功能        ：分配选看bas通道
算法实现    ：
引用全局变量：
输入参数说明：TBasChnData tBasChn    选看预留的适配通道
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuBasMgr::AssignSelChn(CBasChn *pcBasChn, const TBasChnCapData  &tBasChnCapData,const CConfId &cConId)
{	
	if ( NULL == pcBasChn )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[CMcuBasMgr::AssignSelChn]pcBasChn is NULL!\n");
		return FALSE;
	}
				
	if (pcBasChn->GetBas().IsNull())
	{
		return FALSE;
	}

	return m_tSelChn.AddChn(pcBasChn,tBasChnCapData,cConId);
}

/*====================================================================
函数名		   ReMoveBrdChn
功能        ：移除广播bas通道
算法实现    ：
引用全局变量：
输入参数说明：u8 byEqpId
			  u8 byChnId
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuBasMgr::ReMoveBrdChn(const TEqp &tEqp, u8 byChnId)
{
	return m_tBrdChn.ReMoveChn(tEqp, byChnId);
}

/*====================================================================
函数名		   ReMoveSelChn
功能        ：移除选看bas通道
算法实现    ：
引用全局变量：
输入参数说明：u8 byEqpId
			  u8 byChnId
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuBasMgr::ReMoveSelChn(const TEqp &tEqp, u8 byChnId)
{
	return m_tSelChn.ReMoveChn(tEqp, byChnId);
}

/*====================================================================
函数名		   AddBasSelChnParam
功能        ：
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp BAS外设
			  u8 byChnId        通道号
			  const TBasChnIdxParam &tBasChnIdxParam 参数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuBasMgr::AddBasSelChnParam(const TEqp &tEqp, u8 byChnId, const  TBasChnCapData &tBasChnIdxParam)
{
	return m_tSelChn.AddBasSelChnParam(tEqp,byChnId,tBasChnIdxParam);
}

/*====================================================================
函数名        SetBrdAdaptParam
功能        ：设置广播适配参数
算法实现    ：
引用全局变量：
输入参数说明：THDAdaptParam tParam  适配参数
			  u8 byMediaMode		媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
// BOOL32 CMcuBasMgr::SetBrdAdaptParam(const TConfInfo& tConfInfo, THDAdaptParam tParam, u8 byMediaMode)
// {
// 	//return m_tBrdChn.SetOutPutParam(tConfInfo, tParam, byMediaMode);	
// }

/*====================================================================
函数名      ClearBrdAdaptParam
功能        ：清空广播适配参数
算法实现    ：
引用全局变量：
输入参数说明：u8 byMediaMode  媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuBasMgr::ClearBrdAdaptParam(u8 byMediaMode)
{
	return m_tBrdChn.ClearAdaptParam(byMediaMode);
}

/*====================================================================
函数名				GetBrdChnGrp
功能        : 获取对应媒体模式的广播通道
算法实现    ：
引用全局变量：
输入参数说明：u8		   &byNum	    对应模式通道数
			  TBasChnData *ptBasChn		对应模式通道
			  u8           byMediaMode  媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuBasMgr::GetBrdChnGrp(u8 &byNum, CBasChn **pcBasChn, u8 byMediaMode)
{
	if (MODE_VIDEO    !=  byMediaMode &&
		MODE_SECVIDEO !=  byMediaMode &&
		MODE_AUDIO    !=  byMediaMode)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[TMcuBrdChnGrp][GetChn] unexpected Mode:%d!\n", byMediaMode);
		return FALSE;
	}
	return m_tBrdChn.GetChn(byNum, pcBasChn, byMediaMode);
} 

/*====================================================================
函数名			GetAllBrdChn
功能        : 获取所有V播通道
算法实现    ：
引用全局变量：
输入参数说明：u8			&byNum  所有广播通道数
			  TBasChnData *ptBasChn 所有广播通道
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuBasMgr::GetAllBrdChn(u8 &byNum, CBasChn **pcBasChn)
{
	return m_tBrdChn.GetAllChn(byNum, pcBasChn);
}

/*====================================================================
函数名			GetDiffBrdEqp
功能        :  获取广播适配占用的不同适配器信息
算法实现    ：
引用全局变量：
输入参数说明：
u8            byMediaMode
u8			&byEqpNum  广播占用的适配单板数
TEqp           *ptBas    广播占用的所有适配单板
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuBasMgr::GetDiffBrdEqp(u8 byMediaMode, u8 &byEqpNum, TEqp *ptBas)
{
	if (ptBas == NULL)
	{
		return FALSE;
	}
	
	if (MODE_VIDEO    !=  byMediaMode &&
		MODE_SECVIDEO !=  byMediaMode &&
		MODE_AUDIO    !=  byMediaMode)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[TMcuBrdChnGrp][GetDiffBrdEqp] unexpected Mode:%d!\n", byMediaMode);
		return FALSE;
	}
	
	byEqpNum = 0;
	u8 byNum = 0;
	CBasChn  *apcBasChn[MAXNUM_PERIEQP]={NULL};
	
	if (m_tBrdChn.GetChn(byNum, apcBasChn, byMediaMode))
	{
		for (u8 byIdx = 0; byIdx < byNum; byIdx++)
		{
			for (u8 byId = 0; byId < MAXNUM_PERIEQP; byId++)
			{
				if (ptBas[byId].IsNull())
				{
					byEqpNum ++;
					ptBas[byId] = apcBasChn[byIdx]->GetBas();
					break;
				}
				if(ptBas[byId].GetMtId() == apcBasChn[byIdx]->GetBas().GetMtId() )
				{
					break;
				}
			}
		}
	}
	
	return  byEqpNum != 0;
	
}
/*====================================================================
函数名           GetGrpType
功能        : 获取通道的所属组
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8    byChnId		通道Id	
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
u8 CMcuBasMgr::GetGrpType(const TEqp &tEqp, u8 byChnId)
{
	u8 byGrpType = CHN_ADPMODE_NONE;
	u8 byIdx = 0;
	if (m_tBrdChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		byGrpType = CHN_ADPMODE_BRD;
	}
	else if(m_tSelChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		byGrpType = CHN_ADPMODE_SEL;
	}
	return byGrpType;
}

/*====================================================================
函数名				SetChnMode
功能        : 设置对应通道D媒体模式
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
			  u8   byMediaMode  媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuBasMgr::SetChnMode(const TEqp &tEqp, u8 byChnId, u8 byMediaMode)
{
	u8 byIdx = 0;
	if (m_tBrdChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		return m_tBrdChn.SetChnMode(tEqp, byChnId, byMediaMode,byIdx);
	}
	else if(m_tSelChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		return m_tSelChn.SetChnMode(tEqp, byChnId, byMediaMode,byIdx);
	}
	return FALSE;
}

/*====================================================================
函数名				GetChnMode
功能        : 获取对应通道D媒体模式
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
u8 CMcuBasMgr::GetChnMode(const TEqp &tEqp, u8 byChnId)
{
	u8 byMode = MODE_NONE;
	u8 byIdx = 0;
	if (m_tBrdChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		byMode = m_tBrdChn.GetChnMode(tEqp, byChnId,byIdx);
	}
	else if(m_tSelChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		byMode = m_tSelChn.GetChnMode(tEqp, byChnId,byIdx);
	}	
	return byMode;
}

/*====================================================================
函数名				SetChnSrc
功能        : 设置对应适配通道D源信息
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
			  TMt    tSrc		源信息
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuBasMgr::SetChnSrc(const TEqp &tEqp, u8 byChnId, TMt tSrc)
{
	u8 byIdx=0;
	if (m_tBrdChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		return m_tBrdChn.SetChnSrc(tEqp, byChnId, tSrc,byIdx);
	}
	else if(m_tSelChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		return m_tSelChn.SetChnSrc(tEqp, byChnId,tSrc,byIdx);
	}
	return FALSE;
}

/*====================================================================
函数名				GetChnSrc
功能        : 获取对应适配通道D源信息
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
TMt CMcuBasMgr::GetChnSrc(const TEqp &tEqp, u8 byChnId)
{
	TMt tSrc;
	tSrc.SetNull();
	u8 byIdx =0;
	if (m_tBrdChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		tSrc = m_tBrdChn.GetChnSrc(tEqp, byChnId,byIdx);
	}
	else if(m_tSelChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		tSrc = m_tSelChn.GetChnSrc(tEqp, byChnId,byIdx);
	}
	return tSrc;
}

/*====================================================================
函数名      SetVcuTick
功能        : 设置tick
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
			  u32    dwTick     tick数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuBasMgr::SetVcuTick(const TEqp &tEqp, u8 byChnId, u32 dwTick)
{
	u8 byIdx = 0;
	if (m_tBrdChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		return m_tBrdChn.SetVcuTick(tEqp, byChnId, dwTick,byIdx);
	}
	else if(m_tSelChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		return m_tSelChn.SetVcuTick(tEqp, byChnId,dwTick,byIdx);
	}
	return FALSE;
}

/*====================================================================
函数名      GetVcuTick
功能        : 获取tick
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
u32 CMcuBasMgr::GetVcuTick(const TEqp &tEqp, u8 byChnId)
{
	u8 byIdx = 0;
	if (m_tBrdChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		return m_tBrdChn.GetVcuTick(tEqp, byChnId,byIdx);
	}
	else if(m_tSelChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		return m_tSelChn.GetVcuTick(tEqp, byChnId,byIdx);
	}
	return 0;
}

/*====================================================================
函数名			GetPosition
功能        : 获取指定通道索引
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
u8 CMcuBasMgr::GetPosition(const TEqp &tEqp, u8 byChnId)
{
	u8 byIdx = 0;
	if (m_tBrdChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		return byIdx;
	}
	else if(m_tSelChn.IsChnExist(tEqp, byChnId,byIdx))
	{
		return byIdx + MAXNUM_PERIEQP;
	}
	return 0xff;
}

/*====================================================================
函数名      GetSelChnGrp
功能        : 获取对应媒体模式的广播通道
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuBasMgr::GetSelChnGrp(u8 &byNum, CBasChn **pcBasChn, u8 byMediaMode)
{
	if (MODE_VIDEO    !=  byMediaMode &&
		MODE_SECVIDEO !=  byMediaMode &&
		MODE_AUDIO    !=  byMediaMode)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetSelChnGrp][GetChn] unexpected Mode:%d!\n", byMediaMode);
		return FALSE;
	}
	return m_tSelChn.GetChn(byNum, pcBasChn, byMediaMode);
}
/*====================================================================
函数名      Print
功能        ：bas管理类打印
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
void CMcuBasMgr::Print()
{
	StaticLog("----------Brd-Bas-Chn As Follows----------!\n");
	m_tBrdChn.Print();
	StaticLog("----------Sel-Bas-Chn As Follows----------!\n");
	m_tSelChn.Print();
	return;
}
/*====================================================================
函数名      : GetBasInPutChnNum
功能        : 获取bas输入通道数
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp 设信息

返回值说明  ：
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  06/21/2010              周嘉麟         创建
====================================================================*/
u8 CMcuVcData::GetBasInPutChnNum(const TEqp &tEqp)
{
	if (tEqp.IsNull())
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasInPutChnNum] tEqp is null!\n");
		return 0;
	}
	
	TPeriEqpStatus tBasStatus;
	if(!GetPeriEqpStatus(tEqp.GetEqpId(), &tBasStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasInPutChnNum] GetPeriEqpStatus-->EqpId:%d failed!\n", tEqp.GetEqpId());
		return 0;	
	}
	u8 byInputChnNum = 0;
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if (g_cMcuAgent.IsEqpBasHD(tEqp.GetEqpId()))
#endif
	{
		u8 byBasType = tBasStatus.m_tStatus.tHdBas.GetEqpType();
		
		switch (byBasType)
		{
		case TYPE_MPU2_BASIC:
			byInputChnNum = MAXNUM_MPU2_BASIC_CHN;
			break;
		case TYPE_MPU2_ENHANCED:
			byInputChnNum = MAXNUM_MPU2_EHANCED_CHN;
			break;
		case TYPE_MPU:
			byInputChnNum = MAXNUM_MPU_CHN;
			break;
		case TYPE_MPU_H:
			byInputChnNum = MAXNUM_MPU_H_CHN;
			break;
		case TYPE_MAU_NORMAL:
		case TYPE_MAU_H263PLUS:
			byInputChnNum = MAXNUM_MAU_VDCHN;
			break;
		case TYPE_8KE_BAS:
			byInputChnNum = MAXNUM_8KEBAS_INPUT;
			break;
		case TYPE_8KH_BAS:
			byInputChnNum = MAXNUM_8KHBAS_INPUT;
			break;
		case TYPE_8KI_VID_BAS:
			byInputChnNum = MAXNUM_8KIBAS_INPUT;
			break;
		default:			
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasInPutChnNum] unexpected BasType:%d!\n", byBasType);
						
			break;
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else if ( g_cMcuAgent.IsEqpBasAud(tEqp.GetEqpId())  )
#endif
	{
		u8 byAudType = tBasStatus.m_tStatus.tAudBas.GetEqpType();
		if (byAudType == TYPE_APU2_BAS || byAudType == TYPE_8KI_AUD_BAS )
		{
			byInputChnNum = byAudType == TYPE_APU2_BAS ? MAXNUM_APU2_BASCHN:MAXNUM_8KIAUDBAS_INPUT;
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else
	{
		byInputChnNum = MAXNUM_VPU_OUTPUT;
	}
#endif
	
	return byInputChnNum;
}

/*====================================================================
函数名      AddMcuIdleBasChnlInfo
功能        ：统计各类型BAS信息
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8      byChnId   通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30     4.6        周嘉麟          创建
2011/12/14   4.7        倪志俊			修改
====================================================================*/
void CMcuVcData::AddMcuBasChnlInfo(const TEqp &tEqp, u8 byChnId)
{
	if (tEqp.IsNull())
	{
		LogPrint( LOG_LVL_ERROR, MID_MCU_BAS, "[AddMcuBasChnlInfo] tEqp is null!\n");
		return;
	}

	if (tEqp.GetEqpId() < BASID_MIN || tEqp.GetEqpId() > BASID_MAX)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[AddMcuBasChnlInfo] unexpected bas EqpId:%d!\n", tEqp.GetEqpId());
		return;
	}

	TPeriEqpStatus tBasStatus;
	if ( !g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tBasStatus) )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[AddMcuBasChnlInfo] GetPeriEqpStatus failed!\n");
		return ;
	}

	u8 byBasType = 0;
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if (g_cMcuAgent.IsEqpBasHD(tEqp.GetEqpId()))
#endif
	{
		byBasType = tBasStatus.m_tStatus.tHdBas.GetEqpType();
	}

#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if (g_cMcuAgent.IsEqpBasAud(tEqp.GetEqpId()))
	{
		byBasType = tBasStatus.m_tStatus.tAudBas.GetEqpType();
	}
#endif
	
	LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[AddMcuBasChnlInfo]InsertBasChn(%d-%d) type:%d!\n",
		tEqp.GetEqpId(), byChnId,byBasType
			);

	if (m_cBasChnListMgr.IsNodeExist(tEqp, byChnId,TRUE))
	{
		LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[AddMcuBasChnlInfo]tEqp:%d chnid:%d type:%d has been existed!\n",
				 tEqp.GetEqpId(), byChnId,byBasType
				);
		return ;
	}

	if ( !m_cBasChnListMgr.InsertBasChn(tEqp, byChnId) )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[AddMcuBasChnlInfo]InsertBasChn(%d-%d) type:%d failed!\n",
				 tEqp.GetEqpId(), byChnId,byBasType
				);
		return ;
	}

	return;
}

/*====================================================================
函数名      IsBasChnlEnoughForConf
功能        ：开启会议的bas资源是否充足
算法实现    ：
引用全局变量：
输入参数说明：const TConfInfo   &tConfInfo       会议信息
			  const TConfInfoEx &tConfInfoEx	 会议扩展能力集勾选信息 
			  CBasChn **patBasChnConfNeed		返回会议需要的适配通道指针数组
			  TBasChnIdxParam *ptBasChnParam	返回会议需要的适配通道对应的参数
返回值说明  ： 成功返回TRUE 
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30     4.6        周嘉麟          创建
2011/12/20   4.7		倪志俊			修改
====================================================================*/
BOOL32 CMcuVcData::IsBasChnlEnoughForConf(const TConfInfo &tConfInfo, const TConfInfoEx &tConfInfoEx, 
										  CBasChn **patBasChnConfNeed,  TBasChnCapData *ptBasChnCapData,u16 &wErrorCode)
{
	TNeedVidAdaptData atReqResource[emMODE_END];	//主流视频、主流音频、双流
	TNeedAudAdaptData tAudReqResource;

	if ( !GetBasCapConfNeed(tConfInfo, tConfInfoEx, atReqResource,&tAudReqResource) )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[IsBasChnlEnoughForConf]GetBasCapConfNeed failed\n");
		return FALSE;
	}

	if ( m_cBasChnListMgr.CheckBasEnoughForReq(atReqResource,&tAudReqResource, patBasChnConfNeed, ptBasChnCapData,wErrorCode) )
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

/*====================================================================
函数名      IsBasChnEnoughForReplace
功能        ：根据掉链的适配通道获取对等能力的替代通道
算法实现    ：
引用全局变量：
输入参数说明：      const TConfInfo   &tConfInfo       会议信息
返回值说明  ：      TBasChnData *ptMvBasConfNeed       交叉备份适配通道
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30     4.6        周嘉麟          创建
====================================================================*/
BOOL32 CMcuVcData::IsBasChnEnoughForReq(TNeedVidAdaptData *ptReqResData, TNeedAudAdaptData *pReqAudResource,CBasChn **ptNeedChns, TBasChnCapData*ptBasChnCapData)
{
	u16 wErrorCode = ERR_MCU_NOENOUGH_HDBAS_CONF;
	return	m_cBasChnListMgr.CheckBasEnoughForReq(ptReqResData,pReqAudResource,ptNeedChns,ptBasChnCapData,wErrorCode);
}

/*====================================================================
函数名      GetBasChnAddr
功能        ：根据掉链的适配通道获取对等能力的替代通道
算法实现    ：
引用全局变量：
输入参数说明：      const TConfInfo   &tConfInfo       会议信息
返回值说明  ：      TBasChnData *ptMvBasConfNeed       交叉备份适配通道
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/03/29   4.7        倪志俊          创建
====================================================================*/
CBasChn* CMcuVcData::GetBasChnAddr(const TEqp &tEqp, u8 byChnId)
{
	return	m_cBasChnListMgr.GetBasChnAddr(tEqp,byChnId);
}

/*====================================================================
函数名        GetBasCapConfNeed
功能        ：获取会议编解码能力集
算法实现    ：
引用全局变量：
输入参数说明：[in]const TConfInfo &tConfInfo		  会议信息
			  [in]const TConfInfoEx &tConfInfoEx,     会议勾选额外信息
			  [out]TNeedBasResData *ptMVReqResource   返回编解码信息
			  [in] u8  byMediaNum					  媒体类型个数							
			  
返回值说明  ：成功获得编解码信息返回TRUE,失败返回FALSE
					
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/26  4.7			倪志俊		   创建
====================================================================*/
BOOL32 CMcuVcData::GetBasCapConfNeed(const TConfInfo &tConfInfo,const TConfInfoEx &tConfInfoEx, 
									 TNeedVidAdaptData *ptReqResource,TNeedAudAdaptData *pReqAudResource)
{	
	if (  NULL == ptReqResource || NULL == pReqAudResource )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[GetBasCapConfNeed]pReqAudResource or pReqAudResource is NULL!\n");
		return FALSE;
	}
		
	//1.获得会议解码能力(获得主流视频与双流能力解码能力，音频解码能力最后获得)
	u8 byIdx = 0;
	for ( byIdx = emMODE_VIDEO; byIdx < (emMODE_END); byIdx++ )
	{
		if (  byIdx == emMODE_VIDEO && tConfInfo.GetMainVideoMediaType() == MEDIA_TYPE_H261 )
		{
			ptReqResource[byIdx].m_byDecNeedRes = (u8)1 << CBasChn::emDecH261;
		}
		else if (tConfInfo.GetProfileAttrb() == emHpAttrb)
		{
			//8kh双流通道支持解HP，但不支持解高帧率，所以这里针对HP做特殊处理，记录解码能力emDecHighFps
#ifdef _8KH_
			if ( byIdx == emMODE_SECVIDEO && IsDSFR50OR60(tConfInfo))
			{
				ptReqResource[byIdx].m_byDecNeedRes = (u8)1 <<CBasChn::emDecHighFps;
			}
			else
			{
				ptReqResource[byIdx].m_byDecNeedRes = (u8)1 <<CBasChn::emDecHp;
			}
#else
			ptReqResource[byIdx].m_byDecNeedRes = (u8)1 <<CBasChn::emDecHp;
#endif
		
		}
		else if ( tConfInfo.GetProfileAttrb() == emBpAttrb )
		{
			BOOL32 bHighFps = FALSE;
			if ( byIdx == emMODE_VIDEO )
			{
				bHighFps= IsConfFR50OR60(tConfInfo);
			}
			else if ( byIdx == emMODE_SECVIDEO )
			{
				bHighFps= IsDSFR50OR60(tConfInfo);
			}

			BOOL32 bMainMediaH264   =  tConfInfo.GetMainVideoMediaType() == MEDIA_TYPE_H264;
			BOOL32 bSecMediaH264	=  tConfInfo.GetSecVideoMediaType() != MEDIA_TYPE_NULL &&
									   tConfInfo.GetSecVideoMediaType() == MEDIA_TYPE_H264;
			if(bHighFps)
			{
				//双流的解码能力做下特殊处理，为了兼容以前的规格
				//以前：高帧率会议 双流同主视频 才认为需要highfps解码能力的通道，否则其他情况只占hd解码能力的即可
				//现在：现在没有同主视频的适配，故认为只要双流主格式不是50/60的话，解码能力可修改成hd
				if ( byIdx ==emMODE_SECVIDEO &&
					tConfInfo.GetCapSupport().GetDStreamCapSet().GetVideoStremCap().GetUserDefFrameRate() <= 30)
				{
					ptReqResource[byIdx].m_byDecNeedRes= (u8)1 <<CBasChn::emDecHD;
				}
				else
				{
					ptReqResource[byIdx].m_byDecNeedRes= (u8)1 <<CBasChn::emDecHighFps;
				}
			}
			else if((IsResGE(tConfInfo.GetMainVideoFormat(), VIDEO_FORMAT_4CIF) && bMainMediaH264) ||
				(IsResGE(tConfInfo.GetSecVideoFormat(), VIDEO_FORMAT_4CIF) && bSecMediaH264))
			{
				ptReqResource[byIdx].m_byDecNeedRes = (u8)1 <<CBasChn::emDecHD;
			}
			else
			{
				ptReqResource[byIdx].m_byDecNeedRes = (u8)1 <<CBasChn::emDecSD;
			}
		}
		else
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasCapConfNeed]tConfInfo.GetProfileAttrb() failed!\n");
			return FALSE;
		}
	}

	//2. 获得主流视频所需编码能力
	u8	byStartIdx = 0;		//设置编码idx的起始位置记录
	ptReqResource[emMODE_VIDEO].m_byMediaMode = MODE_VIDEO;

	//预留主格式
	if ( IsConfNeedReserveMainCap(tConfInfo,tConfInfoEx) )
	{
		//8000H 主格式1080 60，由于能力限制，需要将帧率减半作假
		TVideoStreamCap tTempVideoCap = tConfInfo.GetMainSimCapSet().GetVideoCap();
#ifdef _8KH_		
		if ( tConfInfo.GetProfileAttrb() == emHpAttrb )
		{	
			// HP的话能力填 720 30 HP
			tTempVideoCap.SetResolution(VIDEO_FORMAT_HD720);
			tTempVideoCap.SetH264ProfileAttrb(emHpAttrb);			
			ptReqResource[emMODE_VIDEO].SetVieoSimCapSet( byStartIdx, tTempVideoCap );
		}
		else
		{
			ptReqResource[emMODE_VIDEO].SetVieoSimCapSet( byStartIdx, tTempVideoCap );
		}
#elif defined(_8KI_)
		if( tTempVideoCap.GetResolution() == VIDEO_FORMAT_HD1080 &&
				tTempVideoCap.GetUserDefFrameRate() > 30 
			)
		{
			tTempVideoCap.SetUserDefFrameRate( tTempVideoCap.GetUserDefFrameRate() / 2 );
		}
		ptReqResource[emMODE_VIDEO].SetVieoSimCapSet( byStartIdx, tTempVideoCap );		
#else
		ptReqResource[emMODE_VIDEO].SetVieoSimCapSet( byStartIdx, tTempVideoCap );
#endif
		
		byStartIdx++;
		LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[GetBasCapConfNeed]reserve MainVideoCap:mediatype:%d-res:%d-profile:%d-userframe:%d-biterate:%d !\n",
				tTempVideoCap.GetMediaType(), 
				tTempVideoCap.GetResolution(),
				tTempVideoCap.GetH264ProfileAttrb(),
				tTempVideoCap.GetUserDefFrameRate(),
				tTempVideoCap.GetMaxBitRate()
					);	
	}

	//获得主流模板勾选
	TVideoStreamCap tVideoCap[MAX_CONF_CAP_EX_NUM];
	u8 byCapNUm = MAX_CONF_CAP_EX_NUM;
	if ( tConfInfoEx.GetMainStreamCapEx(tVideoCap,byCapNUm) )
	{
		for ( byIdx = 0; byIdx<byCapNUm; byIdx++)
		{
			if ( tVideoCap[byIdx].GetMediaType() == MEDIA_TYPE_NULL )
			{
				continue;
			}
			//8000H由于能力限制，如果勾选的是720 60的话，需要将帧率减半
#ifdef _8KH_
			//勾选有HP过滤掉，因为主格式预留逻辑中已经强行预留720 30 HP,此处无需预留
			if ( tVideoCap[byIdx].GetH264ProfileAttrb() == emHpAttrb )
			{
				continue;
			}
			else
			{
				ptReqResource[emMODE_VIDEO].SetVieoSimCapSet(byStartIdx,tVideoCap[byIdx]);
			}
#elif defined(_8KI_)
		if( (tVideoCap[byIdx].GetResolution() == VIDEO_FORMAT_HD720 ||
			tVideoCap[byIdx].GetResolution() == VIDEO_FORMAT_HD1080) &&
				tVideoCap[byIdx].GetUserDefFrameRate() > 30 
			)
		{
			tVideoCap[byIdx].SetUserDefFrameRate( tVideoCap[byIdx].GetUserDefFrameRate() / 2 );
		}
		ptReqResource[emMODE_VIDEO].SetVieoSimCapSet( byStartIdx, tVideoCap[byIdx] );
#else		
			//设置勾选能力
			ptReqResource[emMODE_VIDEO].SetVieoSimCapSet(byStartIdx,tVideoCap[byIdx]);
#endif
			byStartIdx++;	
			LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[GetBasCapConfNeed]reserve video cap:mediatype:%d-res:%d-profile:%d-userframe:%d-biterate:%d !\n",
				tVideoCap[byIdx].GetMediaType(), 
				tVideoCap[byIdx].GetResolution(),
				tVideoCap[byIdx].GetH264ProfileAttrb(),
				tVideoCap[byIdx].GetUserDefFrameRate(),
				tVideoCap[byIdx].GetMaxBitRate()
					);	
		}
	}
	else
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[GetBasCapConfNeed]tConfInfoEx.GetMainStreamCapEx failed!\n");
		return FALSE;
	}

	//记录编码路数
	ptReqResource[emMODE_VIDEO].m_byRealEncNum = byStartIdx;

	//最后预留辅格式	
	if ( tConfInfo.GetSecVideoMediaType()!= MEDIA_TYPE_NULL )
	{
		ptReqResource[emMODE_VIDEO].SetVieoSimCapSet( byStartIdx, tConfInfo.GetSecSimCapSet().GetVideoCap() );
		LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[GetBasCapConfNeed]reserve SecVideoCap:mediatype:%d-res:%d-profile:%d-userframe:%d-biterate:%d !\n",
			tConfInfo.GetSecSimCapSet().GetVideoMediaType(), 
			tConfInfo.GetSecSimCapSet().GetVideoResolution(),
			tConfInfo.GetSecSimCapSet().GetVideoProfileType(),
			tConfInfo.GetSecSimCapSet().GetUserDefFrameRate(),
			tConfInfo.GetSecSimCapSet().GetVideoMaxBitRate()
			);	
		byStartIdx++;
		ptReqResource[emMODE_VIDEO].m_byRealEncNum = byStartIdx;
	}

	//如果同时存在720 30fps 和720 60fps 则去除该路720 60fps的idx
#ifndef _8KI_
#if defined(_8KH_)
	ptReqResource[emMODE_VIDEO].Filter720P60FPSOnlyFor8KH();
#else
	ptReqResource[emMODE_VIDEO].Filter720P60FPS();
#endif
#endif

	
	//3.获得双流所需编码能力
	byStartIdx = 0;
	ptReqResource[emMODE_SECVIDEO].m_byMediaMode = MODE_SECVIDEO;
	//预留主格式
	if ( IsConfNeedReserveDSMainCap(tConfInfo,tConfInfoEx) )
	{
		if ( IsConfDualEqMV(tConfInfo) )//同主视频双速会议预留主流主格式
		{
			ptReqResource[emMODE_SECVIDEO].SetVieoSimCapSet(byStartIdx, tConfInfo.GetMainSimCapSet().GetVideoCap());	
#if	defined(_8KE_) || defined(_8KH_) //8KH 8kG能力作假
			ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetResolution(VIDEO_FORMAT_CIF);
			ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetUserDefFrameRate(25);
			ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetH264ProfileAttrb(emBpAttrb);
#endif

#if defined(_8KI_)
			if( tConfInfo.GetMainSimCapSet().GetVideoCap().GetResolution() >= VIDEO_FORMAT_HD720 )
			{
				u8 byFrameRate = tConfInfo.GetMainSimCapSet().GetVideoCap().GetUserDefFrameRate();
				if( byFrameRate >= 50 )
				{
					byFrameRate = byFrameRate / 2;
				}
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetResolution(VIDEO_FORMAT_HD720);
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetUserDefFrameRate(byFrameRate);
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetH264ProfileAttrb(emBpAttrb);
			}
#endif

			LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[GetBasCapConfNeed]reserve DSDualMainCap:mediatype:%d-res:%d-profile:%d-userframe:%d-biterate:%d !\n",
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].GetMediaType(),
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].GetResolution(),
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].GetH264ProfileAttrb(),
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].GetUserDefFrameRate(),
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].GetMaxBitRate()
				);
			byStartIdx++;
		}
		else
		{
			ptReqResource[emMODE_SECVIDEO].SetVieoSimCapSet(byStartIdx, tConfInfo.GetCapSupport().GetDStreamCapSet().GetVideoStremCap());
			if ( ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].GetResolution() == VIDEO_FORMAT_VGA ||
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].GetResolution() == VIDEO_FORMAT_SVGA
				)
			{
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetResolution(VIDEO_FORMAT_XGA);
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetUserDefFrameRate(5);
			}
#if	defined(_8KE_) || defined(_8KH_)
			ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetResolution(VIDEO_FORMAT_XGA);
			ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetUserDefFrameRate(5);
			ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetH264ProfileAttrb(emBpAttrb);
#endif

#if defined(_8KI_)
			if( tConfInfo.GetCapSupport().GetDStreamCapSet().GetVideoStremCap().GetMediaType() == MEDIA_TYPE_H264 )
			{				
				emProfileAttrb emProfile = emHpAttrb;
				if( IsConfHasBpCapOrBpExCap(tConfInfo,tConfInfoEx) )
				{
					emProfile = emBpAttrb;
				}
				
				if( Is8KINeedDsAdaptH264SXGA(tConfInfo) )
				{
					ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetResolution(VIDEO_FORMAT_SXGA);
					ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetUserDefFrameRate(20);					
					ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetH264ProfileAttrb(emProfile);						
				}
				else
				{
					if( tConfInfoEx.IsDSSupportCapEx( VIDEO_FORMAT_XGA,5,emBpAttrb ) )
					{						
						ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetResolution(VIDEO_FORMAT_XGA);
						ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetUserDefFrameRate(5);
						ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetH264ProfileAttrb(emBpAttrb);						
					}
					else if(  tConfInfoEx.IsDSSupportCapEx( VIDEO_FORMAT_XGA,5,emHpAttrb ) )
					{
						ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetResolution(VIDEO_FORMAT_XGA);
						ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetUserDefFrameRate(5);
						ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetH264ProfileAttrb(emHpAttrb);
					}
				}			
			}
#endif
			LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[GetBasCapConfNeed]reserve DSMainCap:mediatype:%d-res:%d-profile:%d-userframe:%d-biterate:%d !\n",
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].GetMediaType(),
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].GetResolution(),
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].GetH264ProfileAttrb(),
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].GetUserDefFrameRate(),
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].GetMaxBitRate()
				);	
			byStartIdx++;
		}
	}

	//获得双流模板勾选
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	TVideoStreamCap tSecVideoCap[MAX_CONF_CAP_EX_NUM];
	u8 byDSCapNum = MAX_CONF_CAP_EX_NUM;
	if ( tConfInfoEx.GetDoubleStreamCapEx(tSecVideoCap,byDSCapNum) )
	{
		for ( byIdx = 0; byIdx<byDSCapNum; byIdx++)
		{
			if ( tSecVideoCap[byIdx].GetMediaType() == MEDIA_TYPE_NULL )
			{
				continue;
			}
			//设置勾选能力
			ptReqResource[emMODE_SECVIDEO].SetVieoSimCapSet(byStartIdx,tSecVideoCap[byIdx]);
			byStartIdx++;

			LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[GetBasCapConfNeed]reserve ds video cap:mediatype:%d-res:%d-profile:%d-userframe:%d-biterate:%d !\n",
				tSecVideoCap[byIdx].GetMediaType(), 
				tSecVideoCap[byIdx].GetResolution(),
				tSecVideoCap[byIdx].GetH264ProfileAttrb(),
				tSecVideoCap[byIdx].GetUserDefFrameRate(),
				tSecVideoCap[byIdx].GetMaxBitRate()
					);	
		}
	}
	else
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[GetBasCapConfNeed]tConfInfoEx.GetDoubleStreamCapEx failed!\n");
		return FALSE;
	}
#endif
	
	//记录编码路数
	ptReqResource[emMODE_SECVIDEO].m_byRealEncNum = byStartIdx;

	//双双流预留 辅格式
	BOOL32  bDoubleDual= IsConfDoubleDual(tConfInfo);
	if ( bDoubleDual && tConfInfo.GetDStreamUsrDefFPS() >= 5 )
	{
		//辅格式双流预留
		ptReqResource[emMODE_SECVIDEO].SetVieoSimCapSet(byStartIdx,tConfInfo.GetCapSupportEx().GetSecDSVideoCap());
		//H263+使用宏定义，在BAS外设处会根据宏调整成实际帧率，目前都是5帧,
		ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetFrameRate(VIDEO_FPS_2997_6);
		//H263+ 分辨率此处调整成XGA
		ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetResolution(VIDEO_FORMAT_XGA);
		byStartIdx++;
		ptReqResource[emMODE_SECVIDEO].m_byRealEncNum = byStartIdx;
		LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[GetBasCapConfNeed]reserve DoubleDual\n");
	}
#ifdef _8KI_
	else
	{
		if( Is8KINeedDsAdaptH264SXGA(tConfInfo) )
		{
			if( tConfInfoEx.IsDSSupportCapEx( VIDEO_FORMAT_XGA,5,emBpAttrb ) )
			{
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetMediaType( MEDIA_TYPE_H264 );
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetResolution(VIDEO_FORMAT_XGA);
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetUserDefFrameRate(5);
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetH264ProfileAttrb(emBpAttrb);
				byStartIdx++;
				ptReqResource[emMODE_SECVIDEO].m_byRealEncNum = byStartIdx;
			}
			else if( tConfInfoEx.IsDSSupportCapEx( VIDEO_FORMAT_XGA,5,emHpAttrb ) )
			{
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetMediaType( MEDIA_TYPE_H264 );
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetResolution(VIDEO_FORMAT_XGA);
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetUserDefFrameRate(5);
				ptReqResource[emMODE_SECVIDEO].m_atSimCapSet[byStartIdx].SetH264ProfileAttrb(emHpAttrb);
				byStartIdx++;
				ptReqResource[emMODE_SECVIDEO].m_byRealEncNum = byStartIdx;
			}
		}
	}
#endif

	//如果同时存在720 30fps 和720 60fps 则去除该路720 60fps的idx
	ptReqResource[emMODE_SECVIDEO].Filter720P60FPS();
	
	//4.音频适配获得
	u8 byAudTypeNum = 0;
	TAudioTypeDesc atAudTypeDesc[MAXNUM_CONF_AUDIOTYPE];
	byAudTypeNum = tConfInfoEx.GetAudioTypeDesc(atAudTypeDesc);
	if ( byAudTypeNum > 1 ) //音频能力集个数大于1，说明需要音频适配
	{
		memcpy(pReqAudResource->m_atAudTypeDesc,atAudTypeDesc,sizeof(atAudTypeDesc));
		pReqAudResource->m_byNeedAudEncNum = byAudTypeNum-1;		
		for ( u8 byLoop=0 ; byLoop<byAudTypeNum; byLoop++ )
		{
			LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[GetBasCapConfNeed]conf all audiotype:mediatype-%d-tracknum-%d\n",atAudTypeDesc[byLoop].GetAudioMediaType(), atAudTypeDesc[byLoop].GetAudioTrackNum() );	
		}
	}
	else
	{
		pReqAudResource->m_byNeedAudEncNum = 0;
	}

	return TRUE;
}

/*====================================================================
函数名        OcuppyBasChn
功能        ：占用广播bas通道
算法实现    ：
引用全局变量：
输入参数说明：TBasChnData atBasChn[] 广播适配通道
			  u8 byChnNum			 通道数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuVcData::OcuppyBasChn(CBasChn **aptBasChn, u8 byChnNum )
{
	if ( NULL == aptBasChn)
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[CMcuVcData::OcuppyBasChn]aptBasChn is NULL!\n");
		return FALSE;
	}

	for (u8 byChnIdx = 0; byChnIdx < byChnNum; byChnIdx++)
	{
		if (NULL == aptBasChn[byChnIdx])
		{
			continue;
		}
		if (aptBasChn[byChnIdx]->GetBas().IsNull())
		{
			continue;
		}
		OcuppyBasChn(aptBasChn[byChnIdx]->GetBas().GetEqpId(), aptBasChn[byChnIdx]->GetChnId());		
	}
	return TRUE;
}


/*====================================================================
函数名        OcuppyBasChn
功能        ：单个占用bas通道
算法实现    ：
引用全局变量：
输入参数说明：u8 byEqpId 外设Id
			  u8 byChnId 通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuVcData::OcuppyBasChn(u8 byEqpId, u8 byChnId)
{
	TPeriEqpStatus tBasStatus;
	if(!GetPeriEqpStatus(byEqpId, &tBasStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[OcuppyBasChn] GetPeriEqpStatus<EqpId:%d> failed!\n", byEqpId);
		return FALSE;
	}
	TAudBasChnStatus *pAudBasChn = NULL;
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if (g_cMcuAgent.IsEqpBasHD(byEqpId))
#endif
	{
		THDBasVidChnStatus *ptHDVid = NULL;
		switch (tBasStatus.m_tStatus.tHdBas.GetEqpType())
		{
		case TYPE_MPU2_BASIC:
		case TYPE_MPU2_ENHANCED:
			{
				ptHDVid = tBasStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnId);
				if (NULL != ptHDVid)
				{
					ptHDVid->SetIsReserved(TRUE);
				}
				else
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[OcuppyBasChn][TYPE_MPU] ptHDVid<EqpId:%d> is null!\n", byEqpId);
					return FALSE;
				}
			}
			break;
		case TYPE_MPU:
		case TYPE_MPU_H:
			{
				ptHDVid = tBasStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId);
				if (NULL != ptHDVid)
				{
					ptHDVid->SetIsReserved(TRUE);
				}
				else
				{
			    	LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[OcuppyBasChn][TYPE_MPU] ptHDVid<EqpId:%d> is null!\n", byEqpId);
					return FALSE;
				}
			}					
			break;
		case TYPE_MAU_NORMAL:
			{
				ptHDVid = tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnId);
				if (NULL != ptHDVid)
				{
					ptHDVid->SetIsReserved(TRUE);
				}
				else
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[OcuppyBasChn][TYPE_MAU_NORMAL] ptHDVid<EqpId:%d> is null!\n", byEqpId);
					return FALSE;
				}
			}			
			break;
		case TYPE_MAU_H263PLUS:
			{
				ptHDVid = tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(byChnId);
				if (NULL != ptHDVid)
				{
					ptHDVid->SetIsReserved(TRUE);
				}
				else
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[OcuppyBasChn][TYPE_MAU_H263PLUS] ptHDVid<EqpId:%d> is null!\n", byEqpId);
					return FALSE;
				}
			}
			break;
		case TYPE_8KE_BAS:
			{	
				ptHDVid = tBasStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0);
				if (NULL != ptHDVid)
				{
					ptHDVid->SetIsReserved(TRUE);
				}
				else
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[OcuppyBasChn][TYPE_8KE_BAS] ptHDVid<EqpId:%d> is null!\n", byEqpId);
					return FALSE;
				}
			}
			break;
		case TYPE_8KH_BAS:
			{	
				ptHDVid = tBasStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0);
				if (NULL != ptHDVid)
				{
					ptHDVid->SetIsReserved(TRUE);
				}
				else
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[OcuppyBasChn][TYPE_8KH_BAS] ptHDVid<EqpId:%d> is null!\n", byEqpId);	
					return FALSE;
				}
			}
			break;
		case TYPE_8KI_VID_BAS:
			{	
				ptHDVid = tBasStatus.m_tStatus.tHdBas.tStatus.t8kiBas.GetVidChnStatus(0);
				if (NULL != ptHDVid)
				{
					ptHDVid->SetIsReserved(TRUE);
				}
				else
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[OcuppyBasChn][TYPE_8KH_BAS] ptHDVid<EqpId:%d> is null!\n", byEqpId);	
					return FALSE;
				}
			}
			break;
		default:			
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[OcuppyBasChn] unexpected BasType:%d!\n", 
				tBasStatus.m_tStatus.tHdBas.GetEqpType());
			}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
			return FALSE;
#endif
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else if ( g_cMcuAgent.IsEqpBasAud(byEqpId)  )
#endif
	{
		u8 byAudType = tBasStatus.m_tStatus.tAudBas.GetEqpType();
		if (byAudType == TYPE_APU2_BAS || byAudType == TYPE_8KI_AUD_BAS )
		{	
			if( byAudType == TYPE_APU2_BAS )
			{
				pAudBasChn = tBasStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.GetAudChnStatus(byChnId);
			}
			else
			{
				pAudBasChn = tBasStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChnId);
			}
			
			if (NULL != pAudBasChn)
			{
				pAudBasChn->SetIsReserved(TRUE);
			}
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else
	{
		tBasStatus.m_tStatus.tBas.tChnnl[byChnId].SetReserved(TRUE);
	}	
#endif
	SetPeriEqpStatus(byEqpId, &tBasStatus);
	
	//2. 占用bas链表结点reserved
	return m_cBasChnListMgr.OcuppyBasChn(byEqpId, byChnId);
}

/*====================================================================
函数名      ReleaseBasChn
功能        ：释放占用BAS通道
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
08/11/09    4.5         周嘉麟        创建
====================================================================*/
void CMcuVcData::ReleaseBasChn(const TEqp &tEqp, u8 byChnId)
{
	if (!IsPeriEqpValid(tEqp.GetEqpId()))
    {
        return;
    }
	TPeriEqpStatus *ptStatus = NULL;
	ptStatus = &(m_atPeriEqpTable[tEqp.GetEqpId()-1].m_tPeriEqpStatus);
	
	if (NULL == ptStatus)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] ptStatus is null!\n");
		return;
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if (g_cMcuAgent.IsEqpBasHD(tEqp.GetEqpId()))
#endif
	{
		u8 byHDType = ptStatus->m_tStatus.tHdBas.GetEqpType();
		switch(byHDType)
		{
		case TYPE_MPU2_BASIC:
		case TYPE_MPU2_ENHANCED:
			{
				u8 byBasInputChnNum = GetBasInPutChnNum(tEqp);
				if (byBasInputChnNum == 0 || byChnId >= byBasInputChnNum)
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] unexpected  chnId.%d\n", byChnId);
					return;
				}
				
				if ( NULL == ptStatus->m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnId) )
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] GetVidChnStatus NULL chnId.%d\n", byChnId);
					return;
				}

				THDBasVidChnStatus tVidChn;
				memset( &tVidChn, 0, sizeof(tVidChn) );
				memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnId), sizeof(tVidChn) );
				
				tVidChn.SetIsReserved(FALSE);
				tVidChn.SetStatus(TBasBaseChnStatus::READY);
				tVidChn.ClrOutputVidParam();
				ptStatus->m_tStatus.tHdBas.tStatus.tMpu2Bas.SetVidChnStatus(tVidChn, byChnId );  
			}
			break;
		case TYPE_MPU:
		case TYPE_MPU_H:
			{
				u8 byBasInputChnNum = GetBasInPutChnNum(tEqp);
				if (byBasInputChnNum == 0 || byChnId >= byBasInputChnNum)
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] unexpected  chnId.%d\n", byChnId);
					return;
				}

				if ( NULL == ptStatus->m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId) )
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] GetVidChnStatus NULL chnId.%d\n", byChnId);
					return;
				}

				THDBasVidChnStatus tVidChn;
				memset( &tVidChn, 0, sizeof(tVidChn) );
				memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId), sizeof(tVidChn) );
				
				tVidChn.SetIsReserved(FALSE);
				tVidChn.SetStatus(TBasBaseChnStatus::READY);
				tVidChn.ClrOutputVidParam();
				ptStatus->m_tStatus.tHdBas.tStatus.tMpuBas.SetVidChnStatus(tVidChn, byChnId );  
			}
			break;
		case TYPE_MAU_NORMAL:
		case TYPE_MAU_H263PLUS:
			{
				if (byChnId >= MAXNUM_MAU_VCHN + MAXNUM_MAU_DVCHN)
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] unexpected mau chnId.%d\n", byChnId);
					return;
				}
				BOOL32 bReleaseMV = byChnId == 0 ? TRUE : FALSE;
				
				if (bReleaseMV)
				{
					if ( NULL == ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnId) )
					{
						LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] GetVidChnStatus NULL chnId.%d\n", byChnId);
						return;
					}

					THDBasVidChnStatus tVidChn;
					memset( &tVidChn, 0, sizeof(tVidChn) );
					memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(), sizeof(tVidChn) );          
					
					tVidChn.SetIsReserved(FALSE);
					tVidChn.SetStatus(TBasBaseChnStatus::READY);
					tVidChn.ClrOutputVidParam();
					ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.SetVidChnStatus(tVidChn);
				}
				else
				{
					if ( NULL == ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(byChnId) )
					{
						LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] GetVidChnStatus NULL chnId.%d\n", byChnId);
						return;
					}

					THDBasVidChnStatus tVidChn;
					memset( &tVidChn, 0, sizeof(tVidChn) );
					memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(), sizeof(tVidChn) );
					
					tVidChn.SetIsReserved(FALSE);
					tVidChn.SetStatus(TBasBaseChnStatus::READY);
					tVidChn.ClrOutputVidParam();
					ptStatus->m_tStatus.tHdBas.tStatus.tMauBas.SetDVidChnStatus(tVidChn);
				}
			}
			break;
		case TYPE_8KE_BAS:
			{
				u8 byBasInputChnNum = GetBasInPutChnNum(tEqp);
				if (byBasInputChnNum == 0 || byChnId >= byBasInputChnNum)
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] unexpected  chnId.%d\n", byChnId);
					return;
				}

				if ( NULL == ptStatus->m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0) )
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] GetVidChnStatus NULL chnId.%d\n", byChnId);
					return;
				}

				THDBasVidChnStatus tVidChn;
				memset( &tVidChn, 0, sizeof(tVidChn) );
				memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0), sizeof(tVidChn) );
				
				tVidChn.SetIsReserved(FALSE);
				tVidChn.SetStatus(TBasBaseChnStatus::READY);
				tVidChn.ClrOutputVidParam();
				ptStatus->m_tStatus.tHdBas.tStatus.t8keBas.SetVidChnStatus(tVidChn, byChnId );  
			}
			break;
		case TYPE_8KH_BAS:
			{
				u8 byBasInputChnNum = GetBasInPutChnNum(tEqp);
				if (byBasInputChnNum == 0 || byChnId >= byBasInputChnNum)
				{
					LogPrint( LOG_LVL_ERROR, MID_MCU_BAS,"[ReleaseBasChn] tEqp-%d,chnid-%d, unexpected  8KH chnId!\n",
						tEqp.GetEqpId(), byChnId
						);
					return;
				}

				if ( NULL == ptStatus->m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0) )
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] GetVidChnStatus NULL chnId.%d\n", byChnId);
					return;
				}

				THDBasVidChnStatus tVidChn;
				memset( &tVidChn, 0, sizeof(tVidChn) );
				memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0), sizeof(tVidChn) );
				
				tVidChn.SetIsReserved(FALSE);
				tVidChn.SetStatus(TBasBaseChnStatus::READY);
				tVidChn.ClrOutputVidParam();
				ptStatus->m_tStatus.tHdBas.tStatus.t8khBas.SetVidChnStatus(tVidChn, byChnId );  
			}
			break;
			case TYPE_8KI_VID_BAS:
			{
				u8 byBasInputChnNum = GetBasInPutChnNum(tEqp);
				if (byBasInputChnNum == 0 || byChnId >= byBasInputChnNum)
				{
					LogPrint( LOG_LVL_ERROR, MID_MCU_BAS,"[ReleaseBasChn] tEqp-%d,chnid-%d, unexpected  8KH chnId!\n",
						tEqp.GetEqpId(), byChnId
						);
					return;
				}

				if ( NULL == ptStatus->m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0) )
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] GetVidChnStatus NULL chnId.%d\n", byChnId);
					return;
				}

				THDBasVidChnStatus tVidChn;
				memset( &tVidChn, 0, sizeof(tVidChn) );
				memcpy( &tVidChn, ptStatus->m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0), sizeof(tVidChn) );
				
				tVidChn.SetIsReserved(FALSE);
				tVidChn.SetStatus(TBasBaseChnStatus::READY);
				tVidChn.ClrOutputVidParam();
				ptStatus->m_tStatus.tHdBas.tStatus.t8khBas.SetVidChnStatus(tVidChn, byChnId );  
			}
			break;
		default:
			
			break;
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else if ( g_cMcuAgent.IsEqpBasAud(tEqp.GetEqpId())  )
#endif
	{
		u8 byAudType = ptStatus->m_tStatus.tAudBas.GetEqpType();
		if (byAudType == TYPE_APU2_BAS  )
		{
			u8 byBasInputChnNum = GetBasInPutChnNum(tEqp);
			if (byBasInputChnNum == 0 || byChnId >= byBasInputChnNum)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] unexpected  chnId.%d\n", byChnId);
				return;
			}
			
			if ( NULL == ptStatus->m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.GetAudChnStatus(byChnId) )
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] GetAudChnStatus NULL chnId.%d\n", byChnId);
				return;
			}
			
			TAudBasChnStatus pAudBasChn;
			memset( &pAudBasChn, 0, sizeof(pAudBasChn) );
			memcpy( &pAudBasChn, ptStatus->m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.GetAudChnStatus(byChnId), sizeof(pAudBasChn) );
			
			pAudBasChn.SetIsReserved(FALSE);
			pAudBasChn.SetStatus(TBasBaseChnStatus::READY);
			pAudBasChn.ClrOutputAudParam();
			ptStatus->m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.SetAudChnStatus(pAudBasChn, byChnId ); 
		}
		else if( TYPE_8KI_AUD_BAS == byAudType )
		{
			u8 byBasInputChnNum = GetBasInPutChnNum(tEqp);
			if (byBasInputChnNum == 0 || byChnId >= byBasInputChnNum)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] unexpected  chnId.%d\n", byChnId);
				return;
			}

			if ( NULL == ptStatus->m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChnId) )
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ReleaseBasChn] GetAudChnStatus NULL chnId.%d\n", byChnId);
				return;
			}

			TAudBasChnStatus pAudBasChn;
			memset( &pAudBasChn, 0, sizeof(pAudBasChn) );
			memcpy( &pAudBasChn, ptStatus->m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChnId), sizeof(pAudBasChn) );
			
			pAudBasChn.SetIsReserved(FALSE);
			pAudBasChn.SetStatus(TBasBaseChnStatus::READY);
			pAudBasChn.ClrOutputAudParam();
			ptStatus->m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.SetAudChnStatus(pAudBasChn, byChnId );
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else
	{
		TBasChnStatus tBasChnStatus;
		memset(&tBasChnStatus, 0, sizeof(tBasChnStatus));
		u8 byTmpChnType = ptStatus->m_tStatus.tBas.tChnnl[byChnId].GetChannelType();
		memcpy(&ptStatus->m_tStatus.tBas.tChnnl[byChnId], &tBasChnStatus, sizeof(tBasChnStatus));
		ptStatus->m_tStatus.tBas.tChnnl[byChnId].SetChannelType(byTmpChnType);
		SetBasChanStatus(tEqp.GetEqpId(), byChnId, TBasChnStatus::READY);
		SetBasChanReserved(tEqp.GetEqpId(), byChnId, FALSE);
	}
#endif
	m_cBasChnListMgr.ReleaseBasChn(tEqp.GetEqpId(), byChnId);
	SendPeriEqpStatusToMcs(tEqp.GetEqpId());
}

/*====================================================================
函数名      GetHDBasChnStatus
功能        ：获取高清适配器指定通道状态
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
08/11/09    4.5         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcData::GetHDBasChnStatus(const TEqp &tEqp, u8 byChnId, THDBasVidChnStatus &tChnStatus)
{
	if (tEqp.IsNull())
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetHDBasChnStatus] tEqp is null!\n");
		return FALSE;
	}
	
	if (!g_cMcuAgent.IsEqpBasHD(tEqp.GetEqpId()))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetHDBasChnStatus] tEqp is not hdbas!\n");
		return FALSE;
	}
	
	TPeriEqpStatus tBasStatus;
	if (!GetPeriEqpStatus(tEqp.GetEqpId(), &tBasStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetHDBasChnStatus] GetPeriEqpStatus--<EqpId:%d> failed!\n",tEqp.GetEqpId());
		return FALSE;
	}
	
	u8 byHDType = tBasStatus.m_tStatus.tHdBas.GetEqpType();
	BOOL32 bFind = FALSE;
	switch (byHDType)
	{
	case TYPE_MPU2_BASIC:
	case TYPE_MPU2_ENHANCED:
		{
			THDBasVidChnStatus *pChnStatus = NULL;
			pChnStatus	= tBasStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnId);
			if ( pChnStatus != NULL )
			{
				tChnStatus = *pChnStatus;
				bFind = TRUE;
			}
		}
		break;
	case TYPE_MPU:
	case TYPE_MPU_H:
		{
			THDBasVidChnStatus *pChnStatus = NULL;
			pChnStatus	= tBasStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId);
			if ( pChnStatus != NULL )
			{
				tChnStatus = *pChnStatus;
				bFind = TRUE;
			}
		}
		break;
	case TYPE_MAU_NORMAL:
	case TYPE_MAU_H263PLUS:
		{
			if (0 == byChnId)
			{
				THDBasVidChnStatus *pChnStatus = NULL;
				pChnStatus	= tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnId);
				if ( pChnStatus != NULL )
				{
					tChnStatus = *pChnStatus;
					bFind = TRUE;
				}
			}
			else
			{
				THDBasDVidChnStatus *pChnStatus = NULL;
				pChnStatus	= tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(byChnId);
				if ( pChnStatus != NULL )
				{
					tChnStatus = *pChnStatus;
					bFind = TRUE;
				}
			}			
		}
		break;
	default:
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetHDBasChnStatus] unexpected byHDType--<:%d>!\n", byHDType);
	}
	return bFind;
}

/*====================================================================
函数名      GetAudBasChnStatus
功能        ：获取音频适配器指定通道状态
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/15  4.7         倪志俊        创建
====================================================================*/
BOOL32 CMcuVcData::GetAudBasChnStatus(const TEqp &tEqp, u8 byChnId, TAudBasChnStatus &tChnStatus)
{
	if (tEqp.IsNull())
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetAudBasChnStatus] tEqp is null!\n");
		return FALSE;
	}
	
	if (!g_cMcuAgent.IsEqpBasAud(tEqp.GetEqpId()))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetAudBasChnStatus] tEqp is not hdbas!\n");
		return FALSE;
	}
	
	TPeriEqpStatus tBasStatus;
	if (!GetPeriEqpStatus(tEqp.GetEqpId(), &tBasStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetAudBasChnStatus] GetPeriEqpStatus--<EqpId:%d> failed!\n",tEqp.GetEqpId());
		return FALSE;
	}
	
	u8 byAudType = tBasStatus.m_tStatus.tAudBas.GetEqpType();
	BOOL32 bFind = FALSE;
	switch (byAudType)
	{
	case TYPE_APU2_BAS:
		{
			TAudBasChnStatus *pChnStatus = NULL;
			pChnStatus	= tBasStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.GetAudChnStatus(byChnId);
			if ( pChnStatus != NULL )
			{
				tChnStatus = *pChnStatus;
				bFind = TRUE;
			}
		}
		break;
	case TYPE_8KI_AUD_BAS:
		{
			TAudBasChnStatus *pChnStatus = NULL;
			pChnStatus	= tBasStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChnId);
			if ( pChnStatus != NULL )
			{
				tChnStatus = *pChnStatus;
				bFind = TRUE;
			}
		}
		break;
	default:
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetAudBasChnStatus] unexpected byAudType--<:%d>!\n", byAudType);
		break;
	}
	return bFind;
}

/*====================================================================
函数名        GetBasChnFrontOutPutNum
功能        ：获得通道所在外设上，前面已经占用的输出
算法实现    ：
引用全局变量：
输入参数说明：[in]TEqp &tEqp	BAS外设
			  [in] u8 byChnId   BAS通道号
			  [out]u8 &byFrontOutNum 返回编解码信息			  
返回值说明  ：成功获得返回TRUE,失败返回FALSE					
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/26  4.7			倪志俊		   创建
====================================================================*/
BOOL32 CMcuVcData::GetBasChnFrontOutPutNum(const TEqp &tEqp, u8 byChnId,  u8 &byOutNum, u8 &byFrontOutNum)
{
	byFrontOutNum = 0;
	byOutNum = 0;

	if ( tEqp.IsNull() )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasChnFrontOutPutNum] tEqp is null!\n");
		return FALSE;
	}

	if ( !m_cBasChnListMgr.GetBasChnFrontOutPutNum(tEqp,byChnId,byOutNum,byFrontOutNum) )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasChnFrontOutPutNum] m_cBasChnListMgr.GetBasChnFrontOutPutNum failed!\n");
		return FALSE;
	}
	return TRUE;
}

/*====================================================================
函数名      IsBasChnAdapting
功能        : 更新bas通道状态
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
emBASCHNSTATUS CMcuVcData::GetBasChnStatus(TEqp tBas, u8 byChnId)
{
	if (tBas.IsNull())
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasChnStatus] tBas is null!\n");
		return BASCHN_STATE_INVALIED;
	}

	TPeriEqpStatus tBasStatus;
	if (!GetPeriEqpStatus(tBas.GetEqpId(), &tBasStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasChnStatus] GetPeriEqpStatus failed!\n");
		return BASCHN_STATE_INVALIED;
	}

	u8 byChnState = BASCHN_STATE_INVALIED;
	TAudBasChnStatus *pAudBasChn = NULL;
	THDBasVidChnStatus *ptVidChnStatus = NULL;
	THDBasDVidChnStatus *ptDVidChnStatus = NULL;
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if (g_cMcuAgent.IsEqpBasHD(tBas.GetEqpId()))
#endif
	{
		u8 byHDType = tBasStatus.m_tStatus.tHdBas.GetEqpType();
		switch (byHDType)
		{
		case TYPE_MPU2_BASIC:
		case TYPE_MPU2_ENHANCED:
			{			
				ptVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnId);
				if ( ptVidChnStatus != NULL )
				{
					byChnState = ptVidChnStatus->GetStatus();
				}
			}
			break;
		case TYPE_MPU:
		case TYPE_MPU_H:
			{			
				ptVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId);
				if ( ptVidChnStatus != NULL )
				{
					byChnState = ptVidChnStatus->GetStatus();
				}
			}
			break;
		case TYPE_MAU_NORMAL:
			{
				if (0 == byChnId)
				{
					ptVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnId);
					if ( ptVidChnStatus != NULL )
					{
						byChnState = ptVidChnStatus->GetStatus();
					}			   
				}
				else
				{
					ptDVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(byChnId);
					if ( ptDVidChnStatus != NULL )
					{
						byChnState = ptDVidChnStatus->GetStatus();
					}
				}				
			}
			break;
		case TYPE_MAU_H263PLUS:
			{
				ptDVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(byChnId);
				if ( ptDVidChnStatus != NULL )
				{
					byChnState = ptDVidChnStatus->GetStatus();
				}
			}
			break;
		case TYPE_8KE_BAS:
			{
				ptVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(byChnId);
				if ( ptVidChnStatus != NULL )
				{
					byChnState = ptVidChnStatus->GetStatus();
				}
			}
			break;
		case TYPE_8KH_BAS:
			{
				ptVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(byChnId);
				if ( ptVidChnStatus != NULL )
				{
					byChnState = ptVidChnStatus->GetStatus();
				}
			}
			break;
		case TYPE_8KI_VID_BAS:
			{
				ptVidChnStatus = tBasStatus.m_tStatus.tHdBas.tStatus.t8kiBas.GetVidChnStatus(byChnId);
				if ( ptVidChnStatus != NULL )
				{
					byChnState = ptVidChnStatus->GetStatus();
				}
			}
			break;
		default:			
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasChnStatus] unexpected byHDType:%d!\n", byHDType);			
			break;
		}

		if (THDBasVidChnStatus::READY == byChnState)
		{
			return BASCHN_STATE_READY;
		}
		else if (THDBasVidChnStatus::WAIT_START == byChnState)
		{
			return BASCHN_STATE_WAITSTART;
		}
		else if (THDBasVidChnStatus::RUNING == byChnState)
		{
			return BASCHN_STATE_RUNNING;
		}
		else
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasChnStatus:HD] Unexpected Bas<EqpId.%d, Type.%d> State.%d!\n",
									tBas.GetEqpId(), byHDType, byChnState);
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
			return BASCHN_STATE_INVALIED;
#endif
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else if ( g_cMcuAgent.IsEqpBasAud(tBas.GetEqpId())  ) 
#endif
	{
		u8 byAudType = tBasStatus.m_tStatus.tAudBas.GetEqpType();
		if ( byAudType == TYPE_APU2_BAS || TYPE_8KI_AUD_BAS == byAudType )
		{
			if( byAudType == TYPE_APU2_BAS )
			{
				pAudBasChn = tBasStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.GetAudChnStatus(byChnId);
			}
			else
			{
				pAudBasChn = tBasStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChnId);
			}
			
			if (NULL != pAudBasChn)
			{
				byChnState = pAudBasChn->GetStatus();
			}

			if (TAudBasChnStatus::READY == byChnState)
			{
				return BASCHN_STATE_READY;
			}
			else if (TAudBasChnStatus::WAIT_START == byChnState)
			{
				return BASCHN_STATE_WAITSTART;
			}
			else if (TAudBasChnStatus::RUNING == byChnState)
			{
				return BASCHN_STATE_RUNNING;
			}
			else
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasChnStatus:HD] Unexpected Bas<EqpId.%d, Type.%d> State.%d!\n",
					tBas.GetEqpId(), byAudType, byChnState);
				return BASCHN_STATE_INVALIED;
			}
		}
		return BASCHN_STATE_INVALIED;
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else
	{
		byChnState = tBasStatus.m_tStatus.tBas.tChnnl[byChnId].GetStatus();
		if (TBasChnStatus::READY == byChnState)
		{
			return BASCHN_STATE_READY;
		}
		else if (TBasChnStatus::WAIT_START == byChnState)
		{
			return BASCHN_STATE_WAITSTART;
		}
		else if (TBasChnStatus::RUNING == byChnState)
		{
			return BASCHN_STATE_RUNNING;
		}
		else 
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasChnStatus:SD] Unexpected Bas<EqpId.%d> State.%d!\n",
									tBas.GetEqpId(), byChnState);
			return BASCHN_STATE_INVALIED;
		}
	}
#endif
}


/*====================================================================
函数名      UpdateBasChnStatus
功能        : 更新bas通道状态
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuVcData::UpdateBasChnStatus(const TEqp &tEqp, u8 byChnId, emBASCHNSTATUS emState)
{
	if (tEqp.IsNull())
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[UpdateBasChnStatus] tEqp is null!\n");
		return FALSE;
	}
	
	TPeriEqpStatus tBasStatus;
	if (!GetPeriEqpStatus(tEqp.GetEqpId(), &tBasStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[UpdateBasChnStatus] GetPeriEqpStatus faield!\n");
		return FALSE;
	}
	
	TAudBasChnStatus *pAudBasChn = NULL;
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if (g_cMcuAgent.IsEqpBasHD(tEqp.GetEqpId()))
#endif	
	{
		THDBasVidChnStatus *ptVidChn = NULL;
		u8 byHDType = tBasStatus.m_tStatus.tHdBas.GetEqpType();
		switch (byHDType)
		{
		case TYPE_MPU2_BASIC:
		case TYPE_MPU2_ENHANCED:
			{
				ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnId);
			}
			break;
		case TYPE_MPU:
		case TYPE_MPU_H:
			{
				ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId);
			}
			break;
		case TYPE_MAU_NORMAL:
		case TYPE_MAU_H263PLUS:
			{
				if (0 == byChnId)
				{
					ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnId);
				}
				else 
				{
					ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(byChnId);
				}
			}
			break;
		case TYPE_8KE_BAS:
			{
				ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(byChnId);
			}
			break;
		case TYPE_8KH_BAS:
			{
				ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(byChnId);
			}
			break;
		case TYPE_8KI_VID_BAS:
			{
				ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.t8kiBas.GetVidChnStatus(byChnId);
			}
			break;
		default:
			break;
			
		}
		if (NULL != ptVidChn)
		{
			if (emState == BASCHN_STATE_READY)
			{
				ptVidChn->SetStatus(THDBasVidChnStatus::READY);		
			}
			else if (emState == BASCHN_STATE_WAITSTART)
			{
				ptVidChn->SetStatus(THDBasVidChnStatus::WAIT_START);		
			}
			else if (emState == BASCHN_STATE_RUNNING)
			{
				ptVidChn->SetStatus(THDBasVidChnStatus::RUNING);
			}
			else
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[UpdateBasChnStatus:HD] unexpected byState:%d!\n", emState);
				return FALSE;
			}
		}
		else
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[UpdateBasChnStatus] ptVidChn is null!\n");
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
			return FALSE;
#endif
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else if ( g_cMcuAgent.IsEqpBasAud(tEqp.GetEqpId())  )
#endif 
	{
		u8 byAudType = tBasStatus.m_tStatus.tAudBas.GetEqpType();
		if (byAudType == TYPE_APU2_BAS || TYPE_8KI_AUD_BAS == byAudType)
		{
			if( byAudType == TYPE_APU2_BAS )
			{
				pAudBasChn = tBasStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.GetAudChnStatus(byChnId);
			}
			else
			{
				pAudBasChn = tBasStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChnId);
			}
			
			if (NULL != pAudBasChn)
			{
				if (emState == BASCHN_STATE_READY)
				{
					pAudBasChn->SetStatus(TAudBasChnStatus::READY);		
				}
				else if (emState == BASCHN_STATE_WAITSTART)
				{
					pAudBasChn->SetStatus(TAudBasChnStatus::WAIT_START);		
				}
				else if (emState == BASCHN_STATE_RUNNING)
				{
					pAudBasChn->SetStatus(TAudBasChnStatus::RUNING);
				}
				else
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[UpdateBasChnStatus:Aud] unexpected byState:%d!\n", emState);
					return FALSE;
				}
			}
			else
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[UpdateBasChnStatus] pAudBasChn is null!\n");
				return FALSE;
			}
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else
	{
		if (emState == BASCHN_STATE_READY)
		{
			tBasStatus.m_tStatus.tBas.tChnnl[byChnId].SetStatus(TBasChnStatus::READY);	
		}
		else if (emState == BASCHN_STATE_WAITSTART)
		{
			tBasStatus.m_tStatus.tBas.tChnnl[byChnId].SetStatus(TBasChnStatus::WAIT_START);
		}
		else if (emState == BASCHN_STATE_RUNNING)
		{
			tBasStatus.m_tStatus.tBas.tChnnl[byChnId].SetStatus(TBasChnStatus::RUNING);
		}
		else
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[UpdateBasChnStatus:SD] unexpected byState:%d!\n", emState);
			return FALSE;
		}
	}
#endif
	
	SetPeriEqpStatus(tEqp.GetEqpId(), &tBasStatus);
	SendPeriEqpStatusToMcs(tEqp.GetEqpId());
	return TRUE;
}

/*====================================================================
函数名      GetIdleBasChnPossible
功能        : 根据源和目的能力获取空闲适配通道, 如不足则通过降低编码性能循序尝试
算法实现    ：
引用全局变量：
输入参数说明：TSimCapSet tSrcCap       源能力
			  TSimCapSet tDstCap       目的能力
			  u8		 byMediaMode   媒体模式

返回值说明  ：CBasChn **ppcBasChnData 获取到的适配通道
		     TBasChnCapData *ptBasChnCapData 参数
----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  10/06/30    4.6         周嘉麟          创建
  2012/03/01  4.7		  倪志俊		  修改
====================================================================*/
BOOL32 CMcuVcData::GetIdleBasChnPossible(TSimCapSet tSrcCap, TSimCapSet &tDstCap, u8 byMediaMode, 
										CBasChn **ppcBasChnData,  TBasChnCapData *ptBasChnCapData)
{
	if (tSrcCap.IsNull() || tDstCap.IsNull() || byMediaMode == MODE_NONE)
	{
	  return FALSE;
	}

	if (GetIdleBasChn(tSrcCap, tDstCap, byMediaMode, ppcBasChnData,ptBasChnCapData))
	{
	    return TRUE;
	}
	else
	{
	  if (MEDIA_TYPE_H264 == tDstCap.GetVideoMediaType())
	  {
		  u8 byNextDownStandRes = GetDownStandRes(tDstCap.GetVideoResolution());
		  if (VIDEO_FORMAT_INVALID != byNextDownStandRes)
		  {
			  tDstCap.SetVideoResolution(byNextDownStandRes);
			  if ( tDstCap.GetVideoResolution() == VIDEO_FORMAT_4CIF ||
				  tDstCap.GetVideoResolution() == VIDEO_FORMAT_CIF
				  )
			  {
				  tDstCap.SetVideoProfileType(emBpAttrb);
				}
			  return GetIdleBasChnPossible(tSrcCap, tDstCap, byMediaMode, ppcBasChnData,ptBasChnCapData);
		  }
		  else
		  {
			  return FALSE;
		  }	
	  }
	  else
	  {
		  return FALSE;
	  }
	}
}
/*====================================================================
函数名      GetIdleBasChn
功能        : 根据逻辑通道能力获取最合适的适配通道
算法实现    ：
引用全局变量：
输入参数说明：TSimCapSet &tSrcCap 源能力
			  TSimCapSet &tDstCap 目的能力
			   u8 byMediaMode     媒体类型
			 CBasChn  **ppcBasChnData 通道指针的地址
			 TBasChnIdxParam *ptBasChnParam 参数指针
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
2011/12/20  4.7         倪志俊			修改
====================================================================*/
BOOL32 CMcuVcData::GetIdleBasChn(TSimCapSet &tSrcCap, TSimCapSet &tDstCap, u8 byMediaMode,  
								 CBasChn  **ppcBasChnData,  TBasChnCapData *ptBasChnCapData
								 )
{
	if (  NULL == ppcBasChnData ||
		  NULL == ptBasChnCapData 
		)
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[GetIdleBasChn]ppcBasChnData or ptBasChnParam is NULL!\n");
		return FALSE;
	}

	TNeedVidAdaptData	tBasNeedData;
	GetBasNeedResDataByCap(tSrcCap,tDstCap,byMediaMode,tBasNeedData);
	if ( !m_cBasChnListMgr.GetSuitableBasChnForVidSel(tBasNeedData,ppcBasChnData, ptBasChnCapData) )
	{
		return FALSE;	
	}
	
	return TRUE;
}	

/*====================================================================
函数名			GetIdleAudBasChn
功能        : 根据逻辑通道能力获取最合适的适配通道
算法实现    ：
引用全局变量：
输入参数说明：TAudioTypeDesc &tAudSrcCap 源能力
				TAudioTypeDesc&tAudDstCap 目的能力
				CBasChn  **ppcBasChnData 通道指针的地址
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/14  4.7         倪志俊			修改
====================================================================*/
BOOL32 CMcuVcData::GetIdleAudBasChn(TAudioTypeDesc &tAudSrcCap, TAudioTypeDesc&tAudDstCap,CBasChn **ppcBasChnData)
{
	if (  NULL == ppcBasChnData )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[GetIdleAudBasChn]ppcBasChnData or ptBasChnParam is NULL!\n");
		return FALSE;
	}
	
	TNeedAudAdaptData	tBasNeedData;
	tBasNeedData.m_atAudTypeDesc[0] = tAudDstCap;
	tBasNeedData.m_atAudTypeDesc[1]=tAudSrcCap;	//加上源能力，是为了让BAS通道判断是否支持解码
	tBasNeedData.m_byNeedAudEncNum = 1;
	if ( !m_cBasChnListMgr.GetSuitableBasChnForAudSel(tBasNeedData,ppcBasChnData) )
	{
		return FALSE;	
	}
	
	return TRUE;
}	

/*====================================================================
函数名      SetBasChnOnLine
功能        : 设置链表bas结点在线状态
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟          创建
====================================================================*/
void CMcuVcData::SetBasOnLine(u8 byEqpId, BOOL32 bOnLine)
{
	m_cBasChnListMgr.SetBasOnLine(byEqpId, bOnLine);
}	

/*====================================================================
函数名      ConstructCriMacInfoMsg
功能        : 构造需要上报的接入板MAC地址信息消息体
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
12/05/16    4.7         chendaiwei          创建
====================================================================*/
void CMcuVcData::ConstructCriMacInfoMsg(CServMsg & cMsg)
{
	u8 byBrdNum = 1; //必然上报MPC板（8000E，8000H,8000I ）
	for( u8 byIdx = 0; byIdx < MAXNUM_DRI;byIdx ++)
	{
		u8 abyNullMacAddr[6] = {0};
		if(m_atMtAdpData[byIdx].m_bConnected 
			&& 0 != memcmp(m_atMtAdpData[byIdx].m_abyMacAddr,abyNullMacAddr,sizeof(abyNullMacAddr)))
		{
			byBrdNum ++;
		}
	}
	
	cMsg.SetMsgBody((u8*)&byBrdNum,sizeof(byBrdNum));

	u8 byBrdId = g_cMcuAgent.GetBrdIdbyIpAddr(ntohl(g_cMcuAgent.GetMpcIp()));
	u16 wLicenseNum = htons(GetLicenseNum());
	u16 wHdMtNum = htons(GetLicenseHDMtNum());
	u16 wAudAccessNum = htons(GetAudMtLicenseNum());

	u8 abyMacAddr[6] = {0};
#if defined(_LINUX_) 
	#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
	TMcu8KECfg tMcu8KeCfg;
	g_cMcuAgent.GetMcuEqpCfg(&tMcu8KeCfg);
	for( u8 byIdx = 0; byIdx < MAXNUM_ETH_INTERFACE; byIdx ++)
	{
		TNetAdaptInfo *ptNetAdapt = tMcu8KeCfg.m_tLinkNetAdap.GetValue(byIdx); //当前启用的eth，无论0或1均从结点0开始累计
		if( ptNetAdapt != NULL )
		{
			u8 *pbyMacAddr = ptNetAdapt->GetMacAddress();
			if( pbyMacAddr == NULL )
			{
				continue;
			}

			for(u8 byIdx = 0; byIdx < sizeof(abyMacAddr); byIdx ++)
			{
				abyMacAddr[byIdx] = pbyMacAddr[byIdx];
			}

			break;		
		}
	}

	#else

	TBrdEthParam tEthParam;
	memset(&tEthParam,0,sizeof(TBrdEthParam));
	BrdGetEthParam(g_cMcuAgent.GetCurEthChoice(),&tEthParam);
	memcpy(abyMacAddr,tEthParam.byMacAdrs,sizeof(abyMacAddr));
	
	#endif
#else
	//win32上报空MaC地址 [5/17/2012 chendaiwei]
#endif

	LogPrint(LOG_LVL_WARNING,MID_MCU_MCS,"[ConstructCriMacInfoMsg] BrdNum:%d, Mpc <BrdId:%d,IP:%s,LicenseNum:%d,HDMtNum:%d>\n",byBrdNum,byBrdId,StrOfIP(ntohl(g_cMcuAgent.GetMpcIp())),GetLicenseNum(),GetLicenseHDMtNum());
	LogPrint(LOG_LVL_WARNING,MID_MCU_MCS,"[ConstructCriMacInfoMsg] Mpc MacAddr %02x-%02x-%02x-%02x-%02x-%02x\n",abyMacAddr[0],abyMacAddr[1],abyMacAddr[2],abyMacAddr[3],abyMacAddr[4],abyMacAddr[5]);

	cMsg.CatMsgBody((u8*)&byBrdId,sizeof(byBrdId));
	cMsg.CatMsgBody((u8*)&wLicenseNum,sizeof(u16));
	cMsg.CatMsgBody((u8*)&wHdMtNum,sizeof(u16));
	cMsg.CatMsgBody((u8*)abyMacAddr,sizeof(abyMacAddr));
	//新增信息上报，只需在消息体后添加。界面会通过消息体长度做好兼容支持。[10/18/2012 chendaiwei]
	cMsg.CatMsgBody((u8*)&wAudAccessNum,sizeof(u16));

	for( u8 byIndex = 0; byIndex < MAXNUM_DRI;byIndex ++)
	{
		u8 abyNullMacAddr[6] = {0};
		if(m_atMtAdpData[byIndex].m_bConnected 
			&& 0 != memcmp(m_atMtAdpData[byIndex].m_abyMacAddr,abyNullMacAddr,sizeof(abyNullMacAddr)))
		{
			u8 byCriBrdId = g_cMcuAgent.GetBrdIdbyIpAddr(ntohl(m_atMtAdpData[byIndex].m_dwIpAddr));

			cMsg.CatMsgBody((u8*)&byCriBrdId,sizeof(byCriBrdId));

			u16 wMaxMtNum = htons((u16)m_atMtAdpData[byIndex].m_byMaxMtNum);
			u16 wMaxHdMtNum = htons((u16)m_atMtAdpData[byIndex].m_byMaxHDMtNum);
			u16 wMaxAudAccessNum = htons((u16)m_atMtAdpData[byIndex].m_wMaxAudMtNum);
			cMsg.CatMsgBody((u8*)&wMaxMtNum,sizeof(wMaxMtNum));
			cMsg.CatMsgBody((u8*)&wMaxHdMtNum,sizeof(wMaxHdMtNum));
			cMsg.CatMsgBody((u8*)m_atMtAdpData[byIndex].m_abyMacAddr,sizeof(m_atMtAdpData[byIndex].m_abyMacAddr));
			cMsg.CatMsgBody((u8*)&wMaxAudAccessNum,sizeof(wMaxAudAccessNum));
			//新增信息上报，只需在消息体后添加。界面会通过消息体长度做好兼容支持。[10/18/2012 chendaiwei]
		}
	}

	return;
}

/*====================================================================
函数名      GetBasChnOutputNum
功能        :获得BAS输出通道数
算法实现    ：
引用全局变量：
输入参数说明:[in]const TEqp &tEqp		外设信息
			 [in] u8	 byChnId		通道ID
			 [out] u8	 &byOutNum		返回输出通道数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7         倪志俊          创建
====================================================================*/
BOOL32  CMcuSingleConfAllInfo::GetBasChnOutputNum(const TEqp &tEqp, u8 byChnId, u8 &byOutNum, u8 &byFrontOutNum)
{
	return g_cMcuVcApp.GetBasChnFrontOutPutNum(tEqp, byChnId,byOutNum,byFrontOutNum);
}

/*====================================================================
函数名      GetBasResDataByEqp
功能        :根据外设获得外设对应通道上的能力集
算法实现    ：
引用全局变量：
输入参数说明:[in]TEqp tDiscBas		 BAS外设
			 [out]TNeedBasResData &tBasResData
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7         倪志俊          创建
====================================================================*/
BOOL32  CMcuSingleConfAllInfo::GetBasResDataByEqp(TEqp tDiscBas, TNeedVidAdaptData *patBasResData)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}

	if (  IS_PTR_NULL(patBasResData) )
	{
		return FALSE;
	}

	return m_pcMcuBasMgr->GetBasResDataByEqp(tDiscBas,patBasResData);

}

/*====================================================================
函数名      GetBasResAudDataByEqp
功能        :根据外设获得外设对应通道上的能力集
算法实现    ：
引用全局变量：
输入参数说明:[in]TEqp tDiscBas		 BAS外设
[out]TNeedAudAdaptData &tBasResData
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/13  4.7         倪志俊          创建
====================================================================*/
BOOL32  CMcuSingleConfAllInfo::GetBasResAudDataByEqp(TEqp tDiscBas, TNeedAudAdaptData *patBasResData)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	
	if (  IS_PTR_NULL(patBasResData) )
	{
		return FALSE;
	}
	
	return m_pcMcuBasMgr->GetBasResAudDataByEqp(tDiscBas,patBasResData);
	
}

/*====================================================================
函数名      : SetBasAdaptParam
功能        : 根据bas信息设置输出通道参数
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp				外设信息
			  u8 byChnId					通道入索引	
			  THDAdaptParam tHDParm			适配参数
			  BOOL32 bForceSet				是否强制设置适配参数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
03/01/2010              周嘉麟         创建
====================================================================*/
// BOOL32 CMcuVcData::SetBasAdaptParam(const TConfInfo& tConfInfo, 
// 									const TEqp &tEqp, u8 byChnId,
// 									THDAdaptParam tHDParm, BOOL32 bForceSet/*False*/, BOOL32 bAdjRes/*False*/)
// {
// 	if (tEqp.IsNull())
// 	{
// 		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetBasAdaptParam] tEqp is null!\n");
// 		return FALSE;
// 	}
// 
// 	if (tHDParm.IsNull())
// 	{
// 		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetBasAdaptParam] tHDParm is null!\n");
// 		return FALSE;
// 	}
// 
// 	LogPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[SetBasAdaptParam] tHDParm VidType:%d, Res:%d!\n",
// 		tHDParm.GetVidType(), GetResByWH(tHDParm.GetWidth(), tHDParm.GetHeight()));
// 
// 	TPeriEqpStatus tStatus;
// 	if (!GetPeriEqpStatus(tEqp.GetEqpId(), &tStatus))
// 	{
// 		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetBasAdaptParam] GetPeriEqpStatus failed! EqpId:%d !\n", tEqp.GetEqpId());
// 		return FALSE;
// 	}
// 
// 	//适配通道资源利用最优帧率调整
// 	//如果当前参数是1080/720-50/60,将帧率降为30fps
// 	BOOL32 bIsAdpOptimization = IsConfAdpOptimization(tConfInfo);
// 	if (MEDIA_TYPE_H264 == tHDParm.GetVidType() &&
// 		   (VIDEO_FORMAT_HD1080 == GetResByWH(tHDParm.GetWidth(),tHDParm.GetHeight()) ||
// 		     VIDEO_FORMAT_HD720 == GetResByWH(tHDParm.GetWidth(),tHDParm.GetHeight())
// 			  ) &&
// 	     tHDParm.GetFrameRate() >= 50 &&
// 		 bIsAdpOptimization
// 	      )
// 	{
// 		if (MEDIA_TYPE_H264 == tConfInfo.GetMainVideoMediaType())
// 		{
// 			if (tConfInfo.GetMainVidUsrDefFPS() >= 30)
// 			{
// 				tHDParm.SetFrameRate(30);
// 			}
// 			else
// 			{
// 				tHDParm.SetFrameRate(tConfInfo.GetMainVidUsrDefFPS());
// 			}
// 		
// 		}
// 		else 
// 		{
// 			if(MEDIA_TYPE_H264 == tConfInfo.GetSecVideoMediaType())
// 			{
// 				if (tConfInfo.GetSecVidUsrDefFPS() >= 30)
// 				{
// 					tHDParm.SetFrameRate(30);
// 				}
// 				else
// 				{
// 					tHDParm.SetFrameRate(tConfInfo.GetSecVidUsrDefFPS());
// 				}
// 			}
// 		}
// 	}
// 
// #ifndef _8KE_
// 	if (g_cMcuAgent.IsEqpBasHD(tEqp.GetEqpId()))
// #endif	
// 	{
// 		u8 byOutIdx = 0;
// 		u8 byHDBasType = tStatus.m_tStatus.tHdBas.GetEqpType();
// 		
// 		THDBasVidChnStatus tVidChn;
// 		memset(&tVidChn, 0, sizeof(tVidChn));
// 
// 		switch (byHDBasType)
// 		{
// 		case TYPE_MAU_NORMAL:
// 		case TYPE_MPU:
// 			{
// 				if (TYPE_MAU_NORMAL == byHDBasType)
// 				{
// 					tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnId);
// 				}
// 				else
// 				{
// 					tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId);
// 				}
// 				
// 				if (MEDIA_TYPE_H264 != tHDParm.GetVidType() ||
// 					( MEDIA_TYPE_H264 == tHDParm.GetVidType() &&
// 					  VIDEO_FORMAT_CIF == GetResByWH(tHDParm.GetWidth(), tHDParm.GetHeight())
// 						)
// 					)
// 				{
// 					 byOutIdx = 1;
// 				}
// 				else
// 				{
// 					 byOutIdx = 0;
// 				}
// 
// 				if ((!tVidChn.GetOutputVidParam(byOutIdx)->IsNull() || !tVidChn.IsReserved())
// 					&& !bForceSet)
// 				{
// 					LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[SetBasAdaptParam] Mau<ChnId:%d, OutIdx:%d> AdaptParam is not null chn or not reserved!\n", 
// 													   byChnId, byOutIdx);
// 					return FALSE;
// 				}
// 				
// 				tVidChn.SetOutputVidParam(tHDParm, byOutIdx);
// 				if (TYPE_MAU_NORMAL == byHDBasType)
// 				{
// 					tStatus.m_tStatus.tHdBas.tStatus.tMauBas.SetVidChnStatus(tVidChn, byChnId);
// 				}
// 				else
// 				{
// 					tStatus.m_tStatus.tHdBas.tStatus.tMpuBas.SetVidChnStatus(tVidChn, byChnId);
// 				}
// 				SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
// 			}
// 			break;
// 		case TYPE_MPU_H:
// 			{
// 				tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId);
// 				//tos只能编一路1080-60fps, 其余挂空
// 				THDAdaptParam tHD1080Param = *tVidChn.GetOutputVidParam(0);
// 				BOOL32 bHD108060FpsExists = FALSE;
// 				if (VIDEO_FORMAT_HD1080 == GetResByWH(tHD1080Param.GetWidth(), tHD1080Param.GetHeight())
// 					&& tHD1080Param.GetFrameRate() >= 50)
// 				{
// 					bHD108060FpsExists = TRUE;
// 				}
// 
// 				//对于1080p-60fps反向判断tos上是否有h264编码(前4路为高清)
// 				BOOL32 bH264InTos = FALSE;
// 				for (byOutIdx = 0; byOutIdx < 4; byOutIdx++)
// 				{
// 					if (MEDIA_TYPE_H264 == tVidChn.GetOutputVidParam(byOutIdx)->GetVidType())
// 					{
// 						bH264InTos = TRUE;
// 						break;
// 					}
// 				}
// 
// 				u8 byRes = GetResByWH(tHDParm.GetWidth(), tHDParm.GetHeight());
// 				byOutIdx = 0;
// 				//tos 如果有编码是1080_50/60fps时则只设dsp
// 				if (!bHD108060FpsExists)
// 				{			
// 					//1.1080 30/40fps
// 					//2.720
// 					//3.4cif
// 					//4.cif
// 					//5.other1
// 					//6.other2//dsp上优先用other2
// 					if (MEDIA_TYPE_H264 == tHDParm.GetVidType())
// 					{
// 						switch (byRes)
// 						{
// 						case VIDEO_FORMAT_HD1080:
// 						case VIDEO_FORMAT_SVGA:
// 						case VIDEO_FORMAT_VGA:
// 						case VIDEO_FORMAT_XGA:
// 						case VIDEO_FORMAT_SXGA:
// 						case VIDEO_FORMAT_UXGA:
// 							{
// 								byOutIdx = 0;
// 								if (bH264InTos 
// 									&& VIDEO_FORMAT_HD1080 == byRes 
// 									&& tHDParm.GetFrameRate() >= 50)//tos上已有h264编码，无法设置1080-50/60fps
// 								{
// 									return FALSE;
// 								}
// 							}				
// 							break;
// 						case VIDEO_FORMAT_HD720://zjl[20100610] 底层调整，如果是720p_50/60fps则从索引0编码
// 							if (tHDParm.GetFrameRate() >= 50)
// 							{
// 								byOutIdx = 0;
// 							}
// 							else
// 							{
// 								byOutIdx = 1;
// 							}						
// 							break;
// 						case VIDEO_FORMAT_4CIF:
// 							byOutIdx = 2;
// 							break;
// 						case VIDEO_FORMAT_CIF:
// 							byOutIdx = 3;										
// 							break;
// 						default:
// 							LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[SetBasAdaptParam] can not set Param<MediaType:%d, Res:%d> because unexpected res!\n",
// 													tHDParm.GetVidType(), byRes);				
// 							return FALSE;								
// 						}	
// 					}	
// 					else
// 					{
// 						if (tVidChn.GetOutputVidParam(5)->IsNull() || 
// 							(bForceSet && byRes == GetResByWH(tVidChn.GetOutputVidParam(5)->GetWidth(), 
// 							tVidChn.GetOutputVidParam(5)->GetHeight()) 
// 							&& tHDParm.GetVidType() == tVidChn.GetOutputVidParam(5)->GetVidType()))
// 						{
// 							byOutIdx = 5;
// 						}
// 						else if (tVidChn.GetOutputVidParam(4)->IsNull() || 
// 							(bForceSet && byRes == GetResByWH(tVidChn.GetOutputVidParam(4)->GetWidth(), 
// 							tVidChn.GetOutputVidParam(4)->GetHeight()) 
// 							&& tHDParm.GetVidType() == tVidChn.GetOutputVidParam(4)->GetVidType()))
// 						{
// 							byOutIdx = 4;
// 						} 
// 						else
// 						{
// 							LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[SetBasAdaptParam] can not set Param<MediaType:%d, Res:%d> because out4/out5 has been ocuppied!\n", 
// 								tHDParm.GetVidType(), byRes);
// 							return FALSE;
// 						}
// 					}
// 				}
// 				else
// 				{
// 					//1.1080 50/60fps
// 					//2.挂空
// 					//3.挂空
// 					//4.挂空
// 					//5.4cif/cif/other
// 					//6.4cif/cif/other
// 					//优先选other2
// 					if (!IsResG(byRes, VIDEO_FORMAT_4CIF))
// 					{
// 						u8 byVidCodeType = tHDParm.GetVidType();
// 						if (tVidChn.GetOutputVidParam(5)->IsNull() || (bForceSet && byRes == GetResByWH(tVidChn.GetOutputVidParam(5)->GetWidth(), tVidChn.GetOutputVidParam(5)->GetHeight()) 
// 																		&& byVidCodeType == tVidChn.GetOutputVidParam(5)->GetVidType())) 
// 						{
// 							byOutIdx = 5;
// 						}
// 						else if(tVidChn.GetOutputVidParam(4)->IsNull() || (bForceSet && byRes == GetResByWH(tVidChn.GetOutputVidParam(4)->GetWidth(), tVidChn.GetOutputVidParam(4)->GetHeight())
// 																			 && byVidCodeType == tVidChn.GetOutputVidParam(4)->GetVidType()))
// 						{
// 							byOutIdx = 4;
// 						}
// 						else
// 						{
// 							LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[SetBasAdaptParam] can not set Param<MediaType:%d, Res:%d> because out4/out5 has been ocuppied!\n", 
// 															   tHDParm.GetVidType(), byRes);
// 							return FALSE;
// 						}
// 					}
// 					else if (VIDEO_FORMAT_HD1080 == byRes)
// 					{
// 						byOutIdx = 0;
// 					}
// 					else
// 					{
// 						LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[SetBasAdaptParam] can not set Param<MediaType:%d, Res:%d> because first out is 1080/50/60fps!\n", 
// 															tHDParm.GetVidType(), byRes);
// 						return FALSE;
// 					}				
// 				}
// 				if ((!tVidChn.GetOutputVidParam(byOutIdx)->IsNull() || !tVidChn.IsReserved())
// 					&& !bForceSet)
// 				{
// 					LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[SetBasAdaptParam] Mpu_H<ChnId:%d, OutIdx:%d> AdaptParam is not null or chn not reserved!\n", 
// 						byChnId, byOutIdx);
// 					return FALSE;
// 				}
// 				else
// 				{
// 					//H264-4Cif/Cif 帧率保护
// 					//当前如果没有与会终端是4Cif或Cif时，帧率不会往下刷，这里要保护下,否则给mpu会有问题
// 					if (MEDIA_TYPE_H264 == tHDParm.GetVidType() &&
// 						   (VIDEO_FORMAT_4CIF == GetResByWH(tHDParm.GetWidth(), tHDParm.GetHeight()) ||
// 						     VIDEO_FORMAT_CIF == GetResByWH(tHDParm.GetWidth(), tHDParm.GetHeight())
// 						      ) &&
// 						 tHDParm.GetFrameRate() >= 50)
// 					{
// 						if (MEDIA_TYPE_H264 == tConfInfo.GetMainVideoMediaType())
// 						{
// 							if (tConfInfo.GetMainVidUsrDefFPS() >= 30)
// 							{
// 								tHDParm.SetFrameRate(30);
// 							}
// 							else
// 							{
// 								tHDParm.SetFrameRate(tConfInfo.GetMainVidUsrDefFPS());
// 							}
// 						}
// 						else if(MEDIA_TYPE_H264 == tConfInfo.GetSecVideoMediaType())
// 						{
// 							if (tConfInfo.GetSecVidUsrDefFPS() >= 30)
// 							{
// 								tHDParm.SetFrameRate(30);
// 							}
// 							else
// 							{
// 								tHDParm.SetFrameRate(tConfInfo.GetSecVidUsrDefFPS());
// 							}
// 						}
// 					}
// 
// 					//[2011/09/20/zhangli]第4、5两路other输出如果一样就不再下参
// 					if (byOutIdx == 4 && !tVidChn.GetOutputVidParam(5)->IsNull())
// 					{
// 						if (tHDParm.GetVidType() == tVidChn.GetOutputVidParam(5)->GetVidType()
// 							&& (tHDParm.GetVidActiveType() == MEDIA_TYPE_NULL
// 								|| tVidChn.GetOutputVidParam(5)->GetVidActiveType() == MEDIA_TYPE_NULL
// 								|| tHDParm.GetVidActiveType() == tVidChn.GetOutputVidParam(5)->GetVidActiveType())
// 							&& (tHDParm.GetAudType() == MEDIA_TYPE_NULL 
// 								|| tVidChn.GetOutputVidParam(5)->GetAudType() == MEDIA_TYPE_NULL 
// 								|| tHDParm.GetAudType() == tVidChn.GetOutputVidParam(5)->GetAudType())
// 							&& tHDParm.GetWidth() == tVidChn.GetOutputVidParam(5)->GetWidth()
// 							&& tHDParm.GetHeight() == tVidChn.GetOutputVidParam(5)->GetHeight())
// 						{
// 							return TRUE;
// 						}
// 					}
// 
// 					if (byOutIdx == 5 && !tVidChn.GetOutputVidParam(4)->IsNull())
// 					{
// 						if (tHDParm.GetVidType() == tVidChn.GetOutputVidParam(4)->GetVidType()
// 							&& (tHDParm.GetVidActiveType() == MEDIA_TYPE_NULL
// 								|| tVidChn.GetOutputVidParam(4)->GetVidActiveType() == MEDIA_TYPE_NULL
// 								|| tHDParm.GetVidActiveType() == tVidChn.GetOutputVidParam(4)->GetVidActiveType())
// 							&& (tHDParm.GetAudType() == MEDIA_TYPE_NULL 
// 								|| tVidChn.GetOutputVidParam(4)->GetAudType() == MEDIA_TYPE_NULL 
// 								|| tHDParm.GetAudType() == tVidChn.GetOutputVidParam(4)->GetAudType())
// 							&& tHDParm.GetWidth() == tVidChn.GetOutputVidParam(4)->GetWidth()
// 							&& tHDParm.GetHeight() == tVidChn.GetOutputVidParam(4)->GetHeight())
// 						{
// 							return TRUE;
// 						}
// 					}
// 
// 					tVidChn.SetOutputVidParam(tHDParm, byOutIdx);	
// 					tStatus.m_tStatus.tHdBas.tStatus.tMpuBas.SetVidChnStatus(tVidChn, byChnId);
// 					SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
// 				}		
// 			}
// 			break;
// 		case TYPE_MAU_H263PLUS://只有双流？？？
// 			{
// 				tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(byChnId);
// 				byOutIdx = 0;
// 				if ((!tVidChn.GetOutputVidParam(byOutIdx)->IsNull() || !tVidChn.IsReserved())
// 					&& !bForceSet)
// 				{
// 					LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[SetBasAdaptParam] MauH263p<ChnId:%d, OutIdx:%d> AdaptParam is not null or chn not reserved!\n", 
// 																byChnId, byOutIdx);
// 					return FALSE;
// 				}
// 				else
// 				{
// 					tVidChn.SetOutputVidParam(tHDParm, byOutIdx);
// 					tStatus.m_tStatus.tHdBas.tStatus.tMauBas.SetDVidChnStatus(tVidChn, byChnId);
// 					SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
// 				}
// 			}		
// 			break;
// 		case TYPE_8KE_BAS:
// 			{
// 				tVidChn = *tStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0);
// 				u8 byOutNum = 0;
// 				BOOL32 bSetOK = FALSE;
// 				switch (tVidChn.GetType())
// 				{
// 				case BAS_8KECHN_MV:
// 					byOutNum = 4;
// 					break;
// 				case BAS_8KECHN_DS:
// 					 byOutNum = 3;
// 					break;
// 				case BAS_8KECHN_SEL:
// 					 byOutNum = 1;
// 					break;
// 				default:
// 					return FALSE;
// 				}
// 				for ( byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
// 				{
// 					if ((!tVidChn.GetOutputVidParam(byOutIdx)->IsNull() || !tVidChn.IsReserved()) && !bForceSet)
// 					{
// 						LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[SetBasAdaptParam] 8kebas<ChnId:%d, OutIdx:%d> AdaptParam is not null or chn not reserved!\n", 
// 							byChnId, byOutIdx);
// 						continue;
// 					}
// 					else
// 					{
// 						if (GetResByWH(tHDParm.GetWidth(), tHDParm.GetHeight()) > VIDEO_FORMAT_HD720)
// 						{
// 							return FALSE;
// 						}
// 
// 						//[2011/09/20/zhangli]根据8ke广播bas各通道能力加一些限制
// 						if (tVidChn.GetType() == BAS_8KECHN_MV && tHDParm.GetVidType() == MEDIA_TYPE_H264)
// 						{
// 							if (VIDEO_FORMAT_HD720 == GetResByWH(tHDParm.GetWidth(), tHDParm.GetHeight()) && byOutIdx > 0)
// 							{
// 								return FALSE;
// 							}
// 							else if (VIDEO_FORMAT_4CIF == GetResByWH(tHDParm.GetWidth(), tHDParm.GetHeight()) && byOutIdx > 1)
// 							{
// 								return FALSE;
// 							}
// 							else if (VIDEO_FORMAT_CIF == GetResByWH(tHDParm.GetWidth(), tHDParm.GetHeight()) && byOutIdx > 2)
// 							{
// 								return FALSE;
// 							}
// 						}
// 						else if (tVidChn.GetType() == BAS_8KECHN_SEL)
// 						{
// 							if (GetResByWH(tHDParm.GetWidth(), tHDParm.GetHeight()) > VIDEO_FORMAT_4CIF)
// 							{
// 								return FALSE;
// 							}
// 						}
// 
// 						if(tVidChn.GetOutputVidParam(byOutIdx)->IsNull() ||
// 							(!tVidChn.GetOutputVidParam(byOutIdx)->IsNull() && bForceSet &&
// 							  tVidChn.GetOutputVidParam(byOutIdx)->GetVidType() == tHDParm.GetVidType() &&
// 							  GetResByWH(tVidChn.GetOutputVidParam(byOutIdx)->GetWidth(), tVidChn.GetOutputVidParam(byOutIdx)->GetHeight())
// 								== GetResByWH(tHDParm.GetWidth(), tHDParm.GetHeight())))
// 						{
// 							//bSetOK = TRUE;
// 							tVidChn.SetOutputVidParam(tHDParm, byOutIdx);
// 							tStatus.m_tStatus.tHdBas.tStatus.t8keBas.SetVidChnStatus(tVidChn, 0);
// 							SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
// 							return TRUE;
// 						}
// 						//级联调分辨率时不考虑与原分辨率是否相同
// 						else if (bAdjRes)
// 						{
// 							tVidChn.SetOutputVidParam(tHDParm, byOutIdx);
// 							tStatus.m_tStatus.tHdBas.tStatus.t8keBas.SetVidChnStatus(tVidChn, 0);
// 							SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
// 							return TRUE;
// 						}
// 					}
// 				}	
// 				if (!bSetOK)
// 				{
// 					return FALSE;
// 				}
// 			}
// 			break;
// 		default:
// 			LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[SetBasAdaptParam] unexpected basType:%d!\n", byHDBasType);
// 			return FALSE;
// 		}
// 	}
// #ifndef _8KE_
// 	else//目前只有vpu
// 	{
// 		if (ADAPT_TYPE_AUD == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetChannelType())
// 		{
// 			if (MEDIA_TYPE_NULL == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetAudType() ||
// 				0 == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetAudType() ||
// 				bForceSet)
// 			{
// 				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetVidType(MEDIA_TYPE_NULL);
// 				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudType(tHDParm.GetAudType());
// 				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudActiveType(tHDParm.GetAudActiveType());
// 				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetBitRate(tHDParm.GetBitrate());
// 				SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
// 			}	
// 			else
// 			{
// 				LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[SetBasAdaptParam] Audbas<EqpId:%d, ChnId:%d>'s param is not null!\n", tEqp.GetEqpId(), byChnId);
// 				return FALSE;
// 			}
// 		}
// 		else if(ADAPT_TYPE_VID == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetChannelType())
// 		{
// 			if(MEDIA_TYPE_NULL == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetVidType() ||
// 				0 == tStatus.m_tStatus.tBas.tChnnl[byChnId].GetVidType() ||
// 				bForceSet)
// 			{
// 				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudType(MEDIA_TYPE_NULL);
// 				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetAudActiveType(tHDParm.GetAudActiveType());
// 				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetVidType(tHDParm.GetVidType());
// 				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetVidActiveType(tHDParm.GetVidActiveType());
// 				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetBitRate(tHDParm.GetBitrate());
// 				tStatus.m_tStatus.tBas.tChnnl[byChnId].SetResolution(tHDParm.GetWidth(), tHDParm.GetHeight());
// 				SetPeriEqpStatus(tEqp.GetEqpId(), &tStatus);
// 			}
// 			else
// 			{
// 				LogPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[SetBasAdaptParam] Vidbas<EqpId:%d, ChnId:%d>'s param is not null!\n", tEqp.GetEqpId(), byChnId);
// 				return FALSE;
// 			}
// 		}
// 	}
// #endif
// 	return TRUE;
// }
/*====================================================================
函数名      : GetBasOutPutParam
功能        : 获取适配参数
算法实现    ：
引用全局变量：
输入参数说明：
				const TEqp &tEqp				外设信息
				u8      byChnId					通道入索引	
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
06/21/2010              周嘉麟         创建
====================================================================*/
BOOL32 CMcuVcData::GetBasOutPutParam(const TEqp &tEqp, u8 byChnId, u8 &byOutNum, THDAdaptParam *ptParam)
{
	if (tEqp.IsNull())
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasOutPutParam] tEqp is null!\n");
		return FALSE;
	}
	
	TPeriEqpStatus tBasStatus;
	if (!GetPeriEqpStatus(tEqp.GetEqpId(), &tBasStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasOutPutParam] GetPeriEqpStatus-->EqpId:%d failed!\n", tEqp.GetEqpId());
		return FALSE;
	}
	THDBasVidChnStatus *ptVidChn = NULL;
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if (g_cMcuAgent.IsEqpBasHD(tEqp.GetEqpId()))
#endif
	{
		u8 byHDType = tBasStatus.m_tStatus.tHdBas.GetEqpType();
		switch (byHDType)
		{
		case TYPE_MPU:
			{
				ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId);
				if ( ptVidChn != NULL )
				{
					byOutNum = MAXNUM_MPU_VOUTPUT;
					for (u8 byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
					{
						ptParam[byOutIdx] = *( ptVidChn->GetOutputVidParam(byOutIdx) );
					}
				}	
			}
			break;
		case TYPE_MPU_H:
			{
				ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId);
				if ( ptVidChn != NULL )
				{
					byOutNum = MAXNUM_MPU_H_VOUTPUT;
					for (u8 byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
					{
						ptParam[byOutIdx] = *( ptVidChn->GetOutputVidParam(byOutIdx) );
					}
				}
			}
			break;
		case TYPE_MPU2_BASIC:
			{
				ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnId);
				if ( ptVidChn != NULL )
				{
					if ( byChnId == 0 )
					{
						byOutNum = MPU2_BAS_BASIC_MVOUTPUT;
					}
					else if ( byChnId == 1 )
					{
						byOutNum = MPU2_BAS_BASIC_DSOUTPUT;
					}
					else
					{
						byOutNum = MPU2_BAS_BASIC_SELOUTPUT;
					}
					
					for (u8 byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
					{
						ptParam[byOutIdx] = *( ptVidChn->GetOutputVidParam(byOutIdx) );
					}
				}
			}
			break;
		case TYPE_MPU2_ENHANCED:
			{
				ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnId);
				if ( ptVidChn != NULL )
				{
					if ( byChnId == 0  )
					{
						byOutNum = MPU2_BAS_ENHACNED_MVOUTPUT;
					}
					else if ( byChnId == 1 )
					{
						byOutNum = MPU2_BAS_ENHACNED_DSOUTPUT;
					}
					else
					{
						byOutNum = MPU2_BAS_ENHACNED_SELOUTPUT;
					}
					
					for (u8 byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
					{
						ptParam[byOutIdx] = *( ptVidChn->GetOutputVidParam(byOutIdx) );
					}
				}
			}
			break;
		case TYPE_MAU_NORMAL:
		case TYPE_MAU_H263PLUS:
			{
				if ( byChnId == 0 )
				{
					ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnId);
				}
				else
				{
					ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(byChnId);
				}

				if ( ptVidChn != NULL )
				{
					byOutNum = MAXNUM_VOUTPUT;
					for (u8 byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
					{
						ptParam[byOutIdx] = *( ptVidChn->GetOutputVidParam(byOutIdx) );
					}
				}
			}
			break;
		case TYPE_8KE_BAS:
			{
				ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(byChnId);
				if ( ptVidChn != NULL )
				{
					byOutNum = MAXNUM_8KEBAS_VOUTPUT;
					for (u8 byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
					{
						ptParam[byOutIdx] = *( ptVidChn->GetOutputVidParam(byOutIdx) );
					}
				}
			}
			break;
		case TYPE_8KH_BAS:
			{
				ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(byChnId);
				if ( ptVidChn != NULL )
				{
					byOutNum = MAXNUM_8KHBAS_VOUTPUT;
					for (u8 byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
					{
						ptParam[byOutIdx] = *( ptVidChn->GetOutputVidParam(byOutIdx) );
					}
				}
			}
			break;
		case TYPE_8KI_VID_BAS:
			{
				ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.t8kiBas.GetVidChnStatus(byChnId);
				if ( ptVidChn != NULL )
				{
					byOutNum = MAXNUM_8KHBAS_VOUTPUT;
					for (u8 byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
					{
						ptParam[byOutIdx] = *( ptVidChn->GetOutputVidParam(byOutIdx) );
					}
				}
			}
			break;
		default:
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasOutPutParam] unexpected HDBas Type:%d!\n", byHDType);
			return FALSE;
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else
	{
		byOutNum = MAXNUM_VPU_VAOUTPUT;
		TBasChnStatus tBasChnStatus = tBasStatus.m_tStatus.tBas.tChnnl[byChnId];
		ptParam[0].SetAudActiveType(tBasChnStatus.GetAudActiveType());
		ptParam[0].SetAudType(tBasChnStatus.GetAudType());
		ptParam[0].SetBitRate(tBasChnStatus.GetBitrate());
		ptParam[0].SetResolution(tBasChnStatus.GetWidth(), tBasChnStatus.GetHeight());
		ptParam[0].SetVidType(tBasChnStatus.GetVidType());
		ptParam[0].SetVidActiveType(tBasChnStatus.GetVidActiveType());
	}
#endif
	return TRUE;
}

/*====================================================================
函数名      : GetAudBasOutPutParam
功能        : 获取适配参数
算法实现    ：
引用全局变量：
输入参数说明：
const TEqp &tEqp				外设信息
u8      byChnId					通道入索引	
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/13  4.7         倪志俊         创建
====================================================================*/
BOOL32 CMcuVcData::GetAudBasOutPutParam(const TEqp &tEqp, u8 byChnId, u8 &byOutNum, TAudAdaptParam *ptParam)
{
	if (tEqp.IsNull())
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetAudBasOutPutParam] tEqp is null!\n");
		return FALSE;
	}
	
	TPeriEqpStatus tBasStatus;
	if (!GetPeriEqpStatus(tEqp.GetEqpId(), &tBasStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetAudBasOutPutParam] GetPeriEqpStatus-->EqpId:%d failed!\n", tEqp.GetEqpId());
		return FALSE;
	}
	
	TAudBasChnStatus *ptAudChn = NULL;
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if (g_cMcuAgent.IsEqpBasAud(tEqp.GetEqpId()))
#endif
	{
		u8 byHDType = tBasStatus.m_tStatus.tAudBas.GetEqpType();
		switch (byHDType)
		{
		case TYPE_APU2_BAS:
			{
				ptAudChn = tBasStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.GetAudChnStatus(byChnId);
				if ( ptAudChn != NULL )
				{
					byOutNum = MAXNUM_APU2BAS_OUTCHN;
					for (u8 byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
					{
						ptParam[byOutIdx] = *( ptAudChn->GetOutputAudParam(byOutIdx) );
					}
				}	
			}
			break;
		case TYPE_8KI_AUD_BAS:
			{
				ptAudChn = tBasStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChnId);
				if ( ptAudChn != NULL )
				{
					byOutNum = MAXNUM_8KIAUDBAS_OUTPUT;
					for (u8 byOutIdx = 0; byOutIdx < byOutNum; byOutIdx++)
					{
						ptParam[byOutIdx] = *( ptAudChn->GetOutputAudParam(byOutIdx) );
					}
				}	
			}
			break;
		default:
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetAudBasOutPutParam] unexpected HDBas Type:%d!\n", byHDType);
			return FALSE;
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	//vpu
	else
	{
		byOutNum = MAXNUM_VPU_VAOUTPUT;
		TBasChnStatus tBasChnStatus = tBasStatus.m_tStatus.tBas.tChnnl[byChnId];
		ptParam[0].SetAudActiveType(tBasChnStatus.GetAudActiveType());
		ptParam[0].SetAudCodeType(tBasChnStatus.GetAudType());
		ptParam[0].SetTrackNum(1);
	}
#endif
	
	return TRUE;
}


/*====================================================================
函数名      : ClearAdaptParam
功能        : 清空适配参数
算法实现    ：
引用全局变量：
输入参数说明：
			  const TEqp &tEqp				外设信息
			  u8 byChnId					通道入索引	
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
06/21/2010              周嘉麟         创建
====================================================================*/
BOOL32 CMcuVcData::ClearAdaptParam(const TEqp &tEqp, u8 byChnId, u8 byMediaMode)
{
	if (tEqp.IsNull())
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS,"[ClearAdaptParam] tEqp is null!\n");
		return FALSE;
	}
	TPeriEqpStatus tBasStatus;
	if (!GetPeriEqpStatus(tEqp.GetEqpId(), &tBasStatus))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ClearAdaptParam] GetPeriEqpStatus-->EqpId:%d failed!\n", tEqp.GetEqpId());
		return FALSE;
	}

	u8 byOutPutNum = 0;
	u8 byOutFrontNum =0;
	if ( !GetBasChnFrontOutPutNum(tEqp,byChnId,byOutPutNum,byOutFrontNum) )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ClearAdaptParam] GetBasChnFrontOutPutNum-->EqpId:%d failed!\n", tEqp.GetEqpId());
		return FALSE;
	}

#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if(g_cMcuAgent.IsEqpBasHD(tEqp.GetEqpId()))
#endif
	{
		THDBasVidChnStatus *ptVidChn = NULL;
		THDAdaptParam tParam;
		tParam.Reset();
		u8 byHDType = tBasStatus.m_tStatus.tHdBas.GetEqpType();
		switch (byHDType)
		{
		case TYPE_MPU2_BASIC:
		case TYPE_MPU2_ENHANCED:
			{
				if (MODE_VIDEO == byMediaMode || MODE_SECVIDEO == byMediaMode)
				{
					ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnId);
				}
				else
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ClearAdaptParam][HDBasType:%d] Not Support other media:%d!\n", byMediaMode);
					return FALSE;
				}
			}
			break;
		case TYPE_MPU:
		case TYPE_MPU_H:
			{
				if (MODE_VIDEO == byMediaMode || MODE_SECVIDEO == byMediaMode)
				{
					ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnId);
				}
				else
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ClearAdaptParam][HDBasType:%d] Not Support other media:%d!\n", byMediaMode);
					return FALSE;
				}
			}
			break;
		case TYPE_MAU_NORMAL:
			{
				if (MODE_VIDEO == byMediaMode)
				{
					ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnId);
				}
				else if(MODE_SECVIDEO == byMediaMode)
				{
					ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(byChnId);
				}
				else
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ClearAdaptParam][TYPE_MAU_NORMAL] Not Support other media:%d!\n");
					return FALSE;
				}
			}
			break;
		case TYPE_MAU_H263PLUS:
			{
				if (MODE_VIDEO == byMediaMode)
				{
					ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnId);
				}
				else if(MODE_SECVIDEO == byMediaMode)
				{
					ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(byChnId);
				}
				else
				{
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ClearAdaptParam][TYPE_MAU_H263PLUS] Not Support other media:%d!\n");
					return FALSE;
				}
			}
			break;
		case TYPE_8KE_BAS:
			{
				ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0);
			}
			break;
		case TYPE_8KH_BAS:
			{
				ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0);
			}
			break;
		case TYPE_8KI_VID_BAS:
			{
				ptVidChn = tBasStatus.m_tStatus.tHdBas.tStatus.t8kiBas.GetVidChnStatus(0);
			}
			break;
		default:	
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ClearAdaptParam] unexpected HDBas Type:%d!\n", byHDType);
			return FALSE;
#else
			break;
#endif
		}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
		if (NULL == ptVidChn)
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ClearAdaptParam] ptVidChn-->BasType:%d is null!\n", byHDType);
			return FALSE;
		}
#endif

		if ( NULL != ptVidChn && 0 != byOutPutNum)
		{
			for (u8 byOutIdx = 0; byOutIdx < byOutPutNum; byOutIdx++)
			{
				ptVidChn->SetOutputVidParam(tParam, byOutIdx);
			}
		}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
		else
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ClearAdaptParam] GetBasOutPutChnNumAcdMode failed!\n");
			return FALSE;
		}
#endif
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else if ( g_cMcuAgent.IsEqpBasAud(tEqp.GetEqpId())  )
#endif
	{
		u8 byAudType = tBasStatus.m_tStatus.tAudBas.GetEqpType();
		TAudAdaptParam tAudNullParam;
		tAudNullParam.Clear();
		if (byAudType == TYPE_APU2_BAS || byAudType == TYPE_8KI_AUD_BAS)
		{
			TAudBasChnStatus *pAudBasChn = NULL;
			if( byAudType == TYPE_APU2_BAS )
			{
				pAudBasChn = tBasStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.GetAudChnStatus(byChnId);
			}
			else
			{
				pAudBasChn = tBasStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChnId);
			}
			
			if (NULL == pAudBasChn)
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ClearAdaptParam] ptVidChn-->BasType:%d is null!\n", byAudType);
				return FALSE;
			}
			if (0 != byOutPutNum)
			{
				for (u8 byOutIdx = 0; byOutIdx < byOutPutNum; byOutIdx++)
				{
					pAudBasChn->SetOutputAudParam(tAudNullParam, byOutIdx);
				}
			}
			else
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ClearAdaptParam] GetBasOutPutChnNumAcdMode failed!\n");
				return FALSE;
			}
		}
	}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	else
	{	
		TBasChnStatus tBasChnStatus;
		memset(&tBasChnStatus, 0, sizeof(tBasChnStatus));
		tBasChnStatus.SetStatus(tBasStatus.m_tStatus.tBas.tChnnl[byChnId].GetStatus());
		tBasChnStatus.SetChannelType(tBasStatus.m_tStatus.tBas.tChnnl[byChnId].GetChannelType());
		tBasChnStatus.SetReserved(tBasStatus.m_tStatus.tBas.tChnnl[byChnId].IsReserved());
		memcpy(&tBasStatus.m_tStatus.tBas.tChnnl[byChnId], &tBasChnStatus, sizeof(tBasChnStatus));
	}
#endif
	SetPeriEqpStatus(tEqp.GetEqpId(), &tBasStatus);
	return TRUE;
}

/*====================================================================
    函数名      ：GetMonitorIdx
    功能        ：获取监控索引（根据dst地址）
    算法实现    ：（该接口不对外）
    引用全局变量：
    输入参数说明：u8 byMode						[i] 模式
				  const TTransportAddr &tTransportAddr	[i] dst Addr
    返回值说明  ：u16	监控索引值	
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/08/28    4.6         薛亮	        创建
====================================================================*/
u16 TMonitorMgr::GetMonitorIdx(u8 byMode, const TTransportAddr &tTransportAddr)
{
	u16 wMonitorIdx = MAXNUM_MONITOR_NUM;
	u32 dwIp = tTransportAddr.GetIpAddr();
	u16 wPort = tTransportAddr.GetPort();
// 	u16 wPort = tMonitorData.GetAPort();

	for(u16 wIdx = 0; wIdx < MAXNUM_MONITOR_NUM; wIdx ++)
	{
		if( m_atMonitorDate[wIdx].GetDstAddr().GetIpAddr() == dwIp
			&& m_atMonitorDate[wIdx].GetDstAddr().GetPort() == wPort
			&& m_atMonitorDate[wIdx].GetMode() == byMode
			&& !(m_atMonitorDate[wIdx].GetMonitorSrc().IsNull())
			)
		{
			wMonitorIdx = wIdx;
			break;
		}
			
	}
	return wMonitorIdx;
}

/*====================================================================
    函数名      ：SetMonitorData
    功能        ：设置监控数据
    算法实现    ：（该接口不对外）
    引用全局变量：
    输入参数说明：	u16 wIdx						[i] 监控索引
					TMonitorData tMonitorData		[i]
    返回值说明  ：BOOL32	
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/08/28    4.6         薛亮	        创建
====================================================================*/
BOOL32 TMonitorMgr::SetMonitorData(u16 wIdx, TMonitorData tMonitorData)
{
	if( wIdx >= MAXNUM_MONITOR_NUM )
	{
		return FALSE;
	}

	m_atMonitorDate[wIdx] = tMonitorData;
	
	return TRUE;
}

/*====================================================================
    函数名      ：AddMonitorData
    功能        ：添加监控数据
    算法实现    ：
    引用全局变量：
    输入参数说明：TMonitorData tMonitorData		[i]
    返回值说明  ：BOOL32	
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/08/28    4.6         薛亮	        创建
====================================================================*/
BOOL32 TMonitorMgr::AddMonitorData(TMonitorData tMonitorData)
{
	TTransportAddr tDstAddr = tMonitorData.GetDstAddr();
	u16 wIdx = GetMonitorIdx( tMonitorData.GetMode(),tDstAddr);
	
	if( wIdx < MAXNUM_MONITOR_NUM )
	{
		//idx 找到的情况下，就用该idx
		SetMonitorData(wIdx, tMonitorData);
	}
	else
	{
		//重新分配idx
		wIdx = AssignMonitorIdx();
		if( wIdx < MAXNUM_MONITOR_NUM )
		{
			SetMonitorData(wIdx, tMonitorData);
		}
		else
		{
			//print error
			LogPrint(LOG_LVL_ERROR, MID_MCU_EQP, "Cannot find vacant monitor Idx!\n");
			return FALSE;
		}
		
	}
	return TRUE;
}

/*====================================================================
    函数名      ：AssignMonitorIdx
    功能        ：分配监控索引
    算法实现    ：（该接口不对外）
    引用全局变量：
    输入参数说明：void
    返回值说明  ：u16	监控索引号	
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/08/28    4.6         薛亮	        创建
====================================================================*/
u16 TMonitorMgr::AssignMonitorIdx(void)
{
	u16 wVacantIdx = MAXNUM_MONITOR_NUM;

	for(u16 wIdx = 0; wIdx < MAXNUM_MONITOR_NUM; wIdx ++)
	{
		if(m_atMonitorDate[wIdx].IsVacant())
		{
			wVacantIdx = wIdx;
			break;
		}
	}

	return wVacantIdx;
}

/*====================================================================
    函数名      ：GetMonitorSrc
    功能        ：获取某监控的源
    算法实现    ：通过监控索引来获取对应的源（该接口不对外）
    引用全局变量：
    输入参数说明：u16 wIdx						[i] 监控的索引
				  TMt *ptSrc					[o] 源
    返回值说明  ：BOOL32	
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/08/28    4.6         薛亮	        创建
====================================================================*/
BOOL32 TMonitorMgr::GetMonitorSrc(u16 wIdx, TMt *ptSrc)
{
	BOOL32 bRet = TRUE;
	if(wIdx < MAXNUM_MONITOR_NUM )
	{
		*ptSrc = m_atMonitorDate[wIdx].GetMonitorSrc();
	}
	else
	{
		bRet = FALSE;
	}
	return bRet;
}

/*====================================================================
    函数名      ：GetMonitorSrc
    功能        ：获取某监控的源
    算法实现    ：通过监控接收地址来查找获取对应的源
    引用全局变量：
    输入参数说明：u8 byMode						[i] 表征获取视频还是音频源
				  const TTransportAddr &tTransportAddr	[i] 监控接收地址
				  TMt *ptSrc					[o] 源
    返回值说明  ：BOOL32	
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/08/28    4.6         薛亮	        创建
====================================================================*/
BOOL32 TMonitorMgr::GetMonitorSrc(u8 byMode, const TTransportAddr &tTransportAddr, TMt *ptSrc)
{
	u16 wIdx = GetMonitorIdx(byMode, tTransportAddr);
	return GetMonitorSrc(wIdx, ptSrc);
}

/*====================================================================
    函数名      ：GetMonitorData
    功能        ：获取某监控的数据
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wIdx						[i] 监控通道的索引
				  TMonitorData &tMonitorData	[o] 
    返回值说明  ：BOOL32	获取到则返回TRUE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/08/28    4.6         薛亮	        创建
====================================================================*/
BOOL32 TMonitorMgr::GetMonitorData(u16 wIdx, TMonitorData &tMonitorData)
{
	BOOL32 bRet = TRUE;
	if(wIdx < MAXNUM_MONITOR_NUM)
	{
		tMonitorData = m_atMonitorDate[wIdx];
	}
	else
	{
		bRet = FALSE;
	}
	return bRet;
}

/*====================================================================
    函数名      ：SetMonitorSrc
    功能        ：设置某监控的源
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wMcInstId					[i] 界面的实例id
				  u8  byMode					[i] 视频 or 音频
				  const TTransportAddr &tTransportAddr [i]监控的接收地址
				  const TMt &tSrc				[i] 源
    返回值说明  ：BOOL32
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/08/28    4.6         薛亮	        创建
====================================================================*/
BOOL32 CMcuVcData::SetMonitorSrc( u16 wMcInstId, u8 byMode, const TTransportAddr &tTransportAddr, const TMt &tSrc)
{
	if( wMcInstId == 0 || wMcInstId > MAXNUM_MCU_MC + MAXNUM_MCU_VC || byMode == MODE_NONE || byMode == MODE_BOTH)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_MCS, "[SetMonitorSrc] error param: wMcInstId is %d, byMode is %d\n", wMcInstId, byMode);
		return FALSE;
	}
	
	BOOL32 bRet = TRUE;

	TMonitorData tMonitorData;
	tMonitorData.SetDstAddr(tTransportAddr);
	tMonitorData.SetMonitorSrc( tSrc);
	tMonitorData.SetMode(byMode);
	
	bRet = m_atMonitorTable[wMcInstId -1].AddMonitorData(tMonitorData) ;
	return bRet;

}

/*====================================================================
    函数名      ：GetMonitorSrc
    功能        ：获取某监控的源
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wMcInstId					[i] 界面的实例id
				  u8  byMode					[i] 视频 or 音频
				  const TTransportAddr &tTransportAddr [i]监控的接收地址
				  TMt * ptSrc					[o] 源
    返回值说明  ：BOOL32
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/08/28    4.6         薛亮	        创建
====================================================================*/
BOOL32 CMcuVcData::GetMonitorSrc( u16 wMcInstId, u8 byMode, const TTransportAddr &tTransportAddr, TMt * ptSrc )
{
	if( wMcInstId == 0 || wMcInstId > MAXNUM_MCU_MC + MAXNUM_MCU_VC || byMode == MODE_NONE || byMode == MODE_BOTH)
	{
		return FALSE;
	}
	
	return (m_atMonitorTable[wMcInstId -1].GetMonitorSrc(byMode, tTransportAddr, ptSrc) );
}

/*====================================================================
    函数名      ：GetMonitorData
    功能        ：获取某监控的数据
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wMcInstId					[i] 界面的实例id
				  u16 wIdx						[i] 监控通道的索引
				  TMonitorData &tMonitorData	[o] 
    返回值说明  ：BOOL32	只有当取到数据且源不为NULL，才返回TRUE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/08/28    4.6         薛亮	        创建
====================================================================*/
BOOL32 CMcuVcData::GetMonitorData( u16 wMcInstId, u16 wIdx, TMonitorData &tMonitorData)
{
	if( wMcInstId == 0 || wMcInstId > MAXNUM_MCU_MC + MAXNUM_MCU_VC )
	{
		return FALSE;
	}

	m_atMonitorTable[wMcInstId -1].GetMonitorData(wIdx, tMonitorData);

	return ( !tMonitorData.IsVacant() );	//实际src是null，返回false
	
}

/*====================================================================
函数名         GetBasListBuf
功能        ：获取适配链表缓存信息
算法实现    ：
引用全局变量：
输入参数说明： 
u8 byChnId  通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30     4.6        周嘉麟          创建
2012/03/28   4.7		倪志俊			修改
====================================================================*/
u32 CBasChnListMgr::GetBasListBuf(u8 *pbyBuf)
{
	if (NULL == pbyBuf)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasListBuf] pBuf is null!\n");
		return 0 ;
	}
    u32 dwBasListLen = 0;
	u8 byNodeNum = 0;
	CBasChnNode *ptTmpNode = m_pHeadNode;
	
	//加结点个数
	while(ptTmpNode)
	{
		byNodeNum ++;
		ptTmpNode = ptTmpNode->GetNext();
	}
	memcpy(pbyBuf, (s8*)&byNodeNum, sizeof(byNodeNum));
	pbyBuf += sizeof(byNodeNum);
	dwBasListLen += sizeof(byNodeNum);
	
	//累加结点:结点类型+数据 --结点类型+数据--结点类型+数据....
	ptTmpNode = m_pHeadNode;
	u8	byChnType = (u8)ILLEGAL_BAS_CHN;
	while(ptTmpNode)
	{		
		CBasChn *pTmpBasChn = ptTmpNode->GetBasChnData();
		if ( NULL == pTmpBasChn )
		{
			ptTmpNode = ptTmpNode->GetNext();
			continue;
		}
		
		//类型
		TPeriEqpStatus tBasStatus;
		if ( !g_cMcuVcApp.GetPeriEqpStatus(pTmpBasChn->GetBas().GetEqpId(), &tBasStatus) )
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasListBuf] GetPeriEqpStatus failed!\n");
			return 0;
		}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
		if (g_cMcuAgent.IsEqpBasHD(pTmpBasChn->GetBas().GetEqpId()))
#endif
		{
			u8 byHDBasType = tBasStatus.m_tStatus.tHdBas.GetEqpType();
			switch (byHDBasType)
			{
			case TYPE_MPU:
			case TYPE_MPU_H:
			case TYPE_MAU_NORMAL:
			case TYPE_MAU_H263PLUS:
			case TYPE_8KE_BAS:
			case TYPE_8KH_BAS:
			case TYPE_8KI_VID_BAS:
				{
					byChnType = (u8)OLD_BAS_CHN;	
				}
				break;
			case TYPE_MPU2_BASIC:
			case TYPE_MPU2_ENHANCED:
				{
					byChnType = (u8)MPU2_BAS_CHN;
				}
				break;
			default:
				if( tBasStatus.m_tStatus.tAudBas.GetEqpType() == TYPE_8KI_AUD_BAS )
				{
					byChnType = X868KI_AUDBAS_CHN;
				}
				else
				{
					LogPrint( LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasListBuf] unexpected HDBas Type:%d!\n", byHDBasType);
				}
				break;
			}
		}
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
		else if ( g_cMcuAgent.IsEqpBasAud(pTmpBasChn->GetBas().GetEqpId())  )
		{
			u8 byAudType = tBasStatus.m_tStatus.tAudBas.GetEqpType();
			if (byAudType == TYPE_APU2_BAS)
			{
				byChnType = (u8)APU2_BAS_CHN;
			}
		}
		else//标清适配器 
		{
			byChnType = (u8)OLD_BAS_CHN;
		}
#endif
		if ( byChnType == OLD_BAS_CHN )
		{
			memcpy(pbyBuf,(u8*)&byChnType,sizeof(byChnType));
			pbyBuf += sizeof(byChnType);
			dwBasListLen += sizeof(byChnType);
			
			memcpy(pbyBuf, pTmpBasChn, sizeof(COldBasChn));
			pbyBuf += sizeof(COldBasChn);
			dwBasListLen += sizeof(COldBasChn);

			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[GetBasListBuf] OLD_BAS EqpId:%d, ChnId:%d, EncNum:%d!\n", 
				pTmpBasChn->GetBas().GetEqpId(),
				pTmpBasChn->GetChnId(),
				pTmpBasChn->GetEncNum()
				);
		}
		else if ( byChnType == MPU2_BAS_CHN )
		{
			memcpy(pbyBuf,(u8*)&byChnType,sizeof(byChnType));
			pbyBuf += sizeof(byChnType);
			dwBasListLen += sizeof(byChnType);

			memcpy(pbyBuf, pTmpBasChn, sizeof(CMpu2BasChn));
			pbyBuf += sizeof(CMpu2BasChn);
			dwBasListLen += sizeof(CMpu2BasChn);

			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[GetBasListBuf] MPU2_BAS EqpId:%d, ChnId:%d, EncNum:%d!\n", 
				pTmpBasChn->GetBas().GetEqpId(),
				pTmpBasChn->GetChnId(),
				pTmpBasChn->GetEncNum()
				);
		}
		else if ( byChnType == APU2_BAS_CHN )
		{
			memcpy(pbyBuf,(u8*)&byChnType,sizeof(byChnType));
			pbyBuf += sizeof(byChnType);
			dwBasListLen += sizeof(byChnType);
			
			memcpy(pbyBuf, pTmpBasChn, sizeof(CApu2BasChn));
			pbyBuf += sizeof(CApu2BasChn);
			dwBasListLen += sizeof(CApu2BasChn);
			
			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[GetBasListBuf] APU2_BAS EqpId:%d, ChnId:%d, EncNum:%d!\n", 
				pTmpBasChn->GetBas().GetEqpId(),
				pTmpBasChn->GetChnId(),
				pTmpBasChn->GetEncNum()
				);
		}
		else if( X868KI_AUDBAS_CHN == byChnType )
		{
			memcpy(pbyBuf,(u8*)&byChnType,sizeof(byChnType));
			pbyBuf += sizeof(byChnType);
			dwBasListLen += sizeof(byChnType);

			memcpy(pbyBuf, pTmpBasChn, sizeof(C8KIAudBasChn));
			pbyBuf += sizeof(C8KIAudBasChn);
			dwBasListLen += sizeof(C8KIAudBasChn);

			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[GetBasListBuf] X868KI_AUDBAS_CHN EqpId:%d, ChnId:%d, EncNum:%d!\n", 
				pTmpBasChn->GetBas().GetEqpId(),
				pTmpBasChn->GetChnId(),
				pTmpBasChn->GetEncNum()
				);
		}
		ptTmpNode = ptTmpNode->GetNext();
	}
	return dwBasListLen;
}

/*====================================================================
函数名         SetBasListBuf
功能        ：备份适配链表缓存信息
算法实现    ：
引用全局变量：
输入参数说明： 
u8 byChnId  通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30     4.6        周嘉麟          创建
2012/03/28   4.7		倪志俊			修改
====================================================================*/
u32 CBasChnListMgr::SetBasListBuf(u8 *pbyBuf)
{
	if (NULL == pbyBuf)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetBasListBuf]pbyBuf = null!\n ");
		return 0;
	}
    u32 dwBasListLen = 0;
	
	u8 byNodeNum  = *(u8*)pbyBuf;
	pbyBuf       += sizeof(byNodeNum);
	dwBasListLen += sizeof(byNodeNum);
	LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[SetBasListBuf] BasNodeNum is %d!\n", byNodeNum);

	CBasChn *pChnData = NULL;
	CBasChn *pNewData = NULL;
	u8	byBasChnType = ILLEGAL_BAS_CHN;
	for (u8 byNodeIdx = 0; byNodeIdx < byNodeNum; byNodeIdx++)
	{
		byBasChnType = *(u8*)pbyBuf;
		pbyBuf		 += sizeof(byBasChnType);
		dwBasListLen += sizeof(byBasChnType);
	
		if ( byBasChnType == OLD_BAS_CHN )
		{
			pChnData = (COldBasChn*)pbyBuf;	
		}
		else if ( byBasChnType == MPU2_BAS_CHN )
		{
			pChnData = (CMpu2BasChn*)pbyBuf;	
		}
		else if ( byBasChnType == APU2_BAS_CHN )
		{
			pChnData = (CApu2BasChn*)pbyBuf;	
		}
		else if( X868KI_AUDBAS_CHN == byBasChnType )
		{
			pChnData = (C8KIAudBasChn*)pbyBuf;
		}
		else
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetBasListBuf]byBasChnType is :%d!\n ",byBasChnType);
			return 0;
		}

		if ( byBasChnType == OLD_BAS_CHN )
		{
			if ( NULL == pChnData )
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetBasListBuf]pChnData is NULL!\n ");
			}
			else if ( !IsNodeExist(pChnData->GetBas(), pChnData->GetChnId()) )
			{
				pNewData = new COldBasChn(*(COldBasChn*)pChnData);			
				LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[SetBasListBuf] OldBas EqpId:%d, ChnId:%d, EncNum%d,IsReseve:%d!\n", 
					pNewData->GetBas().GetEqpId(),
					pNewData->GetChnId(),
					pNewData->GetEncNum(),
					pNewData->IsReserved()
					);
				
				if(!AddBasChnBySort(pNewData))
				{
					delete pNewData;
					pNewData = NULL;
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetBasListBuf] OldBas AddBasChnBySort failed!\n");
				}
			}
			//if baschn has existed,update the baschn's content.
			else
			{
				CBasChn *pTempBasChn = GetBasChnAddr(pChnData->GetBas(), pChnData->GetChnId());
				if ( pTempBasChn!= NULL )
				{
					pTempBasChn->SetIsReserved( pChnData->IsReserved() );
					pTempBasChn->SetSrc( pChnData->GetSrc() );
					pTempBasChn->SetMediaMode( pChnData->GetMediaMode() );
					pTempBasChn->SetVcuTick(pChnData->GetVcuTick());
				}
				LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[SetBasListBuf]update the baschn's:%d-%d content IsReseve:%d!\n",
						pChnData->GetBas().GetEqpId(), 
						pChnData->GetChnId(),
						pChnData->IsReserved()
						);
			}

			pbyBuf		 += sizeof(COldBasChn);
			dwBasListLen += sizeof(COldBasChn);
		}
		else if ( byBasChnType == MPU2_BAS_CHN )
		{
			if ( NULL == pChnData )
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetBasListBuf]pChnData is NULL!\n ");
			}
			else if ( !IsNodeExist(pChnData->GetBas(), pChnData->GetChnId()) )
			{
				pNewData = new CMpu2BasChn(*(CMpu2BasChn*)pChnData);				
				LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[SetBasListBuf] MPU2Bas EqpId:%d, ChnId:%d, EncNum%d,IsReseve:%d!\n", 
					pNewData->GetBas().GetEqpId(),
					pNewData->GetChnId(),
					pNewData->GetEncNum(),
					pNewData->IsReserved()
					);

				if(!AddBasChnBySort(pNewData))
				{
					delete pNewData;
					pNewData = NULL;
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetBasListBuf] MPU2Bas AddBasChnBySort failed!\n");
				}
			}
			//if baschn has existed,update the baschn's content.
			else
			{
				CBasChn *pTempBasChn = GetBasChnAddr(pChnData->GetBas(), pChnData->GetChnId());
				if ( pTempBasChn!= NULL )
				{
					pTempBasChn->SetIsReserved( pChnData->IsReserved() );
					pTempBasChn->SetSrc( pChnData->GetSrc() );
					pTempBasChn->SetMediaMode( pChnData->GetMediaMode() );
					pTempBasChn->SetVcuTick(pChnData->GetVcuTick());
				}
				LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[SetBasListBuf]update the baschn's:%d-%d content,IsReseve:%d!\n",
						 pChnData->GetBas().GetEqpId(),
						 pChnData->GetChnId(),
						 pChnData->IsReserved()
						 );
			}
			pbyBuf		 += sizeof(CMpu2BasChn);
			dwBasListLen += sizeof(CMpu2BasChn);
		}
		else if ( byBasChnType == APU2_BAS_CHN )
		{
			if ( NULL == pChnData )
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetBasListBuf]pChnData is NULL!\n ");
			}
			else if ( !IsNodeExist(pChnData->GetBas(), pChnData->GetChnId()) )
			{
				pNewData = new CApu2BasChn(*(CApu2BasChn*)pChnData);				
				LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[SetBasListBuf] APU2_BAS EqpId:%d, ChnId:%d, EncNum%d,IsReseve:%d!\n", 
					pNewData->GetBas().GetEqpId(),
					pNewData->GetChnId(),
					pNewData->GetEncNum(),
					pNewData->IsReserved()
					);
				
				if(!AddBasChnBySort(pNewData))
				{
					delete pNewData;
					pNewData = NULL;
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetBasListBuf] APU2_BAS AddBasChnBySort failed!\n");
				}
			}
			//if baschn has existed,update the baschn's content.
			else
			{
				CBasChn *pTempBasChn = GetBasChnAddr(pChnData->GetBas(), pChnData->GetChnId());
				if ( pTempBasChn!= NULL )
				{
					pTempBasChn->SetIsReserved( pChnData->IsReserved() );
					pTempBasChn->SetSrc( pChnData->GetSrc() );
					pTempBasChn->SetMediaMode( pChnData->GetMediaMode() );
					pTempBasChn->SetVcuTick(pChnData->GetVcuTick());
				}
				LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[SetBasListBuf]update the baschn's:%d-%d content,IsReseve:%d!\n",
					pChnData->GetBas().GetEqpId(),
					pChnData->GetChnId(),
					pChnData->IsReserved()
					);
			}
			pbyBuf		 += sizeof(CApu2BasChn);
			dwBasListLen += sizeof(CApu2BasChn);
		}
		else if( X868KI_AUDBAS_CHN == byBasChnType )
		{
			if ( NULL == pChnData )
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetBasListBuf]pChnData is NULL!\n ");
			}
			else if ( !IsNodeExist(pChnData->GetBas(), pChnData->GetChnId()) )
			{
				pNewData = new CApu2BasChn(*(CApu2BasChn*)pChnData);				
				LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[SetBasListBuf] 8KI_AUDBAS EqpId:%d, ChnId:%d, EncNum%d,IsReseve:%d!\n", 
					pNewData->GetBas().GetEqpId(),
					pNewData->GetChnId(),
					pNewData->GetEncNum(),
					pNewData->IsReserved()
					);
				
				if(!AddBasChnBySort(pNewData))
				{
					delete pNewData;
					pNewData = NULL;
					LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetBasListBuf] 8KI_AUDBAS AddBasChnBySort failed!\n");
				}
			}
			//if baschn has existed,update the baschn's content.
			else
			{
				CBasChn *pTempBasChn = GetBasChnAddr(pChnData->GetBas(), pChnData->GetChnId());
				if ( pTempBasChn!= NULL )
				{
					pTempBasChn->SetIsReserved( pChnData->IsReserved() );
					pTempBasChn->SetSrc( pChnData->GetSrc() );
					pTempBasChn->SetMediaMode( pChnData->GetMediaMode() );
					pTempBasChn->SetVcuTick(pChnData->GetVcuTick());
				}
				LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[SetBasListBuf]update the baschn's:%d-%d content,IsReseve:%d!\n",
					pChnData->GetBas().GetEqpId(),
					pChnData->GetChnId(),
					pChnData->IsReserved()
					);
			}
			pbyBuf		 += sizeof(C8KIAudBasChn);
			dwBasListLen += sizeof(C8KIAudBasChn);
		}
		else
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetBasListBuf]byBasChnType is :%d!\n ",byBasChnType);
			return 0;
		}
	}	

// 无视pclint对pNewData的内存未释放的检查
/*lint -save -esym(429,pNewData)*/

	return dwBasListLen;

// 恢复pclint对pNewData的错误号为429的检查
/*lint -restore*/
}
/*=============================================================================
函 数 名： IsChairAutoSpecMix
功    能： 是否支持申请主席自动开启定制混音
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
01/10/11    4.0			田志勇                    创建
=============================================================================*/
BOOL32 CMcuVcData::IsChairAutoSpecMix() 
{
    return (1 == m_tMcuDebugVal.m_byIsChairAutoSpecMix);
}
/*=============================================================================
函 数 名： GetMcIns
功    能： 根据Mcs-Ip和会控随机数获取Mcssn的实例号
算法实现： 
全局变量： 
参    数： u32 dwMcIp   Mcs-Ip
		   u32 dwMcSSrc 会控随机数
		   u8  byConfSource 会议类型
返 回 值： u8  Mcssn的实例号
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
08/30/11    4.0			周嘉麟                    创建
=============================================================================*/
u16 CMcuVcData::GetMcIns(u32 dwMcIp, u32 dwMcSSrc, u8 byConfSource)
{
	if (0 == dwMcIp)
	{
		return 0;
	}

	u16 wIndex = 0;
	if (MCS_CONF == byConfSource)
	{
		wIndex = 1;
	}
	else if (VCS_CONF == byConfSource)
	{
		wIndex = MAXNUM_MCU_MC + 1;
	}
	else
	{
		OspPrintf(TRUE, FALSE, "[GetMcIns] Unexpected byConfSource.%d!\n", byConfSource);
		return 0;
	}

	TLogicalChannel tLogicalChannel;
	TMcsRegInfo tMcRegInfo;
	for ( ; wIndex <= (MAXNUM_MCU_MC + MAXNUM_MCU_VC); wIndex++)
	{
		tLogicalChannel.Clear();
		memset(&tMcRegInfo, 0, sizeof(tMcRegInfo));

		if(!IsMcConnected(wIndex))
		{
			continue;
		}
		if (GetMcsRegInfo(wIndex, &tMcRegInfo) && 
			tMcRegInfo.GetMcsIpAddr() == dwMcIp &&
			tMcRegInfo.GetMcsSSRC() == dwMcSSrc) 
		{
			return wIndex;
		}
	}
	return 0 ;
}
/*=============================================================================
函 数 名： Set8kxMixerCfg
功    能： 设置8K系列混音器相关配置
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
02/16/12    4.7 		田志勇                    创建
=============================================================================*/
BOOL32 CMcuVcData::Set8kxMixerCfg(TEqpRegAck &tRegAck)
{
	u8 byMixerId = tRegAck.GetEqpId();
#ifdef _8KH_//从配置中取得该8000H混音器的混音成员数目报给外设，以便外设进行INIT操作。
		TEqpMixerInfo tTempMixerInfo;	
		if (SUCCESS_AGENT != g_cMcuAgent.GetEqpMixerCfg( byMixerId, &tTempMixerInfo ) )
		{
			LogPrint(LOG_LVL_WARNING, MID_MCU_EQP,"[Set8kxMixerCfg]GetEqpMixerCfg() Failed!\n");
			return FALSE;
		}
		tRegAck.SetMemNum(tTempMixerInfo.GetMaxChnInGrp());
		TPeriEqpStatus t8khMixerStatus;	
		if (!g_cMcuVcApp.GetPeriEqpStatus(byMixerId, &t8khMixerStatus) || tTempMixerInfo.GetMaxChnInGrp() <= 0)
		{
			LogPrint(LOG_LVL_WARNING, MID_MCU_EQP,"[Set8kxMixerCfg]GetPeriEqpStatus() Failed!\n");
			return FALSE;
		}
		t8khMixerStatus.m_tStatus.tMixer.m_atGrpStatus[0].m_byMixGrpChnNum = tTempMixerInfo.GetMaxChnInGrp();
		t8khMixerStatus.SetAlias(tTempMixerInfo.GetAlias());
		g_cMcuVcApp.SetPeriEqpStatus(byMixerId, &t8khMixerStatus);
#endif
	return TRUE;
}


/*=============================================================================
函 数 名： FindMatchedMpIpForMt
功    能： 查找Mt所挂转发板的IP地址（该IP地址应与Mt IP同网段，针对8000H/G/I）
算法实现： 
全局变量： 
参    数： u32 dwMtIp 终端IP
		   u32 &dwMpIp 查找的转发板IP地址
返 回 值： BOOL32
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2012/05/25   4.7 		chendaiwei            创建
=============================================================================*/
BOOL32 CMcuVcData::FindMatchedMpIpForMt(u32 dwMtIp, u32 &dwMpIp)
{
#if defined(_8KH_) || defined(_8KE_)
	
	TMultiManuNetAccess tMultiManuNetAccess;
	g_cMcuAgent.GetMultiManuNetAccess(tMultiManuNetAccess);
	TGKProxyCfgInfo tGKProxyCfgInfo;
	g_cMcuAgent.GetGkProxyCfgInfo(tGKProxyCfgInfo);
	if( tGKProxyCfgInfo.IsProxyUsed())
	{
		for( u8 byIdx = 0; byIdx < tMultiManuNetAccess.GetIpSecNum(); byIdx++ )
		{
			u32 dwIp = tMultiManuNetAccess.GetIpAddr(byIdx);
			u32 dwMask = tMultiManuNetAccess.GetNetMask(byIdx);
			if( (dwMtIp & dwMask) == (dwIp & dwMask) 
				&& (dwMpIp & dwMask) != (dwMtIp & dwMask)) //[5/30/2012 chendaiwei]如果MP的默认IP（eth0）和mt的IP为同一网段，不用修改MP IP为多运营商中配置的IP
			{
				LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_CALL,"[FindMatchedMpIpForMt] MtIp:%x MpIp:%x\n",dwMtIp,dwIp);
				dwMpIp = dwIp;
				
				return TRUE;
			}
		}
	}

#endif

#ifdef _8KI_

	TNewNetCfg tNewNetCfg;
	g_cMcuAgent.GetNewNetCfgInfo( tNewNetCfg );
	TEthCfg tEthCfg;
	TNetCfg tNetCfg;
	u32 dwIp = 0,dwMask = 0;
	for( u8 byIdx = 0;byIdx < MAXNUM_ETH_INTERFACE;++byIdx )
	{
		tEthCfg.Clear();
		
		tNewNetCfg.GetEthCfg( byIdx,tEthCfg );
		for( u8 byIpIdx = 0;byIpIdx < MCU_MAXNUM_ADAPTER_IP;++byIpIdx )
		{
			tNetCfg.Clear();
			tEthCfg.GetNetCfg( byIpIdx,tNetCfg );	
			
			dwIp   = tNetCfg.GetIpAddr();
			dwMask = tNetCfg.GetIpMask();

			if( 0 == dwIp || 0 == dwMask )
			{
				continue;
			}
	
			if( (dwMtIp & dwMask) == (dwIp & dwMask) 
				&& (dwMtIp & dwMask) != (dwMpIp & dwMask) ) 
			{
				LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_CALL,"[FindMatchedMpIpForMt] MtIp:%x MpIp:%x\n",dwMtIp,dwIp);
				dwMpIp = dwIp;
				
				return TRUE;
			}
		}
	}
#endif

	LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_CALL,"[FindMatchedMpIpForMt]Not Find Mt.MtIp:%x MpIp:%x\n",dwMtIp,dwMpIp);

	return FALSE;
}

/*=============================================================================
函 数 名： IsMultiCastMtIp
功    能： IP是否在组播终端ip表中
算法实现： 
全局变量： 
参    数：IP(主机序) 
返 回 值： BOOL32
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/01/09    4.7 		朱胜泽                    创建
=============================================================================*/
BOOL32 CMcuVcData::IsMultiCastMtIp( u32 dwIpAddr ) const
{
    
    for ( u8 byIndex = 0; byIndex < m_tMcuDebugVal.m_byMultiCastMtTableSize; byIndex++)
    {
        if ( dwIpAddr == ntohl( m_tMcuDebugVal.m_adwMultiCastMtTable[byIndex] ) )
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

/*=============================================================================
函 数 名： ResignBasChnAddr
功    能： 主备时，重新分配BAS通道地址
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2012/03/29    4.7 		倪志俊                    创建
=============================================================================*/
void CConfBasChnData::ResignBasChnAddr()
{
	if ( m_tBas.IsNull() )
	{
		return;
	}
	m_pcBasChn = g_cMcuVcApp.GetBasChnAddr(m_tBas,m_byChnId);	
	if ( m_pcBasChn != NULL )
	{
		LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[ResignBasChnAddr]m_tBas:%d,m_byChnId:%d ok!\n",m_tBas.GetEqpId(), m_byChnId);
	}
	else
	{	
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[ResignBasChnAddr]GetBasChnAddr m_tBas:%d,m_byChnId:%d error!\n",m_tBas.GetEqpId(), m_byChnId);
	}
	return;
}

//////////////////////////////
//  适配录像管理类
//////////////////////////////
/*=============================================================================
函 数 名： 构造函数
功    能： 
算法实现： 
全局变量： 
参    数： 
返 回 值： 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/02/04  4.7 		倪志俊                    创建
=============================================================================*/
CRecAdaptMgr::CRecAdaptMgr()
{
	Clear();
}

/*=============================================================================
函 数 名： 析构函数
功    能： 
算法实现： 
全局变量： 
参    数： 
返 回 值：  
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/02/04  4.7 		倪志俊                    创建
=============================================================================*/
CRecAdaptMgr::~CRecAdaptMgr()
{
	Clear();
}

/*=============================================================================
函 数 名： Clear
功    能： 清除数据
算法实现： 
全局变量： 
参    数： 
返 回 值： void
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/02/04  4.7 		倪志俊                    创建
=============================================================================*/
void CRecAdaptMgr::Clear(u8 byMediaMode /*= MODE_BOTH*/)
{
	if ( MODE_BOTH == byMediaMode )
	{
		Clear(MODE_VIDEO);
		Clear(MODE_SECVIDEO);
		Clear(MODE_AUDIO);
		return;
	}

	if ( MODE_VIDEO == byMediaMode )
	{
		m_tRecMainParam.Clear();
		m_atRecBasChn[RECBAS_VIDEO].Clear();
	}
	else if ( MODE_SECVIDEO == byMediaMode )
	{
		m_tRecDSParam.Clear();
		m_atRecBasChn[RECBAS_SECVIDEO].Clear();
	}
	else if( MODE_AUDIO == byMediaMode )
	{
		m_tRecAudParam.Clear();
		m_atRecBasChn[RECBAS_AUDIO].Clear();
	}
	else
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_REC,"[CRecAdaptMgr::Clear]byMediaMode:%d is wrong!\n",byMediaMode);	
	}
	
	return;
}


/*=============================================================================
函 数 名： SetRecVideoCapSet
功    能： 设置视频参数
算法实现： 
全局变量： 
参    数： 
返 回 值： void
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/02/04  4.7 		倪志俊                    创建
=============================================================================*/
void CRecAdaptMgr::SetRecVideoCapSet(u8 byMediaMode, const TVideoStreamCap &tVideoCap)
{
	if ( MODE_VIDEO == byMediaMode )
	{
		m_tRecMainParam = tVideoCap;
	}
	else if ( MODE_SECVIDEO == byMediaMode )
	{
		m_tRecDSParam = tVideoCap;
	}
	else
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_REC,"[CRecAdaptMgr::SetRecVideoCapSet]byMediaMode:%d is wrong!\n",byMediaMode);
	}
	return;
}


/*=============================================================================
函 数 名： GetRecVideoCapSet
功    能： 获得视频参数
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/02/04  4.7 		倪志俊                    创建
=============================================================================*/
BOOL32 CRecAdaptMgr::GetRecVideoCapSet(u8 byMediaMode, TVideoStreamCap &tVideoCap)
{
	if ( MODE_VIDEO == byMediaMode )
	{
		if ( m_tRecMainParam.GetMediaType() != MEDIA_TYPE_NULL )
		{
			tVideoCap = m_tRecMainParam;
			return TRUE;
		}
	}
	else if ( MODE_SECVIDEO == byMediaMode )
	{
		if ( m_tRecDSParam.GetMediaType() != MEDIA_TYPE_NULL )
		{
			tVideoCap = m_tRecDSParam;
			return TRUE;
		}
	}
	else
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_REC,"[CRecAdaptMgr::SetRecVideoCapSet]byMediaMode:%d is wrong!\n",byMediaMode);
	}
	return FALSE;
}

/*=============================================================================
函 数 名： SetRecAudCapSet
功    能： 设置音频参数
算法实现： 
全局变量： 
参    数： 
返 回 值： void
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/02/04  4.7 		倪志俊                    创建
=============================================================================*/
void CRecAdaptMgr::SetRecAudCapSet(const TAudioTypeDesc &tAudCap)
{
	m_tRecAudParam = tAudCap;
	return;
}


/*=============================================================================
函 数 名： GetRecAudCapSet
功    能： 获得音频参数
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/02/04  4.7 		倪志俊                    创建
=============================================================================*/
BOOL32 CRecAdaptMgr::GetRecAudCapSet(TAudioTypeDesc &tAudCap)
{
	if ( m_tRecAudParam.GetAudioMediaType() != MEDIA_TYPE_NULL )
	{
		tAudCap = m_tRecAudParam;
		return TRUE;
	}
	return FALSE;
}

/*=============================================================================
函 数 名： AddRecBasChn
功    能：	添加BAS通道
算法实现： 
全局变量： 
参    数： 
返 回 值： void
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/02/04  4.7 		倪志俊                    创建
=============================================================================*/
void CRecAdaptMgr::AddRecBasChn(u8 byMediaMode, const TRecBasChn &tRecBasChn)
{
	if ( MODE_VIDEO == byMediaMode )
	{
		m_atRecBasChn[RECBAS_VIDEO] = tRecBasChn;
	}
	else if ( MODE_SECVIDEO == byMediaMode )
	{
		m_atRecBasChn[RECBAS_SECVIDEO] = tRecBasChn;
	}
	else if ( MODE_AUDIO == byMediaMode )
	{
		m_atRecBasChn[RECBAS_AUDIO] = tRecBasChn;
	}
	else
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_REC,"[CRecAdaptMgr::AddRecBasChn]byMediaMode:%d is wrong!\n",byMediaMode);
	}

	return;
}

/*=============================================================================
函 数 名： IsExistRecBasChn
功    能：	判断是否存在BAS通道
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/02/04  4.7 		倪志俊                    创建
=============================================================================*/
BOOL32 CRecAdaptMgr::IsExistRecBasChn(u8 byMediaMode, TRecBasChn &tRecBasChn)
{
	if ( MODE_VIDEO == byMediaMode )
	{
		if ( !m_atRecBasChn[RECBAS_VIDEO].m_tBas.IsNull() )
		{
			tRecBasChn = m_atRecBasChn[RECBAS_VIDEO];
			return TRUE;
		}
	}
	else if ( MODE_SECVIDEO == byMediaMode )
	{
		if ( !m_atRecBasChn[RECBAS_SECVIDEO].m_tBas.IsNull() )
		{
			tRecBasChn = m_atRecBasChn[RECBAS_SECVIDEO];
			return TRUE;
		}
	}
	else if ( MODE_AUDIO == byMediaMode )
	{
		if ( !m_atRecBasChn[RECBAS_AUDIO].m_tBas.IsNull() )
		{
			tRecBasChn = m_atRecBasChn[RECBAS_AUDIO];
			return TRUE;
		}
	}
	else
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_REC,"[CRecAdaptMgr::AddRecBasChn]byMediaMode:%d is wrong!\n",byMediaMode);
	}

	return FALSE;
}

/*=============================================================================
函 数 名： ClearBasChnForAud
功    能：	录像源切换成终端时，清楚音频适配录像记录的广播BAS通道
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/04/02  4.7 		倪志俊                    创建
=============================================================================*/
void   CRecAdaptMgr::ClearBasChnForAud()
{
	m_atRecBasChn[RECBAS_AUDIO].Clear();
}

/*=============================================================================
函 数 名： IsExistMediaModeForRecAdpat
功    能：	根据传入的BAS通道，查找是否存在该BAS通道，并返回对应模式
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/02/04  4.7 		倪志俊                    创建
=============================================================================*/
BOOL32 CRecAdaptMgr::IsExistMediaModeForRecAdpat(const TRecBasChn &tRecBasChn,u8& byMediaMode)
{
	for ( u8 byIdx = RECBAS_VIDEO; byIdx< RECBAS_AUDIO; byIdx ++)
	{
		if ( !m_atRecBasChn[byIdx].m_tBas.IsNull() &&
			 tRecBasChn.m_tBas == m_atRecBasChn[byIdx].m_tBas &&
			 tRecBasChn.m_byChnId == m_atRecBasChn[byIdx].m_byChnId
			)
		{
			if ( byIdx == RECBAS_VIDEO )
			{
				byMediaMode = MODE_VIDEO;
			}
			else if ( byIdx == RECBAS_SECVIDEO )
			{
				byMediaMode = MODE_SECVIDEO;
			}
			else
			{
				byMediaMode = MODE_AUDIO;
			}

			return TRUE;
		}

	}

	return FALSE;
}

/*=============================================================================
函 数 名： Print
功    能：	打印
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/02/04  4.7 		倪志俊                    创建
=============================================================================*/
void CRecAdaptMgr::Print()
{
	StaticLog("-------------RecAdaptMgr Info as follows----------\n");

	StaticLog("MainVideo Param:type:%d-res:%d-framerate:%d-biterate:%d-profile:%d\n",
				m_tRecMainParam.GetMediaType(),
				m_tRecMainParam.GetResolution(),
				m_tRecMainParam.GetUserDefFrameRate(),
				m_tRecMainParam.GetMaxBitRate(),
				m_tRecMainParam.GetH264ProfileAttrb()
				);
	StaticLog("MainVideo baschn:%d-%d\n",
			  m_atRecBasChn[RECBAS_VIDEO].m_tBas.GetEqpId(), 
			  m_atRecBasChn[RECBAS_VIDEO].m_byChnId 
				);

	StaticLog("SecVideo Param:type:%d-res:%d-framerate:%d-biterate:%d-profile:%d\n",
				m_tRecDSParam.GetMediaType(),
				m_tRecDSParam.GetResolution(),
				m_tRecDSParam.GetUserDefFrameRate(),
				m_tRecDSParam.GetMaxBitRate(),
				m_tRecDSParam.GetH264ProfileAttrb()
				);
	StaticLog("SecVideo baschn:%d-%d\n",
				m_atRecBasChn[RECBAS_SECVIDEO].m_tBas.GetEqpId(), 
				m_atRecBasChn[RECBAS_SECVIDEO].m_byChnId 
				);

	StaticLog("Audio Param:type:%d-tracknum:%d\n",
				m_tRecAudParam.GetAudioMediaType(),
				m_tRecAudParam.GetAudioTrackNum()
				);
	StaticLog("Audio baschn:%d-%d\n",
				m_atRecBasChn[RECBAS_AUDIO].m_tBas.GetEqpId(), 
				m_atRecBasChn[RECBAS_AUDIO].m_byChnId 
				);
}


/*
 *	设置MP的IP类型
 */
BOOL32 CMcuVcData::SetMpIpType(u8 byMpId, u8 byIpType)
{
	if ( byMpId == 0 || byMpId > MAXNUM_DRI
		|| byIpType == IP_NONE)
	{
		return FALSE;
	}

	m_atMpData[byMpId-1].SetIpType(byIpType);

	return TRUE;
}

/*
 *	取MP的IP类型
 */
u8 CMcuVcData::GetMpIpType(u8 byMpId)
{
	if ( byMpId == 0 || byMpId > MAXNUM_DRI )
	{
		return IP_NONE;
	}

	return m_atMpData[byMpId-1].GetIpType();
}

/*
 *	设置接入板的IP类型
 */
BOOL32 CMcuVcData::SetMtAdpIpType(u8 byMtAdpId, u8 byIpType)
{
	if ( byMtAdpId == 0 || byMtAdpId > MAXNUM_DRI
		|| byIpType == IP_NONE)
	{
		return FALSE;
	}

	m_atMtAdpData[byMtAdpId-1].m_byIpType = byIpType;

	return TRUE;
}
/*
 *	取接入板的IP类型
 */
 u8 CMcuVcData::GetMtAdpIpType(u8 byMtAdpId )
{
	if ( byMtAdpId == 0 || byMtAdpId > MAXNUM_DRI )
	{
		return IP_NONE;
	}

	return m_atMtAdpData[byMtAdpId-1].m_byIpType;
}

/*
 *	查看指定的IP地址实际是不是IPV6
 *	注意点：参数 dwIp必须为*主机序*
 */
 BOOL32 CMcuVcData::IsMtIpV6(u32 dwIp)
 {
	 LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[IsMtIpV6]:Input Ip[host]:0x%x\n", dwIp);
	 if ( dwIp == 0 )
	 {
		 return FALSE;
	 }

// 	 s8 achDebugFile[64] = {0};
// 	 sprintf(achDebugFile, "%s/%s", DIR_CONFIG, MCUDEBUGFILENAME);
// 	 s32 nEntryNum = 0;
// 
// 	 if ( !GetRegKeyInt(achDebugFile, "IpV6MtTable", "EntryNum", 0, &nEntryNum) )
// 	 {
// 		 return FALSE;
// 	 }

	 for ( u8 byNum = 0; byNum < (u8)MAXNUM_CONF_MT; byNum++)
	 {
// 		 s8 achIP[16] = {0};
// 		 s8 achKey[7] = {0};
// 		 sprintf(achKey, "Entry%d", byNum);
// 
// 		 if ( !GetRegKeyString(achDebugFile, "IpV6MtTable", achKey, "0.0.0.0", achIP, sizeof(achIP)))
// 		 {
// 			 continue;
// 		 }

// 		 u32 dwFindIp = ntohl(INET_ADDR(achIP));

		 if ( m_tMcuDebugVal.m_dwIpv6[byNum] == 0)
		 {
			 continue;
		 }

		 if ( m_tMcuDebugVal.m_dwIpv6[byNum] == dwIp)	// 都是主机序 [pengguofeng 6/5/2012]
		 {
			 return TRUE;
		 }
	 }

	 return FALSE;
 }

 /*
  *	取某MT的可用接入板(H323协议)
  */
 u8 CMcuVcData::GetH323MtDriId( TMtAlias &tMtAlias )
 {
	 BOOL32 bFind = FALSE;
	 u8 byRetId = 0;
	 u8 byDriId = 0;
	 s32 nMaxMtNumLeft = (s32)0x80000000 ;	// xliang [2/16/2009] 接入能力最大剩余数,因为这里有可能为负，所以这里取个最小值

	 BOOL32 bIsIpV6 = IsMtIpV6(tMtAlias.m_tTransportAddr.GetIpAddr());

	 LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[GetH323MtDriId]src MT is IPV6:%d\n", bIsIpV6);

	 //step 1:先找纯的
	 u8 byIpType = (bIsIpV6 ? IP_V6 : IP_V4);
	 for ( byDriId = 1; byDriId <= MAXNUM_DRI; byDriId++)
	 {
		 if ( !m_atMtAdpData[byDriId-1].m_bConnected
			 || m_atMtAdpData[byDriId-1].m_byProtocolType != PROTOCOL_TYPE_H323
			 || GetMtAdpIpType(byDriId) != byIpType)
		 {
			 continue;
		 }
		 
		 s32 nMtNumLeft = m_atMtAdpData[byDriId-1].m_byMaxMtNum - m_atMtAdpData[byDriId-1].m_wMtNum;
		 
		 LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[GetH323MtDriId]Dri:%d IPtype:%d remain %d pos for Mt\n",
			 byDriId, byIpType, nMtNumLeft);
		 
		 if ( nMtNumLeft > nMaxMtNumLeft )
		 {
			 nMaxMtNumLeft = nMtNumLeft;
			 byRetId = byDriId;
			 bFind = TRUE;
		 }
	 }
	 
	 //step 2:仍未找到，看同时支持V4 V6的板子
	 if ( bFind == FALSE ) 
	 {
		 for ( byDriId = 1; byDriId <= MAXNUM_DRI; byDriId++)
		 {
			 if ( !m_atMtAdpData[byDriId-1].m_bConnected
				 || m_atMtAdpData[byDriId-1].m_byProtocolType != PROTOCOL_TYPE_H323
				 || GetMtAdpIpType(byDriId) != IP_V4V6)
			 {
				 continue;
			 }
			 
			 s32 nMtNumLeft = m_atMtAdpData[byDriId-1].m_byMaxMtNum - m_atMtAdpData[byDriId-1].m_wMtNum;
			 
			 LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[GetH323MtDriId]Dri:%d Both V4/V6 remain %d pos for Mt\n", byDriId, nMtNumLeft);
			 
			 if ( nMtNumLeft > nMaxMtNumLeft )
			 {
				 nMaxMtNumLeft = nMtNumLeft;
				 byRetId = byDriId;
// 				 bFind = TRUE; //其实没有必要
			 }
		 }
	 }
	 
	 return byRetId;
 }


//////////////////////////////
//  End 会控监控通道管理类
//////////////////////////////

/*=============================================================================
函 数 名： SaveNplusVmpModuleByConfIdx
功    能： 保存某会议的Nplus VMP模板信息
算法实现： 
全局变量： 
参    数： u8 byConfIdx会议idx
		   TNplusVmpModule *ptVmpMod vmp模板指针 
		   u8 byModNum模板数目
返 回 值： BOOL32 保存成功返回TRUE，否则FALSE
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/04/09  4.7.2 		chendaiwei                    创建
=============================================================================*/
BOOL32 CMcuVcData::NplusSaveVmpModuleByConfIdx ( u8 byConfIdx, TNplusVmpModule *ptVmpMod, u8 byModNum)
{
	if( ptVmpMod == NULL || byModNum == 0 )
	{
		return FALSE;
	}
	
	for( u8 byEqpIdx = 0; byEqpIdx < MAXNUM_PERIEQP; byEqpIdx++ )
	{
		if( m_tNplusVmpModule[byEqpIdx].m_byConfIdx == byConfIdx )
		{
			m_tNplusVmpModule[byEqpIdx].Clear();
		}
	}

	u8 byVmpModNumIdx = 0;
	for( u8 byIdx = 0; byIdx < MAXNUM_PERIEQP; byIdx++ )
	{
		if( m_tNplusVmpModule[byIdx].IsNull() && byVmpModNumIdx < byModNum)
		{
			m_tNplusVmpModule[byIdx] = ptVmpMod[byVmpModNumIdx];
			byVmpModNumIdx++;
		}
	}

	return TRUE;
}

/*=============================================================================
函 数 名： RemoveNplusVmpModuleByConfIdx
功    能： 移除某会议的Nplus VMP模板信息
算法实现： 
全局变量： 
参    数： u8 byConfIdx会议idx
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/04/09  4.7.2 		chendaiwei                    创建
=============================================================================*/
void CMcuVcData::NplusRemoveVmpModuleByConfIdx ( u8 byConfIdx )
{
	for( u8 byEqpIdx = 0; byEqpIdx < MAXNUM_PERIEQP; byEqpIdx++ )
	{
		if( m_tNplusVmpModule[byEqpIdx].m_byConfIdx == byConfIdx )
		{
			m_tNplusVmpModule[byEqpIdx].Clear();
		}
	}
}

/*=============================================================================
函 数 名： RemoveNplusVmpModuleByConfIdx
功    能： 移除某会议的Nplus VMP模板信息
算法实现： 
全局变量： 
参    数： u8 byConfIdx会议idx
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/04/09  4.7.2 		chendaiwei                    创建
=============================================================================*/
void CMcuVcData::NplusRemoveVmpModuleEqpId ( u8 byEqpId )
{
	for( u8 byEqpIdx = 0; byEqpIdx < MAXNUM_PERIEQP; byEqpIdx++ )
	{
		if( m_tNplusVmpModule[byEqpIdx].m_byEqpId == byEqpId )
		{
			m_tNplusVmpModule[byEqpIdx].Clear();
		}
	}
}

/*=============================================================================
函 数 名： IsMtInNPlusVmpModule
功    能： 判断某终端是否在特定VMP特定会议特定通道里
算法实现： 
全局变量： 
参    数： u8 byEqpId 外设ID  u8 byConfIdx 会议下标 u8 &byMemberType成员类型
		   u8 byLoopChIx 通道下标  u8 byMtId 终端ID
返 回 值： 在返回TRUE，否则返回FALSE
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/04/02    4.7 		chendaiwei                    创建
=============================================================================*/
BOOL32 CMcuVcData::NPlusIsMtInVmpModule(u8 byMtId,u8 byChIdx,u8 byConfIdx, u8 byEqpId, u8 &byMember)
{
	for( u8 byModIdx = 0; byModIdx < MAXNUM_PERIEQP; byModIdx++ )
	{
		if(m_tNplusVmpModule[byModIdx].m_byEqpId == byEqpId
		   && m_tNplusVmpModule[byModIdx].m_byConfIdx == byConfIdx
		   && m_tNplusVmpModule[byModIdx].m_byMtId[byChIdx] == byMtId)
		{
			byMember = m_tNplusVmpModule[byModIdx].m_byMemberType[byChIdx];

			return TRUE;
		}
	}

	return FALSE;
}

/*=============================================================================
函 数 名： RemoveNplusVmpMember
功    能： 从N+1 VMP模板中终端成员
算法实现： TNplusVmpModule中的MtId和Membertype都为空，清EQPID和ConfIdx
全局变量： 
参    数： u8 byMtId 终端ID
		   u8 byConfIdx 会议下标
返 回 值： void
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/04/02    4.7 		chendaiwei                    创建
=============================================================================*/
void CMcuVcData::NplusRemoveVmpMember( u8 byMtId,u8 byConfIdx, u8 byEqpId)
{
	for( u8 byModIdx = 0; byModIdx < MAXNUM_PERIEQP; byModIdx++ )
	{
		if( (byEqpId == 0 && m_tNplusVmpModule[byModIdx].m_byConfIdx == byConfIdx)
			||  (byEqpId!=0 && m_tNplusVmpModule[byModIdx].m_byEqpId == byEqpId && m_tNplusVmpModule[byModIdx].m_byConfIdx == byConfIdx))
		{
			for(u8 byChIdx = 0; byChIdx < MAXNUM_VMP_MEMBER; byChIdx++)
			{
				if(m_tNplusVmpModule[byModIdx].m_byMtId[byChIdx] == byMtId)
				{
					m_tNplusVmpModule[byModIdx].m_byMtId[byChIdx] = 0;
					m_tNplusVmpModule[byModIdx].m_byMemberType[byChIdx] = 0;
				}
			}
			
			if(!m_tNplusVmpModule[byModIdx].HasVmpMember())
			{
				m_tNplusVmpModule[byModIdx].Clear();
			}
		}
	}

	return;
}

BOOL32 CMcuVcData::NPlusIsVmpOccupyByConf (u8 byEqpId,u8 byConfIdx)
{
	for( u8 byModIdx = 0; byModIdx < MAXNUM_PERIEQP; byModIdx++ )
	{
		if(m_tNplusVmpModule[byModIdx].m_byConfIdx == byConfIdx
			&& m_tNplusVmpModule[byModIdx].m_byEqpId == byEqpId)
		{
			return TRUE;
		}
	}

	return FALSE;
}

void CMcuVcData::GetNPlusVmpMember(u8 byEqpId,u8 byChIdx,u8 &byMtId,u8 &byMemberType)
{
	for( u8 byModIdx = 0; byModIdx < MAXNUM_PERIEQP; byModIdx++ )
	{
		if(m_tNplusVmpModule[byModIdx].m_byEqpId == byEqpId)
		{
			byMtId = m_tNplusVmpModule[byModIdx].m_byMtId[byChIdx];
			byMemberType =  m_tNplusVmpModule[byModIdx].m_byMemberType[byChIdx];

			return;
		}
	}
	
	return;
}

//END FILE
