/*****************************************************************************
模块名      : mcu
文件名      : mcuvc.cpp
相关文件    : mcuvc.h
文件实现功能: MCU业务应用类消息映射函数定义
作者        : 李屹
版本        : V0.9  Copyright(C) 2001-2002 KDC, All rights reserved.
-----------------------------------------------------------------------------
修改记录:
日  期      版本        修改人      修改内容
2002/07/25  0.9         李屹        创建
2005/02/19  3.6         万春雷      级联修改、与3.5版本合并
******************************************************************************/

#include "evmcumcs.h"
#include "evmcuvcs.h"
#include "evmcumt.h"
#include "evmcueqp.h"
#include "evmcu.h"
#include "evmcutest.h"
#include "evmcudcs.h"
#include "evmp.h"
#include "mcuvc.h"
#include "mcsssn.h"
//#include "mcuerrcode.h"
#include "mtadpssn.h"
//#include "mcuutility.h"
#include "mpssn.h"
#include "eqpssn.h"
//#include "mpmanager.h"
#include "dcsssn.h"
#include "mcuguard.h"
#include "commonlib.h"
#include "nplusmanager.h"

#if defined(_VXWORKS_)
#include <vxWorks.h>
#include <usrLib.h>
#include <inetLib.h>
#endif

// MPC2 支持
#ifdef _LINUX_
    #ifdef _LINUX12_
        #include "brdwrapper.h"
        #include "brdwrapperdef.h"
        #include "nipwrapper.h"
        #include "nipwrapperdef.h"
    #else
        #include "boardwrapper.h"
    #endif
#else
    #include "brddrvlib.h"
#endif

CMcuVcApp	        g_cMcuVcApp;	//MCU业务应用实例
CMpManager          g_cMpManager;   //MP管理类全局变量
CAgentInterface     g_cMcuAgent;    //mcu agent
extern CGuardCheck	g_cMcuVcGuardCheck;		// [11/15/2011 liuxu] 新guard检测

BOOL32	g_bpIntMsg  = FALSE;
BOOL32  g_bpUnitMsg = FALSE;
API void showintmsg()
{
	g_bpIntMsg = !g_bpIntMsg;
}
API void showunitmsg()
{
	g_bpUnitMsg = !g_bpUnitMsg;
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


TMt CMcuSingleConfAllInfo::GetVidBrdSrc()
{
	return m_tVidBrdSrc;
}

TMt CMcuSingleConfAllInfo::GetSecVidBrdSrc()
{
	return m_tSecVidBrdSrc;
}


TMt CMcuSingleConfAllInfo::GetLocalVidBrdSrc()
{
	return GetLocalMtFromOtherMcuMt(m_tVidBrdSrc);
}


void CMcuSingleConfAllInfo::SetVidBrdSrc(TMt& tMt)
{
	m_tVidBrdSrc = tMt;
}

void CMcuSingleConfAllInfo::SetVidBrdSrcNull()
{
	m_tVidBrdSrc.SetNull();
}


BOOL32 CMcuSingleConfAllInfo::IsVidBrdSrcNull()
{
	return m_tVidBrdSrc.IsNull();
}

TMt CMcuSingleConfAllInfo::GetAudBrdSrc()
{
	return m_tAudBrdSrc;
}

TMt CMcuSingleConfAllInfo::GetLocalAudBrdSrc()
{
	return GetLocalMtFromOtherMcuMt(m_tAudBrdSrc);
}

void CMcuSingleConfAllInfo::SetAudBrdSrc(TMt& tMt)
{
	m_tAudBrdSrc = tMt;
}

void CMcuSingleConfAllInfo::SetAudBrdSrcNull()
{
	m_tAudBrdSrc.SetNull();
}

BOOL32 CMcuSingleConfAllInfo::IsAudBrdSrcNull()
{
	return m_tAudBrdSrc.IsNull();
}

TMt CMcuSingleConfAllInfo::GetLocalMtFromOtherMcuMt(const TMt& tMt )
{
	if( tMt.IsNull() )
	{
		return tMt;
	}
    u8 byMtId;
	if (TYPE_MCUPERI == tMt.GetType())
	{
		if( tMt.IsLocal() )
		{
			return tMt;
		}
	}
    if( tMt.IsLocal() )
    {
        /*if (TYPE_MCUPERI == tMt.GetType())
        {
            return tMt;
        }*/
        byMtId = tMt.GetMtId();
    }
    else
    {
		u8 abyMcuId[MAX_CASCADEDEPTH-1];
		if( !m_tConfAllMcuInfo.GetMcuIdByIdx( tMt.GetMcuIdx(),&abyMcuId[0] ) )
		{
			TMt tNullMt;
			tNullMt.SetNull();

			return tNullMt;
		}    
		byMtId = abyMcuId[0];
    }

    return m_ptMtTable->GetMt(byMtId);
}

TMt CMcuSingleConfAllInfo::GetMcuIdxMtFromMcuIdMt( const TMt& tMt )
{
	if( tMt.IsNull() )
	{
		return tMt;
	}

	TMt tMcuIdxMt;
	tMcuIdxMt.SetNull();
	tMcuIdxMt.SetConfIdx( m_byConfIdx );
	if( tMt.IsMcuIdLocal() )
	{
		tMcuIdxMt = tMt;
		tMcuIdxMt.SetMcuIdx( LOCAL_MCUIDX );
		return tMcuIdxMt;
	}
	//u8 byMcuId = (u8)tMt.GetMcuId();
	
	
	u8 abyMcuId[MAX_CASCADEDEPTH-1];
	memset( &abyMcuId[0],0,sizeof(abyMcuId) );
	abyMcuId[0] = (u8)tMt.GetMcuId();

	u16 wMcuIdx = INVALID_MCUIDX;
	if( m_tConfAllMcuInfo.GetIdxByMcuId( &abyMcuId[0],1,&wMcuIdx ) )
	{
		tMcuIdxMt = tMt;
		tMcuIdxMt.SetMcuIdx( wMcuIdx );
	}
	return tMcuIdxMt;	

}
TMt CMcuSingleConfAllInfo::GetMcuIdMtFromMcuIdxMt( const TMt &tMt )
{
	if( tMt.IsNull() )
	{
		return tMt;
	}
	TMt tMcuIdMt;
	tMcuIdMt.SetNull();
	tMcuIdMt.SetConfIdx( m_byConfIdx );
	if( tMt.IsLocal() )
	{
		tMcuIdMt = tMt;
		tMcuIdMt.SetMcuId( LOCAL_MCUID );
		return tMcuIdMt;
	}	
	
	u8 abyMcuId[MAX_CASCADEDEPTH-1];
	memset( &abyMcuId[0],0,sizeof(abyMcuId) );

	if( m_tConfAllMcuInfo.GetMcuIdByIdx( tMt.GetMcuIdx(),&abyMcuId[0] ) )
	{
		tMcuIdMt.SetMcuId( abyMcuId[0] );
		if( 0 != abyMcuId[1] )
		{
			tMcuIdMt.SetMtId(abyMcuId[1]);
		}
		else
		{
			tMcuIdMt.SetMtId(tMt.GetMtId());
		}		
	}

	return tMcuIdMt;
}

u16 CMcuSingleConfAllInfo::GetMcuIdxFromMcuId( u8 byMcuId )
{
	if( LOCAL_MCUID == byMcuId )
	{
		return LOCAL_MCUIDX;
	}
	u8 abyMcuId[MAX_CASCADEDEPTH-1];
	memset( &abyMcuId[0],0,sizeof(abyMcuId) );
	abyMcuId[0] = byMcuId;
	u16 wMcuIdx = INVALID_MCUIDX;
	if( !m_tConfAllMcuInfo.GetIdxByMcuId( &abyMcuId[0],1,&wMcuIdx ) )
	{
		return INVALID_MCUIDX;
	}
	return wMcuIdx;
}

u16 CMcuSingleConfAllInfo::GetMcuIdxFromMcuId( u8 *pMcuId,u8 byLevel  )
{
	if( NULL == pMcuId || 0 == byLevel || byLevel > (MAX_CASCADEDEPTH-1) )
	{
		return INVALID_MCUIDX;
	}
	if( LOCAL_MCUID == *pMcuId )
	{
		return LOCAL_MCUIDX;
	}
		
	u16 wMcuIdx = INVALID_MCUIDX;
	if( !m_tConfAllMcuInfo.GetIdxByMcuId( pMcuId,byLevel,&wMcuIdx ) )
	{
		return INVALID_MCUIDX;
	}
	return wMcuIdx;
}

u8  CMcuSingleConfAllInfo::GetFstMcuIdFromMcuIdx( u16 wMcuIdx )
{
	u8 abyMcuId[MAX_CASCADEDEPTH-1];
	if( !m_tConfAllMcuInfo.GetMcuIdByIdx( wMcuIdx,&abyMcuId[0] ) )
	{
		return 0;
	}
	/*if( !m_tConfAllMcuInfo.GetMcuIdByIdx( wMcuIdx,byFstMcuId,bySecMcuId) )
	{
		return 0;
	}*/
	return abyMcuId[0];
}
TMultiCacMtInfo CMcuSingleConfAllInfo::BuildMultiCascadeMtInfo( const TMt &tMt,TMt &tNormalMt )
{
	TMultiCacMtInfo tMtInfo;
    
	if( tMt.IsNull() )
	{
		// [12/21/2010 liuxu] 主动将tNormalMt设为空
		tNormalMt.SetNull();
		return tMtInfo;
	}
	
	u8 abyMcuId[MAX_CASCADEDEPTH-1];
	memset( &abyMcuId[0],0,sizeof(abyMcuId) );

	if( m_tConfAllMcuInfo.GetMcuIdByIdx( tMt.GetMcuIdx(),&abyMcuId[0]) )
	{
		if( 0 != abyMcuId[1] )
		{
			tMtInfo.m_abyMtIdentify[0] = tMt.GetMtId();
			tMtInfo.m_byCasLevel = MAX_CASCADELEVEL;
			tNormalMt.SetMcuId( abyMcuId[0] );
			tNormalMt.SetMtId( abyMcuId[1] );			
		}
		else
		{
			tMtInfo.m_byCasLevel = 0;
			tNormalMt.SetMcuId( abyMcuId[0] );
			tNormalMt.SetMtId( tMt.GetMtId() );
		}
	}
	tNormalMt.SetConfIdx( m_byConfIdx );

	return tMtInfo;
}

TMt CMcuSingleConfAllInfo::GetMtFromMultiCascadeMtInfo( const TMultiCacMtInfo &tMultiCacMtInfo,const TMt &tMt )
{
	TMt tMtRet;
	tMtRet.SetNull();
	tMtRet.SetConfIdx( m_byConfIdx );	
	if( tMt.IsMcuIdLocal() )
	{
		tMtRet = tMt;//tMultiCacMtInfo.m_tMt;
		tMtRet.SetMcuIdx( LOCAL_MCUIDX );
		tMtRet.SetMtId( tMt.GetMtId() );
		return tMtRet;
	}

	u8 abyMcuId[MAX_CASCADEDEPTH-1];
	memset( &abyMcuId[0],0,sizeof(abyMcuId) );
	u16 wMcuIdx = INVALID_MCUIDX;
	

	if( tMultiCacMtInfo.m_byCasLevel > 0 )
	{
		abyMcuId[0] = (u8)/*tMultiCacMtInfo.m_*/tMt.GetMcuId();
		abyMcuId[1] = (u8)/*tMultiCacMtInfo.m_*/tMt.GetMtId();
		if( !m_tConfAllMcuInfo.GetIdxByMcuId( &abyMcuId[0],2,&wMcuIdx ) )
		{
			return tMtRet;
		}
		tMtRet.SetMcuIdx( wMcuIdx );
		tMtRet.SetMtId( tMultiCacMtInfo.m_abyMtIdentify[tMultiCacMtInfo.m_byCasLevel-1] );
	}
	else
	{
		abyMcuId[0] = (u8)/*tMultiCacMtInfo.m_*/tMt.GetMcuId();		
		if( !m_tConfAllMcuInfo.GetIdxByMcuId( &abyMcuId[0],1,&wMcuIdx ) )
		{
			return tMtRet;
		}
		tMtRet.SetMcuIdx( wMcuIdx );
		tMtRet.SetMtId( tMt.GetMtId() );
	}

	
	return tMtRet;
}

/*====================================================================
    函数名      ：SetMtRecording
    功能        ：设置终端tMt的录像状态，此终端可以是本级终端，也可以是级联终端
    算法实现    ：
    引用全局变量：
    输入参数说明：tMt : 终端的TMt结构
				  bRecording ： 是否录像，默认是录像
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/09/17    1.0         liuxu         创建
====================================================================*/
void CMcuSingleConfAllInfo::SetMtRecording(const TMt& tMt, BOOL32 bRecording /*= TRUE*/ )
{
	u8 byMtId = tMt.GetMtId();

	if (tMt.IsLocal())
	{
		//判断终端是否与会
		if( !m_tConfAllMtInfo.MtInConf( byMtId )) 
		{
			// 没有与会，直接返回
			return;
		}

		if( byMtId != 0 && byMtId <= MAXNUM_CONF_MT )
		{
			if (bRecording)
			{
				// 设置录像
				m_ptMtTable->SetMtRecording( byMtId );
			}else
			{
				// 设置非录像
				m_ptMtTable->SetMtNoRecording( byMtId );
			}
		}
	}
	else
	{
		// 获取mcu id
		u16 wMcuId = tMt.GetMcuId();
		//下级指定终端
		TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(wMcuId);
		if (ptMcInfo == NULL)
		{
			return;
		}
		
		TMcMtStatus *ptMcMtStatus = ptMcInfo->GetMtStatus(tMt);
		
		if (ptMcMtStatus == NULL)
		{
			return;
		}

		if(bRecording)
		{
			ptMcMtStatus->SetRecording();
		}else
		{
			ptMcMtStatus->SetNoRecording();
		}
	}
}

CMcuVcInst::CMcuVcInst()
{
	// NEXTSTATE( STATE_IDLE );
	ClearVcInst();

	m_ptMtTable = NULL;
	m_ptSwitchTable = NULL;
	m_ptConfOtherMcTable = NULL;

    m_tPlayFileMediaInfo.clear();
}

CMcuVcInst::~CMcuVcInst()
{
/*lint -save -e1551*/	

	DeleteMcuBasMgr();
    MCU_SAFE_DELETE(m_ptMtTable);
    MCU_SAFE_DELETE(m_ptSwitchTable);
    MCU_SAFE_DELETE(m_ptConfOtherMcTable);
}

/*====================================================================
    函数名      ：InstanceDump
    功能        ：重载打印信息
    算法实现    ：
    引用全局变量：
    输入参数说明：u32 param, 打印状态过滤，0表示打印所有，
					STATE_SCHEDULED打印预约，STATE_MASTER
					打印主MCU会议
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/08/18    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::InstanceDump( u32 param )
{
	StaticLog("\n---------------Conf: %s-------------------\n",m_tConf.GetConfName() );
	switch( HIWORD16( param ) ) 
	{
	case DUMPCONFALL:

		StaticLog("\nInsID: %d  Create by.%d\n", GetInsID(), m_byCreateBy );

		m_tConf.Print();
		m_tConfEx.Print();
		//周期性预约会议相关打印
		if ( m_tConf.IsCircleScheduleConf() )
		{
			emCircleSchedulConfMode emMode = m_tConf.GetScheduleConfMode();
			StaticLog("\nCircleScheduleConfMode:%d(%s)\n",emMode,emMode == CIRCLE_SCHEDULE_CONFMODE_DAY ? "DAY":"WEEK");
			if (emMode == CIRCLE_SCHEDULE_CONFMODE_WEEK)
			{
				StaticLog("Selected WeekDay:");
				s8 aszWeekDay[7][5] = {
					"Sun.",
						"Mon.",
						"Tue.",
						"Wen.",
						"Thu.",
						"Fri.",
						"Sat."
						
				};
				for (int byWeekIdx = 0 ;byWeekIdx < 7;byWeekIdx++)
				{
					if (m_tConf.IsWeekDaySelected(byWeekIdx))
					{
						StaticLog("%s",aszWeekDay[byWeekIdx]);
					}
				}
			}
			StaticLog("\n m_tDurationDate.DuraStartTime:");
			m_tConfEx.GetDurationDate().GetDuraStartTime().Print();
			StaticLog("\n m_tDurationDate.DuarEndTime:");
			m_tConfEx.GetDurationDate().GetDuraEndTime().Print();
			StaticLog("\n m_tNextStartTime:");
			m_tConfEx.GetNextStartTime().Print();
			StaticLog("\n");
		}
		m_tConf.GetConfAttrb().Print();
   
		ShowConfMod();

		m_tConf.m_tStatus.Print();
        m_tConf.m_tStatus.GetConfMode().Print();
                
        if ( CurState() == STATE_ONGOING )
        {            
            if ( m_tConf.m_tStatus.GetProtectMode() != CONF_LOCKMODE_NONE)
            {
                StaticLog("\n");
                m_tConfProtectInfo.Print();
            }
            StaticLog("\n");
            m_tConfInStatus.Print();
            if ( m_tConfInStatus.IsPollSwitch())
            {
                m_tPollSwitchParam.Print();
            }

            if( m_tConf.m_tStatus.GetVMPMode() != CONF_VMPMODE_NONE )
            {
                m_tConf.m_tStatus.GetVmpParam().Print(LOG_LVL_KEYSTATUS);
            }		
            
            if ( m_tConf.m_tStatus.GetPollState() != POLL_STATE_NONE )
            {
                m_tConfPollParam.Print();
            }
            
			//[03/04/2010] zjl modify (电视墙多通道轮询代码合并)
//          if ( m_tConf.m_tStatus.GetTvWallPollState() != POLL_STATE_NONE )
//          {
//                 m_tTvWallPollParam.Print();
//          }
//             
// 			if ( m_tConf.m_tStatus.GethduPollState() != POLL_STATE_NONE )
// 			{
// 				m_tHduPollParam.Print();
// 			}
			if(m_tTWMutiPollParam.HasTWIsPolling())
			{
				m_tTWMutiPollParam.Print();
			}
            ShowConfEqp();

			ShowConfMc();

			if( !m_tConf.GetConfAttrb().IsSupportCascade() )
			{
				StaticLog( "m_byOtherConfMtId=%d\n",m_byOtherConfMtId );
			}			
			
        }        		
        
        //ShowConfMt();

		break;

	case DUMPSPEAKLIST:
		
		m_tApplySpeakQue.ShowQueue();
		
		break;
		
		
	case DUMPPRTSPEAKLIST:
		
		m_tApplySpeakQue.PrtQueueInfo();
		
		break;
		
	case DUMPNPRTSPEAKLIST:
		
		m_tApplySpeakQue.PrtQueueInfo(FALSE);
		
		break;

	case DUMPCONFINFO:

		StaticLog("\nInsID: %d  Create by.%d\n", GetInsID(), m_byCreateBy );

		m_tConf.Print();

		m_tConfEx.Print();

		//周期性预约会议相关打印
		if ( m_tConf.IsCircleScheduleConf() )
		{
			emCircleSchedulConfMode emMode = m_tConf.GetScheduleConfMode();
			StaticLog("\nCircleScheduleConfMode:%d(%s)\n",emMode,emMode == CIRCLE_SCHEDULE_CONFMODE_DAY ? "DAY":"WEEK");
			if (emMode == CIRCLE_SCHEDULE_CONFMODE_WEEK)
			{
				StaticLog("Selected WeekDay:");
				s8 aszWeekDay[7][5] = {
					"Sun.",
					"Mon.",
					"Tue.",
					"Wen.",
					"Thu.",
					"Fri.",
					"Sat."

				};
				for (int byWeekIdx = 0 ;byWeekIdx < 7;byWeekIdx++)
				{
					if (m_tConf.IsWeekDaySelected(byWeekIdx))
					{
						StaticLog("%s",aszWeekDay[byWeekIdx]);
					}
				}
			}
			StaticLog("\n m_tDurationDate.DuraStartTime:");
			m_tConfEx.GetDurationDate().GetDuraStartTime().Print();
			StaticLog("\n m_tDurationDate.DuarEndTime:");
			m_tConfEx.GetDurationDate().GetDuraEndTime().Print();
			StaticLog("\n m_tNextStartTime:");
			m_tConfEx.GetNextStartTime().Print();
			StaticLog("\n");
		}

		// zgc, 2008-04-25, 增加会议发言人源的指定方式打印
		StaticLog("\nType of spec speaker src:\nAud: %d\nVid: %d\n", 
					m_bySpeakerAudSrcSpecType, m_bySpeakerVidSrcSpecType );

		m_tConf.GetConfAttrb().Print();

		m_tConf.m_tStatus.Print();		
		
		m_tConf.m_tStatus.GetConfMode().Print();

		if (!m_tCascadeMMCU.IsNull())
		{
			TConfMcInfo *ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(GetMcuIdxFromMcuId(m_tCascadeMMCU.GetMtId()));
			if (ptConfMcInfo != NULL)
			{
				StaticLog("MMcu SpyMt(%d,%d)\n", ptConfMcInfo->m_tSpyMt.GetMcuId(), ptConfMcInfo->m_tSpyMt.GetMtId() );
			}
		}
		
		if (CONF_LOCKMODE_NEEDPWD == m_tConf.m_tStatus.GetProtectMode())
		{
			StaticLog("\nAll the mc pwd status: \n");

			for( u8 byIdx = 1; byIdx <= (MAXNUM_MCU_MC + MAXNUM_MCU_VC); byIdx ++)
			{
				if (g_cMcuVcApp.IsMcConnected(byIdx))
				{
					StaticLog("MC.%d pwd passed.%d\n", byIdx, m_tConfProtectInfo.IsMcsPwdPassed(byIdx) );
				}
			}
		}

		// 对于VCS会议
		if (VCS_CONF == m_tConf.GetConfSource())
		{
			StaticLog("\nVCSConfStatus:\n");
			m_cVCSConfStatus.VCCPrint();
		}
		StaticLog("HduBathPollMode.%d\n", m_tHduBatchPollInfo.GetStatus());
		StaticLog("m_tVidBrdSrc:[%d,%d]\n", GetVidBrdSrc().GetMcuId(), GetVidBrdSrc().GetMtId());
		StaticLog("m_tSecVidBrdSrc:[%d,%d]\n", m_tSecVidBrdSrc.GetMcuId(), m_tSecVidBrdSrc.GetMtId());
		StaticLog("m_tAudBrdSrc:[%d,%d]\n", GetAudBrdSrc().GetMcuId(), GetAudBrdSrc().GetMtId());

		m_cRecAdaptMgr.Print();
		break;

	case DUMPCONFMT:

        {
            u16 wParam = LOWORD16(param);
            u8 byMtId = (u8)wParam;
            
            ShowConfMt(byMtId);
        }

		break;

	case DUMPCONFMIX:
		{
			ShowConfMix();
		}
		break;
        
    case DUMPCHGMTRES:
        {
            u16 wParam = LOWORD16(param);
            u8 byMtId = LOBYTE(wParam);
            u8 byRes = HIBYTE(param);
            
            if (!m_tConfAllMtInfo.MtJoinedConf(byMtId))
            {
                StaticLog("[InstanceDump] Mt.%d unexist in conf.%d, try another...\n", byMtId, m_byConfIdx);
                return;
            }
            u8 byChnnlType = LOGCHL_VIDEO;

            CServMsg cServMsg;
            cServMsg.SetEventId( MCU_MT_VIDEOPARAMCHANGE_CMD );
            cServMsg.SetMsgBody( &byChnnlType, sizeof(u8) );
            cServMsg.CatMsgBody( &byRes, sizeof(u8) );
            SendMsgToMt( byMtId, cServMsg.GetEventId(), cServMsg );
            
            StaticLog("[InstanceDump] chnnl type: %d, send videoformat<%d> change msg to mt<%d>!\n",
                byChnnlType, byRes, byMtId );
        }
        break;

	case DUMPBASINFO:
		
		{
			u16 wParam = LOWORD16(param);
            u8 byBasId = (u8)wParam;

			ShowBasInfo(byBasId);
		}
		break;

	case DUMPMTMONITOR:

		ShowMtMonitor();

		break;
		
	case DUMPCONFSWITCH:

		ShowConfSwitch();

		break;

	case DUMPCONFEQP:

		ShowConfEqp();

		break;

	case DUMPMTSTAT:

		ShowMtStat();

		break;
	case DUMPVMPADAPT:
		 ShowVmpAdaptMember();
		 break;

// 	case DUMPMULTISPYSMCU:
// 		ShowMultiSpySMcuInfo();
// 		break;
// 
// 	case DUMPMULTISPYMMCU:
// 		ShowMultiSpyMMcuInfo();
// 		break;

	case DUMPMULTISPY:
		ShowConfMultiSpy();
		break;
	case DUMPBASLIST:
		{
			ShowBasInfo(0);
		}
		break;
	case DUMPCONFMCU:
		ShowConfMcu();
		break;
	case DUMPPRSINFO:
		{
			ShowPrsInfo();
		}
		break;
	case DUMPSMSTIMER:
		{
			u16 wParam = LOWORD16(param);
			if( 0 == wParam )
			{
				StaticLog("Sms timer is %d(ms)\n", m_cSmsControl.GetTimerSpan());
			}
			else
			{
				m_cSmsControl.SetTimerSpan(wParam);
			}
			break;
		}
	case DUMPTOKENOWNER:
		{
			ShowToken();
		}
		break;
	case DUMPMCOTHERTABLE:
		{
			ShowMcOtherTable();
		}
		break;
	case DUMPCFGEXTRADATA:
		{
			ShowCfgExtraData();
		}
		break;
	default:
		break;
	}
}

/*====================================================================
    函数名      ：DaemonInstanceDump
    功能        ：重载打印信息
    算法实现    ：
    引用全局变量：
    输入参数说明：u32 param
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/09    1.0         JQL            创建
	04/03/10    3.0         胡昌威         修改
	11/07/12    4.6         彭国锋         修改
====================================================================*/
void CMcuVcInst::DaemonInstanceDump( u32 param )
{
	u8   byIndex;
	TLogicalChannel tLogicalChannel;
	CConfId       cConfId;
	u32           dwVSndIp = 0, dwASndIp = 0, dwVRcvIp = 0,dwARcvIp = 0;
	u16           wVSndPort = 0, wASndPort = 0, wVRcvPort = 0, wARcvPort = 0;
	TMt           tMt[4];
	BOOL32        bDcsExist = FALSE;
	TMonitorData  tMonitorData;

	cConfId.SetNull();

	StaticLog("\nData information in VC:\n");
	switch( HIWORD16( param ) )
	{
	case DUMPMCINFO: //MC
		if( LOWORD16( param ) == DUMPSRC )
		{
			//MCINST CHANNEL SNDASRC   SNDVSRC
			StaticLog("MCINST CHANNEL  SNDVSRC      SNDASRC   \n");
			StaticLog("------ ------- ----------   ----------\n");
			for( byIndex = 1; byIndex <= (MAXNUM_MCU_MC + MAXNUM_MCU_VC); byIndex++ )
			{
				if( g_cMcuVcApp.IsMcConnected( byIndex ) )
				{
					u8 byChannelNum;
					if( g_cMcuVcApp.GetMcLogicChnnl( byIndex, MODE_VIDEO, &byChannelNum, &tLogicalChannel ) )
					{
						while( byChannelNum-- != 0 )
						{
							if( g_cMcuVcApp.GetMcSrc( byIndex, &tMt[0], byChannelNum, MODE_VIDEO ) 
								|| g_cMcuVcApp.GetMcSrc( byIndex, &tMt[1], byChannelNum, MODE_AUDIO ) )
							{
								StaticLog("%6u %7u %3u-%3u-%2u %3u-%3u-%2u\n", byIndex, byChannelNum,
								tMt[0].GetMcuId(), tMt[0].GetMtId(), tMt[0].GetEqpId(),
								tMt[1].GetMcuId(), tMt[1].GetMtId(), tMt[1].GetEqpId() );
							}
						}
					}
					for( u16 wLoop = 0; wLoop < MAXNUM_MONITOR_NUM; wLoop ++ )
					{
						if( !g_cMcuVcApp.GetMonitorData(byIndex, wLoop, tMonitorData) )
						{
							continue;
						}
						StaticLog("McIdx(%d) MonChnIdx(%d) Mt(%d,%d) mode(%d) DstIpAndPort(%s, %d)\n",
							byIndex,wLoop,tMonitorData.m_tSrc.GetMcuId(),tMonitorData.m_tSrc.GetMtId(),
							tMonitorData.m_byMode,StrOfIP(tMonitorData.m_DstAddr.GetIpAddr()),tMonitorData.m_DstAddr.GetPort());
					}
				}
			}
		}
		else
		{
			StaticLog("MCINST SNDVIP   SNDVSTARTPORT SNDVIP   SNDVSTARTPORT MCSNDVCHNNL MCSIP   MCSSSRC  GRP\n");
			StaticLog("------ -------- ------------- -------- ------------- ---------- -------- -------- ---\n");
			
			for (byIndex = 1; byIndex < (MAXNUM_MCU_MC + MAXNUM_MCU_VC); byIndex++)
			{
				if (g_cMcuVcApp.IsMcConnected(byIndex))
				{
					u8 byChannelNum;
					TMcsRegInfo	tMcsReg;
					if (g_cMcuVcApp.GetMcLogicChnnl(byIndex, MODE_VIDEO, &byChannelNum, &tLogicalChannel))
					{
						dwVSndIp = tLogicalChannel.m_tRcvMediaChannel.GetIpAddr();
						wVSndPort = tLogicalChannel.m_tRcvMediaChannel.GetPort();
					}

					if (g_cMcuVcApp.GetMcLogicChnnl(byIndex, MODE_AUDIO, &byChannelNum, &tLogicalChannel))
					{	
						dwASndIp = tLogicalChannel.m_tRcvMediaChannel.GetIpAddr();
						wASndPort = tLogicalChannel.m_tRcvMediaChannel.GetPort();
					}
					g_cMcuVcApp.GetMcsRegInfo(byIndex, &tMcsReg);

					StaticLog("%6u %.8x %13u %.8x %13u %10u %.8x %.8x %3d\n", 
						      byIndex, dwVSndIp, wVSndPort, dwASndIp, wASndPort, byChannelNum, tMcsReg.GetMcsIpAddr(), tMcsReg.GetMcsSSRC(), CMcsSsn::GetUserGroup(byIndex)); 
				}
			}
		}
		break;

	case DUMPEQPINFO: //Peri
		StaticLog("EQPID  SNDVIP          SPORT SNDAIP          SPORT CHNNUM RCVVIP          RPORT RCVAIP          RPORT CHNNUM\n");
		StaticLog("------ --------------- ----- --------------- ----- ------ --------------- ----- --------------- ----- ------\n");
		for( byIndex = 1; byIndex <= MAXNUM_MCU_PERIEQP; byIndex++ )
		{
			u8 byFwdChannelNum;
			u8 byRvsChannelNum;

			if( g_cMcuVcApp.IsPeriEqpConnected( byIndex ) )
			{	
				if( g_cMcuVcApp.GetPeriEqpLogicChnnl( byIndex, MODE_VIDEO, &byFwdChannelNum, &tLogicalChannel, TRUE) )
				{
					dwVSndIp = htonl(tLogicalChannel.m_tRcvMediaChannel.GetIpAddr());
		            wVSndPort = tLogicalChannel.m_tRcvMediaChannel.GetPort();
				}

				if( g_cMcuVcApp.GetPeriEqpLogicChnnl( byIndex, MODE_AUDIO, &byFwdChannelNum, &tLogicalChannel, TRUE) )
				{
					dwASndIp = htonl(tLogicalChannel.m_tRcvMediaChannel.GetIpAddr());
		            wASndPort = tLogicalChannel.m_tRcvMediaChannel.GetPort();
				}

				if( g_cMcuVcApp.GetPeriEqpLogicChnnl( byIndex, MODE_VIDEO, &byRvsChannelNum, &tLogicalChannel, FALSE) )
				{
					dwVRcvIp = htonl(tLogicalChannel.m_tRcvMediaChannel.GetIpAddr());
		            wVRcvPort = tLogicalChannel.m_tRcvMediaChannel.GetPort();
				}

				if( g_cMcuVcApp.GetPeriEqpLogicChnnl( byIndex, MODE_AUDIO, &byRvsChannelNum, &tLogicalChannel, FALSE) )
				{
					dwARcvIp = htonl(tLogicalChannel.m_tRcvMediaChannel.GetIpAddr());
		            wARcvPort = tLogicalChannel.m_tRcvMediaChannel.GetPort();
				}
				StaticLog("%6u %3d.%3d.%3d.%3d %5u %3d.%3d.%3d.%3d %5u %6u %3d.%3d.%3d.%3d %5u %3d.%3d.%3d.%3d %5u %6u\n", byIndex,
						  ((u8 *)&dwVSndIp)[0], ((u8 *)&dwVSndIp)[1], ((u8 *)&dwVSndIp)[2], ((u8 *)&dwVSndIp)[3],
						   wVSndPort,
						  ((u8 *)&dwASndIp)[0], ((u8 *)&dwASndIp)[1], ((u8 *)&dwASndIp)[2], ((u8 *)&dwASndIp)[3],
						   wASndPort, byFwdChannelNum,
					      ((u8 *)&dwVRcvIp)[0], ((u8 *)&dwVRcvIp)[1], ((u8 *)&dwVRcvIp)[2], ((u8 *)&dwVRcvIp)[3],
						   wVRcvPort,
						  ((u8 *)&dwARcvIp)[0], ((u8 *)&dwARcvIp)[1], ((u8 *)&dwARcvIp)[2], ((u8 *)&dwARcvIp)[3],
						   wARcvPort, byRvsChannelNum);
			}
		}
        
        for( byIndex = 1; byIndex <= MAXNUM_MCU_DCS; byIndex ++ )
        {
            if ( g_cMcuVcApp.IsPeriDcsConnected(byIndex) )
            {
                bDcsExist = TRUE;
                break;
            }
        }
        if ( bDcsExist )
        {
            StaticLog("\nDCSID  DCSIP    DCSPORT\n");
            StaticLog("------ -------- -----\n");

            for( byIndex = 1; byIndex <= MAXNUM_MCU_DCS; byIndex ++ )
            {
                if ( g_cMcuVcApp.IsPeriDcsConnected(byIndex) )
                {
                    StaticLog("%6u %.8x %5u \n", byIndex,
                               g_cMcuVcApp.m_atPeriDcsTable[byIndex-1].m_dwDcsIp, 
                               g_cMcuVcApp.m_atPeriDcsTable[byIndex-1].m_wDcsPort);
                }
            }
        }
        StaticLog( "________________________________________________________________________________\n");
		break;
	case DUMPEQPSTATUS:
		g_cMcuVcApp.EqpStatusShow((u8  )LOWORD16(param));
		break;
    case DUMPTEMPLATE:
        g_cMcuVcApp.ShowTemplate();
        break;
    case DUMPCONFMAP:
        g_cMcuVcApp.ShowConfMap();
        break;
    case DUMPRLSCONF:
        ReleaseConf();
        NEXTSTATE( STATE_IDLE );
        break;
    case DUMPRLSBAS:
        //m_pcBasMgr->ReleaseHdBasChn();
		ReleaseBasChn();
        break;
    case DUMPBASINFO:
        g_cMcuVcApp.ShowBasInfo();
        break;
	case DUMPBASLIST:
		g_cMcuVcApp.ShowBasList();
		break;
	case DUMPTWINFO:
		g_cMcuVcApp.ShowTW((u8)LOWORD16(param));
        break;
	case DUMPPRSINFO:
		g_cMcuVcApp.ShowPrsInfo();
		break;	
	default:
		break;
	}
}

/*====================================================================
    函数名      ：IsMsgNeedTranslate
    功能        ：判断发送到终端的消息是否要转换消息体
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wEventId
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
  03/12/09      3.0			JQL			  创建
====================================================================*/
BOOL32 CMcuVcInst::IsMsgNeedTranslate( u16 wEventId )
{
	switch( wEventId )
	{
	case MCU_MT_MTAPPLYMIX_NOTIF:
	case MCU_MT_YOUARESEEING_NOTIF:
	case MCU_MT_APPLYSPEAKER_NOTIF:
	case MCU_MT_SIMPLECONF_NOTIF:
	case MCU_MT_MTJOINED_NOTIF:
	case MCU_MT_MTLEFT_NOTIF:
	case MCU_MT_CONF_NOTIF:
	case MCU_MT_GETCHAIRMAN_ACK:
	case MCU_MT_VMPPARAM_NOTIF:
	case MCU_MT_GETVMPPARAM_ACK:
	case MCU_MT_GETCONFINFO_ACK:
	case MCU_MT_APPLYCHAIRMAN_NOTIF:
	//case MCU_POLY_GETH239TOKEN_REQ:
	//case MCU_MT_RELEASEH239TOKEN_CMD:
		return TRUE;

	default:
		break;
	}
	
	return FALSE;
}
/*====================================================================
    函数名      ：TranslateMsg
    功能        ：将要发给终端的信息中带的Tmt信息转换成终端可用的TMt信息
    算法实现    ：
    引用全局变量：
    输入参数说明：CServMsg & cServMsg
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
  10/08/03      4.6		周晶晶			  创建
====================================================================*/
void CMcuVcInst::TranslateMsg( u16 wEvent,CServMsg & cServMsg )
{
	TMt tMt;
	//CServMsg cMsg;
	switch( wEvent )
	{
	case MCU_MT_MTAPPLYMIX_NOTIF:
		{
			tMt = *(TMt*)cServMsg.GetMsgBody();
			tMt = GetMcuIdMtFromMcuIdxMt( tMt );
			cServMsg.SetMsgBody((u8*)&tMt, sizeof(tMt));
		}
		break;
	case MCU_MT_YOUARESEEING_NOTIF:
		{
			tMt = *(TMt*)cServMsg.GetMsgBody();
			tMt = GetMcuIdMtFromMcuIdxMt( tMt );
			cServMsg.SetMsgBody((u8*)&tMt, sizeof(tMt));
			break;
		}
	case MCU_MT_APPLYSPEAKER_NOTIF:
		{
			tMt = *(TMt*)cServMsg.GetMsgBody();
			tMt = GetMcuIdMtFromMcuIdxMt( tMt );
			cServMsg.SetMsgBody((u8*)&tMt, sizeof(tMt));
			break;
		}
	case MCU_MT_SIMPLECONF_NOTIF:
		{		
			TSimConfInfo *pInfo = (TSimConfInfo*)cServMsg.GetMsgBody();
			pInfo->m_tSpeaker = GetMcuIdMtFromMcuIdxMt( pInfo->m_tSpeaker );
			pInfo->m_tChairMan = GetMcuIdMtFromMcuIdxMt( pInfo->m_tChairMan );
			if( pInfo->m_tSpeaker.IsNull() )
			{
				pInfo->m_tSpeaker.SetMcuId( 0 );
			}
			if( pInfo->m_tChairMan.IsNull() )
			{
				pInfo->m_tChairMan.SetMcuId( 0 );
			}
		}
		break;
	case MCU_MT_MTJOINED_NOTIF:
		tMt = *(TMt*)cServMsg.GetMsgBody();
		tMt = GetMcuIdMtFromMcuIdxMt( tMt );
		cServMsg.SetMsgBody((u8*)&tMt, sizeof(tMt));
		break;
	case MCU_MT_MTLEFT_NOTIF:
		tMt = *(TMt*)cServMsg.GetMsgBody();
		tMt = GetMcuIdMtFromMcuIdxMt( tMt );
		cServMsg.SetMsgBody((u8*)&tMt, sizeof(tMt));
		break;
	case MCU_MT_CONF_NOTIF:
	case MCU_MT_GETCONFINFO_ACK:
		{		
			TConfInfo *ptConfInfo = (TConfInfo*)cServMsg.GetMsgBody();
			ptConfInfo->m_tStatus.m_tSpeaker = GetMcuIdMtFromMcuIdxMt( ptConfInfo->m_tStatus.m_tSpeaker );
			ptConfInfo->m_tStatus.m_tChairman = GetMcuIdMtFromMcuIdxMt( ptConfInfo->m_tStatus.m_tChairman );
			if( ptConfInfo->m_tStatus.m_tSpeaker.IsNull() )
			{
				ptConfInfo->m_tStatus.m_tSpeaker.SetMcuId( 0 );
			}
			if( ptConfInfo->m_tStatus.m_tChairman.IsNull() )
			{
				ptConfInfo->m_tStatus.m_tChairman.SetMcuId( 0 );
			}
		}
		break;
	case MCU_MT_VMPPARAM_NOTIF:
	case MCU_MT_GETVMPPARAM_ACK:
		{
			// [10/14/2010 xliang] convert member
			u8 byLoop = 0;
			TVMPMember *ptVmpMember = NULL;
			TVMPParam tVmpParam = *(TVMPParam *)cServMsg.GetMsgBody();
			for(byLoop = 0; byLoop < tVmpParam.GetMaxMemberNum(); byLoop++)
			{
				ptVmpMember = tVmpParam.GetVmpMember(byLoop);
				if( ptVmpMember == NULL )
				{
					continue;
				}
				
				if( ptVmpMember->GetMcuId() == 0 && ptVmpMember->GetMtId() == 0)
				{
					// [12/20/2010 xliang] remain the original value
				}
				else
				{
					TMt tTransMt = GetMcuIdMtFromMcuIdxMt(*ptVmpMember);
					ptVmpMember->SetMt(tTransMt);
				}				
			}

			for(; byLoop < MAXNUM_VMP_MEMBER; byLoop++)
			{
				ptVmpMember = tVmpParam.GetVmpMember(byLoop);
				if( ptVmpMember == NULL )
				{
					continue;
				}
				ptVmpMember->SetMcuId( 0 );
				ptVmpMember->SetMtId( 0 );
			}
			//tVmpParam.Print();
			cServMsg.SetMsgBody((u8*)&tVmpParam, sizeof(tVmpParam));
			break;
		}
	case MCU_MT_GETCHAIRMAN_ACK:
		{
			tMt = *(TMt*)cServMsg.GetMsgBody();
			TMtAlias tMtAlias = *(TMtAlias*)( cServMsg.GetMsgBody()+sizeof(TMt) );
			tMt = GetMcuIdMtFromMcuIdxMt( tMt );
			if( tMt.IsNull() )
			{
				tMt.SetMcuId( 0 );
			}
			cServMsg.SetMsgBody((u8*)&tMt, sizeof(tMt));
			cServMsg.CatMsgBody((u8*)&tMtAlias, sizeof(tMtAlias));
			break;
		}
	case MCU_MT_APPLYCHAIRMAN_NOTIF:
		{
			tMt = *(TMt*)cServMsg.GetMsgBody();
			tMt = GetMcuIdMtFromMcuIdxMt( tMt );
			cServMsg.SetMsgBody((u8*)&tMt, sizeof(tMt));
		}
		break;
	/*case MCU_POLY_GETH239TOKEN_REQ:
		{
			tMt = *(TMt*)cServMsg.GetMsgBody();
			tMt = GetMcuIdMtFromMcuIdxMt( tMt );
			cMsg.SetMsgBody( cServMsg.GetMsgBody() + sizeof(TMt),cServMsg.GetMsgBodyLen() - sizeof(TMt) );
			cServMsg.SetMsgBody((u8*)&tMt, sizeof(tMt));
			cServMsg.CatMsgBody( cMsg.GetMsgBody(),cMsg.GetMsgBodyLen() );
			break;
		}
		*/
	/*case MCU_MT_RELEASEH239TOKEN_CMD:
		{
			tMt = *(TMt*)cServMsg.GetMsgBody();
			tMt = GetMcuIdMtFromMcuIdxMt( tMt );
			cMsg.SetMsgBody( cServMsg.GetMsgBody() + sizeof(TMt),cServMsg.GetMsgBodyLen() - sizeof(TMt) );
			cServMsg.SetMsgBody((u8*)&tMt, sizeof(tMt));
			cServMsg.CatMsgBody( cMsg.GetMsgBody(),cMsg.GetMsgBodyLen() );
		}
		*/
	default:
		break;
	}	
}

/*====================================================================
    函数名      ：SendMsgToMt
    功能        ：给会议中的下级终端发送消息
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMtId. 接受消息的终端ID号，该终端的数据必须在会议实例的终端数据区中，且有效。
				  u16 wEvent. 事件号
				  u8 byMtId 终端Id号
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
  03/12/09      3.0			JQL			  创建
====================================================================*/
BOOL32 CMcuVcInst::SendMsgToMt( u8 byMtId, u16 wEvent, CServMsg & cServMsg )
{
    // [2013/04/08 chenbing] H460关闭终端逻辑通道对打洞的终端要补洞
    if (MCU_MT_CLOSELOGICCHNNL_CMD == wEvent)
    {
        //终端已经打洞的进行补洞
        if (m_ptMtTable->m_atMtData[byMtId - 1].m_bIsPinHole)
        {
            
            TLogicalChannel tLogicalChannel = *(TLogicalChannel *)cServMsg.GetMsgBody();
            u8 byMediaType = tLogicalChannel.GetMediaType();

            //双流类型转成内部表示
            if ( byMediaType == MODE_SECVIDEO )
            {
                byMediaType = LOGCHL_SECVIDEO;
            }

            //如果是后向通道
            if ( byMediaType == LOGCHL_VIDEO ||
                 byMediaType == LOGCHL_AUDIO ||
                 byMediaType == LOGCHL_SECVIDEO)
            {

                TLogicalChannel tLogicChnl;
                TTransportAddr tRcvMediaChannel, tMtRcvMediaChannel;
                tRcvMediaChannel.SetNull();
                tMtRcvMediaChannel.SetNull();
                tRcvMediaChannel = tLogicalChannel.GetRcvMediaChannel();                
                
                m_ptMtTable->GetMtLogicChnnl(byMtId, byMediaType, &tLogicChnl, FALSE);
                tMtRcvMediaChannel = tLogicChnl.GetRcvMediaChannel();
                if ( tMtRcvMediaChannel == tRcvMediaChannel)
                {
                    //rtp
                    StopH460PinHole( m_ptMtTable->GetMpId(byMtId), 
                        tLogicalChannel.m_tRcvMediaChannel.GetPort(),
                        m_ptMtTable->m_atMtData[byMtId - 1].m_tSecRtpSndTransportAddr.GetIpAddr(),
                        htonl(m_ptMtTable->m_atMtData[byMtId - 1].m_tSecRtpSndTransportAddr.GetPort()) );
                    //rtcp
                    StopH460PinHole( m_ptMtTable->GetMpId(byMtId), 
                        tLogicalChannel.m_tRcvMediaCtrlChannel.GetPort(),
                        tLogicalChannel.m_tSndMediaCtrlChannel.GetIpAddr(),
                        tLogicalChannel.m_tSndMediaCtrlChannel.GetPort() );
                }
                
                //如果是前向通道
                tLogicChnl.Clear();
                m_ptMtTable->GetMtLogicChnnl(byMtId, byMediaType, &tLogicChnl, TRUE);
                tMtRcvMediaChannel.SetNull();             
                tMtRcvMediaChannel = tLogicChnl.GetRcvMediaChannel();
                if ( tMtRcvMediaChannel == tRcvMediaChannel )
                {
                    //rtcp
                    StopH460PinHole( m_ptMtTable->GetMpId(byMtId), 
                        tLogicalChannel.m_tSndMediaCtrlChannel.GetPort(),
                        tLogicalChannel.m_tRcvMediaCtrlChannel.GetIpAddr(),
                        tLogicalChannel.m_tRcvMediaCtrlChannel.GetPort() );
                }
            }
            

            //rtp
//             StopH460PinHole( m_ptMtTable->GetMpId(byMtId), 
//                              tLogicalChannel.m_tRcvMediaChannel.GetPort(),
//                              m_ptMtTable->m_atMtData[byMtId - 1].m_tSecRtpSndTransportAddr.GetIpAddr(),
//                              htonl(m_ptMtTable->m_atMtData[byMtId - 1].m_tSecRtpSndTransportAddr.GetPort()) );
            //rtcp
//             StopH460PinHole( m_ptMtTable->GetMpId(byMtId), 
//                              tLogicalChannel.m_tRcvMediaCtrlChannel.GetPort(),
//                              tLogicalChannel.m_tSndMediaCtrlChannel.GetIpAddr(),
//                              tLogicalChannel.m_tSndMediaCtrlChannel.GetPort() );

            ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[SendMsgToMt]Send msg to Mt Dri.%d, event: %s(%d)\n", 
                cServMsg.GetSrcDriId(), OspEventDesc(wEvent), wEvent);

        }
        
        ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[SendMsgToMt] m_bIsPinHole(%d)\n", 
            m_ptMtTable->m_atMtData[byMtId - 1].m_bIsPinHole);
	}

	if (byMtId == 0)
	{
        ConfPrint(LOG_LVL_ERROR, MID_MCU_MT2, "Send Message(%s) To Mt.%d not exist.\n", OspEventDesc(wEvent), byMtId );
		return FALSE;
	}
    else if (byMtId == CONF_CREATE_MT || byMtId == CONF_CREATE_SMCU)
    {
        // guzh [7/31/2006] 
        // 如果是创会消息，当时MtId还没有赋值。需要直接取其接入DriId
        ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "Send msg to Mt Dri.%d, event: %s(%d)\n", 
                cServMsg.GetSrcDriId(), 
                OspEventDesc(wEvent),
                wEvent);

		cServMsg.SetMcuId( LOCAL_MCUID );
		return g_cMtAdpSsnApp.SendMsgToMtAdpSsn( cServMsg.GetSrcDriId(), wEvent, cServMsg );
    }
	else
	{		
        TMt tDstMt = m_ptMtTable->GetMt( byMtId );

		if( GetInsID() != CInstance::DAEMON )
		{
			cServMsg.SetConfId( m_tConf.GetConfId() );
			cServMsg.SetConfIdx( m_byConfIdx );
		}

        if (MCU_MT_FLOWCONTROL_CMD == wEvent)
        {
            TLogicalChannel tLogicalChannel = *(TLogicalChannel *)cServMsg.GetMsgBody();     
            u16 wBitrate = 0;
			if(MODE_AUDIO != tLogicalChannel.GetMediaType()&& IsMultiCastMt(byMtId))
			{
				u16 wOldMainVideoBaud = 0;
				u16 wOldSecdVideoBaud = 0;
				u16 wOldVidoeBaud     = 0;
				BOOL32 bIsOldSend     = FALSE;
				TLogicalChannel tSatMtSndChnnl;
				if (m_ptMtTable->GetMtLogicChnnl(byMtId, LOGCHL_VIDEO, &tSatMtSndChnnl, FALSE))
				{
					wOldMainVideoBaud = tSatMtSndChnnl.GetFlowControl();
				}
				if (m_ptMtTable->GetMtLogicChnnl(byMtId, LOGCHL_SECVIDEO, &tSatMtSndChnnl, FALSE))
				{
					wOldSecdVideoBaud = tSatMtSndChnnl.GetFlowControl();
				}
				bIsOldSend = (wOldMainVideoBaud + wOldSecdVideoBaud) > 0 ;
				if (MODE_VIDEO == tLogicalChannel.GetMediaType())
				{
					wOldMainVideoBaud = tLogicalChannel.GetFlowControl();
				}
				else if (MODE_SECVIDEO == tLogicalChannel.GetMediaType())
				{
					wOldSecdVideoBaud = tLogicalChannel.GetFlowControl();
				} 
				else
				{
					LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[SendMsgToMt]Mt(%d) tLogicalChannel.GetMediaType(%d),So return false!\n",
					byMtId,tLogicalChannel.GetMediaType());
					return FALSE;
				}
				LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[SendMsgToMt]Mt(%d) CurBaud(%d) bIsOldSend(%d) CurSatMtNum(%d)\n",
					byMtId,wOldMainVideoBaud + wOldSecdVideoBaud,bIsOldSend,GetCurSatMtNum());
				if (wOldMainVideoBaud + wOldSecdVideoBaud == 0 && bIsOldSend)
				{
					SetCurSatMtNum(GetCurSatMtNum() + 1);
					LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"[SendMsgToMt]AddMt(%d) SatMtNum(%d)\n",byMtId,GetCurSatMtNum());
					TMt tSpeaker = m_tConf.GetSpeaker();
					if (!tSpeaker.IsNull() && byMtId != GetLocalSpeaker().GetMtId() && IsSpeakerCanBrdVid( &tSpeaker ) && !(tSpeaker == GetLocalVidBrdSrc()) )
					{
						LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[SendMsgToMt]Sat Conf recover vid brd src:%d\n",
													tSpeaker.GetMtId());
						ChangeVidBrdSrc(&tSpeaker);
					}
				} 
				if (wOldMainVideoBaud + wOldSecdVideoBaud > 0 && !bIsOldSend)
				{
					SetCurSatMtNum(GetCurSatMtNum() - 1);
					LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[SendMsgToMt]Remove SatMt(%d) CurSatMtNum(%d)\n",byMtId,GetCurSatMtNum());
				}
			}
            if (MODE_VIDEO == tLogicalChannel.GetMediaType())
            {
                //是否需要调整码率
                if (IsNeedAdjustMtSndBitrate(byMtId, wBitrate) && wBitrate < tLogicalChannel.GetFlowControl())
                {
                    ConfPrint(LOG_LVL_DETAIL, MID_MCU_MT2, "[SendFlowctrl2Mt] mt.%d, mode %d, old flowcontrol :%d, min flowcontrol :%d\n",
                            byMtId, 
                            tLogicalChannel.GetMediaType(), tLogicalChannel.GetFlowControl(), wBitrate);                   
                    
                    tLogicalChannel.SetFlowControl(wBitrate);
                    cServMsg.SetMsgBody((u8*)&tLogicalChannel, sizeof(tLogicalChannel));                                        
                }

				TPeriEqpStatus tPeriEqpStatus; 
				g_cMcuVcApp.GetPeriEqpStatus( m_tVmpEqp.GetEqpId(), &tPeriEqpStatus );
				u8 byVmpSubType = tPeriEqpStatus.m_tStatus.tVmp.m_bySubType;

                // xsl [8/1/2006] 终端发送码率大于4M通知终端按4M发送码流
				TVMPParam_25Mem tTempVmpParm = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
				TVMPParam tTempVmpTWParm = m_tConf.m_tStatus.GetVmpTwParam();
                if ( byVmpSubType == VMP && // xliang [4/20/2009] MPU不做该限制
					tLogicalChannel.GetFlowControl() > MAXBITRATE_MTSEND_INVMP &&
                    (tTempVmpParm.IsMtInMember(tDstMt) || 
                    tTempVmpTWParm.IsMtInMember(tDstMt)))
                {
                    tLogicalChannel.SetFlowControl(MAXBITRATE_MTSEND_INVMP); 
                    cServMsg.SetMsgBody((u8*)&tLogicalChannel, sizeof(tLogicalChannel)); 
                    
                    ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT2, "[SendFlowctrl2Mt] mt in vmp, mode %d, old flowcontrol :%d, min flowcontrol :%d\n",
                            tLogicalChannel.GetMediaType(), tLogicalChannel.GetFlowControl(), wBitrate);  
                }

                // xsl [8/7/2006] 若在回传通道内，则发送码率应小于上级mcu接收带宽
                if( !m_tCascadeMMCU.IsNull() )
	            {
                    wBitrate = m_ptMtTable->GetMtReqBitrate(m_tCascadeMMCU.GetMtId(), TRUE);
					u16 wMMcuIdx = GetMcuIdxFromMcuId( m_tCascadeMMCU.GetMtId() );					
		            TConfMcInfo *ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(wMMcuIdx);//m_tCascadeMMCU.GetMtId());
		            if( ptConfMcInfo != NULL && !ptConfMcInfo->m_tSpyMt.IsNull() )
		            {
			            if( tLogicalChannel.GetFlowControl() > wBitrate &&
                            ptConfMcInfo->m_tSpyMt.GetMtId() == tDstMt.GetMtId() &&
				            ptConfMcInfo->m_tSpyMt.GetMcuIdx() == tDstMt.GetMcuIdx() )
                        {
                            tLogicalChannel.SetFlowControl(wBitrate);
                            cServMsg.SetMsgBody((u8*)&tLogicalChannel, sizeof(tLogicalChannel)); 
                            
                            ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT2, "[SendFlowctrl2Mt] mt in spying, mode %d, old flowcontrol :%d, min flowcontrol :%d\n",
                            tLogicalChannel.GetMediaType(), tLogicalChannel.GetFlowControl(), wBitrate);  
                        }
                    }
                }
                
                //是否小于发送带宽
                wBitrate = m_ptMtTable->GetSndBandWidth(byMtId);
                if (wBitrate > 0 && wBitrate <= m_tConf.GetBitRate() && wBitrate < tLogicalChannel.GetFlowControl())
                {                   
                    ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT2, "[SendFlowctrl2Mt] mode %d, old flowcontrol :%d, bandwidth :%d\n",
                            tLogicalChannel.GetMediaType(), tLogicalChannel.GetFlowControl(), wBitrate);
                    
                    tLogicalChannel.SetFlowControl(wBitrate);
                    cServMsg.SetMsgBody((u8*)&tLogicalChannel, sizeof(tLogicalChannel));     
                }                
            }   
            else if (MODE_SECVIDEO == tLogicalChannel.GetMediaType())
            {
                if(!m_tDoubleStreamSrc.IsNull())
			    {
                    u16 wMinBitRate = GetLeastMtReqBitrate(FALSE, MEDIA_TYPE_NULL, m_tDoubleStreamSrc.GetMtId()); 
					u16 wTempBitrate = 0;
					if (  IsNeedAdjustMtSndBitrate(byMtId,wTempBitrate,MODE_SECVIDEO) 
						&& wTempBitrate < wMinBitRate )
					{
						wMinBitRate = wTempBitrate;
					}
				    if (tLogicalChannel.GetFlowControl() > wMinBitRate)
                    {
                        tLogicalChannel.SetFlowControl(wMinBitRate);
                        cServMsg.SetMsgBody((u8*)&tLogicalChannel, sizeof(tLogicalChannel));     

                        ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT2, "[SendFlowctrl2Mt] mt %d mode %d, flowcontrol :%d\n",
                            m_tDoubleStreamSrc.GetMtId(),tLogicalChannel.GetMediaType(), tLogicalChannel.GetFlowControl()); 
                    }
			    }
            }

            if (tLogicalChannel.GetFlowControl() == tLogicalChannel.GetCurrFlowControl() &&
                tLogicalChannel.GetFlowControl() > 64)  //兼容MT3.6的FlowControl处理
            {
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT2, "[SendFlowctrl2Mt] FlowControl.%d = CurrFlowControl!\n", tLogicalChannel.GetFlowControl());
                return TRUE;
            }
            else
            {
               tLogicalChannel.SetCurrFlowControl(tLogicalChannel.GetFlowControl());
            }
            
			
            u8 byChannel;
            if (MODE_VIDEO == tLogicalChannel.GetMediaType())
            {
				byChannel = LOGCHL_VIDEO;			
            }
            else if (MODE_AUDIO == tLogicalChannel.GetMediaType())
            {
                byChannel = LOGCHL_AUDIO;
            }
            else if (MODE_SECVIDEO == tLogicalChannel.GetMediaType())
            {
				byChannel = LOGCHL_SECVIDEO;				
            }
            else
            {
				ConfPrint(LOG_LVL_ERROR, MID_MCU_MT2, "[SendFlowctrl2Mt] Unexpected ChanType.%d!\n", tLogicalChannel.GetMediaType());
                return FALSE;
            }
            m_ptMtTable->SetMtLogicChnnl(byMtId, byChannel, &tLogicalChannel, FALSE);

			m_ptMtTable->GetMtLogicChnnl(byMtId, LOGCHL_VIDEO, &tLogicalChannel, FALSE);
			wBitrate = tLogicalChannel.GetFlowControl();
			m_ptMtTable->GetMtLogicChnnl(byMtId, LOGCHL_SECVIDEO, &tLogicalChannel, FALSE);
			wBitrate += tLogicalChannel.GetFlowControl();

			TMtStatus tStatus;   
			m_ptMtTable->GetMtStatus( byMtId,&tStatus );
			tStatus.SetSendBitRate( wBitrate );
			m_ptMtTable->SetMtStatus( byMtId,&tStatus );

		

			if( m_ptMtTable->GetMtTransE1(byMtId) 
				&& (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_MMCU
				    || m_ptMtTable->GetMtType(byMtId) == MT_TYPE_SMCU))
			{
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT2, "[SendFlowctrl2Mt]No need to adjust E1 MCU<Id:%d,type:%d> Bitrate!\n",byMtId,m_ptMtTable->GetMtType(byMtId));

				return TRUE;
			}
			else
			{
				m_ptMtTable->GetMtLogicChnnl(byMtId, byChannel, &tLogicalChannel, FALSE);

				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT2, "[SendFlowctrl2Mt] Mt.%d(%s), bitrate: %d, mode :%d\n", 
                    byMtId, StrOfIP(tLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr()), 
                    tLogicalChannel.GetFlowControl(), byChannel);
			}
        }
        else if(MCU_MT_YOUARESEEING_NOTIF == wEvent)
        {
            TMt tSrcMt = *(TMt *)cServMsg.GetMsgBody();            
            ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT2, "[SendMsg] send msg %s to Mt.%d, SrcMt(mcuid:%d mtid:%d, mtmaintype:%d, mtsubtype:%d)\n",
                    OspEventDesc(wEvent), byMtId, tSrcMt.GetMcuId(), tSrcMt.GetMtId(), tSrcMt.GetType(), tSrcMt.GetMtType());         
        }
        else if ( MCU_MT_FASTUPDATEPIC_CMD == wEvent )
        {
            u8 byMode = *(cServMsg.GetMsgBody());
            ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT2, "[SendMsg] send msg %s to Mt.%d for mode.%d\n",
                    OspEventDesc(wEvent), byMtId, byMode );   
        }
		// xliang [4/16/2009] print test
        else if ( MCU_MCU_ADJMTRES_REQ == wEvent )
		{	
			TMt tMt = *(TMt *)(cServMsg.GetMsgBody() + sizeof(TMsgHeadMsg));
			u8 byStart = *(u8 *)(cServMsg.GetMsgBody() + sizeof(TMsgHeadMsg) + sizeof(TMt));
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT2, "[SendMsg] send msg %s to Mt.%d to ask Mt(%u,%u) adjust[%d] Video resolution.\n",
				OspEventDesc(wEvent), byMtId, tMt.GetMcuId(), tMt.GetMtId(), byStart);
		}
		else if ( MCU_MCU_ADJMTFPS_REQ == wEvent ) 
		{	
			TMt tMt = *(TMt *)(cServMsg.GetMsgBody());
			u8 byStart = *(u8 *)(cServMsg.GetMsgBody() + sizeof(TMt));
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT2, "[SendMsg] send msg %s to Mt.%d to ask Mt(%u,%u) adjust[%d] Video fps.\n",
				OspEventDesc(wEvent), byMtId, tMt.GetMcuId(), tMt.GetMtId(), byStart);
		}
		cServMsg.SetMcuId( LOCAL_MCUID );		
		BOOL32 bRet = g_cMtAdpSsnApp.SendMsgToMtAdpSsn( tDstMt, wEvent, cServMsg );

		// 针对vrs放像实体，判发送以下消息时需清理vrs实体相关信息
		if (tDstMt.GetMtType() == MT_TYPE_VRSREC && m_ptMtTable->GetRecChlType(byMtId) == TRecChnnlStatus::TYPE_PLAY)
		{
			if (MCU_MT_OPENLOGICCHNNL_NACK == wEvent)
			{
				ReleaseVrsMt(byMtId);
			}
		}

		return bRet;
	}
}

/*====================================================================
    函数名      ：SendMsgToEqp
    功能        ：发消息给外设
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
				  u16 wEvent. 事件号
				  u8 byEqpId 外设Id号
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/02/26    3.0         胡昌威         创建
====================================================================*/
BOOL32 CMcuVcInst::SendMsgToEqp( u8 byEqpId, u16 wEvent, CServMsg & cServMsg )
{
	if( byEqpId == 0 )
	{
		ConfPrint( LOG_LVL_ERROR, MID_MCU_EQP, "[SendMsgToEqp] ERROR: Send Message.%d<%s> To Eqp %d not exist.\n",
			     wEvent, OspEventDesc(wEvent), byEqpId );
		return FALSE;
	}
	else
	{
		if( GetInsID() != CInstance::DAEMON )
		{
			cServMsg.SetConfId( m_tConf.GetConfId() );
			cServMsg.SetConfIdx( m_byConfIdx );
		}
		cServMsg.SetMcuId( LOCAL_MCUID );       

		return g_cEqpSsnApp.SendMsgToPeriEqpSsn( byEqpId, wEvent, cServMsg.GetServMsg(), cServMsg.GetServMsgLen() );		 
	}	
}

/*====================================================================
    函数名      ：SendMsgToMcs
    功能        ：发消息给会控
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
				  u16 wEvent. 事件号
				  u8 byMcsId 会控Id号
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/02/26    3.0         胡昌威         创建
====================================================================*/
BOOL32 CMcuVcInst::SendMsgToMcs( u8 byMcsId, u16 wEvent, CServMsg & cServMsg )
{
	if( byMcsId == 0 )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "Send Message.%d(%s) To Mcs.%d not exist.\n", wEvent, OspEventDesc(wEvent), byMcsId );
		return FALSE;
	}
	else
	{
		if( GetInsID() != CInstance::DAEMON )
		{
			cServMsg.SetConfId( m_tConf.GetConfId() );
			cServMsg.SetConfIdx( m_byConfIdx );
		}
		cServMsg.SetMcuId( LOCAL_MCUID );
		return CMcsSsn::SendMsgToMcsSsn( byMcsId, wEvent, cServMsg.GetServMsg(), cServMsg.GetServMsgLen() );		 
	}
}

/*====================================================================
    函数名      ：SendMsgToAllMcs
    功能        ：发消息给所有会控
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
				  u16 wEvent. 事件号
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/02/26    3.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::SendMsgToAllMcs( u16 wEvent, CServMsg & cServMsg )
{
	if( GetInsID() != CInstance::DAEMON )
	{
		cServMsg.SetConfIdx( m_byConfIdx );
		cServMsg.SetConfId( m_tConf.GetConfId() );
	}

	cServMsg.SetMcuId( LOCAL_MCUID );
	CMcsSsn::BroadcastToAllMcsSsn( wEvent, cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
}

/*====================================================================
    函数名      ：SendMsgToAllMp
    功能        ：发消息给所有MP
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wEvent. 事件号
                  CServMsg & cServMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/04/27    3.6         libo          创建
====================================================================*/
void CMcuVcInst::SendMsgToAllMp(u16 wEvent, CServMsg & cServMsg)
{
	if (GetInsID() != CInstance::DAEMON)
	{
		cServMsg.SetConfIdx(m_byConfIdx);
		//cServMsg.SetConfId( m_tConf.GetConfId() );
	}
	cServMsg.SetMcuId(LOCAL_MCUID);
	g_cMpSsnApp.BroadcastToAllMpSsn(wEvent, cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
}

/*=============================================================================
  函 数 名： SendMsgToDcsSsn
  功    能： 发消息给DCS会话的某个实例
  算法实现： 
  全局变量： 
  参    数：
  返 回 值： BOOL32
  -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2005/12/16    4.0			张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcInst::SendMsgToDcsSsn( u8 byInst, CServMsg &cServMsg )
{
	u32 dwRet = OspPost( MAKEIID(AID_MCU_DCSSSN, byInst), cServMsg.GetEventId(), 
						 cServMsg.GetServMsg(), cServMsg.GetServMsgLen(), 0, 
						 MAKEIID(GetAppID(), GetInsID()) );
	if ( OSP_OK != dwRet )
	{
        ConfPrint( LOG_LVL_ERROR, MID_MCU_CONF,"send msg %d<%s> to dcsssn failed, ret:%d !\n", 
            cServMsg.GetEventId(), OspEventDesc( cServMsg.GetEventId() ), dwRet );
        return FALSE;
	}	

	return TRUE;
}

/*====================================================================
    函数名      ：BroadcastToAllSubMtJoinedConf
    功能        ：发广播消息到所有参加本会议的直连终端
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wEvent, 事件号
				  u8 * const pbyMsg, 发送的消息指针，缺省为NULL
				  u16 wLen, 消息长度，缺省为0
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/08/03    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::BroadcastToAllSubMtJoinedConf( u16 wEvent, CServMsg & cServMsg )
{
// 	if( IsMsgNeedTranslate(wEvent) )
// 	{
// 		TranslateMsg( wEvent,cServMsg );
// 	}
	cServMsg.SetConfIdx( m_byConfIdx );
	cServMsg.SetConfId( m_tConf.GetConfId() );
	cServMsg.SetDstMtId( 0 );
	g_cMtAdpSsnApp.BroadcastToAllMtAdpSsn( wEvent, cServMsg );
}

/*====================================================================
    函数名      ：InstanceEntry
    功能        ：实例消息处理入口函数，必须override
    算法实现    ：
    引用全局变量：
    输入参数说明：CMessage * const pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/07/25    1.0         LI Yi         创建
	03/11/17    3.0         胡昌威        修改
====================================================================*/

#define MCUVC_EV_LOG(level)	MCU_EV_LOG(level, MID_MCU_MCS, "Vc")

/*lint -save -e825*/
void CMcuVcInst::InstanceEntry( CMessage * const pcMsg )
{
	// [11/15/2011 liuxu] 新Guard检测
	g_cMcuVcGuardCheck.ClientSet();

	if( NULL == pcMsg )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[CMcuVcInst] The received msg's pointer in the msg InstanceEntry is NULL!");

		return;
	}

	switch(pcMsg->event)
	{
		// 过滤的消息, 这些消息会在消息处理函数里输出
	case MT_MCU_INVITEMT_NACK:
	case MT_MCU_MTDISCONNECTED_NOTIF:
		break;

		// 这些消息优先级比较低
	case MCUVC_INVITE_UNJOINEDMT_TIMER:
	case MCUVC_MCUSRC_CHECK_TIMER:
		// break;
	case REC_MCU_RECORDPROG_NOTIF:
	case REC_MCU_PLAYPROG_NOTIF:
	case REC_MCU_RECSTATUS_NOTIF:
	case MCU_MCU_MTSTATUS_NOTIF:
	case MCUVC_REFRESH_MCS_TIMER:
	case MP_MCU_REMOVESWITCH_ACK:
	case REC_MCU_LISTALLRECORD_NOTIF:
		MCUVC_EV_LOG(LOG_LVL_DETAIL);
		break;
	default:
		MCUVC_EV_LOG(LOG_LVL_KEYSTATUS);
	}
	
	//主备数据倒换时，[MSMag <->McuVc]模块互锁，锁定 2005-12-15
	g_cMSSsnApp.EnterMSSynLock(AID_MCU_VC);

	if ( pcMsg->event > MCUVC_FASTUPDATE_TIMER_ARRAY && pcMsg->event <= MCUVC_FASTUPDATE_TIMER_ARRAY + MAXNUM_CONF_MT )
	{
		ProcMcuMtFastUpdateTimer(pcMsg);
		//主备数据倒换时，[MSMag <->McuVc]模块互锁，解锁 2005-12-15
		g_cMSSsnApp.LeaveMSSynLock(AID_MCU_VC);

		return;
	}
    
    if ( pcMsg->event > MCUVC_FASTUPDATE_TIMER_ARRAY4EQP && pcMsg->event <= MCUVC_FASTUPDATE_TIMER_ARRAY4EQP + MAXNUM_PERIEQP*3)
    {
        ProcMcuEqpFastUpdateTimer(pcMsg);
        g_cMSSsnApp.LeaveMSSynLock(AID_MCU_VC);
		
        return;
    }
    
	//[03/04/2010] zjl add 电视墙多通道轮询定时器处理
	if (pcMsg->event >= MCUVC_TWPOLLING_CHANGE_TIMER && pcMsg->event < MCUVC_TWPOLLING_CHANGE_TIMER + MAXNUM_TVWALL_CHNNL)
	{		
		ProcTWPollingChangeTimerMsg(pcMsg);
		g_cMSSsnApp.LeaveMSSynLock(AID_MCU_VC);

		return;
	}
	
	//[03/28/2013] yhz add 多画面合成等待外设消息回复超时处理
	if (pcMsg->event >= MCUVC_VMP_WAITVMPRSP_TIMER && pcMsg->event < MCUVC_VMP_WAITVMPRSP_TIMER + MAXNUM_CONF_VMP)
	{		
		ProcVmpRspWaitTimer(pcMsg);
		g_cMSSsnApp.LeaveMSSynLock(AID_MCU_VC);
		
		return;
	}
	//[03/28/2013] yhz add 多画面合成开启前等待多回传下级回复超时处理
	if (pcMsg->event >= MCUVC_WAIT_ALLVMPPRESETIN_ACK_TIMER && pcMsg->event < MCUVC_WAIT_ALLVMPPRESETIN_ACK_TIMER + MAXNUM_CONF_VMP)
	{		
		ProcWaitAllVMPPrestInAckTimer(pcMsg);
		g_cMSSsnApp.LeaveMSSynLock(AID_MCU_VC);
		
		return;
	}
	
	
	// [6/14/2011 zjj] vcs会议主席终端控制台功能屏蔽:指定取消发言，指定取消主席，选看终端，
	// 邀请终端，请退终端，轮询，会议讨论，画面合成，静音哑音，结束会议，终端选看合成，
	// 语音激励，强制广播，申请插话
	if( VCS_CONF == m_tConf.GetConfSource() )
	{
		switch(pcMsg->event)
		{		
		case MT_MCU_SPECSPEAKER_REQ:		
		case MT_MCU_SPECCHAIRMAN_REQ:
		case MT_MCU_CANCELCHAIRMAN_REQ:		
		case MT_MCU_STARTSELMT_REQ:
		case MT_MCU_ADDMT_REQ:
		case MT_MCU_DELMT_REQ:
		case MT_MCU_STARTDISCUSS_REQ:
		case MT_MCU_STOPDISCUSS_REQ:
		case MT_MCU_STARTSWITCHVMPMT_REQ:
		case MT_MCU_STARTVMP_REQ:
		case MT_MCU_STOPVMP_REQ:
		case MT_MCU_CHANGEVMPPARAM_REQ:
		case MT_MCU_GETVMPPARAM_REQ:
		case MT_MCU_STARTVMPBRDST_REQ:
		case MT_MCU_STOPVMPBRDST_REQ:
		case MT_MCU_STARTVAC_REQ:
		case MT_MCU_STOPVAC_REQ:
		case MT_MCU_SPECSPEAKER_CMD:
		case MT_MCU_CANCELSPEAKER_CMD:
		case MT_MCU_STARTSELMT_CMD:
		case MT_MCU_MTMUTE_CMD:
		case MT_MCU_MTDUMB_CMD:
		case MT_MCU_DROPCONF_CMD:
		case MT_MCU_VIEWBRAODCASTINGSRC_CMD:
		case MT_MCU_APPLYMIX_NOTIF:
			g_cMSSsnApp.LeaveMSSynLock(AID_MCU_VC);

			ConfPrint( LOG_LVL_WARNING, MID_MCU_MT, "[CMcuVcInst] Fail to handle msg(%s) in vcs conf\n",OspEventDesc(pcMsg->event) );

			return;
		default:
			break;
		}
	}

	switch( pcMsg->event )
	{
	case OSP_POWERON:				//上电消息
		break;
    
	case OSP_OVERFLOW:
        {
			CServMsg cServMsg( pcMsg->content, pcMsg->length );
			cServMsg.SetErrorCode( ERR_MCU_CONFOVERFLOW );
			SendMsgToMcs(cServMsg.GetSrcSsnId(), cServMsg.GetEventId()+2, cServMsg);
        }
		break;
    
    /*----------------------------会议管理-------------------------------*/

	//会议管理---创建会议
	case MCS_MCU_CREATECONF_REQ:          //会议控制台在MCU上创建一个会议
	case MCU_CREATECONF_FROMFILE:		  //自身创建会议消息 
	case MCU_SCHEDULE_CONF_START:         //预约会议变为即时会议
	case MT_MCU_CREATECONF_REQ:		      //创建会议消息
    case MCU_CREATECONF_NPLUS:
		ProcMcsMcuCreateConfReq(pcMsg);
		break;
	case MCU_WAITEQP_CREATE_CONF_NOTIFY:
		ProcWaitEqpToCreateConf(pcMsg);
		break;

    case MCUVC_CONFSTARTREC_TIMER:        //自动录像
        ProcTimerAutoRec(pcMsg);
        break;
	case MCUVC_WAIT_LASTVMPROLLCALLFINISH_TIMER:
		ProcWaitLastVmpRollCallFinishTimer();
		break;
    //  [12/25/2009 pengjie] 隔天刷新自动录像
	case MCUVC_UPDATA_AUTOREC_TIMER:
		ProcTimerUpdataAutoRec(pcMsg);
		break;
    // End

	// [pengjie 2010/9/29] 检测会议是否有广播源处理
	case MCUVC_CHECK_CONFBRDSRC_TIMER:
		ProcTimerConfHasBrdSrc();
		break;
	// End
				
	// [pengjie 2010/2/26] 双流放像，mcu定时发令牌环
	case MCUVC_NOTIFYMCUH239TOKEN_TIMER:
		ProcTimer239TokenNtf();
		break;
    // End
     
	case MCUVC_WAITMSCONFDATA_TIMER:
		ProcWaitMSConfDataTimer();
		break;

	//会议管理---结束会议
	case MCS_MCU_RELEASECONF_REQ:         //会议控制台请求MCU结束一个会议
	case MT_MCU_DROPCONF_CMD:		      //主席终端中止会议请求
		ProcMcsMcuReleaseConfReq(pcMsg);
		break;

	//会议管理---保护会议
	case MCS_MCU_CHANGECONFLOCKMODE_REQ:  //会议控制台请求MCU改变会议保护方式
		ProcMcsMcuChangeLockModeConfReq(pcMsg);
		break;
	case MCS_MCU_ENTERCONFPWD_ACK:        //会议控制台回应MCU的密码请求   
	case MCS_MCU_ENTERCONFPWD_NACK:       //会议控制台拒绝MCU的密码请求
		ProcMcsMcuEnterPwdRsp(pcMsg);
		break;
	case MCS_MCU_CHANGECONFPWD_REQ:       //会议控制台请求MCU改变会议密码
		ProcMcsMcuChangeConfPwdReq(pcMsg);
		break;
	case MCS_MCU_GETLOCKINFO_REQ:
		ProcMcsMcuGetLockInfoReq(pcMsg); //会控得到会议独享消息请求
		break;

	//会议管理---保存会议
	case MCS_MCU_SAVECONF_REQ:            //会议控制台请求MCU保存会议
		ProcMcsMcuSaveConfReq(pcMsg);
		break;

	//会议管理---修改会议
	case MCS_MCU_MODIFYCONF_REQ:	      //修改会议消息
		ProcMcsMcuModifyConfReq(pcMsg);
		break;

	//会议管理---延长会议
	case MT_MCU_DELAYCONF_REQ:			  //终端请求MCU延长会议
	case MCS_MCU_DELAYCONF_REQ:           //会议控制台请求MCU延长会议
		ProcMcsMcuDelayConfReq(pcMsg);
		break;

	//数据会议管理---来自DCS的应答 2005-12-16
	case DCSSSN_MCU_CREATECONF_ACK:
	case DCSSSN_MCU_CREATECONF_NACK:
	case DCSSSN_MCU_CONFCREATED_NOTIF:
		ProcDcsMcuCreateConfRsp(pcMsg);
		break;

	case MCS_MCU_CHANGEVACHOLDTIME_REQ:	  //会议控制台请求MCU改变语音激励切换时间
		ProcMcsMcuChangeVacHoldTimeReq(pcMsg);
		break;

	/*----------------------------会议操作-------------------------------*/

	//会议操作---主席
	case MCS_MCU_SPECCHAIRMAN_REQ:       //会议控制台指定一台终端为主席
	case MT_MCU_SPECCHAIRMAN_REQ:		 //主席终端指定主席请求
		ProcMcsMcuSpecChairmanReq(pcMsg);
		break;
	case MCS_MCU_CANCELCHAIRMAN_REQ:     //会议控制台取消当前会议主席 
	case MT_MCU_CANCELCHAIRMAN_REQ:		 //主席终端取消自己主席权限请求
		ProcMcsMcuCancelChairmanReq(pcMsg);
		break;
    case MCS_MCU_SETCHAIRMODE_CMD:       //会议控制台设置会议的主席方式
        ProcMcsMcuSetConfChairMode(pcMsg);
		break;

	//会议操作---发言
	case MCS_MCU_SPECSPEAKER_REQ:        //会议控制台指定一台终端发言
	case MT_MCU_SPECSPEAKER_REQ:		 //普通终端指定发言人请求
	case MT_MCU_SPECSPEAKER_CMD:		 //主席终端指定发言人请求
		ProcMcsMcuSpecSpeakerReq(pcMsg);
		break;
	case MCS_MCU_CANCELSPEAKER_REQ:      //会议控制台取消会议Speaker
	case MT_MCU_CANCELSPEAKER_CMD:		 //主席终端取消发言人请求
		ProcMcsMcuCancelSpeakerReq(pcMsg);
		break;
	case MCS_MCU_MTSEESPEAKER_CMD:
    case MT_MCU_VIEWBRAODCASTINGSRC_CMD:    //强制广播
		ProcMcsMcuSeeSpeakerCmd(pcMsg);
		break;
        
    case MCS_MCU_SPECOUTVIEW_REQ:       //会议控制台指定回传通道
        ProcMcsMcuSpecOutViewReq(pcMsg);
        break;        
		
	case MCUVC_SMSPACK_TIMER:
		ProcSmsPackTimer();
		break;

    //级联MCU
	case MCU_MCU_REGISTER_NOTIF:
		ProcMcuMcuRegisterNotify(pcMsg);
		break;
	case MCU_MCU_ROSTER_NOTIF:
		ProcMcuMcuRosterNotify(pcMsg);
		break;
	case MCU_MCU_MTLIST_REQ:
		ProcMcuMcuMtListReq(pcMsg);
		break;
	case MCU_MCU_MTLIST_ACK:
		ProcMcuMcuMtListAck(pcMsg);
		break;
	case MCU_MCU_VIDEOINFO_REQ:
		ProcMcuMcuVideoInfoReq(pcMsg);
		break;
	case MCU_MCU_VIDEOINFO_ACK:
		ProcMcuMcuVideoInfoAck(pcMsg);
		break;
	case MCU_MCU_CONFVIEWCHG_NOTIF:
		ProcMcuMcuConfViewChgNtf(pcMsg);
		break;
	case MCU_MCU_AUDIOINFO_REQ:
		ProcMcuMcuAudioInfoReq(pcMsg);
		break;
	case MCU_MCU_AUDIOINFO_ACK:
		ProcMcuMcuAudioInfoAck(pcMsg);
        break;
	case MCU_MCU_NEWMT_NOTIF:
		ProcMcuMcuNewMtNotify(pcMsg);
		break;
	case MCU_MCU_CALLALERTING_NOTIF:
		ProcMcuMcuCallAlertMtNotify(pcMsg);
		break;
	case MCU_MCU_DROPMT_NOTIF:
		ProcMcuMcuDropMtNotify(pcMsg);
		break;
	case MCU_MCU_DELMT_NOTIF:
		ProcMcuMcuDelMtNotify(pcMsg);
		break;
	case MCU_MCU_SETMTCHAN_REQ:
		ProcMcuMcuSetMtChanReq(pcMsg);
		break;
	case MCU_MCU_SETMTCHAN_NOTIF:
		ProcMcuMcuSetMtChanNotify(pcMsg);
		break;
	case MCU_MCU_SETIN_REQ:
		ProcMcuMcuSetInReq(pcMsg);
		break;
	case MCU_MCU_SETOUT_REQ:
		ProcMcuMcuSetOutReq(pcMsg);
		break;
	case MCU_MCU_SETOUT_NOTIF:
		ProcMcuMcuSetOutNotify(pcMsg);
		break;

	case MCU_MCU_STARTMIXER_CMD:
		ProcMcuMcuStartMixerCmd(pcMsg);
		break;
/*		
	case MCU_MCU_STARTMIXER_REQ:
		ProcMcuMcuStartMixerReq(pcMsg);
		break;
	case MCU_MCU_STARTMIXER_ACK:
		ProcMcuMcuStartMixerAck(pcMsg);
		break;
	case MCU_MCU_STARTMIXER_NACK:
		ProcMcuMcuStartMixerNack(pcMsg);
		break;
*/
	case MCU_MCU_STARTMIXER_NOTIF:
		ProcMcuMcuStartMixerNotif(pcMsg);
		break;
	case MCU_MCU_STOPMIXER_CMD:
		ProcMcuMcuStopMixerCmd(pcMsg);
		break;
	/*
	case MCU_MCU_STOPMIXER_REQ:
		ProcMcuMcuStopMixerReq(pcMsg);
		break;
	case MCU_MCU_STOPMIXER_ACK:
		ProcMcuMcuStopMixerAck(pcMsg);
		break;
	case MCU_MCU_STOPMIXER_NACK:
		ProcMcuMcuStopMixerNack(pcMsg);
		break;
	*/
	case MCU_MCU_STOPMIXER_NOTIF:
		ProcMcuMcuStopMixerNotif(pcMsg);
		break;

	case MCU_MCU_MTAUDMUTE_REQ:
		ProcMcuMcuMuteDumbReq(pcMsg);
		break;

	case MCU_MCU_ADJMTRES_REQ:
		ProcMcuMcuAdjustMtResReq(pcMsg);
		break;
	case MCU_MCU_ADJMTRES_ACK:
		ProcMcuMcuAdjustMtResAck(pcMsg);
		break;
	case MCU_MCU_ADJMTRES_NACK:
		ProcMcuMcuAdjustMtResNack(pcMsg);
		break;
// [pengjie 2010/4/23] 级联降帧率
	case MCU_MCU_ADJMTFPS_REQ:
		ProcMcuMcuAdjustMtFpsReq(pcMsg);
		break;
	case MCU_MCU_ADJMTFPS_ACK:
		ProcMcuMcuAdjustMtFpsAck(pcMsg);
		break;
	case MCU_MCU_ADJMTFPS_NACK:
		ProcMcuMcuAdjustMtFpsNack(pcMsg);
		break;
// End

	case MCU_MCU_ADJMTBITRATE_CMD:
		ProcMcuMcuAdjustMtBitRateCmd(pcMsg);		
		break;

	case MCU_MCU_SPEAKSTATUS_NTF:
		ProcMcuMcuSpeakStatusNtf( pcMsg );
		break;
		
	

	case MCU_MCU_GETMIXERPARAM_REQ:
		ProcMcuMcuGetMixerParamReq(pcMsg);
		break;
	case MCU_MCU_GETMIXERPARAM_ACK:
		ProcMcuMcuGetMixerParamAck(pcMsg);
		break;
	case MCU_MCU_GETMIXERPARAM_NACK:
		ProcMcuMcuGetMixerParamNack(pcMsg);
		break;
	case MCU_MCU_MIXERPARAM_NOTIF:
		ProcMcuMcuMixerParamNotif(pcMsg);
		break;
	case MCU_MCU_ADDMIXMEMBER_CMD:
		ProcMcuMcuAddMixerMemberCmd(pcMsg);
		break;
	case MCU_MCU_REMOVEMIXMEMBER_CMD:
		ProcMcuMcuRemoveMixerMemberCmd(pcMsg);
		break;
	case MCU_MCU_LOCK_REQ:
		ProcMcuMcuLockReq(pcMsg);
		break;
	case MCU_MCU_LOCK_ACK:
		ProcMcuMcuLockAck(pcMsg);
		break;
	case MCU_MCU_LOCK_NACK:
		ProcMcuMcuLockNack(pcMsg);
		break;
	case MCU_MCU_MTSTATUS_CMD:
		ProcMcuMcuMtStatusCmd(pcMsg);
		break;
	case MCU_MCU_MTSTATUS_NOTIF:
		ProcMcuMcuMtStatusNotif(pcMsg);
		break;
    case MCU_MCU_AUTOSWITCH_REQ:
        ProcMcuMcuAutoSwitchReq(pcMsg);
        break;
    case MCU_MCU_AUTOSWITCH_ACK:
    case MCU_MCU_AUTOSWITCH_NACK:           
        ProcMcuMcuAutoSwitchRsp(pcMsg);
        break;
    case MCUVC_AUTOSWITCH_TIMER:
        ProcMcuMcuAutoSwitchTimer();
        break;

	//////////////////////////////////////////////////////////////////////////		
	//zjj20100201 多回传代码合并
	//  pengjie[9/28/2009] 级联多回传消息处理
	case MCU_MCU_PRESETIN_REQ:
		ProcMcuMcuPreSetInReq(pcMsg);
		break;
	case MCU_MCU_PRESETIN_ACK:
		ProcMcuMcuPreSetInAck(pcMsg);
		break;
	case MCU_MCU_PRESETIN_NACK:
		ProcMcuMcuPreSetInNack(pcMsg);
		break;
	case MCU_MCU_MULTSPYCAP_NOTIF:
        ProcMcuMcuMultSpyCapNotif(pcMsg);
		break;		
	case MCU_MCU_SPYCHNNL_NOTIF:
		ProcMcuMcuSpyNotify(pcMsg);
		break;
	case MCU_MCU_SWITCHTOMCUFAIL_NOTIF:
		ProcMcuMcuSwitchToMcuFailNotif(pcMsg);
		break;
	case MCU_MCU_REJECTSPY_NOTIF:
		ProcMcuMcuRejectSpyNotify(pcMsg);
		break;
	case MCU_MCU_BANISHSPY_CMD:
		ProcMcuMcuBanishSpyCmd(pcMsg);
		break;
	case MCU_MCU_MTEXTINFO_NOTIF:
		ProcMcuMcuMtExtInfoNotif(pcMsg);
		break;
	//lukunpeng 2010/06/10 由于现在是由上级管理下级带宽占用情况，故不需要再通过下级通知上级
// 	case MCU_MCU_BANISHSPY_NOTIF:
// 		ProcMMcuBanishedSpyNotify(pcMsg);
// 		break;
	
    // [pengjie 2010/4/2] 级联多回传请求关键帧
	case MCU_MCU_SPYFASTUPDATEPIC_CMD:
		ProcMcuMcuSpyFastUpdateCmd(pcMsg);
		break;
	//////////////////////////////////////////////////////////////////////////
	
		
	case MCS_MCU_ADDMT_REQ:              //会议控制台增加终端	
	case MT_MCU_ADDMT_REQ:			     //主席终端增加终端
	case MCU_MCU_INVITEMT_REQ:           //MCU-MCU增加终端
		ProcMcsMcuAddMtReq(pcMsg);
		break;
	case MCS_MCU_ADDMTEX_REQ:
		ProcMcsMcuAddMtExReq(pcMsg);     //调试版会控增加终端处理，含打开通道使用的能力级
		break;

    
	case MCS_MCU_DELMT_REQ:              //会议控制台驱逐终端离会
	case MT_MCU_DELMT_REQ:			     //主席终端强制终端退出请求
	case MCU_MCU_DELMT_REQ:			     //主席终端强制终端退出请求
		ProcMcsMcuDelMtReq(pcMsg);
		break;

	// 会议操作 --- hdu  //4.6.1 新加  jlb
    case MCS_MCU_START_SWITCH_HDU_REQ:
    case MCUVC_STARTSWITCHHDU_NOTIFY:
        ProcMcsMcuStartSwitchHduReq( pcMsg );
        break;

	// 界面切换HDU通道模式
	case MCS_MCU_CHGHDUVMPMODE_CMD:
		ProcMcsMcuChangeHduVmpMode(pcMsg);
		break;

    case MCS_MCU_STOP_SWITCH_HDU_REQ:
		ProcMcsMcuStopSwitchHduReq( pcMsg );
		break;

    case MCS_MCU_CHANGEHDUVOLUME_REQ:
		ProcMcsMcuChangeHduVolume( pcMsg );
		break;

    //会议操作---选看
	case MT_MCU_STARTSELMT_CMD:			 //标准选看命令
	case MT_MCU_STARTSELMT_REQ:          //
	case MCS_MCU_STARTSWITCHMT_REQ:	     //控制台要求交换命令
	case MCS_MCU_STARTSWITCHMC_REQ:      //会控选看终端
		ProcMtMcuStartSwitchMtReq(pcMsg);
		break;
	case MCS_MCU_STARTSWITCHVMPMT_REQ:	 //主席终端选看画面合成 // xliang [12/31/2008]  
	case MT_MCU_STARTSWITCHVMPMT_REQ:	
		ProcMcsMcuStartSwitchVmpMtReq(pcMsg);
		break;
	case MCS_MCU_START_SWITCH_TW_REQ:    //会议控制台向电视墙开始播放请求
		ProcMcsMcuStartSwitchTWReq(pcMsg);
		break;
	case MT_MCU_STOPSELMT_CMD:			 //标准停止选看命令
	case MCS_MCU_STOPSWITCHMT_REQ:	     //控制台要求交换命令
		ProcMtMcuStopSwitchMtReq(pcMsg);
		break;

    //会议操作---短消息
	case MCS_MCU_SENDRUNMSG_CMD:         //会议控制台命令MCU向终端发送短消息，终端号为0表示发给所有终端
	case MT_MCU_SENDMSG_CMD:             //终端短消息请求
		ProcMcsMcuSendMsgReq(pcMsg);
		break;
	case MCU_MCU_SENDMSG_NOTIF:          //跨MCU的短消息
		ProcMcuMcuSendMsgReq(pcMsg);
		break;

	//会议操作---得到终端列表
	case MCS_MCU_GETMTLIST_REQ:          //会议控制台发给MCU的得到终端列表请求
        ProcMcsMcuGetMtListReq(pcMsg);
		break;
	case MCS_MCU_REFRESHMCU_CMD:
		ProcMcsMcuRefreshMcuCmd(pcMsg);
		break;
		//vmp抢占应答：// xliang [12/12/2008] 
	case MCS_MCU_VMPPRISEIZE_ACK:
	case MCS_MCU_VMPPRISEIZE_NACK:
		ProcMcsMcuVmpPriSeizeRsp(pcMsg);
		break;
	case MCUVC_MTSEIZEVMP_TIMER:
		ProcMtSeizeVmpTimer(pcMsg);
		break;
	case MCUVC_VMPBATCHPOLL_TIMER:
		ProcVmpBatchPollTimer();

	//会议操作---得到会议信息
	case MCS_MCU_GETCONFINFO_REQ:        //会议控制台向MCU查询会议信息 
	case MT_MCU_GETCONFINFO_REQ:         //终端向MCU查询会议信息
    case MCS_MCU_GETMAUSTATUS_REQ:       //会议控制台向MCU查询MAU信息 
        ProcMcsMcuGetConfInfoReq(pcMsg);
		break;

	//会议控制---视频复合控制
	case MCS_MCU_STARTVMP_REQ:			//会控开始视频复合请求
	case MCS_MCU_STOPVMP_REQ:			//会控结束视频复合请求	
	case MCS_MCU_CHANGEVMPPARAM_REQ:	//会控会议控制台请求MCU改变混音参数			
	case MCS_MCU_GETVMPPARAM_REQ:		//会控查询混音成员请求
	case MCS_MCU_STARTVMPBRDST_REQ:		//会议控制台命令MCU开始把画面合成图像广播到终端
	case MCS_MCU_STOPVMPBRDST_REQ:		//会议控制台命令MCU停止把画面合成图像广播到终端
	case MT_MCU_STARTVMP_REQ:			//主席开始视频复合请求
	case MT_MCU_STOPVMP_REQ:			//主席结束视频复合请求	
	case MT_MCU_CHANGEVMPPARAM_REQ:		//主席会议控制台请求MCU改变混音参数
	case MT_MCU_GETVMPPARAM_REQ:		//主席查询混音成员请求
	case MT_MCU_STARTVMPBRDST_REQ:		//主席命令MCU开始把画面合成图像广播到终端
	case MT_MCU_STOPVMPBRDST_REQ:		//主席命令MCU停止把画面合成图像广播到终端
	case MCS_MCU_START_VMPBATCHPOLL_REQ://开始画面合成批量轮询// xliang [12/31/2008] 
        ProcMcsMcuVMPReq(pcMsg);
		break;
	case MCS_MCU_PAUSE_VMPBATCHPOLL_CMD:	//暂停画面合成批量轮询// xliang [12/31/2008]  
	case MCS_MCU_RESUME_VMPBATCHPOLL_CMD:	//恢复画面合成批量轮询
	case MCS_MCU_STOP_VMPBATCHPOLL_CMD:		//停止画面合成批量轮询
		ProcMcsMcuVmpCmd(pcMsg);
		break;
	case VMP_MCU_STARTVIDMIX_ACK:       //VMP给MCU开始工作确认
	case VMP_MCU_STARTVIDMIX_NACK:      //VMP给MCU开始工作拒绝
	case VMP_MCU_STOPVIDMIX_ACK:        //VMP给MCU停止工作确认
	case VMP_MCU_STOPVIDMIX_NACK:       //VMP给MCU停止工作拒绝
	case VMP_MCU_CHANGEVIDMIXPARAM_ACK: //VMP给MCU改变复合参数确认
	case VMP_MCU_CHANGEVIDMIXPARAM_NACK://VMP给MCU改变复合参数拒绝
	case VMP_MCU_GETVIDMIXPARAM_ACK:    //VMP给MCU回送复合参数确认
	case VMP_MCU_GETVIDMIXPARAM_NACK:   //VMP给MCU回送复合参数拒绝
        ProcVmpMcuRsp(pcMsg);
		break;
    case VMP_MCU_STARTVIDMIX_NOTIF:     //VMP给MCU开始工作通知
    case VMP_MCU_STOPVIDMIX_NOTIF:      //VMP给MCU停止工作通知
    case VMP_MCU_CHANGESTATUS_NOTIF:    //VMP给MCU改变复合参数通知
    case MCU_VMPCONNECTED_NOTIF:
    case MCU_VMPDISCONNECTED_NOTIF:     //VMP断链通知
    case VMP_MCU_NEEDIFRAME_CMD:        //画面合成请求I帧
        ProcVmpMcuNotif(pcMsg); 
        break;
//	case MCUVC_VMP_WAITVMPRSP_TIMER:      //MCU等待VMP应答定时
//		ProcVmpRspWaitTimer(pcMsg);
//		break;
//	case MCUVC_WAIT_ALLVMPPRESETIN_ACK_TIMER:
//		ProcWaitAllVMPPrestInAckTimer();
//		break;

    //会议控制---复合电视墙控制
	case MCS_MCU_STARTVMPTW_REQ:        //会控开始复合电视墙请求
	case MCS_MCU_STOPVMPTW_REQ:         //会控结束复合电视墙请求
	case MCS_MCU_CHANGEVMPTWPARAM_REQ:  //会控会议控制台请求MCU改变复合电视墙参数
//	case MCS_MCU_GETVMPPARAM_REQ:		//会控查询混音成员请求
//	case MCS_MCU_STARTVMPBRDST_REQ:		//会议控制台命令MCU开始把画面合成图像广播到终端
//	case MCS_MCU_STOPVMPBRDST_REQ:		//会议控制台命令MCU停止把画面合成图像广播到终端
        ProcMcsMcuVmpTwReq(pcMsg);
        break;
    case VMPTW_MCU_STARTVIDMIX_ACK:       //VMPTW给MCU开始工作确认
    case VMPTW_MCU_STARTVIDMIX_NACK:      //VMPTW给MCU开始工作拒绝
    case VMPTW_MCU_STOPVIDMIX_ACK:        //VMPTW给MCU停止工作确认
    case VMPTW_MCU_STOPVIDMIX_NACK:       //VMPTW给MCU停止工作拒绝
    case VMPTW_MCU_CHANGEVIDMIXPARAM_ACK: //VMPTW给MCU改变复合参数确认
    case VMPTW_MCU_CHANGEVIDMIXPARAM_NACK://VMPTW给MCU改变复合参数拒绝
//    case VMPTW_MCU_GETVIDMIXPARAM_ACK:    //VMPTW给MCU回送复合参数确认
//    case VMPTW_MCU_GETVIDMIXPARAM_NACK:   //VMPTW给MCU回送复合参数拒绝
        ProcVmpTwMcuRsp(pcMsg);
        break;
    case VMPTW_MCU_STARTVIDMIX_NOTIF:     //VMPTW给MCU开始工作通知
	case VMPTW_MCU_STOPVIDMIX_NOTIF:      //VMPTW给MCU停止工作通知
	case VMPTW_MCU_CHANGESTATUS_NOTIF:    //VMPTW给MCU改变复合参数通知
    case MCU_VMPTWCONNECTED_NOTIF:
	case MCU_VMPTWDISCONNECTED_NOTIF:     //VMPTW断链通知
	case VMPTW_MCU_NEEDIFRAME_CMD:        //VMPTW给MCU请求I帧
	    ProcVmpTwMcuNotif(pcMsg); 
		break;

	//会议控制---得到会议状态
	case MCS_MCU_GETCONFSTATUS_REQ:     //会议控制台向MCU查询会议状态
        ProcMcsMcuGetConfStatusReq(pcMsg);
		break;
	case MCS_MCU_MCUMEDIASRC_REQ:
		ProcMcsMcuMcuMediaSrcReq(pcMsg);
		break;
	case MCS_MCU_LOCKSMCU_REQ:
		ProcMcsMcuLockSMcuReq(pcMsg);
		break;	
	case MCS_MCU_GETMCULOCKSTATUS_REQ:
		ProcMcsMcuGetMcuLockStatusReq(pcMsg);
		break;

    //会议控制---语音激励控制发言
	case MCS_MCU_STARTVAC_REQ:        //会议控制台请求MCU开始语音激励控制发言		
	case MCS_MCU_STOPVAC_REQ:         //会议控制台请求MCU停止语音激励控制发言
	case MT_MCU_STARTVAC_REQ:         //终端请求MCU开始语音激励控制发言
	case MT_MCU_STOPVAC_REQ:          //终端请求MCU停止语音激励控制发言
        ProcMcsMcuVACReq(pcMsg);
		break;		
				
	//会议控制---混音控制
	case MCS_MCU_STARTDISCUSS_REQ:     //开始会议讨论请求 - 用于本级开始讨论操作
	case MCS_MCU_STOPDISCUSS_REQ:      //结束会议讨论请求 - 用于本级开始讨论操作

    //zbq[11/01/2007] 混音优化
    case MCS_MCU_GETMIXPARAM_REQ:      //会议控制台查询讨论参数请求
    //case MCS_MCU_STARTDISCUSS_CMD:     //开始会议讨论命令 - 用于跨级开始讨论操作
	//case MCS_MCU_STOPDISCUSS_CMD:      //结束会议讨论命令 - 用于跨级开始讨论操作
	//case MCS_MCU_GETDISCUSSPARAM_REQ:  //会议控制台查询讨论参数请求

        ProcMcsMcuMixReq(pcMsg);
		break;
	case MT_MCU_STARTDISCUSS_REQ:      //终端开始会议讨论请求
	case MT_MCU_STOPDISCUSS_REQ:       //终端请求MCU结束会议讨论
		ProcMtMcuMixReq(pcMsg);
		break;
    
    //混音延时设置
    case MCS_MCU_CHANGEMIXDELAY_REQ:
        ProcMcsMcuChgMixDelayReq(pcMsg);
        break;

	case MIXER_MCU_STARTMIX_ACK:        //同意开始混音应答
	case MIXER_MCU_STARTMIX_NACK:       //拒绝开始混音应答
	case MIXER_MCU_STOPMIX_ACK:         //同意停止混音应答
	case MIXER_MCU_STOPMIX_NACK:        //拒绝停止混音应答
	case MIXER_MCU_ADDMEMBER_ACK:       //加入成员应答消息
	case MIXER_MCU_ADDMEMBER_NACK:      //加入成员应答消息
	case MIXER_MCU_REMOVEMEMBER_ACK:    //删除成员应答消息
	case MIXER_MCU_REMOVEMEMBER_NACK:   //删除成员应答消息
	case MIXER_MCU_FORCEACTIVE_ACK:     //强制成员混音应答
	case MIXER_MCU_FORCEACTIVE_NACK:    //强制成员混音拒绝
	case MIXER_MCU_CANCELFORCEACTIVE_ACK:    //取消成员强制混音应答
	case MIXER_MCU_CANCELFORCEACTIVE_NACK:   //取消成员强制混音拒绝
		ProcMixerMcuRsp(pcMsg);
		break;
	case MIXER_MCU_GRPSTATUS_NOTIF:     //混音组状态通知
	case MIXER_MCU_ACTIVEMMBCHANGE_NOTIF:  //混音激励成员改变通知
	case MIXER_MCU_CHNNLVOL_NOTIF:      //某通道音量通知消息
	case MCU_MIXERCONNECTED_NOTIF:      //混音器上线通知
	case MCU_MIXERDISCONNECTED_NOTIF:   //混音器断链通知
    case MIXER_MCU_MIXERSTATUS_NOTIF:   //混音器通道准备完成通知
	    ProcMixerMcuNotif(pcMsg);
		break;
	case MCUVC_MIX_WAITMIXERRSP_TIMER:      //MCU等待VMP应答定时
		ProcMixerRspWaitTimer(pcMsg);
		break;
	case MT_MCU_ADDMIXMEMBER_CMD:           //主席增加混音终端
	case MCS_MCU_ADDMIXMEMBER_CMD:          //增加混音成员
		ProcMcsMcuAddMixMemberCmd(pcMsg);
		break;
	case MCS_MCU_REMOVEMIXMEMBER_CMD:       //移除混音成员
	case MT_MCU_REMOVEMIXMEMBER_CMD:		//主席移除混音终端 
		ProcMcsMcuRemoveMixMemberCmd(pcMsg);
		break;
    case MCS_MCU_REPLACEMIXMEMBER_CMD:      //替换混音成员
        ProcMcsMcuReplaceMixMemberCmd(pcMsg);
        break;
	case MT_MCU_APPLYMIX_NOTIF:             //终端发给MCU的申请参加混音请求
		ProcMtMcuApplyMixNotify(pcMsg);
		break;

	//会议控制---轮询控制
	case MCS_MCU_STARTPOLL_CMD:         //会议控制台命令该会议开始轮询广播
	case MCS_MCU_STOPPOLL_CMD:          //会议控制台命令该会议停止轮询广播  
	case MCS_MCU_PAUSEPOLL_CMD:         //会议控制台命令该会议暂停轮询广播
	case MCS_MCU_RESUMEPOLL_CMD:        //会议控制台命令该会议继续轮询广播
	case MCS_MCU_GETPOLLPARAM_REQ:      //会议控制台向MCU查询会议轮询参数
    case MCS_MCU_CHANGEPOLLPARAM_CMD:   //会议控制台命令该会议更新轮询列表
	case MCS_MCU_SPECPOLLPOS_REQ:		//会议控制台指定会议轮询位置
		ProcMcsMcuPollMsg(pcMsg);
		break;
	case MCUVC_POLLING_CHANGE_TIMER:
		ProcPollingChangeTimerMsg(pcMsg);     //轮询定时消息处理
		break;

    //电视墙轮询
    case MCS_MCU_STARTTWPOLL_CMD:           
    case MCS_MCU_STOPTWPOLL_CMD:
    case MCS_MCU_PAUSETWPOLL_CMD:
    case MCS_MCU_RESUMETWPOLL_CMD:
    case MCS_MCU_GETTWPOLLPARAM_REQ:
        ProcMcsMcuTWPollMsg(pcMsg);
        break;
    
    //hdu轮询
    case MCS_MCU_STARTHDUPOLL_CMD:           
    case MCS_MCU_STOPHDUPOLL_CMD:
    case MCS_MCU_PAUSEHDUPOLL_CMD:
    case MCS_MCU_CHANGEHDUPOLLPARAM_CMD:	
    case MCS_MCU_RESUMEHDUPOLL_CMD:
    case MCS_MCU_GETHDUPOLLPARAM_REQ:
        ProcMcsMcuHduPollMsg(pcMsg);
        break;

	//hdu批量轮询
	case MCS_MCU_STARTHDUBATCHPOLL_REQ:
	case MCS_MCU_STOPHDUBATCHPOLL_REQ:
	case MCS_MCU_RESUMEHDUBATCHPOLL_REQ:
	case MCS_MCU_PAUSEHDUBATCHPOLL_REQ:
	case MCS_MCU_GETBATCHPOLLSTATUS_CMD:
		ProcMcsMcuHduBatchPollMsg(pcMsg);
        break;

    // hdu批量轮询定时处理
	case MCUVC_HDUBATCHPOLLI_CHANGE_TIMER:
		ProcHduBatchPollChangeTimerMsg( pcMsg );
		break;
    case MCUVC_WAITOPENDSCHAN_TIMER:            //终端请求H239token后打开双流通道请求超时
        procWaitOpenDSChanTimeout();
        break;
		
	//vmp单通道轮询处理
    case MCS_MCU_STARTVMPPOLL_CMD:           
    case MCS_MCU_STOPVMPPOLL_CMD:
    case MCS_MCU_PAUSEVMPPOLL_CMD:
    case MCS_MCU_RESUMEVMPPOLL_CMD:
    case MCS_MCU_GETVMPPOLLPARAM_REQ:
        ProcMcsMcuVmpPollMsg(pcMsg);
        break;
	case MCUVC_VMPPOLLING_CHANGE_TIMER:
		ProcVmpPollingChangeTimerMsg(pcMsg);     //轮询定时消息处理
		break;


	// hdu单通道轮询定时处理
    //case MCUVC_HDUPOLLING_CHANGE_TIMER:
    //    ProcHduPollingChangeTimerMsg(pcMsg);
    //    break;

    //case MCUVC_TWPOLLING_CHANGE_TIMER:
    //    ProcTWPollingChangeTimerMsg(pcMsg);
    //    break;

    //会议控制---点名
    case MCS_MCU_STARTROLLCALL_REQ:
    case MCS_MCU_STOPROLLCALL_REQ:
    case MCS_MCU_CHANGEROLLCALL_REQ:
        ProcMcsMcuRollCallMsg(pcMsg);
        break;
	//会议控制---取消回传通道终端
	case MCS_MCU_CANCELCASCADESPYMT_REQ:
		ProcCancelSpyMtMsg( pcMsg );
		break;
        
    /*----------------------------终端控制-------------------------------*/
    //双流FastUpdate
    case MCUVC_SECVIDEO_FASTUPDATE_TIMER:
        ProcMcuMtSecVideoFastUpdateTimer(pcMsg);
        break;

	//终端控制---呼叫与挂断终端
	case MCS_MCU_CALLMT_REQ:            //会议控制台请求MCU呼叫终端
	case MCU_MCU_REINVITEMT_REQ:        //上级MCU请求MCU呼叫终端
		ProcMcsMcuCallMtReq(pcMsg);
		break;
	case MT_MCU_CALLMTFAILURE_NOTIFY:
        ProcMtMcuCallFailureNotify(pcMsg);
		break;
	case MCS_MCU_DROPMT_REQ:            //会议控制台挂断终端请求
	case MCU_MCU_DROPMT_REQ:            //上级MCU挂断终端请求
		ProcMcsMcuDropMtReq(pcMsg);
		break;
	case MCS_MCU_SETCALLMTMODE_REQ:     //会议控制台设置MCU呼叫终端方式
		ProcMcsMcuSetCallMtModeReq(pcMsg);
		break;

	//终端控制---查询终端状态与别名
	case MT_MCU_GETMTSTATUS_REQ:        //终端发给MCU的查询会议中某个终端状态请求
	case MCS_MCU_GETMTSTATUS_REQ:       //会控向MCU查询终端状态
		ProcMcsMcuGetMtStatusReq(pcMsg);
		break;

	// 会控获取终端视频源别名信息
	case MCS_MCU_GETMTVIDEOALIAS_REQ:
		ProcMcsMcuGetMtVidAliaseReq(pcMsg);
		break;

 	case MCS_MCU_GETALLMTSTATUS_REQ:    //会控向MCU查询所有终端状态
		ProcMcsMcuGetAllMtStatusReq(pcMsg);
		break;
	case MCS_MCU_GETMTALIAS_REQ:        //会控向MCU查询终端别名
	case MT_MCU_GETMTALIAS_REQ:			//获取终端别名
		ProcMtMcuGetMtAliasReq(pcMsg);
		break;
	case MCS_MCU_GETALLMTALIAS_REQ:		//会控向MCU查询所有终端别名
		ProcMcsMcuGetAllMtAliasReq(pcMsg);
		break;
    case MCS_MCU_GETMTBITRATE_REQ:      //会控查询终端码率
        ProcMcsMcuGetMtBitrateReq(pcMsg);
        break;
    case MCS_MCU_GETMTEXTINFO_REQ:      //会控查询终端的扩展信息:版本号等
        ProcMcsMcuGetMtExtInfoReq(pcMsg);
        break;
    case MCS_MCU_TRANSPARENTMSG_NOTIFY: //[2/23/2012 zhushengze]界面、终端消息透传
        ProcMcsMcuTransparentMsgNotify( pcMsg );
        break;
		
	//终端控制---其它控制
	case MCS_MCU_MTCAMERA_CTRL_CMD:         //会议控制台命令终端摄像机镜头运动	
	case MCS_MCU_MTCAMERA_CTRL_STOP:        //会议控制台命令终端摄像机镜头停止运动
	case MCS_MCU_MTCAMERA_RCENABLE_CMD:     //会议控制台命令终端摄像机遥控使能	
	case MCS_MCU_MTCAMERA_SAVETOPOS_CMD:    //会议控制台命令终端摄像机将当前位置信息存入指定位置	
	case MCS_MCU_MTCAMERA_MOVETOPOS_CMD:    //会议控制台命令终端摄像机调整到指定位置

	case MCS_MCU_SETMTVIDSRC_CMD:           //会控要求MCU设置终端视频源

	case MT_MCU_MTCAMERA_CTRL_CMD:		    //主席命令终端摄像头移动
	case MT_MCU_MTCAMERA_CTRL_STOP:		    //主席命令终端摄像头停止移动
	case MT_MCU_MTCAMERA_RCENABLE_CMD:	    //主席命令终端摄像头遥控器使能
	case MT_MCU_MTCAMERA_MOVETOPOS_CMD:	    //主席命令终端摄像头调整到指定位置
	case MT_MCU_MTCAMERA_SAVETOPOS_CMD:	    //主席命令终端摄像头保存到指定位置

    case MT_MCU_SELECTVIDEOSOURCE_CMD:           //会控要求MCU设置终端视频源
		ProcMcsMcuCamCtrlCmd(pcMsg);
		break;
    case MT_MCU_VIDEOSOURCESWITCHED_CMD:
        ProcMtMcuVideoSourceSwitched(pcMsg);
        break;
	case MCU_MCU_FECC_CMD:
		ProcMMcuMcuCamCtrlCmd(pcMsg);
		break;
    case MCU_MCU_CHANGEMTSECVIDSEND_CMD:        //[5/4/2011 zhushengze]VCS控制发言人发双流
        ProcMcuMcuChangeMtSecVidSendCmd(pcMsg);
        break;
    case MCU_MCU_TRANSPARENTMSG_NOTIFY:         //[2/23/2012 zhushengze]界面、终端消息透传
        ProcMcuMcuTransparentMsgNotify(pcMsg);
        break;

	case MCS_MCU_SETMTBITRATE_CMD:          //会议控制台命令MCU调节终端码率

	case MT_MCU_MTMUTE_CMD:                    //主席终端命令MCU进行终端静音设置
	case MT_MCU_MTDUMB_CMD:                    //主席终端命令MCU进行终端哑音设置		
		ProcMcsMcuMtOperCmd(pcMsg);
		break;

	case MCS_MCU_SETMTVOLUME_CMD:			//会控命令MCU调节终端音量,zgc 12/26/2006
		ProcMcsMcuSetMtVolumeCmd(pcMsg);
		break;

	case MCS_MCU_MTAUDMUTE_REQ:             //会控要求MCU设置终端静音
       
        //终端内置矩阵控制
    case MCS_MCU_MATRIX_GETALLSCHEMES_CMD:
    case MCS_MCU_MATRIX_GETONESCHEME_CMD:
    case MCS_MCU_MATRIX_SAVESCHEME_CMD:
    case MCS_MCU_MATRIX_SETCURSCHEME_CMD:
    case MCS_MCU_MATRIX_GETCURSCHEME_CMD:
	
        //终端外置矩阵
    case MCS_MCU_EXMATRIX_GETINFO_CMD:      //获取终端外置矩阵类型
    case MCS_MCU_EXMATRIX_SETPORT_CMD:      //设置外置矩阵连接端口号
    case MCS_MCU_EXMATRIX_GETPORT_REQ:      //请求获取外置矩阵连接端口
    case MCS_MCU_EXMATRIX_SETPORTNAME_CMD:  //设置外置矩阵连接端口名
    case MCS_MCU_EXMATRIX_GETALLPORTNAME_CMD://请求获取外置矩阵的所有端口名
        
        //终端扩展视频源
    case MCS_MCU_GETVIDEOSOURCEINFO_CMD:
    case MCS_MCU_SETVIDEOSOURCEINFO_CMD:
        
        //终端切换扩展视频源
    case MCS_MCU_SELECTEXVIDEOSRC_CMD:

		ProcMcsMcuMtOperReq(pcMsg);

		break;
	case MCS_MCU_GETIFRAME_CMD:
		ProcMcsMcuGetIFrameCmd(pcMsg);
		break;
		
    //终端控制---来自于终端的请求与应答	

	case MT_MCU_MTCONNECTED_NOTIF:				//终端与MCU成功建立连接
		ProcMtMcuConnectedNotif(pcMsg);	
		break;
	case MT_MCU_MTDISCONNECTED_NOTIF:	        //终端主动挂断MCU
	    ProcMtMcuDisconnectedNotif(pcMsg);	
		break;
	case MT_MCU_MTJOINCONF_NOTIF:               //终端成功入会通知
        ProcMtMcuMtJoinNotif(pcMsg);
		break;
	case MT_MCU_MTTYPE_NOTIF:                   //终端类型通知（320接入时的额外通知）
		ProcMtMcuMtTypeNotif( pcMsg );
		break;
	case MT_MCU_FLOWCONTROL_CMD:				//终端要求改变接收码率 - 码流控制命令
        ProcMtMcuFlowControlCmd(pcMsg, FALSE);
		break;
	case MT_MCU_FLOWCONTROLINDICATION_NOTIF:	//终端要求改变发送码率 - 码流控制指示
        ProcMtMcuFlowControlIndication(pcMsg);
		break;
	case MT_MCU_MTSTATUS_NOTIF:					//终端状态通知
		ProcMtMcuMtStatusNotif(pcMsg);	
		break;
	case MT_MCU_MTVIDEOALIAS_NOTIF:             //终端视频源别名通知
		ProcMtMcuVidAliasNtf(pcMsg);
		break;
	case MT_MCU_INVITEMT_ACK:					//终端接收邀请
		ProcMtMcuInviteMtAck(pcMsg);	
		break;
	case MT_MCU_INVITEMT_NACK:					//终端拒绝邀请
		ProcMtMcuInviteMtNack(pcMsg);	
		break;
	case MT_MCU_GETCHAIRMAN_REQ:
		ProcMtMcuGetChairmanReq(pcMsg);
		break;
	case MT_MCU_MTJOINCONF_REQ:					//终端申请加入
		ProcMtMcuApplyJoinReq(pcMsg);
		break;
	case MT_MCU_APPLYCHAIRMAN_REQ:				//终端申请主席
		ProcMtMcuApplyChairmanReq(pcMsg);
		break;	
	case MT_MCU_APPLYSPEAKER_NOTIF:				//终端申请发言
		ProcMtMcuApplySpeakerNotif(pcMsg);
		break;
	case MT_MCU_SENDMCMSG_CMD:					//短消息请求给主MCU控制台
		ProcMtMcuSendMcMsgReq(pcMsg);
		break;
	case MT_MCU_OPENLOGICCHNNL_ACK:				//打开逻辑通道应答
	case MT_MCU_OPENLOGICCHNNL_NACK:			//打开逻辑通道应答
		ProcMtMcuOpenLogicChnnlRsp(pcMsg);
		break;
	case MT_MCU_OPENLOGICCHNNL_REQ:				//终端打开逻辑通道请求
	case MT_MCU_LOGICCHNNLOPENED_NTF:
		ProcMtMcuOpenLogicChnnlReq(pcMsg);
		break;
	case MT_MCU_CLOSELOGICCHNNL_NOTIF:
		ProcMtMcuCloseLogicChnnlNotify(pcMsg);
		break;
	case MT_MCU_MEDIALOOPON_REQ:
	case MT_MCU_MEDIALOOPOFF_CMD:
		ProcMtMcuMediaLoopOpr(pcMsg);
		break;
	case MT_MCU_JOINEDMTLIST_REQ:				//查询与会终端列表请求
		ProcMtMcuJoinedMtListReq(pcMsg);
		break;
	case MT_MCU_JOINEDMTLISTID_REQ:
		ProcMtMcuJoinedMtListIdReq(pcMsg);
		break;
	case MT_MCU_CAPBILITYSET_NOTIF:				//终端发给MCU的能力集通知
		ProcMtMcuCapSetNotif(pcMsg);
		break;
	case MT_MCU_MTALIAS_NOTIF:
		ProcMtMcuMtAliasNotif(pcMsg);
		break;
    case MCU_MT_ENTERPASSWORD_REQ: //用于级联
		ProcMtMcuEnterPwdReq(pcMsg);
		break;
	case MT_MCU_ENTERPASSWORD_ACK:				//终端回应密码
	case MT_MCU_ENTERPASSWORD_NACK:
        ProcMtMcuEnterPwdRsp(pcMsg);
		break;
	case MT_MCU_GETH239TOKEN_REQ:               //终端给MCU的 获取 H239令牌 权限请求
        ProcMtMcuGetH239TokenReq(pcMsg);
		break;
	case MT_MCU_OWNH239TOKEN_NOTIF:             //终端给MCU的 拥有 H239令牌 权限通知
        ProcMtMcuOwnH239TokenNotify(pcMsg);
		break;
	case MT_MCU_RELEASEH239TOKEN_NOTIF:         //终端给MCU的 释放 H239令牌 权限通知
        ProcMtMcuReleaseH239TokenNotify(pcMsg);
		break;
    case MT_MCU_TRANSPARENTMSG_NOTIFY:         //界面、终端消息透传
        ProcMtMcuTransParentMsgNotify(pcMsg);
        break;

	case POLY_MCU_GETH239TOKEN_ACK:			//获取PolyMCU的H239TOKEN 同意应答
	case POLY_MCU_GETH239TOKEN_NACK:		//获取PolyMCU的H239TOKEN 拒绝应答
	case POLY_MCU_OWNH239TOKEN_NOTIF:		//PolyMCU通知当前的TOKEN的拥有者
	case POLY_MCU_RELEASEH239TOKEN_CMD:		//PolyMCU释放H329TOKEN 命令
		ProcPolyMCUH239Rsp(pcMsg);
		break;
	//终端数据会议控制 --- 来自终端的应答
	case DCSSSN_MCU_ADDMT_ACK:					//DCS终端删除应答
	case DCSSSN_MCU_ADDMT_NACK:
		ProcDcsMcuAddMtRsp(pcMsg);
		break;
	case DCSSSN_MCU_DELMT_ACK:					//DCS终端增加应答
	case DCSSSN_MCU_DELMT_NACK:
		ProcDcsMcuDelMtRsp(pcMsg);
		break;
	case DCSSSN_MCU_MTJOINED_NOTIF:				//DCS终端上线通知
		ProcDcsMcuMtJoinedNtf(pcMsg);
		break;
	case DCSSSN_MCU_MTLEFT_NOTIF:				//DCS终端下线通知
		ProcDcsMcuMtLeftNtf(pcMsg);
		break;
	case MCU_DCSCONNCETED_NOTIF:				//数据终端的状态通知
	case MCU_DCSDISCONNECTED_NOTIF:
		ProcDcsMcuStatusNotif(pcMsg);
		break;

	case MT_MCU_RELEASEMT_REQ:
		ProcMtMcuReleaseMtReq(pcMsg);
		break;

	case MTADP_MCU_GETMTLIST_NOTIF:
		ProcMtAdpMcuMtListRsp(pcMsg);
		break;
	case MTADP_MCU_GETSMCUMTALIAS_NOTIF:
		ProcMtAdpMcuSmcuMtAliasRsp(pcMsg);
		break;
    case MT_MCU_APPLYCANCELSPEAKER_REQ:
	case MCU_MCU_CANCELMESPEAKER_REQ:
	case MCU_MCU_APPLYSPEAKER_REQ:              //下级终端申请发言
		//ProcMtMcuCancelMeSpeakerReq(pcMsg);
		ProcMtMcuApplyCancelSpeakerReq(pcMsg);
        break;
	/*case MCU_MCU_CANCELMESPEAKER_REQ:
        ProcMcuMcuCancelMeSpeakerReq(pcMsg);
        break;*/
    case MCU_MCU_CANCELMESPEAKER_ACK:
    case MCU_MCU_CANCELMESPEAKER_NACK:
        ProcMcuMcuCancelMeSpeakerRsp(pcMsg);
        break;

	case MCU_MCU_APPLYSPEAKER_ACK:
    case MCU_MCU_APPLYSPEAKER_NACK:
        ProcMcuMcuApplySpeakerRsp(pcMsg);
        break;

	//其它暂未处理的终端消息
	case MT_MCU_FREEZEPIC_CMD:                 //终端发给MCU冻结图像命令
		break;
	case MT_MCU_FASTUPDATEPIC_CMD:             //终端发给MCU快速更新图像
		ProcMtMcuFastUpdatePic(pcMsg);
		break;

	case MT_MCU_GETMTSTATUS_ACK:
	case MT_MCU_GETMTSTATUS_NACK:
    case MT_MCU_GETBITRATEINFO_ACK:
    case MT_MCU_GETBITRATEINFO_NACK:
    case MT_MCU_GETBITRATEINFO_NOTIF:
//    case MT_MCU_GETMTVERID_ACK:
    case MT_MCU_GETMTVERID_NACK:
        
	   ProcMtMcuOtherMsg(pcMsg);	
	   break;

//内置矩阵
    case MT_MCU_MATRIX_ALLSCHEMES_NOTIF:    
    case MT_MCU_MATRIX_ONESCHEME_NOTIF:
    case MT_MCU_MATRIX_SAVESCHEME_NOTIF:
    case MT_MCU_MATRIX_SETCURSCHEME_NOTIF:
    case MT_MCU_MATRIX_CURSCHEME_NOTIF:

 //外置矩阵    
    case MT_MCU_EXMATRIXINFO_NOTIFY:         
    case MT_MCU_EXMATRIX_GETPORT_ACK:        
    case MT_MCU_EXMATRIX_GETPORT_NACK:       
    case MT_MCU_EXMATRIX_GETPORT_NOTIF:
    case MT_MCU_EXMATRIX_PORTNAME_NOTIF:        
    case MT_MCU_EXMATRIX_ALLPORTNAME_NOTIF:    
        
//扩展视频源
    case MT_MCU_ALLVIDEOSOURCEINFO_NOTIF:
    case MT_MCU_VIDEOSOURCEINFO_NOTIF:

		ProcMtMcuMatrixMsg(pcMsg);
		break;

        //终端带宽指示
    case MT_MCU_BANDWIDTH_NOTIF:
        ProcMtMcuBandwidthNotif(pcMsg);
        break;

	//外设控制---录放像控制
    case MCU_RECCONNECTED_NOTIF:
        ProcMcuRecConnectedNotif(pcMsg);
        break;
    case MCU_RECDISCONNECTED_NOTIF:	//录像机断链通知
		ProcMcuRecDisconnectedNotif(pcMsg);
		break;
	case MCS_MCU_STARTREC_REQ:              //会控向MCU请求开始录像
		ProcMcsMcuStartRecReq(pcMsg);
		break;
	case MCS_MCU_PAUSEREC_REQ:              //会控向MCU暂停录像
		ProcMcsMcuPauseRecReq(pcMsg);
		break;
	case MCS_MCU_RESUMEREC_REQ:             //会控向MCU恢复录像
		ProcMcsMcuResumeRecReq(pcMsg);
		break;
	case MCS_MCU_STOPREC_REQ:               //会控向MCU停止录像
		ProcMcsMcuStopRecReq(pcMsg);
		break;
	case MCS_MCU_CHANGERECMODE_REQ:
		ProcMcsMcuChangeRecModeReq(pcMsg);
		break;
	case MCS_MCU_LISTALLRECORD_REQ:			//请求vrs文件列表
		ProcMcsMcuListAllRecordReq(pcMsg);
		break;
	case MCS_MCU_CLOSELISTRECORD_CMD:		//会控关闭文件列表（用于挂断vrs新录播实体）
		ProcMcsMcuCloseListRecordCmd(pcMsg);
		break;
	case MCS_MCU_STARTPLAY_REQ:             //会控开始放像请求
		ProcMcsMcuStartPlayReq(pcMsg);
		break;
	case MCS_MCU_PAUSEPLAY_REQ:             //会控暂停放像请求
		ProcMcsMcuPausePlayReq(pcMsg);
		break;
	case MCS_MCU_RESUMEPLAY_REQ:            //会控恢复放像请求
		ProcMcsMcuResumePlayReq(pcMsg);
		break;
	case MCS_MCU_STOPPLAY_REQ:              //会控停止放像请求
		ProcMcsMcuStopPlayReq(pcMsg);
		break;
    case MCS_MCU_GETRECPROG_CMD:            //会控查询录相进度
    case MCS_MCU_GETPLAYPROG_CMD:           //会控查询放相进度
        ProcMcsMcuGetRecPlayProgCmd(pcMsg);
        break;
	case MCS_MCU_FFPLAY_REQ:                //会控快进放像请求
	case MCS_MCU_FBPLAY_REQ:                //会控快退放像请求
	case MCS_MCU_SEEK_REQ:                  //会控调整放像进度请求
		ProcMcsMcuSeekReq(pcMsg);
		break;
	case MCS_MCU_GETRECSTATUS_CMD:			//查询录像机状态
		ProcMcsMcuGetRecChnnlStatusCmd(pcMsg);
		break;
	case MCUVC_RECPLAY_WAITMPACK_TIMER:		//等待交换建立定时器超时,zgc, 2008-03-26
		ProcRecPlayWaitMpAckTimer();
		break;
	case REC_MCU_PLAYCHNSTATUS_NOTIF:		//录像机放像信道状态通知
		ProcRecMcuPlayChnnlStatusNotif(pcMsg);
		break;
	case REC_MCU_RECORDCHNSTATUS_NOTIF:		//录像机录像信道状态通知
		ProcRecMcuRecChnnlStatusNotif(pcMsg);
		break;
	case REC_MCU_RECORDPROG_NOTIF:			//当前录像进度通知
	case REC_MCU_PLAYPROG_NOTIF:			//当前放像进度通知
		ProcRecMcuProgNotif(pcMsg);
		break;    
	case REC_MCU_NEEDIFRAME_CMD:            //录像机请求关键帧
        ProcRecMcuNeedIFrameCmd(pcMsg);     
		break;
	case REC_MCU_LISTALLRECORD_ACK:			//录像机列应答(完毕)消息
	case REC_MCU_LISTALLRECORD_NACK:		//录像机拒绝录像列表请求
		// 不做处理
		break;
	case REC_MCU_FILEGROUPLIST_NOTIF:		//vrs新录播上报分组列表
	case REC_MCU_LISTALLRECORD_NOTIF:		//vrs新录播上报文件列表
		ProcVrsMcuListAllRecNotif(pcMsg);
		break;

     //外设控制---码流适配器控制
    case BAS_MCU_STARTADAPT_ACK:			//启动适配应答
	case BAS_MCU_STARTADAPT_NACK:			//停止适配应答
// #ifdef _8KE_
// 		Proc8KEBasMcuRsp(pcMsg);			//[03/01/2010] zjl add 8000e bas 适配响应处理
// #else
// 		ProcBasMcuRsp(pcMsg);
// #endif		
//		break;

    case HDBAS_MCU_STARTADAPT_ACK:      //启动高清适配应答
    case HDBAS_MCU_STARTADAPT_NACK:     //启动高清适配拒绝
	case BAS_MCU_CHANGEAUDPARAM_ACK:    //开启改变参数应答
	case BAS_MCU_CHANGEAUDPARAM_NACK:    //开启改变参数拒绝
		ProcBasMcuRsp(pcMsg);
//      ProcHdBasMcuRsp(pcMsg);
        break;

// 	case MCU_BASCONNECTED_NOTIF:			//码率适配登记通知
// 		ProcMcuBasConnectedNotif(pcMsg);
// 		break;
	case MCU_BASDISCONNECTED_NOTIF:			//码率适配断链通知
		ProcMcuBasDisconnectedNotif(pcMsg);
		break;
	
	case VMP_MCU_VMPSTATUS_NOTIF:
    case HDBAS_MCU_BASSTATUS_NOTIF:
        break;
	case BAS_MCU_BASSTATUS_NOTIF:		//[2011/08/27/zhangli]
		ProcBasStatusNotif(pcMsg);
		break;

    case BAS_MCU_CHNNLSTATUS_NOTIF:
		ProcBasChnnlStatusNotif(pcMsg);
		break;    

    case HDBAS_MCU_CHNNLSTATUS_NOTIF:
        ProcHdBasChnnlStatusNotif( pcMsg );
        break;
	case AUDBAS_MCU_CHNNLSTATUS_NOTIF:
		ProcAudBasChnnlStatusNotif(pcMsg);
		break;
    case HDU_MCU_CHNNLSTATUS_NOTIF:
		ProcHduMcuChnnlStatusNotif();
		break;

// 	case MCUVC_WAITBASRRSP_TIMER:				//等待适配器启动应答超时
// 	case MCUVC_WAITBASRRSP_TIMER+1:			//等待适配器启动应答超时
// 	case MCUVC_WAITBASRRSP_TIMER+2:			//等待适配器启动应答超时
//     case MCUVC_WAITBASRRSP_TIMER+3:
//     case MCUVC_WAITBASRRSP_TIMER+4:
// 		ProcBasStartupTimeout(pcMsg);
// 		break;
    case BAS_MCU_NEEDIFRAME_CMD:
        ProcBasMcuCommand(pcMsg);
        break;

	case HDU_MCU_NEEDIFRAME_CMD:
		ProcHduMcuNeedIFrameCmd(pcMsg);
		break;
		
    case MCUVC_SENDFLOWCONTROL_TIMER:
        ProcSendFlowctrlToDSMtTimeout();
		break;
		
	case MCU_SMCUOPENDVIDEOCHNNL_TIMER:
		ProcSmcuOpenDVideoChnnlTimer(pcMsg);
		break;

	case MCU_PRSCONNECTED_NOTIF:		//发给MCU内部会议实例通知PRS建链成功
		ProcPrsConnectedNotif(pcMsg);
		break;
	case MCU_PRSDISCONNECTED_NOTIF:		//发给MCU内部会议实例通知PRS断链
		ProcPrsDisconnectedNotif(pcMsg);
		break;
	case PRS_MCU_SETSRC_ACK:			//PRS给MCU保存信息源确认
	case PRS_MCU_SETSRC_NACK:			//PRS给MCU保存信息源拒绝
//	case PRS_MCU_ADDRESENDCH_ACK:		//PRS给MCU停止工作确认
//	case PRS_MCU_ADDRESENDCH_NACK:		//PRS给MCU停止工作拒绝
//	case PRS_MCU_REMOVERESENDCH_ACK:	//PRS给MCU改变复合参数确认
//	case PRS_MCU_REMOVERESENDCH_NACK:	//PRS给MCU改变复合参数拒绝
	case PRS_MCU_REMOVEALL_ACK:			//PRS给MCU改变复合参数确认
	case PRS_MCU_REMOVEALL_NACK:		//PRS给MCU改变复合参数拒绝
		ProcPrsMcuRsp(pcMsg);
		break;

	case MCS_MCU_STOPSWITCHMC_REQ:
	case MCU_MCSDISCONNECTED_NOTIF:
		ProcMcStopSwitch(pcMsg);
		break;

	case MCS_MCU_STOP_SWITCH_TW_REQ:
		ProcMcsMcuStopSwitchTWReq(pcMsg);
		break;

    case MCU_TVWALLCONNECTED_NOTIF:
        ProcTvwallConnectedNotif(pcMsg);
        break;
	case MCU_TVWALLDISCONNECTED_NOTIF:
		ProcTvwallDisconnectedNotif(pcMsg);
		break;	
		
    //4.6 jlb
//     case HDU_MCU_STATUS_NOTIF:
// 		ProcHduMcuStatusNotif( pcMsg );  
// 		break;

	case MCU_HDUCONNECTED_NOTIF:                    
		ProcHduConnectedNotif(pcMsg);
		break;

	case MCU_HDUDISCONNECTED_NOTIF:
		ProcHduDisconnectedNotif(pcMsg);
		break;


    //来自于终端与外设的应答一般处理	
	case REC_MCU_PAUSEREC_ACK:			//暂停录像应答
	case REC_MCU_RESUMEREC_ACK:			//恢复录像应答	
	case REC_MCU_CHANGERECMODE_ACK:		//改变录像模式
	case REC_MCU_PAUSEPLAY_ACK:			//暂停放像应答
	case REC_MCU_RESUMEPLAY_ACK:		//恢复放像应答
	case REC_MCU_STOPPLAY_ACK:			//停止放像应答
	case REC_MCU_FFPLAY_ACK:			//放像快进应答
	case REC_MCU_FBPLAY_ACK:			//放像快退应答
	case REC_MCU_SEEK_ACK:				//放像进度调整应答
		ProcCommonOperAck(pcMsg);
		break;

    case REC_MCU_STARTREC_ACK:			//开始录像应答
    case REC_MCU_STOPREC_ACK:			//停止录像应答
	case REC_MCU_STARTPLAY_ACK:			//开始放像应答
        ProcRecMcuResp(pcMsg);
        break;

	//来自于终端与外设的拒绝应答一般处理	
    case REC_MCU_STARTREC_NACK:			//开始录像应答
	case REC_MCU_PAUSEREC_NACK:			//暂停录像应答
	case REC_MCU_RESUMEREC_NACK:		//恢复录像应答
	case REC_MCU_STOPREC_NACK:			//停止录像应答
	case REC_MCU_CHANGERECMODE_NACK:	//改变录像模式
	case REC_MCU_STARTPLAY_NACK:		//开始放像应答
	case REC_MCU_PAUSEPLAY_NACK:		//暂停放像应答
	case REC_MCU_RESUMEPLAY_NACK:		//恢复放像应答
	case REC_MCU_STOPPLAY_NACK:			//停止放像应答
	case REC_MCU_FFPLAY_NACK:			//放像快进应答
	case REC_MCU_FBPLAY_NACK:			//放像快退应答
	case REC_MCU_SEEK_NACK:				//放像进度调整应答
		ProcCommonOperNack(pcMsg);
		break;
	
	//立案系统消息
	case MT_MCU_STARTMTSELME_REQ:
	case MT_MCU_STOPMTSELME_CMD:
	case MT_MCU_STARTBROADCASTMT_REQ:
	case MT_MCU_STOPBROADCASTMT_CMD:
	case MT_MCU_GETMTSELSTUTS_REQ:
		ProcBuildCaseSpecialMessage(pcMsg);
        break;

	//Mp 消息
	case MP_MCU_REG_REQ:
	case MP_MCU_ADDSWITCH_ACK:
	case MP_MCU_ADDSWITCH_NACK:
	case MP_MCU_REMOVESWITCH_ACK:
	case MP_MCU_REMOVESWITCH_NACK:
	case MP_MCU_GETSWITCHSTATUS_ACK:
	case MP_MCU_GETSWITCHSTATUS_NACK:
	case MP_MCU_ADDMULTITOONESWITCH_ACK:
	case MP_MCU_ADDMULTITOONESWITCH_NACK:
	case MP_MCU_REMOVEMULTITOONESWITCH_ACK:
	case MP_MCU_REMOVEMULTITOONESWITCH_NACK:
	case MP_MCU_STOPMULTITOONESWITCH_ACK:
	case MP_MCU_STOPMULTITOONESWITCH_NACK:
	case MP_MCU_ADDRECVONLYSWITCH_ACK:
	case MP_MCU_ADDRECVONLYSWITCH_NACK:
	case MP_MCU_REMOVERECVONLYSWITCH_ACK:
	case MP_MCU_REMOVERECVONLYSWITCH_NACK:
	case MP_MCU_SETRECVSWITCHSSRC_ACK:
	case MP_MCU_SETRECVSWITCHSSRC_NACK:
        // guzh [3/29/2007]
    case MP_MCU_ADDBRDSRCSWITCH_ACK:
    case MP_MCU_ADDBRDDSTSWITCH_ACK:
    case MP_MCU_ADDBRDSRCSWITCH_NACK:
    case MP_MCU_ADDBRDDSTSWITCH_NACK:
    case MP_MCU_REMOVEBRDSRCSWITCH_ACK:
    case MP_MCU_REMOVEBRDSRCSWITCH_NACK:
    case MP_MCU_BRDSRCSWITCHCHANGE_NTF:    // 广播源被实际移除通知         
		ProcMpMessage(pcMsg);
		break;

	//处理Mp断链
	case MCU_MP_DISCONNECTED_NOTIFY:
		ProcMpDissconnected(pcMsg);
		break;

	//处理MtAdp断链
	case MCU_MTADP_DISCONNECTED_NOTIFY:
		ProcMtAdpDissconnected(pcMsg);
		break;

	case MT_MCU_MSD_NOTIF:
		ProcMtMcuMsdRsp(pcMsg);
		break;
	case MCUVC_SCHEDULED_CHECK_TIMER:			//预约会议定时检查
		ProcTimerScheduledCheck(pcMsg);
		break;
	case MCUVC_ONGOING_CHECK_TIMER:			//进行中会议定时检查
		ProcTimerOngoingCheck(pcMsg);	
		break;
	case MCUVC_INVITE_UNJOINEDMT_TIMER:		//定时邀请未与会终端
		ProcTimerInviteUnjoinedMt(pcMsg);
		break;
	case MCUVC_REFRESH_MCS_TIMER:
		ProcTimerRefreshMcs();
		break;
	case MCUVC_MCUSRC_CHECK_TIMER:
		ProcTimerMcuSrcCheck(pcMsg);
		break;
	case MCUVC_RECREATE_DATACONF_TIMER:
		ProcTimerRecreateDataConf();
		break;
//     case MCUVC_WAIT_CASCADE_CHANNEL_TIMER:
//         ProcTimerReopenCascadeChannel();
//        break;
	case MT_MCU_REGISTERGK_ACK:         //在GK上注册成功
		ProcConfRegGkAck(pcMsg);
		break;
	case MT_MCU_REGISTERGK_NACK:		//在GK上注册失败
		ProcConfRegGkNack(pcMsg);
		break;
    
    case MT_MCU_CONF_STARTCHARGE_ACK:
    case MT_MCU_CONF_STARTCHARGE_NACK:
	case MT_MCU_CONF_CHARGEEXP_NOTIF:
    case MT_MCU_CONF_STOPCHARGE_ACK:
    case MT_MCU_CHARGE_REGGK_NOTIF:
        ProcGKChargeRsp(pcMsg);
        break;

    case MCUVC_CHANGE_VMPCHAN_SPEAKER_TIMER:
    case MCUVC_CHANGE_VMPCHAN_CHAIRMAN_TIMER:
    case MCUVC_CHANGE_VMPPARAM_TIMER:
        ProcTimerChangeVmpParam(pcMsg);
        break;

	case MT_MCU_UNREGISTERGK_ACK:       //在GK上注销成功
	case MT_MCU_UNREGISTERGK_NACK:      //在GK上注销失败
	case VMP_MCU_SETCHANNELBITRATE_ACK: //改变码率应答
	case VMP_MCU_SETCHANNELBITRATE_NACK://改变码率拒绝
	case BAS_MCU_STOPADAPT_ACK:			//启动适配拒绝
	case BAS_MCU_STOPADAPT_NACK:		//停止适配拒绝
    case HDBAS_MCU_STOPADAPT_ACK:       //停止高清适配应答
    case HDBAS_MCU_STOPADAPT_NACK:      //停止高清适配拒绝
		break;
	case MCU_MCU_REINVITEMT_ACK:
	case MCU_MCU_REINVITEMT_NACK:
	case MCU_MCU_SETIN_ACK:
	case MCU_MCU_SETIN_NACK:
	case MCU_MCU_DROPMT_ACK:
	case MCU_MCU_DROPMT_NACK:
	case MCU_MCU_DELMT_ACK:
	case MCU_MCU_DELMT_NACK:
	case MCU_MCU_INVITEMT_ACK:
    case MCU_MCU_INVITEMT_NACK:
        ProcMcuMcuMtOperateRsp(pcMsg);
		break;

        //N+1注册成功或会议回滚，需要同步会议信息
    case NPLUS_VC_DATAUPDATE_NOTIF:
        ProcNPlusConfDataUpdate(pcMsg);
        break;
	case REC_MCU_RECSTATUS_NOTIF:
		break;
	case EV_MCU_OPENSECVID_TIMER:
		ProcPolycomSecVidChnnl(pcMsg);
		break;
		
	case TVWALL_MCU_STATUS_NOTIF:
		break;

	case MCS_MCU_CHGSPEAKMODE_REQ:
	case MCU_MCU_SPEAKERMODE_NOTIFY:
		ProcMcsMcuChangeSpeakModeReq(pcMsg);
		break;
		
	/*case MCU_MCU_SPEAKERMODE_NOTIFY:
		ProcMcuMcuSpeakModeNtf( pcMsg );
		break;*/

/*-------------------------------------------------------------------------------------*/
	//VCS通过模板创会
	case MCU_SCHEDULE_VCSCONF_START:
	case VCS_MCU_VCMT_REQ:
	case VCS_MCU_VCMODE_REQ:
	case VCS_MCU_CHGVCMODE_REQ:
	case VCS_MCU_MUTE_REQ:
	case VCS_MCU_GROUPCALLMT_REQ:
	case VCS_MCU_GROUPDROPMT_REQ:
	case VCS_MCU_STARTCHAIRMANPOLL_REQ:
	case VCS_MCU_STOPCHAIRMANPOLL_REQ:
	case VCS_MCU_ADDMT_REQ:
	case VCS_MCU_DELMT_REQ:
	case VCS_MCU_SETMTINTVWALL_REQ:
	//zjj20091102
	case VCS_MCU_ADDPLANNAME_REQ:			//VCS请求添加预案
	case VCS_MCU_DELPLANNAME_REQ:			//VCS请求删除预案
	case VCS_MCU_MODIFYPLANNAME_REQ:		//VCS请求修改预案名称
	//case VCS_MCU_SAVEPLANDATA_REQ:			//VCS请求保存某个预案
	case VCS_MCU_GETALLPLANDATA_REQ:		//VCS请求获得所有预案数据信息
	case VCS_MCU_CHGTVWALLMODE_REQ:			//vcs请求mcu改变电视墙模式
	//case VCS_MCU_REVIEWMODEMTINTVWALL_REQ:	//VCS通知mcu终端进入电视墙通道(只限于在预览模式下)
	case VCS_MCU_CLEARONETVWALLCHANNEL_CMD:	//VCS通知mcu清除某个电视墙通道信息(只限于手动模式)
	case VCS_MCU_CLEARALLTVWALLCHANNEL_CMD:	//VCS通知mcu清除全部电视墙通道信息(只限于手动模式)
	case VCS_MCU_TVWALLSTARMIXING_CMD:		//vcs通知mcu设置电视墙通道终端混音状态
	case VCS_MCU_CHGDUALSTATUS_REQ:
	
	case VCS_MCU_START_MONITOR_UNION_REQ:
	case VCS_MCU_STOP_MONITOR_UNION_REQ:
	case VCS_MCU_STOP_ALL_MONITORUNION_CMD:
	case VCS_MCU_MTJOINCONF_ACK:			//终端入会申请同意
	case VCS_MCU_MTJOINCONF_NACK:			//终端入会申请拒绝	 
    case VCS_MCU_GROUPMODELOCK_CMD:         //[5/19/2011 zhushengze]锁定状态控制
		ProcVcsMcuMsg(pcMsg);
		break;
	case MCUVC_VCMTOVERTIMER_TIMER:
		ProcVCMTOverTime();
		break;
	case MCUVC_VCS_CHAIRPOLL_TIMER:
		ProcChairPollTimer();
		break;
    case VCS_MCU_RELEASEMT_ACK:
	case VCS_MCU_RELEASEMT_NACK:
		ProcVcsMcuRlsMtMsg(pcMsg);
		break;
	case MCUVC_MMCUGETCTRL_CMD:
		ProcMMCUGetConfCtrlMsg();
		break;
	case MCU_MT_DBG_FLOWCTRLCMD:
		{
			CServMsg cServMsg( pcMsg->content, pcMsg->length );
			u8 byMtId = *cServMsg.GetMsgBody();
			u16 wBand = *(u16 *)(cServMsg.GetMsgBody() + sizeof(u8));
			u16 wEvent = MCU_MT_FLOWCONTROL_CMD;
			TLogicalChannel tLogicalChannel;
			tLogicalChannel.SetFlowControl( wBand );
			CServMsg cMsg;
			cMsg.SetConfIdx(m_byConfIdx);
	 		cMsg.SetMsgBody( (u8*)&tLogicalChannel, sizeof( tLogicalChannel ) );
			cMsg.SetMcuId( LOCAL_MCUID );
			TMt tDstMt = m_ptMtTable->GetMt(byMtId);
		    g_cMtAdpSsnApp.SendMsgToMtAdpSsn( tDstMt, wEvent, cMsg );
			break;
		}
	case PRS_MCU_PRSSTATUS_NOTIF:		// [9/16/2011 liuxu] 注意, 这条消息没有被处理
		break;

	case MCUVC_SENDALLMT_ALLMCS_TIMER:	// [11/14/2011 liuxu] 定时发送mtlist
		{
			CServMsg cMsg;
			SendAllMtInfoToAllMcs(MCU_MCS_CONFALLMTINFO_NOTIF, cMsg, TRUE);
		}
		break;
		
	case MCUVC_SEND_SMCUMTSTATUS_TIMER:
		{
			OnBufSendMtStatusToMMcu();
		}
		break;
	case HDU_MCU_START_PLAY_ACK:        //hdu播放应答
	case HDU_MCU_START_PLAY_NACK:       //hdu播放拒绝
	case HDU_MCU_STOP_PLAY_ACK:         //停止播放应答
    case HDU_MCU_STOP_PLAY_NACK:        //停止播放应答
	case HDU_MCU_CHGHDUVMPMODE_ACK:		//切换模式应答
	case HDU_MCU_CHGHDUVMPMODE_NACK:	//切换模式应答
		ProcHduMcuRsp(pcMsg);
		break;
    case AGT_SVC_E1BANDWIDTH_NOTIF:
        ProcAgtSvgE1BandWidthNotif( pcMsg );
        break;
    case MCS_MCU_CHANGEMTSECVIDSEND_CMD://[5/4/2011 zhushengze]VCS控制发言人发双流
        ProcMcsMcuChangeMtSecVidSendCmd( pcMsg );
        break;
	case EV_CHANGE_ETH_NOTIF:
		// 8000H-M特殊处理，仅在网卡切换时进行，并且消息内容为NULL [pengguofeng 6/5/2013]
		LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "Handle only for 8khm \n");
		Proc8khmMultiSwitch();
		break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "Vc%d: unexpected msg %u(%s) passed!\n", GetInsID(), pcMsg->event, ::OspEventDesc( pcMsg->event ));
		break;
	}

	//主备数据倒换时，[MSMag <->McuVc]模块互锁，解锁 2005-12-15
	g_cMSSsnApp.LeaveMSSynLock(AID_MCU_VC);
	return;
}

/*====================================================================
    函数名      :DaemonInstanceEntry
    功能        :Daemon实例处理函数入口
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg,  传入的消息
				  CApp* pApp ,传入应用指针
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/05/26    1.0         LI Yi         创建
====================================================================*/

#define DAEMVC_EV_LOG(level)	MCU_EV_LOG(level, MID_MCU_MCS, "DaemVc")

void CMcuVcInst::DaemonInstanceEntry( CMessage* const pcMsg, CApp* pcApp )
{
	// [11/15/2011 liuxu] 新Guard检测
	g_cMcuVcGuardCheck.ClientSet();

	if( NULL == pcMsg )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[CMcuVcInst] The received msg's pointer in the msg DaemonEntry is NULL!");

		return;
	}
	
	switch(pcMsg->event)
	{
		// 过滤的消息, 这些消息会在消息处理函数里输出
	case MP_MCU_FLUXSTATUS_NOTIFY:
		break;
		
		// 这些消息优先级比较低
	case REC_MCU_RECORDPROG_NOTIF:
	case REC_MCU_PLAYPROG_NOTIF:
	case REC_MCU_RECSTATUS_NOTIF:
		DAEMVC_EV_LOG(LOG_LVL_DETAIL);
		break;
	default:
		DAEMVC_EV_LOG(LOG_LVL_KEYSTATUS);
	}

	//主备数据倒换时，[MSMag <->McuVc]模块互锁，锁定 2005-12-15
	g_cMSSsnApp.EnterMSSynLock(AID_MCU_VC);

	if (pcMsg->event >= MCUVC_PACKINFO_TIMER &&
		pcMsg->event < (MCUVC_PACKINFO_TIMER + MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE))
	{
		DaemonProcPackInfoTimer(pcMsg);
		g_cMSSsnApp.LeaveMSSynLock(AID_MCU_VC);

		return;
	}

	CServMsg cServMsg( pcMsg->content, pcMsg->length );

	switch ( pcMsg->event )
	{
	case OSP_POWERON:
		DaemonProcPowerOn();
		break;

    case MCS_MCU_CREATECONF_REQ:
        DaemonProcMcsMcuCreateConfReq(pcMsg);
        break;

	case MCUVC_WAIT_MPREG_TIMER:              // 定时等待Mp注册
		ProcTimerWaitMpRegCheck(pcMsg);
		break;

		//zhouyiliang主备，主板恢复会议的时候给备板同步数据
	case MCUVC_RECOVERCONF_SYN_TIMER:
		ProcMsSynRecoverConfTimer(pcMsg);
		break;

	case MCU_MSSTATE_EXCHANGE_NTF:
		DaemonProcMcuMSStateNtf(pcMsg);       //备用板升级为主用板时 通知[McuVc]模块主备用状态变更
		break;
	case MT_MCU_CREATECONF_REQ:
	case MT_MCU_LOWERCALLEDIN_NTF:
		DaemonProcMtMcuCreateConfReq(pcMsg);
		break;
	case MCS_MCU_LISTALLCONF_REQ:             //列出该MCU上所有会议信息
		DaemonProcMcsMcuListAllConfReq( pcMsg );
		break;   
	case MCS_MCU_GETMCUSTATUS_CMD:
	case MCS_MCU_GETMCUSTATUS_REQ:	          //查询MCU状态
		DaemonProcMcsMcuGetMcuStatusReq(pcMsg);
		break;
	case MCU_APPTASKTEST_REQ:			      //GUARD Probe Message
		DaemonProcAppTaskRequest(pcMsg);
		break;
	case MCU_EQPCONNECTED_NOTIF:	          //外设登记成功
		DaemonProcMcuEqpConnectedNotif(pcMsg);
		break;
	case MCU_EQPDISCONNECTED_NOTIF:           //外设断链
		DaemonProcMcuEqpDisconnectedNotif(pcMsg);
		break;
	case MCU_DCSCONNCETED_NOTIF:			  //DCS登记成功
		DaemonProcMcuDcsConnectedNtf(pcMsg);  
		break;
	case MCU_DCSDISCONNECTED_NOTIF:			  //DCS断链
		DaemonProcMcuDcsDisconnectedNtf(pcMsg);
		break;
	case MCU_MCSCONNECTED_NOTIF:		      //会控登记成功
		DaemonProcMcuMcsConnectedNotif(pcMsg);
		break;
	case MCU_MCSDISCONNECTED_NOTIF:           //会控断链
		DaemonProcMcuMcsDisconnectedNotif(pcMsg);
		break;
    case MCS_MCU_CREATECONF_BYTEMPLATE_REQ: //会议控制台在MCU上按会议模板创建一个会议(会议模板变成即时会议)
    case MCS_MCU_CREATESCHCONF_BYTEMPLATE_REQ:  //根据模板创建预约会议
	case VCS_MCU_CREATECONF_BYTEMPLATE_REQ:
        DaemonProcMcsMcuCreateConfByTemplateReq(pcMsg);        
        break;       
    case MCS_MCU_CREATETEMPLATE_REQ:            //增加模板
    case MCS_MCU_MODIFYTEMPLATE_REQ:            //修改模板
    case MCS_MCU_DELTEMPLATE_REQ:               //删除模板
        DaemonProcMcsMcuTemplateOpr(pcMsg);
        break;

	case MCS_MCU_SAVECONFTOTEMPLATE_REQ:	//会议控制台请求将当前会议保存为会议模板(预留), zgc, 2007/04/20
		DaemonProcMcsMcuSaveConfToTemplateReq(pcMsg);
		break;

	case VCS_MCU_SENDPACKINFO_REQ:
		DaemonProcVcsMcuSavePackinfoReq(pcMsg);
		break;

    case MT_MCU_REGISTERGK_ACK:				//在GK上注册成功
    case MT_MCU_REGISTERGK_NACK:			//在GK上注册失败
    case MT_MCU_UNREGISTERGK_ACK:			//在GK上注销成功
    case MT_MCU_UNREGISTERGK_NACK:			//在GK上注销失败
        DaemonProcGkRegRsp(pcMsg);
        break;

    case MCU_CREATECONF_NPLUS:
        DaemonProcCreateConfNPlus(pcMsg);
        break;

    case MT_MCU_CONF_STOPCHARGE_ACK:
    case MT_MCU_CONF_STOPCHARGE_NACK:
    case MT_MCU_CONF_STARTCHARGE_ACK:
    case MT_MCU_CONF_STARTCHARGE_NACK:
	case MT_MCU_CONF_CHARGEEXP_NOTIF:
    case MT_MCU_CHARGE_REGGK_NOTIF:
        DaemonProcGKChargeRsp(pcMsg);
        break;

    case MCU_MCUREREGISTERGK_NOITF:          //在GK上重新注册mcu别名
        DaemonProcMcuReRegisterGKNtf();
        break;
	
	case VMP_MCU_VMPSTATUS_NOTIF:             //画面合成器状态通知
	case BAS_MCU_BASSTATUS_NOTIF:		      //适配器状态通知
	case MIXER_MCU_MIXERSTATUS_NOTIF:	      //混音器状态通知消息
		{
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
			DaemonProc8KEPeriEqpMcuStatusNotif(pcMsg);
#else
			DaemonProcPeriEqpMcuStatusNotif(pcMsg);
#endif
			break;
		}

    case HDBAS_MCU_BASSTATUS_NOTIF:           //高清适配器状态通知
	case REC_MCU_RECSTATUS_NOTIF:		      //录像机状态通知
    case VMPTW_MCU_VMPTWSTATUS_NOTIF:         //复合电视墙状态通知
	case TVWALL_MCU_STATUS_NOTIF:             //电视墙状态通知
	case PRS_MCU_PRSSTATUS_NOTIF:			  //VMP给MCU的状态上报
	case PRS_MCU_SETSRC_NOTIF:			      //PRS给MCU的保存信息源结果
//	case PRS_MCU_ADDRESENDCH_NOTIF:		      //PRS给MCU的停止结果
//	case PRS_MCU_REMOVERESENDCH_NOTIF:	      //PRS给MCU的状态改变结果
	case PRS_MCU_REMOVEALL_NOTIF:		      //PRS给MCU的状态改变结果
    case HDU_MCU_STATUS_NOTIF:                //高清电视墙状态通知
		DaemonProcPeriEqpMcuStatusNotif(pcMsg);
		break;

	//case MIXER_MCU_GRPSTATUS_NOTIF:			  //混音组状态通知
	//	break;

	case BAS_MCU_CHNNLSTATUS_NOTIF://适配器通道状态通知
		DaemonProBasChnnlStatusNotif( pcMsg);
		break;

    case HDBAS_MCU_CHNNLSTATUS_NOTIF://高清适配器通道状态通知
        DaemonProcHDBasChnnlStatusNotif( pcMsg );
		break;

	case AUDBAS_MCU_CHNNLSTATUS_NOTIF:
		DaemonProcAudBasChnnlStatusNotif(pcMsg);
		break;

    case HDU_MCU_CHNNLSTATUS_NOTIF:
        DaemonProcHduMcuChnnlStatusNotif( pcMsg );
		break;

	case MCS_MCU_STOPSWITCHMC_REQ:		      //会议控制台停止播放请求
		DaemonProcMcsMcuStopSwitchMcReq(pcMsg);
		break;
	case MCS_MCU_STOP_SWITCH_TW_REQ:	      //停止向电视墙交换请求
		DaemonProcMcsMcuStopSwitchTWReq(pcMsg);
		break;
		
	case MCS_MCU_LISTALLRECORD_REQ:         //会控列表请求
		ProcMcsMcuListAllRecordReq(pcMsg);
		break;
	case REC_MCU_LISTALLRECORD_NOTIF:		//列出录像机中所有记录应答
		ProcRecMcuListAllRecNotif(pcMsg);
		break;
	case MCS_MCU_DELETERECORD_REQ:          //会控请求删除文件
		ProcMcsMcuDeleteRecordReq(pcMsg);
		break;
    case MCS_MCU_RENAMERECORD_REQ:          //会控请求更改文件名
        ProcMcsMcuRenameRecordReq(pcMsg);
        break;
	case MCS_MCU_PUBLISHREC_REQ:            //发布录像请求
		ProcMcsMcuPublishRecReq(pcMsg);
		break;
	case MCS_MCU_CANCELPUBLISHREC_REQ:		//撤销发布录像请求
		ProcMcsMcuCancelPublishRecReq(pcMsg);
		break;

	case REC_MCU_RECORDCHNSTATUS_NOTIF:	      //录像机录像信道状态通知
	case REC_MCU_PLAYCHNSTATUS_NOTIF:	      //录像机放像信道状态通知
		DaemonProcRecMcuChnnlStatusNotif(pcMsg);
		break;

	case REC_MCU_RECORDPROG_NOTIF:		      //当前录像进度通知
	case REC_MCU_PLAYPROG_NOTIF:		      //当前放像进度通知
		DaemonProcRecMcuProgNotif(pcMsg);
		break;
	                                           //!录像文件管理应答消息处理
		
	case REC_MCU_LISTALLRECORD_NACK:    //录像机拒绝录像列表请求
	case REC_MCU_PUBLISHREC_NACK:		//发布录像
    case REC_MCU_CANCELPUBLISHREC_NACK: //取消发布录像
	case REC_MCU_DELETERECORD_NACK:     //删除录像记录拒绝消息
	case REC_MCU_RENAMERECORD_NACK:     //更改录像记录拒绝消息
		SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
		break;
		
	case REC_MCU_PUBLISHREC_ACK:		//发布录像
    case REC_MCU_CANCELPUBLISHREC_ACK:  //取消发布录像
	case REC_MCU_DELETERECORD_ACK:      //删除录像记录应答消息
	case REC_MCU_RENAMERECORD_ACK:      //更改录像记录应答消息
	case REC_MCU_LISTALLRECORD_ACK:     //录像机列应答(完毕)消息
		SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
		break;


	case MCS_MCU_GETMCUPERIEQPSTATUS_REQ:     //查询MCU外设状态
	case MCS_MCU_GETRECSTATUS_REQ:	          //查询录像机状态请求
	case MCS_MCU_GETMIXERSTATUS_REQ:	      //查询混音器状态请求
    case MCS_MCU_GETPERIDCSSTATUS_REQ:        //查询DCS状态请求
	//case MCS_MCU_GETBASSTATUS_REQ:	      //查询码率适配器状态请求
		DaemonProcMcsMcuGetPeriEqpStatusReq(pcMsg);
		break;
		
	case REC_MCU_EXCPT_NOTIF:			      //录像机异常通知消息
		DaemonProcCommonNotif(pcMsg);
		break;

	case MT_MCU_MTJOINCONF_REQ:
		DaemonProcMtMcuApplyJoinReq(pcMsg);
		break;
		
	//MP Message
	case MCU_MP_DISCONNECTED_NOTIFY:          //要处理Mp断链
	case MP_MCU_REG_REQ:
        g_cMpManager.ProcMpToMcuMessage(pcMsg);
        break;
         
    //case MP_MCU_FLUXOVERRUN_NOTIFY:
    case MP_MCU_FLUXSTATUS_NOTIFY:
        DaemonProcMpFluxNotify(pcMsg);
        break;
	case MP_MCU_GETDSINFO_ACK:
		{
			DaemonProcGetDsInfoAck(pcMsg);
			break;
		}
	case MP_MCU_GETDSINFO_NACK:
		{
			//break
			break;
		}
	//Mtadp Message
	case MCU_MTADP_DISCONNECTED_NOTIFY:       //要处理MtAdp断链
	case MTADP_MCU_REGISTER_REQ:
		DaemonProcMtadpDiscAndRegMsg(pcMsg);
		//g_cMpManager.ProcMtAdpToMcuMessage(pcMsg);
		break;
	
	//数据会议撤会后的消息处理
	case DCSSSN_MCU_RELEASECONF_ACK:
	case DCSSSN_MCU_RELEASECONF_NACK:
	case DCSSSN_MCU_CONFRELEASED_NOTIF:
		DaemonProcDcsMcuReleaseConfRsp(pcMsg);
		break;
        
    //N+1 备份主板注册备板失败
    case MCU_NPLUS_REG_NACK:
        DaemonProcNPlusRegBackupRsp(pcMsg);
        break;

	//主控热备份单元测试接口
	case EV_TEST_TEMPLATEINFO_GET_REQ:
	case EV_TEST_CONFINFO_GET_REQ:
	case EV_TEST_CONFMTLIST_GET_REQ:
	case EV_TEST_ADDRBOOK_GET_REQ:
	case EV_TEST_MCUCONFIG_GET_REQ:
		//DaemonProcUnitTestMsg();
		break;
	case MT_MCU_CALLFAIL_HDIFULL_NOTIF:
		DaemonProcHDIFullNtf(pcMsg);
		break;
    case AGT_SVC_E1BANDWIDTH_NOTIF:
        DaemonProcAgtSvcE1BandWidthNotif(pcMsg);
		break;
	case MCS_MCU_GETCRIMAC_REQ:
		DaemonProcMcsMcuGetCriMacAddrInfoReq(pcMsg);
		break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[CMcuVcInst] Wrong message %u(%s) received in DaemonEntry()!AppId = %d\n", 
			             pcMsg->event, ::OspEventDesc( pcMsg->event ),pcApp!=NULL?pcApp->appId:0 );
		break;
	}

	//主备数据倒换时，[MSMag <->McuVc]模块互锁，解锁 2005-12-15
	g_cMSSsnApp.LeaveMSSynLock(AID_MCU_VC);

	return;
}
/*lint -restore*/

/*=============================================================================
    函 数 名： DaemonProcMcuMSStateNtf
    功    能： 备用板升级为主用板时 通知[McuVc]模块主备用状态变更
    算法实现： 
    全局变量： 
    参    数： const CMessage * pcMsg
    返 回 值： void 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/12/31  4.0			万春雷                  创建
=============================================================================*/
void CMcuVcInst::DaemonProcMcuMSStateNtf( const CMessage * pcMsg )
{   
    u8 byIsSwitchOk = *( pcMsg->content );

	CServMsg cServMsg;
	cServMsg.SetSrcMtId(0);
	cServMsg.SetSrcSsnId(0);
    cServMsg.SetMsgBody( &byIsSwitchOk, sizeof(u8) );

    // guzh [9/14/2006] 
    //1.主备发生切换时,通知所有外设、DCS、MP、MtAdp、Mc 
    //如果倒换失败,让其断开连接
    g_cMpSsnApp.BroadcastToAllMpSsn( MCU_MSSTATE_EXCHANGE_NTF, &byIsSwitchOk, sizeof(u8) );
    g_cMtAdpSsnApp.BroadcastToAllMtAdpSsn( MCU_MSSTATE_EXCHANGE_NTF, cServMsg );
    CMcsSsn::BroadcastToAllMcsSsn( MCU_MSSTATE_EXCHANGE_NTF, &byIsSwitchOk, sizeof(u8) );
    g_cEqpSsnApp.BroadcastToAllPeriEqpSsn( MCU_MSSTATE_EXCHANGE_NTF, &byIsSwitchOk, sizeof(u8) );
    g_cDcsSsnApp.BroadcastToAllDcsSsn( MCU_MSSTATE_EXCHANGE_NTF,  &byIsSwitchOk, sizeof(u8) );

	
	// 1.1 [pengjie 2010/11/3] 当备mcu切换到主时，尝试重新注册Gk
	if( MCU_MSSTATE_EXCHANGE_NTF == pcMsg->event )
	{
		u8 byMasterMtAdpId = 0;
		byMasterMtAdpId = g_cMcuVcApp.GetRegGKDriId();
		
		if( 0 != g_cMcuAgent.GetGkIpAddr() &&
			PROTOCOL_TYPE_H323 == g_cMcuVcApp.m_atMtAdpData[byMasterMtAdpId-1].m_byProtocolType &&
			0 != byMasterMtAdpId )
		{
			g_cMcuVcApp.SetRegGKDriId( byMasterMtAdpId );
			g_cMcuVcApp.RegisterConfToGK( 0, byMasterMtAdpId );
			
			//在GK上注册会议实体(包括会议和模板)
			for( u8 byConfIdx = MIN_CONFIDX; byConfIdx <= MAX_CONFIDX; byConfIdx++ )
			{
				//注册模板
				TConfMapData tConfMapData = g_cMcuVcApp.GetConfMapData( byConfIdx );
				if ( tConfMapData.IsTemUsed() )
				{
					g_cMcuVcApp.RegisterConfToGK( byConfIdx, byMasterMtAdpId, TRUE, FALSE );
				}
				//注册会议
				else if ( tConfMapData.IsValidConf() )
				{
					g_cMcuVcApp.RegisterConfToGK( byConfIdx, byMasterMtAdpId, FALSE, FALSE );
				}
			}
			// 注册mcu
			g_cMcuVcApp.RegisterConfToGK( 0, byMasterMtAdpId );
			
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT,  "DaemonProcMcuMSStateNtf: Register To GK, Mtadp.%d \n", byMasterMtAdpId );
		}
	}
	// End
    
    // guzh [9/14/2006] 如果没有同步Ok, 直接退出    
    if ( !byIsSwitchOk )
    {
        return;
    }
 
	//2.主备发生切换时,新的主用板 将 [界面化配置信息] 重新通知当前所有会控
	::OspPost(MAKEIID(AID_MCU_CONFIG, 1), MCU_MSSTATE_EXCHANGE_NTF, pcMsg->content, pcMsg->length);

	//3.主备发生切换时,新的主用板将 [MCU状态] 重新通知当前所有会控
	TMcuStatus tMcuStatus;
	if (TRUE == g_cMcuVcApp.GetMcuCurStatus(tMcuStatus))
	{
		//notify all mcs
		cServMsg.SetMsgBody((u8 *)&tMcuStatus, sizeof(tMcuStatus));
		SendMsgToAllMcs(MCU_MCS_MCUSTATUS_NOTIF, cServMsg);
		SendExtMcuStatusNotify(cServMsg.GetSrcSsnId(),MAXNUM_OLDMCU_PERIEQP,TRUE);
	}
	
	//4.主备发生切换时,新的主用板将 [地址簿状态] 重新通知当前所有会控
    CMcsSsn::BroadcastToAllMcsSsn(MCU_ADDRBOOK_GETENTRYLIST_NOTIF);
    CMcsSsn::BroadcastToAllMcsSsn(MCU_ADDRBOOK_GETGROUPLIST_NOTIF);    

	//5.主备发生切换时,新的主用板将 [用户状态] 重新通知当前所有会控
    CMcsSsn::BroadcastToAllMcsSsn(MCS_MCU_GETUSERLIST_REQ);


	//6.主备发生切换时,新的主用板将 [会议状态/会控锁定状态/终端状态/SMCU_MEDAISRC/MMCU锁定状态] 重新通知当前所有会控
	//notify all mcs
	NtfMcsMcuCurListAllConf(cServMsg);

	return;
}

/*=============================================================================
  函 数 名： DaemoProcMcsMcuCreateConfByTemplateReq
  功    能： 通过模板创建会议
  算法实现： 
  全局变量： 
  参    数： const CMessage * pcMsg
  返 回 值： void 
=============================================================================*/
void CMcuVcInst::DaemonProcMcsMcuCreateConfByTemplateReq(const CMessage * pcMsg)
{
	CServMsg cServMsg( pcMsg->content, pcMsg->length );
	TTemplateInfo tTemConf;   
	u8 byConfIdx = g_cMcuVcApp.GetConfIdx(cServMsg.GetConfId());

	cServMsg.GetConfId().Print();

	if (!g_cMcuVcApp.GetTemplate(byConfIdx, tTemConf))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "[DaemoProcMcsCreateConfByTempReq] invalid confidx :%d\n", byConfIdx);
		SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
		return;
	}

	//对于模板中的auto作假分辨率，转换为真实启用的分辨率cif
	if (VIDEO_FORMAT_AUTO == tTemConf.m_tConfInfo.GetMainVideoFormat() &&
		MEDIA_TYPE_H264   == tTemConf.m_tConfInfo.GetMainVideoMediaType())
	{
		tTemConf.m_tConfInfo.SetMainVideoFormat(VIDEO_FORMAT_CIF);
	}

	if (VIDEO_FORMAT_AUTO == tTemConf.m_tConfInfo.GetSecVideoFormat() &&
		MEDIA_TYPE_H264   == tTemConf.m_tConfInfo.GetSecVideoMediaType())
	{
		tTemConf.m_tConfInfo.SetSecVideoFormat(VIDEO_FORMAT_CIF);
	}

	//ongoing conf
	if (MCS_MCU_CREATECONF_BYTEMPLATE_REQ == pcMsg->event 
		|| VCS_MCU_CREATECONF_BYTEMPLATE_REQ == pcMsg->event)
	{
		tTemConf.m_tConfInfo.m_tStatus.SetOngoing();
		tTemConf.m_tConfInfo.SetStartTime( time(NULL) );       
	}
	//schedule conf
	else
	{
		tTemConf.m_tConfInfo.m_tStatus.SetScheduled();
		TKdvTime *ptStartTime = (TKdvTime *)cServMsg.GetMsgBody();	
		//根据ptStartTime,区分是否是周期性预约会议
		if (NULL != ptStartTime)
		{
		
			//周期性预约会议
			if ( IsCircleScheduleConf(*ptStartTime) )
			{
				//解析消息体中的TDurationDate
				TDurationDate tDuraDate ;
				if ( cServMsg.GetMsgBodyLen() > sizeof(TKdvTime) )
				{
					tDuraDate = *(TDurationDate*)(cServMsg.GetMsgBody() + sizeof(TKdvTime));
				}
					
				//SetKdvStartTime 会保留原来的高3位
				tTemConf.m_tConfInfo.SetKdvStartTime(*ptStartTime);
				//取出starttime的周期模式，设置进去
				u16 wYear = ptStartTime->GetYear();
				u16 wScheMode = (wYear & 0xE000)>>13;
				tTemConf.m_tConfInfo.SetScheduleConfMode( (emCircleSchedulConfMode)wScheMode );

				//保证durastart的时分秒为00:00:00,duraend的时分秒为23:59:59
				ModifyCircleScheduleConfDuraDate(tDuraDate);
				TKdvTime tNextStarttime = GetNextOngoingTime(tTemConf.m_tConfInfo,tDuraDate,TRUE);
				TKdvTime tNullTime;//构造就是memset为0
				//找不到下次开启的时间,开不了会，return 
				if ( tNullTime == tNextStarttime )
				{
					cServMsg.SetErrorCode((u16)ERR_MCU_CIRCLESCHEDULECONF_TIME_WRONG);
					SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
					ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "[DaemoProcMcsMcuCreateConfByTemplateReq]circlescheduleconf timeseting error,errorcode:%d!\n",ERR_MCU_CIRCLESCHEDULECONF_TIME_WRONG);
					return;
				}
		
				//更新TTemplateInfo中的有效时间信息
				g_cMcuVcApp.UpdateExInfoInTemplate(tTemConf,emScheduleDurationDateEx,(u16)sizeof(TDurationDate),(u8*)&tDuraDate);
				tTemConf.m_tConfInfo.SetHasConfExFlag(TRUE);
								
			}
			else //非周期性预约会议
			{
				time_t temptime;
				ptStartTime->GetTime(temptime);
				//时间校验
				if ( (tTemConf.m_tConfInfo.GetDuration() == 0 && time( NULL ) > temptime + 30 * 60 ) || 
						( tTemConf.m_tConfInfo.GetDuration() != 0 && time( NULL ) > temptime + tTemConf.m_tConfInfo.GetDuration() * 60 ) 
					)
				{
					cServMsg.SetErrorCode(ERR_MCU_STARTTIME_WRONG);
					SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
					ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "[DaemoProcMcsMcuCreateConfByTemplateReq] starttime error!\n");
					return;
				}
				tTemConf.m_tConfInfo.SetStartTime(temptime);
			}
		
		}
		
	}   

	g_cMcuVcApp.TemInfo2Msg(tTemConf, cServMsg);
	cServMsg.SetSrcMtId(CONF_CREATE_MCS);
	cServMsg.SetConfIdx(byConfIdx);

    u8 byInsID = AssignIdleConfInsID();
    if(0 != byInsID)
    {
		// 对于mcs会议、vcs会议实际处理区分开
		if (VCS_MCU_CREATECONF_BYTEMPLATE_REQ == pcMsg->event)
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "[DaemonProcMcsMcuCreateConfByTemplateReq] VCSConf start command to inst%d\n",
				           byInsID);
			post(MAKEIID( AID_MCU_VC, byInsID ), MCU_SCHEDULE_VCSCONF_START, 
                 cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
		}
		else
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "[DaemonProcMcsMcuCreateConfByTemplateReq] MCSConf start command to inst%d\n",
				           byInsID);
			post(MAKEIID( AID_MCU_VC, byInsID ), MCU_SCHEDULE_CONF_START, 
					cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
		}
    }
	else
    {
        cServMsg.SetErrorCode(ERR_MCU_CONFNUM_EXCEED);
        SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
        ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "[DaemoProcMcsMcuCreateConfByTemplateReq] assign instance id failed!\n");
    }

	return;
}

/*=============================================================================
函 数 名： DaemonProcCreateConfNPlus
功    能： n+1模式创会
算法实现： 
全局变量： 
参    数： const CMessage * pcMsg
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/11/28  4.0			许世林                  创建
=============================================================================*/
void CMcuVcInst::DaemonProcCreateConfNPlus(const CMessage * pcMsg)
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);
    TNPlusConfData *ptConfData = (TNPlusConfData *)cServMsg.GetMsgBody();
    CApp *pcApp = &g_cMcuVcApp;

    //主mcu会议回滚
    if (g_cNPlusApp.GetLocalNPlusState() == MCU_NPLUS_MASTER_CONNECTED)
    {
        //先查找此会议是否已经存在，根据会议名称和e164号匹配
        for (u8 byInsId = 1; byInsId <= MAXNUM_MCU_CONF; byInsId++)
        {
            CMcuVcInst *pcInst = (CMcuVcInst *)pcApp->GetInstance( byInsId );
            if (NULL != pcInst && pcInst->CurState() == STATE_ONGOING)
            {
                if (strcmp(pcInst->m_tConf.GetConfName(), ptConfData->m_tConf.GetConfName()) == 0 &&
                    strcmp(pcInst->m_tConf.GetConfE164(), ptConfData->m_tConf.GetConfE164()) == 0)
                {
                    //先结束这个会议
                    ConfPrint(LOG_LVL_DETAIL, MID_MCU_NPLUS, "[DaemonProcCreateConfNPlus] release conf %s before rollback.\n", pcInst->m_tConf.GetConfName());
                    pcInst->ReleaseConf(FALSE);
                    pcInst->NextState(STATE_IDLE);                    

                    break;
                }
            }
        }
    }
    //备份mcu上会议恢复
    else if (g_cNPlusApp.GetLocalNPlusState() == MCU_NPLUS_SLAVE_SWITCH)
    {
        ConfPrint(LOG_LVL_DETAIL, MID_MCU_NPLUS, "[DaemonProcCreateConfNPlus] conf restore in N+1 mode\n");
    }
    else
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_NPLUS, "[DaemonProcCreateConfNPlus] invalid n+1 mode(%d) in conf restore.\n",
                  g_cNPlusApp.GetLocalNPlusState());
        return;
    }

    u8 byInsID = AssignIdleConfInsID();
	//zjl[20100521]创会时需要将bas状态全部清空，否则会由于状态错误导致新创会时起不了bas
	if(NULL != ptConfData)
	{
		ptConfData->m_tConf.m_tStatus.SetAdaptMode(CONF_BASMODE_AUD, FALSE);
		ptConfData->m_tConf.m_tStatus.SetAdaptMode(CONF_BASMODE_VID, FALSE);
		ptConfData->m_tConf.m_tStatus.SetAdaptMode(CONF_BASMODE_BR, FALSE);
		ptConfData->m_tConf.m_tStatus.SetAdaptMode(CONF_BASMODE_CASDAUD, FALSE);
		ptConfData->m_tConf.m_tStatus.SetAdaptMode(CONF_BASMODE_CASDVID, FALSE);
		ptConfData->m_tConf.m_tStatus.SetHDAdaptMode(CONF_HDBASMODE_VID, FALSE);
		ptConfData->m_tConf.m_tStatus.SetHDAdaptMode(CONF_HDBASMODE_DOUBLEVID, FALSE);
		ptConfData->m_tConf.m_tStatus.SetHDAdaptMode(CONF_HDBASMODE_CASDVID, FALSE);
	}
	
    if (0 != byInsID)
    {
        if (OSP_OK == post(MAKEIID( AID_MCU_VC, byInsID ), MCU_CREATECONF_NPLUS, pcMsg->content, pcMsg->length))
        {            
		    CMcuVcInst *pcInst = (CMcuVcInst *)pcApp->GetInstance( byInsID );
		    pcInst->NextState(STATE_WAITFOR);
        }        
    }
    else
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_NPLUS, "[DaemonProcCreateConfNPlus] assign instance id failed! \n");
    }
    return;
}

/*=============================================================================
  函 数 名： DaemonProcMcsMcuTemplateOpr
  功    能： 模板操作
  算法实现： 
  全局变量： 
  参    数： const CMessage * pcMsg
  返 回 值： void 
=============================================================================*/
void CMcuVcInst::DaemonProcMcsMcuTemplateOpr(const CMessage * pcMsg)
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);  
    u8 byConfIdx = g_cMcuVcApp.GetConfIdx(cServMsg.GetConfId());

    switch(pcMsg->event)
    {
    case MCS_MCU_CREATETEMPLATE_REQ:
    case MCS_MCU_MODIFYTEMPLATE_REQ:
        {
            TTemplateInfo  tTemInfo;
			s8* pszUnProcInfoHead = NULL;
			u16 wUnProcLen = 0;
            g_cMcuVcApp.Msg2TemInfo(cServMsg, tTemInfo);
/*========================================================================*/
/*START:=======测试：添加25风格vmp测试代码=====================================*/
/*

			TVmpChnnlMember atVmpMember[5];
			TVmpModuleInfo tVmpModuleINfo;

			TConfInfoEx tConfEx;
			u16 wUnPackConfExLen = 0;
			BOOL32 bExistUnknowInfo = 0;
			
			UnPackConfInfoEx(tConfEx,&tTemInfo.m_byConInfoExBuf[0],wUnPackConfExLen,bExistUnknowInfo,NULL,&tVmpModuleINfo);
			
			memset(&atVmpMember[0],0,sizeof(atVmpMember));
			atVmpMember[0].m_byChnIdx = 20;
			atVmpMember[0].m_byVmpMember = 1;
			atVmpMember[0].m_byMemberType = 1;

			atVmpMember[1].m_byChnIdx = 24;
			atVmpMember[1].m_byVmpMember = 2;
			atVmpMember[1].m_byMemberType = 1;

			tVmpModuleINfo.SetVmpChnnlMember(atVmpMember,2);

			PackConfInfoEx(tConfEx,&tTemInfo.m_byConInfoExBuf[0],wUnPackConfExLen,NULL,&tVmpModuleINfo);

  */

/*END:=======测试：添加25风格vmp测试代码=====================================*/

/*======================================================================*/
			//测试：添加HDU2vmp预案信息[3/11/2013 chendaiwei]
/*			THduVmpModuleOrTHDTvWall tHduModule;
			TConfInfoEx tConfEx;
			u16 wUnPackConfExLen = 0;
			BOOL32 bExistUnknowInfo = 0;

			UnPackConfInfoEx(tConfEx,&tTemInfo.m_byConInfoExBuf[0],wUnPackConfExLen,bExistUnknowInfo,&tHduModule);
			THduVmpChannlInfo aHdu[2];
			memset(&aHdu[0],0,sizeof(aHdu));
			aHdu[0].m_byHduEqpId = 125;
			aHdu[0].m_byChIdx = 1;
			aHdu[0].m_byVmpStyle = 1;

			for(u8 bySubIdx = 0; bySubIdx <4; bySubIdx++)
			{
				aHdu[0].m_abyMemberType[bySubIdx] = TW_MEMBERTYPE_MCSSPEC;
				aHdu[0].m_abyTvWallMember[bySubIdx] = bySubIdx+1;
			}

			aHdu[0].m_abyTvWallMember[1] = 8;

			aHdu[1].m_byHduEqpId = 126;
			aHdu[1].m_byChIdx = 1;
			aHdu[1].m_byVmpStyle = 1;
			
			for(u8 bySubIdx1 = 0; bySubIdx1 <4; bySubIdx1++)
			{
				aHdu[1].m_abyMemberType[bySubIdx1] = TW_MEMBERTYPE_MCSSPEC;
				aHdu[1].m_abyTvWallMember[bySubIdx1] = 8;
			}
			
			tHduModule.SetHduVmpChnnlInfo(&aHdu[0],2);
  
			PackConfInfoEx(tConfEx,&tTemInfo.m_byConInfoExBuf[0],wUnPackConfExLen,&tHduModule);*/
			
            tTemInfo.m_byConfIdx = byConfIdx;
			
			cServMsg.GetConfId().Print();

			//TODO:是否需要打印
			//zjl[20091208]hdu预案配置临时测试用
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[DaemonProcMcsMcuTemplateOpr] ModuleNum:%d\n", tTemInfo.m_tMultiTvWallModule.GetTvModuleNum());
			for (u8 byIdx = 0; byIdx < MAXNUM_PERIEQP_CHNNL; byIdx++)
			{
				TTvWallModule tTvWallModule;
				if (!tTemInfo.m_tMultiTvWallModule.GetTvModuleByIdx(byIdx, tTvWallModule))
				{
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[DaemonProcMcsMcuTemplateOpr] Cannot GetTvModuleByIdx:%d\n", byIdx);
				}
				u8 byEqpType = tTvWallModule.GetTvEqp().GetEqpType();
				if (byEqpType == 0)
				{
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[DaemonProcMcsMcuTemplateOpr] MoudleId:%d, MoudleEqpId:%d, byEqpType:%d\n", 
						    byIdx, tTvWallModule.m_tTvWall.GetEqpId(), byEqpType);
					continue;
				}
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[DaemonProcMcsMcuTemplateOpr] MoudleId:%d, MoudleEqpId:%d, EqpType:%d\n", 
						 byIdx, tTvWallModule.m_tTvWall.GetEqpId(),byEqpType);
				for(u8 byChnl = 0; byChnl < MAXNUM_TVWALL_CHNNL_INSMOUDLE; byChnl++)
				{
					if (tTvWallModule.m_abyTvWallMember[byChnl] == 0)
					{
						continue;						
					}
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "--------------Chanl:%d, Member:%d, MemberType:%d\n",
						byChnl, 
						tTvWallModule.m_abyTvWallMember[byChnl], 
						tTvWallModule.m_abyMemberType[byChnl]);
				}
			}

            //检验会议信息逻辑
            u16 wErrCode = 0;
            if ( !IsConfInfoCheckPass(cServMsg, tTemInfo.m_tConfInfo, wErrCode, TRUE))
            {
                cServMsg.SetErrorCode( wErrCode );
                SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
				
                return;
            }
			
			// VMP合成性能限制, zgc, 2008-03-26
			TConfAttrb tTempConfAttrb = tTemInfo.m_tConfInfo.GetConfAttrb();
			if ( tTempConfAttrb.IsHasVmpModule() )
			{
				TVMPParam tVMPParam = tTemInfo.m_atVmpModule.GetVmpParam();
				// 按会议信息计算最大支持合成能力
				u8 byMaxChnlNumByConf = CMcuPfmLmt::GetMaxCapVMPByConfInfo(tTemInfo.m_tConfInfo);
				u8 byTempChnl = GetVmpChlNumByStyle( tVMPParam.GetVMPStyle() );
				if ( byTempChnl > byMaxChnlNumByConf )
				{
					cServMsg.SetErrorCode( ERR_INVALID_VMPSTYLE );
					SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );

					return;
				}
			}
            

            // [1/28/2013 liaokang] 针对卫星会议，判断回传通道数是否足            
            if( tTempConfAttrb.IsSatDCastMode() )
            {
                u8 bySatDCastChnlNum = tTemInfo.m_tConfInfo.GetSatDCastChnlNum();
                u8 bySatMtNum = 0;
                TMtAlias tChairAlias = tTemInfo.m_tConfInfo.GetChairAlias();
                TMtAlias tSpeakerAlias = tTemInfo.m_tConfInfo.GetSpeakerAlias();

                for( u8 byMtIdx = 0; byMtIdx < tTemInfo.m_byMtNum; byMtIdx++ )
                {
                    if( tTemInfo.m_atMtAlias[byMtIdx].IsNull() )
                    {
                        continue;
                    }

                    BOOL32 bRet = g_cMcuVcApp.IsMultiCastMtIp( tTemInfo.m_atMtAlias[byMtIdx].m_tTransportAddr.GetIpAddr() );
                    if( FALSE == bRet )
                    {
                        continue;
                    }

                    // 发言人
                    if( tSpeakerAlias == tTemInfo.m_atMtAlias[byMtIdx] )
                    {
                        bySatMtNum++;
                        continue;
                    }

                    // 发言人看主席
                    if( tChairAlias == tTemInfo.m_atMtAlias[byMtIdx] &&
                        1 == tTempConfAttrb.GetSpeakerSrc() &&
                        !tSpeakerAlias.IsNull() &&
                        !(tChairAlias == tSpeakerAlias) )
                    {
                        bySatMtNum++;
                        continue;
                    }

                    BOOL32 bAdd = FALSE;

                    // 计算画面合成
                    if( tTempConfAttrb.IsHasVmpModule() &&
                        CONF_VMPMODE_CTRL == tTemInfo.m_atVmpModule.m_tVMPParam.GetVMPMode() )
                    {
                        u8 byMtIdxInVmp = 0;
                        u8 byMtType = VMP_MEMBERTYPE_NULL;
                        for (u8 byVmpIdx = 0; byVmpIdx < MAXNUM_MPUSVMP_MEMBER; byVmpIdx++)
                        {
                            // 通过索引取终端，然后遍历是否为组播终端
                            byMtIdxInVmp = 0;
                            byMtType = VMP_MEMBERTYPE_NULL;
                            byMtIdxInVmp = tTemInfo.m_atVmpModule.m_abyVmpMember[byVmpIdx];
                            byMtType = tTemInfo.m_atVmpModule.m_abyMemberType[byVmpIdx];
                            if( VMP_MEMBERTYPE_NULL == byMtType ||
                                VMP_MEMBERTYPE_SPEAKER == byMtType  )
                            {
                                continue;
                            }
                            
                            if( tTemInfo.m_atMtAlias[byMtIdx] == tTemInfo.m_atMtAlias[byMtIdxInVmp - 1] )
                            {
                                bySatMtNum++;
                                bAdd = TRUE;
                                break;  // 成员可能存在重复,所以break
                            }
                        }
                    }

                    if( TRUE == bAdd )
                    {
                        continue;  // 成员可能存在重复,所以continue
                    } 

                    // 计算电视墙成员
                    if( tTempConfAttrb.IsHasTvWallModule() &&
                        !(0 == tTemInfo.m_tMultiTvWallModule.m_byTvModuleNum) )
                    { 
                        u8 byMtIdxInTw = 0;
                        u8 byMtTypeInTw = TW_MEMBERTYPE_NULL;                        
                        for (u8 byTwChnlIdx = 0; byTwChnlIdx < MAXNUM_PERIEQP_CHNNL; byTwChnlIdx++)
                        {
                            TTvWallModule tTvWallModule;
                            if (!tTemInfo.m_tMultiTvWallModule.GetTvModuleByIdx(byTwChnlIdx, tTvWallModule))
                            {
                                continue;
                            }

                            u8 byEqpType = tTvWallModule.GetTvEqp().GetEqpType();
                            if (byEqpType == 0)
                            {
                                continue;
                            }
                            
                            for(u8 byChnl = 0; byChnl < MAXNUM_TVWALL_CHNNL_INSMOUDLE; byChnl++)
                            {
                                byMtIdxInTw = 0;
                                byMtTypeInTw = TW_MEMBERTYPE_NULL;
                                byMtIdxInTw = tTvWallModule.m_abyTvWallMember[byChnl];
                                byMtTypeInTw = tTvWallModule.m_abyMemberType[byChnl];
                                if ( TW_MEMBERTYPE_NULL == byMtTypeInTw )
                                {
                                    continue;						
                                }

                                // 判断主席跟随
                                if( tChairAlias == tTemInfo.m_atMtAlias[byMtIdx] &&
                                    TW_MEMBERTYPE_CHAIRMAN == byMtTypeInTw )
                                {
                                    bySatMtNum++;
                                    bAdd = TRUE;
                                    break;  // 成员可能存在重复,所以break
                                }

                                if( tTemInfo.m_atMtAlias[byMtIdx] == tTemInfo.m_atMtAlias[byMtIdxInTw-1] )
                                {
                                    bySatMtNum++;
                                    bAdd = TRUE;
                                    break;  // 成员可能存在重复,所以break
                                }
                            }
                            
                            if( TRUE == bAdd )
                            {
                                break;  // 成员可能存在重复,所以break
                            } 
                        }
                    }                    
                }
                
                if ( bySatMtNum > bySatDCastChnlNum )
                {
                    cServMsg.SetErrorCode( ERR_MCU_DCAST_OVERCHNNLNUM );
                    SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
                    
                    ConfPrint( LOG_LVL_ERROR, MID_MCU_MCS, "template %s create failed because of insufficient Dcast Chnl Num! <Need:%d,Real:%d>\n", 
                        tTemInfo.m_tConfInfo.GetConfName(), bySatMtNum, bySatDCastChnlNum );
                    return;
                }
            }



            //若会议结束模式为无终端自动结束，应该有终端
            if(0 == tTemInfo.m_byMtNum && tTempConfAttrb.IsReleaseNoMt())
            {
                cServMsg.SetErrorCode( ERR_MCU_NOMTINCONF );
                SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
				
				ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "template %s create failed because no mt in auto-end conf!\n", tTemInfo.m_tConfInfo.GetConfName() );
                return;
            }

            if(MCS_MCU_CREATETEMPLATE_REQ == pcMsg->event)
            {
                //会议的E164号码已存在，拒绝 
				//与已有会议E164号重复，拒绝[4/5/2012 chendaiwei]
                if( g_cMcuVcApp.IsConfE164Repeat( tTemInfo.m_tConfInfo.GetConfE164(), TRUE ,FALSE) 
					||0 != g_cMcuVcApp.GetOngoingConfIdxByE164(tTemInfo.m_tConfInfo.GetConfE164()))
                {
                    cServMsg.SetErrorCode( ERR_MCU_CONFE164_REPEAT );
                    SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );

                    ConfPrint( LOG_LVL_ERROR, MID_MCU_MCS, "template %s E164 repeated and create failure!\n", tTemInfo.m_tConfInfo.GetConfName() );
                    return;
                }
                
                //会议名已存在，拒绝
                if( g_cMcuVcApp.IsConfNameRepeat( tTemInfo.m_tConfInfo.GetConfName(), TRUE,FALSE ) )
                {
                    cServMsg.SetErrorCode( ERR_MCU_CONFNAME_REPEAT );
                    SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
					
                    ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "template %s name repeated and create failure!\n", tTemInfo.m_tConfInfo.GetConfName() );
                    return;
                }           

                if(!g_cMcuVcApp.AddTemplate(tTemInfo))
                {
                    // 返回的错误码
                    cServMsg.SetErrorCode( ERR_MCU_TEMPLATE_NOFREEROOM );
                    ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "[DaemonProcMcsMcuTemplateOpr] add template %s failed\n", tTemInfo.m_tConfInfo.GetConfName());
                    SendReplyBack(cServMsg, pcMsg->event+2);

                    return;
                } 
                else
				{
					BackConfHeadInfo();
				}
                cServMsg.SetConfId( tTemInfo.m_tConfInfo.GetConfId() );
				
				tTemInfo.m_tConfInfo.GetConfId().Print();
            }
            else
            {                
                TTemplateInfo tOldTemInfo;
                if(!g_cMcuVcApp.GetTemplate(byConfIdx, tOldTemInfo))
                {
                    cServMsg.SetErrorCode( ERR_MCU_TEMPLATE_NOTEXIST );
                    ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "[DaemonProcMcsMcuTemplateOpr] get template confIdx<%d> failed\n", byConfIdx);
                    SendReplyBack(cServMsg, pcMsg->event+2);
                    return;
                }

                //会议的E164号码已存在，拒绝 
                BOOL32 bSameE164 = (0 == strcmp((s8*)tTemInfo.m_tConfInfo.GetConfE164(), (s8*)tOldTemInfo.m_tConfInfo.GetConfE164()));
                //增加判断当前要修改的e164号是否在其他模板里重复或者在当前即时会议中有重复
				if( !bSameE164 &&
                    (g_cMcuVcApp.IsConfE164Repeat( tTemInfo.m_tConfInfo.GetConfE164(), TRUE ,FALSE) ||
					 0 != g_cMcuVcApp.GetOngoingConfIdxByE164(tTemInfo.m_tConfInfo.GetConfE164())
					 )
					)
                {
                    cServMsg.SetErrorCode( ERR_MCU_CONFE164_REPEAT );
                    SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
                    ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "template %s E164 repeated and modify failure!\n", tTemInfo.m_tConfInfo.GetConfName() );
                    return;
                }
                
                //会议名已存在，拒绝
                BOOL32 bSameName = (0 == strcmp( (s8*)tTemInfo.m_tConfInfo.GetConfName(), (s8*)tOldTemInfo.m_tConfInfo.GetConfName()));
                if( !bSameName &&
                    g_cMcuVcApp.IsConfNameRepeat( tTemInfo.m_tConfInfo.GetConfName(), TRUE ,FALSE) )
                {
                    cServMsg.SetErrorCode( ERR_MCU_CONFNAME_REPEAT );
                    SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
                    ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "template %s name repeated and create failure!\n", tTemInfo.m_tConfInfo.GetConfName() );
                    return;
                }    
                
                if(!g_cMcuVcApp.ModifyTemplate(tTemInfo, bSameE164))
                {
                    ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "[DaemonProcMcsMcuTemplateOpr] modify template %s failed\n", tTemInfo.m_tConfInfo.GetConfName());
                    SendReplyBack(cServMsg, pcMsg->event+2);
                    return;
                }


                if(!bSameE164)
                {
                    cServMsg.SetConfId(tOldTemInfo.m_tConfInfo.GetConfId());
                    SendMsgToAllMcs(MCU_MCS_DELTEMPLATE_NOTIF, cServMsg); 
                }
            }
// 			// 对于存在无需处理的信息，将其保存在分开的文件中
// 			if (pszUnProcInfoHead != NULL && wUnProcLen != 0)
// 			{
// 				CConfId acConfId[MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE+1];
// 				u8      byConfPos  = MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE;
// 
// 				// 在头信息记录中 获取 会议或模板的相对位置
// 				GetAllConfHeadFromFile(acConfId, sizeof(acConfId));
// 
// 				//查找已有会议：此会议已保存，覆盖，不包含缺省会议位置
// 				for (s32 nPos = 0; nPos < (MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE); nPos++)
// 				{
// 					if (acConfId[nPos] == tTemInfo.m_tConfInfo.GetConfId())
// 					{
// 						byConfPos = (u8)nPos;
// 						break;
// 					}
// 				}
// 				//一般走不到，该模板不存在未存于文件中
// 				if (MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE == byConfPos)
// 				{
// 					ConfPrint(LOG_LVL_DETAIL, MID_MCU_MCS, "[DaemonProcMcsMcuTemplateOpr] confinfo_head.dat has no temp with specified confid\n");
// 				}
// 				else
// 				{
// 					SetUnProConfDataToFile(byConfPos, pszUnProcInfoHead, wUnProcLen);
// 				}
// 			}

            SendReplyBack(cServMsg, pcMsg->event+1);
            g_cMcuVcApp.TemInfo2Msg(tTemInfo, cServMsg);
            SendMsgToAllMcs(MCU_MCS_TEMSCHCONFINFO_NOTIF, cServMsg); 

			tTemInfo.m_tConfInfo.GetConfId().Print();
			

//          CConfId cConfId = tTemInfo.m_tConfInfo.GetConfId();
// 			NotifyVCSPackInfo(cConfId, cServMsg.GetSrcSsnId());
        }
        break;

    case MCS_MCU_DELTEMPLATE_REQ:
        {            
            if(!g_cMcuVcApp.DelTemplate(byConfIdx))
            {
                ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "[DaemonProcMcsMcuTemplateOpr] del template confidx<%d> failed\n", byConfIdx);
                SendReplyBack(cServMsg, pcMsg->event+2);
                return;
            }
			else
			{
				BackConfHeadInfo();
			}
            SendReplyBack(cServMsg, pcMsg->event+1);
            SendMsgToAllMcs(MCU_MCS_DELTEMPLATE_NOTIF, cServMsg); 
        }
        break;

    default:
        break;
    }

    return;
}

/*=============================================================================
  函 数 名： DaemonProcGkRegRsp
  功    能： gk注册响应处理函数
  算法实现： 
  全局变量： 
  参    数： const CMessage * pcMsg
  返 回 值： void 
=============================================================================*/
void CMcuVcInst::DaemonProcGkRegRsp(const CMessage * pcMsg)
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);
    u8 byConfIdx = cServMsg.GetConfIdx();

    //[12/2/2011 zhushengze]将会议注册状态通知其他接入板
    if( byConfIdx <= MAX_CONFIDX )
    {
        //u8 byConfIdx  = 0; //0－mcu，1－MAXNUM_MCU_CONF 会议
        u8 byRegState = 0; //0－未注册，1－成功注册
        u8 byOtherDri = 1;
        TMtAlias tMtAlias;
        
        if( MT_MCU_REGISTERGK_ACK == pcMsg->event )
        {
            byRegState = 1;
        }
        g_cMcuVcApp.SetConfRegState( byConfIdx, byRegState );
        
        //同步此时的注册MCU及会议实体 注册信息 到其他适配板
        if( 0 == byConfIdx )
        { 	
            char achMcuAlias[MAXLEN_ALIAS];
            g_cMcuAgent.GetE164Number( achMcuAlias, MAXLEN_ALIAS );
            tMtAlias.SetE164Alias( achMcuAlias );
            cServMsg.SetMcuId( LOCAL_MCUID );
            cServMsg.SetMsgBody( (u8*)&tMtAlias, sizeof( tMtAlias ) );
            cServMsg.CatMsgBody( (u8*)&byConfIdx, sizeof( byConfIdx ) );
            cServMsg.CatMsgBody( (u8*)&byRegState, sizeof( byRegState ) );
        }
        else
        {		
            TConfInfo* ptConfInfo = NULL;
            TTemplateInfo tTemInfo;
            
            TConfMapData tMapData = g_cMcuVcApp.GetConfMapData(byConfIdx);
            if(tMapData.IsValidConf())
            {
                CMcuVcInst* pcVcinst = g_cMcuVcApp.GetConfInstHandle( byConfIdx );
                if( NULL ==  pcVcinst)
                {
                    //主备倒换 辅助接入板带会议的模板注册状态被冲问题：
                    //如果是带会议的模板但却没有会议，尝试同步其模板的当前注册状态
                    LogPrint( LOG_LVL_ERROR, MID_MCU_MT,  "[DaemonProcGkRegRsp] RegAck for Conf.%d received while conf is not create yet which should be there before this moment, just take a try of its template once more\n", byConfIdx);
                    
                    if(tMapData.IsTemUsed())
                    {
                        if(!g_cMcuVcApp.GetTemplate(byConfIdx, tTemInfo))
                        {
                            LogPrint( LOG_LVL_ERROR, MID_MCU_MT,  "[DaemonProcGkRegRsp] RegAck for Conf.%d whose template unexist yet, ignore it\n", byConfIdx);
                            return;
                        }
                        else
                        {
                            ptConfInfo = &tTemInfo.m_tConfInfo;
                            LogPrint( LOG_LVL_ERROR, MID_MCU_MT,  "[DaemonProcGkRegRsp] RegAck for Conf.%d whose template exist, continue\n", byConfIdx);
                        }
                    }
                    return;
                }
                else
                {
                    ptConfInfo = &pcVcinst->m_tConf;
                }
            }
            else if(tMapData.IsTemUsed())
            {
                if(!g_cMcuVcApp.GetTemplate(byConfIdx, tTemInfo))
                {
                    LogPrint( LOG_LVL_ERROR, MID_MCU_MT,  "[DaemonProcGkRegRsp] RegAck for Template.%d while template unexist, ignore it\n", byConfIdx);
                    return;
                }
                else
                {
                    ptConfInfo = &tTemInfo.m_tConfInfo;
                }
            }
            else
            {
                LogPrint( LOG_LVL_ERROR, MID_MCU_MT,  "[DaemonProcGkRegRsp] RegAck for Conf/Temp.%d while both of them unexist, ignore it\n", byConfIdx);
                return;
            }
            
            //MT_MCU_UNREGISTERGK_ACK MT_MCU_UNREGISTERGK_NACK
            if( MT_MCU_REGISTERGK_ACK  == pcMsg->event || 
                MT_MCU_REGISTERGK_NACK == pcMsg->event )
            {
                tMtAlias.SetE164Alias( ptConfInfo->GetConfE164() );
                cServMsg.SetConfId( ptConfInfo->GetConfId() );
            }
            cServMsg.SetMsgBody( (u8*)&tMtAlias, sizeof( tMtAlias ) );
            cServMsg.CatMsgBody( (u8*)&byConfIdx, sizeof( byConfIdx ) );
            cServMsg.CatMsgBody( (u8*)&byRegState, sizeof( byRegState ) );
            
            if (byRegState == 0)
            {
                LogPrint( LOG_LVL_ERROR, MID_PUB_ALWAYS, "[ProcMtAdpMcuGKMsg]conf.%d reg state is NULL, Alias is:\n ", byConfIdx);
                tMtAlias.Print();
            }
        }
        
        for( byOtherDri = 1; byOtherDri <= MAXNUM_DRI; byOtherDri++)
        {
            if( g_cMcuVcApp.IsMtAdpConnected(byOtherDri) && 
                PROTOCOL_TYPE_H323 == g_cMcuVcApp.GetMtAdpProtocalType(byOtherDri) && 
                g_cMcuAgent.GetGkIpAddr()  && 0 != g_cMcuVcApp.GetRegGKDriId() && 
                byOtherDri != g_cMcuVcApp.GetRegGKDriId() )
            {
                cServMsg.SetDstDriId( byOtherDri );
                g_cMtAdpSsnApp.SendMsgToMtAdpSsn( byOtherDri, MCU_MT_UPDATE_REGGKSTATUS_NTF, cServMsg );
            }
        }
    }
    
    if ( 0 == byConfIdx )
    {
        if ( m_tConfInStatus.IsRegGkNackNtf() && MT_MCU_REGISTERGK_NACK == pcMsg->event )
        {
            //MCU 注册GK别名冲突
            u16 wErrCode = cServMsg.GetErrorCode();
            if ( ERR_MCU_RAS_DUPLICATE_ALIAS == wErrCode ) 
            {
                NotifyMcsAlarmInfo( 0, wErrCode );
                m_tConfInStatus.SetRegGkNackNtf(FALSE);
            }
        }
		g_cMcuVcApp.BroadcastToAllConf( pcMsg->event, pcMsg->content, pcMsg->length);
		
        return;
    }
    else
    {
        if ( MT_MCU_REGISTERGK_NACK == pcMsg->event )
        {
            //模板 或 会议 注册GK别名冲突
            u16 wErrCode = cServMsg.GetErrorCode();
            if ( ERR_MCU_RAS_DUPLICATE_ALIAS == wErrCode ) 
            {
                NotifyMcsAlarmInfo( 0, wErrCode );
            }
        }
    }

    if ( byConfIdx < MIN_CONFIDX || byConfIdx > MAX_CONFIDX )
    {
        ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_MT, "[DaemonProcGkRegRsp] confidx received :%d\n", byConfIdx);
        return;
    }

    //更新会议注册状态
    CMcuVcInst *pcInst = g_cMcuVcApp.GetConfInstHandle(byConfIdx);
    if (NULL != pcInst && pcInst->CurState() == STATE_ONGOING)
    {
        g_cMcuVcApp.SendMsgToConf(byConfIdx, pcMsg->event, pcMsg->content, pcMsg->length);
    }
    
    //更新模板注册状态
    TConfMapData tMapData = g_cMcuVcApp.GetConfMapData(byConfIdx);
    if(!tMapData.IsTemUsed())
    {            
        return;
    }

    if(MT_MCU_REGISTERGK_ACK == pcMsg->event)
    {
        g_cMcuVcApp.SetTemRegGK(byConfIdx, TRUE);
    }
    else if(MT_MCU_UNREGISTERGK_ACK == pcMsg->event)
    {
        g_cMcuVcApp.SetTemRegGK(byConfIdx, FALSE);
    }
    else if(MT_MCU_REGISTERGK_NACK == pcMsg->event)
    {
        TTemplateInfo tTemInfo;
        if(g_cMcuVcApp.GetTemplate(byConfIdx, tTemInfo))
        {
            u8 byReg = 0;
            cServMsg.SetMsgBody(&byReg, sizeof(byReg));
            cServMsg.SetConfId(tTemInfo.m_tConfInfo.GetConfId());
            SendMsgToAllMcs( MCU_MCS_CONFREGGKSTATUS_NOTIF, cServMsg ); 
        }
    }

    return;
}

/*=============================================================================
  函 数 名： DaemonProcGKChargeRsp
  功    能： GK计费响应处理函数
  算法实现： 
  全局变量： 
  参    数： const CMessage * pcMsg
  返 回 值： void 
 -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2006/11/09    4.0			张宝卿                  创建
=============================================================================*/
void CMcuVcInst::DaemonProcGKChargeRsp( const CMessage * pcMsg )
{
    CServMsg cServMsg( pcMsg->content, pcMsg->length );

    u8 byInstID = 0;
    CApp *pcApp = &g_cMcuVcApp;
   // CMcuVcInst* pcVcInst = NULL;

    switch( cServMsg.GetEventId() )
    {
    // zbq [03/26/2007] GK 计费注册情况通知
    case MT_MCU_CHARGE_REGGK_NOTIF:

        if ( 0 != cServMsg.GetErrorCode() )
        {
            // 只有计费的MCU的数量超出 GK容量：128
            NotifyMcsAlarmInfo( 0, cServMsg.GetErrorCode() );
            g_cMcuVcApp.SetChargeRegOK( FALSE );
        }
        else
        {
            g_cMcuVcApp.SetChargeRegOK( TRUE );
        }

        CMcuVcInst * pcVcInst;
        for ( ; byInstID <= MAXNUM_MCU_CONF; byInstID++ )
        {
            pcVcInst = (CMcuVcInst *)pcApp->GetInstance(byInstID);
            if ( NULL != pcVcInst )
            {
                if( STATE_IDLE != pcVcInst->CurState() )
                {
                    g_cMcuVcApp.SendMsgToConf( pcVcInst->m_byConfIdx, cServMsg.GetEventId(),
                                               cServMsg.GetServMsg(), cServMsg.GetServMsgLen() );
                }
            }
        }
        break;

    case MT_MCU_CONF_STARTCHARGE_ACK:
		
        g_cMcuVcApp.SendMsgToConf( cServMsg.GetConfIdx(), cServMsg.GetEventId(), 
                              cServMsg.GetServMsg(), cServMsg.GetServMsgLen() );
        ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT, "conf<%d> start charge success !\n", cServMsg.GetConfIdx() );
        break;
        
    case MT_MCU_CONF_STARTCHARGE_NACK:

		NotifyMcsAlarmInfo( 0, cServMsg.GetErrorCode() );        
        g_cMcuVcApp.SendMsgToConf( cServMsg.GetConfIdx(), cServMsg.GetEventId(), NULL, 0 );
        ConfPrint(LOG_LVL_WARNING, MID_MCU_MT, "conf<%d> start charge failed !\n", cServMsg.GetConfIdx() );
        break;

    case MT_MCU_CONF_STOPCHARGE_ACK:

        g_cMcuVcApp.SendMsgToConf( cServMsg.GetConfIdx(), cServMsg.GetEventId(), NULL, 0 );
        ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT, "conf<%d> stop charge success !\n", cServMsg.GetConfIdx() );
    	break;

    case MT_MCU_CONF_STOPCHARGE_NACK:

		NotifyMcsAlarmInfo( 0, cServMsg.GetErrorCode() );
        ConfPrint(LOG_LVL_WARNING, MID_MCU_MT, "conf<%d> stop charge failed !\n", cServMsg.GetConfIdx() );
        break;

	case MT_MCU_CONF_CHARGEEXP_NOTIF:

		NotifyMcsAlarmInfo( 0, cServMsg.GetErrorCode() );
		g_cMcuVcApp.SendMsgToConf( cServMsg.GetConfIdx(), cServMsg.GetEventId(), NULL, 0 );
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT, "conf<%d> charge status has got exception !\n", cServMsg.GetConfIdx() );
		break;

    default:
        break;
    }
    return;
}

/*=============================================================================
    函数名      ：DaemonProcNPlusRegBackupRsp
    功能        ：N+1 备份主MCU注册备份MCU响应处理
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
-------------------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    06/12/18    4.0         张宝卿         创建
=============================================================================*/
void CMcuVcInst::DaemonProcNPlusRegBackupRsp( const CMessage * pcMsg )
{
    // 这里只处理NACK，ACK相关可以在读状态的时候直接读到
    if ( MCU_NPLUS_REG_NACK != pcMsg->event )
    {
        ConfPrint( LOG_LVL_WARNING, MID_MCU_NPLUS, "[DaemonProcNPlusRegBackupRsp] unexpected msg.%d<%s> received !\n",
                                                pcMsg->event, OspEventDesc(pcMsg->event) );
        return;
    }
    if ( MCU_NPLUS_MASTER_IDLE != g_cNPlusApp.GetLocalNPlusState() ) 
    {
        ConfPrint( LOG_LVL_WARNING, MID_MCU_NPLUS, "[DaemonProcNPlusRegBackupRsp] unexpected NPlus state.%d !\n",
                                                   g_cNPlusApp.GetLocalNPlusState() );
        return;
    }
    // guzh [1/15/2007]
/*
    //更新McuStatus
    CServMsg cServMsg( pcMsg->content, pcMsg->length );
    TMcuStatus tMcuStatus;
    if ( GetMcuCurStatus(tMcuStatus) ) 
    {
        tMcuStatus.m_byNPlusState = (u8)cServMsg.GetErrorCode();
    }
*/
    return;
}

/*=============================================================================
  函 数 名： AssignIdleConfInsID
  功    能： 分配会议空闲实例
  算法实现： 
  全局变量： 
  参    数： void
             u8 byStartInsId 
  返 回 值： u8 
=============================================================================*/
u8 CMcuVcInst::AssignIdleConfInsID(u8 byStartInsId)
{
    CApp *pcApp = &g_cMcuVcApp;
    CMcuVcInst* pcVcInst = NULL;
    for (u8 byInstID = byStartInsId; byInstID <= MAXNUM_MCU_CONF; byInstID++)
    {
        pcVcInst = (CMcuVcInst *)pcApp->GetInstance(byInstID);
        if (NULL != pcVcInst)
        {
            if(STATE_IDLE == pcVcInst->CurState())
            {
                return byInstID;
            }
        }
    }

    return 0;
}

/*====================================================================
    函数名      ：DaemonProcMcsMcuCreateConfReq
    功能        ：处理会控召开的会议
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    07/01/25    4.0         张宝卿         创建
====================================================================*/
void CMcuVcInst::DaemonProcMcsMcuCreateConfReq(const CMessage * pcMsg)
{
    CServMsg cServMsg( pcMsg->content, pcMsg->length );

    u8 byInsID = 0;
    if ( g_cMcuVcApp.GetMpNum() > 0 || 
         g_cMcuVcApp.GetMtAdpNum(PROTOCOL_TYPE_H323) > 0 )
    {
        // N+1 模式下，不允许会控创会
        if ( g_cNPlusApp.GetLocalNPlusState() != MCU_NPLUS_SLAVE_IDLE &&
             g_cNPlusApp.GetLocalNPlusState() != MCU_NPLUS_SLAVE_SWITCH )
        {
            byInsID = AssignIdleConfInsID(byInsID+1);
            if(0 != byInsID)
            {
                cServMsg.SetConfIdx(0);
                cServMsg.SetSrcMtId(CONF_CREATE_MCS);
                ::OspPost(MAKEIID( AID_MCU_VC, byInsID ), MCS_MCU_CREATECONF_REQ, 
                                cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
                //CApp *pcApp = &g_cMcuVcApp;
                //CMcuVcInst *pInst = (CMcuVcInst *)pcApp->GetInstance( byInsID );
            }
            else
            {
                SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
                ConfPrint(LOG_LVL_ERROR, MID_MCU_MCS, "[DaemonProcMcsMcuCreateConfReq] assign instance id failed!\n");
            }                        
        }
        else
        {
            NotifyMcsAlarmInfo( cServMsg.GetSrcSsnId(), ERR_MCU_NPLUS_CREATETEMPLATE );
        }
    }
    else
    {
        //一般不会跑到这里
        NotifyMcsAlarmInfo( cServMsg.GetSrcSsnId(), ERR_MCU_CREATECONF_MCS_NOMPMTADP );
    }
    
    return;
}

/*====================================================================
    函数名      ：ProcTimerWaitMpRegCheck
    功能        ：(1) 定时检查Mp是否注册, 从而开启相应等待开启的会议
                  (2) 如果是即时会议，置实例状态 STATE_WAITFOR
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/03/17    3.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::ProcTimerWaitMpRegCheck( const CMessage * pcMsg )
{
    CServMsg cServMsg;
	
	u16 wAliasBufLen = 0;
	u8* pbyAliasBuf  = NULL; //终端别名数组打包缓冲
	u8* pbyModuleBuf = NULL; //电视墙//画面合成模板缓冲
    u8 byInsID = 0;
// 	u8 achMTPackInfo[SERV_MSG_LEN - SERV_MSGHEAD_LEN];  //存放分组信息的缓存

    BOOL32 bHasMpMtAdp = (g_cMcuVcApp.GetMpNum() > 0 && 
                          g_cMcuVcApp.GetMtAdpNum(PROTOCOL_TYPE_H323) > 0);

    BOOL32 bPowerOn = (BOOL32)(*(u32*)pcMsg->content);

    // guzh [4/13/2007] 修改策略
    // 目前策略为：上电后第一次即刻恢复所有模版
    // 但是会议则等待MP/MtAdp

	for (u8 byLoop = 0; byLoop < (MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE); byLoop++)
	{
        if ( !bPowerOn && !bHasMpMtAdp )
        {
            break;
        }
        
		TConfStore tConfStoreBuf;
		TPackConfStore *ptPackConfStore = (TPackConfStore *)&tConfStoreBuf;	

		//提取后的 tConfStore 为 TPackConfStore 结构，即已进行Pack处理的会议数据
        if (g_cMcuVcApp.HasConfStore( byLoop ) && ::GetConfFromFile(byLoop, ptPackConfStore))
		{
			wAliasBufLen = htons(ptPackConfStore->m_wAliasBufLen);
			pbyAliasBuf  = (u8 *)(ptPackConfStore+1);
			pbyModuleBuf = pbyAliasBuf+ptPackConfStore->m_wAliasBufLen;

			
            // guzh [4/11/2007] 在这里标记从文件创会
			if(ptPackConfStore->m_tConfInfo.m_tStatus.IsTemplate())
			{
				//上报给界面时，TakeFromFile应为0[3/22/2012 chendaiwei]
				ptPackConfStore->m_tConfInfo.m_tStatus.SetTakeFromFile(FALSE);
			}
			else
			{
				ptPackConfStore->m_tConfInfo.m_tStatus.SetTakeFromFile(TRUE);
			}

            cServMsg.SetMsgBody((u8*)&ptPackConfStore->m_tConfInfo, sizeof(TConfInfo));
            cServMsg.CatMsgBody((u8*)&wAliasBufLen, 2 );
            cServMsg.CatMsgBody(pbyAliasBuf, ntohs(wAliasBufLen) );

            //电视墙模板 
			TConfAttrb tConfAttrb = ptPackConfStore->m_tConfInfo.GetConfAttrb();
            if (tConfAttrb.IsHasTvWallModule())
            {
                cServMsg.CatMsgBody(pbyModuleBuf, sizeof(TMultiTvWallModule));
                pbyModuleBuf += sizeof(TMultiTvWallModule);
            }
            //画面合成模板 
            if (tConfAttrb.IsHasVmpModule())
            {
                cServMsg.CatMsgBody(pbyModuleBuf, sizeof(TVmpModule));
                pbyModuleBuf += sizeof(TVmpModule);
			}

			// 对于VCS创建的会议模板，包含所需要的额外信息 
			//                  + 1byte(u8: 0 1  是否配置了高清电视墙)
			//                  +(可选, THDTvWall)
			//                  + 1byte(u8: 会议配置HDU的通道总数)
			//                  + (可选, THduModChnlInfo+...)	
			//                  + 1byte(是否为级联调度)＋(可选，2byte[u16 网络序，配置打包的总长度]+下级mcu配置[1byte(终端类型)+1byte(别名长度)+xbyte(别名字符串)+2byte(呼叫码率)...)])
			//                  + 1byte(是否支持分组)＋(可选，2byte(u16 网络序，信息总长)+内容(1byte(组数)+n组[1TVCSGroupInfo＋m个TVCSEntryInfo])
			//                  + 1 TMtAlias (本地地址备份)
			//					+ 1 u8 ( 自动转成指定模式 )

			u8* pbyVCSInfoBuf = pbyModuleBuf;

			if (VCS_CONF == ptPackConfStore->m_tConfInfo.GetConfSource())
			{

				u8 byIsSupportHDTW = *pbyVCSInfoBuf++;
				cServMsg.CatMsgBody(&byIsSupportHDTW, sizeof(u8));
				if (byIsSupportHDTW)
				{
					cServMsg.CatMsgBody((u8*)pbyVCSInfoBuf, sizeof(THDTvWall));
					pbyVCSInfoBuf += sizeof(THDTvWall);
				}

				u8 byHduNum = *pbyVCSInfoBuf++;
				cServMsg.CatMsgBody(&byHduNum, sizeof(u8));
				if (byHduNum)
				{
					cServMsg.CatMsgBody((u8*)pbyVCSInfoBuf, byHduNum * sizeof(THduModChnlInfo));
					pbyVCSInfoBuf += byHduNum * sizeof(THduModChnlInfo);
				}
				
				u8 bySMCUExist = *pbyVCSInfoBuf++;
				cServMsg.CatMsgBody(&bySMCUExist, sizeof(u8));
				if (bySMCUExist)
				{
					wAliasBufLen = htons(*(u16*)pbyVCSInfoBuf);
					cServMsg.CatMsgBody((u8*)&wAliasBufLen, sizeof(u16));
					pbyVCSInfoBuf += sizeof(u16);
					wAliasBufLen = ntohs(wAliasBufLen);
					cServMsg.CatMsgBody((u8*)pbyVCSInfoBuf, wAliasBufLen);
					pbyVCSInfoBuf += wAliasBufLen;					
				}

				// 会议模板中不包含分组信息
				u8 byMTPackExist = *pbyVCSInfoBuf++;
				byMTPackExist = FALSE;
				cServMsg.CatMsgBody(&byMTPackExist, sizeof(u8));
				//zhouyiliang 20100820 增加备份终端
				cServMsg.CatMsgBody((u8*)pbyVCSInfoBuf, sizeof(TMtAlias));
				pbyVCSInfoBuf += sizeof(TMtAlias);

				// [4/20/2011 xliang] VCAutoMode
				cServMsg.CatMsgBody((u8*)pbyVCSInfoBuf, sizeof(u8));
				pbyVCSInfoBuf ++;
			}

			u16 wConInfoExLength = ntohs(*(u16*)pbyVCSInfoBuf);
				
			if ( wConInfoExLength + sizeof(u16) > CONFINFO_EX_BUFFER_LENGTH ) 
			{
				LogPrint(LOG_LVL_WARNING,MID_MCU_CONF,"[ProcTimerWaitMpRegCheck] wConInfoExLength.%d > CONFINFO_EX_BUFFER_LENGTH,error!\n",wConInfoExLength);

				continue;
			}
			else
			{
				cServMsg.CatMsgBody((u8*)pbyVCSInfoBuf,wConInfoExLength + sizeof(u16));
#ifdef _UTF8
				// 多国语言:解析编码方式，Mcs模板需要转换，消息要重新设置 [pengguofeng 4/15/2013]
				if ( ptPackConfStore->m_tConfInfo.GetConfSource() == MCS_CONF )
				{
					TConfInfoEx tConfInfoEx;
					u8 byEncoding = emenCoding_GBK;
					BOOL32 bExistUnknown = FALSE;
					THduVmpModuleOrTHDTvWall tHduVmpModule;
					TVmpModuleInfo tVmpModule;
					UnPackConfInfoEx(tConfInfoEx, pbyVCSInfoBuf, wConInfoExLength, bExistUnknown,
						&tHduVmpModule, &tVmpModule, &byEncoding);
					LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ProcTimerWaitMpRegCheck]Mcs Conf%d Template Encoding:%d\n", byLoop, byEncoding);
					if ( byEncoding == emenCoding_GBK )
					{
						LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[ProcTimerWaitMpRegCheck]confinfo_%d.dat is GBK, will trans to UTF8 in memory\n", byLoop);
						// 修改cServMsg中关于confinfo的部分 [pengguofeng 4/15/2013] 直接用pbyAliasBuf
						TConfInfo tConfInfo = ptPackConfStore->m_tConfInfo;
						// 					memset(&tConfInfo, 0, sizeof(tConfInfo));
						TMtAlias atMtAlias[MAXNUM_CONF_MT];
						memset(atMtAlias, 0, sizeof(atMtAlias));
						u16 awDialBr[MAXNUM_CONF_MT];
						memset(awDialBr, 0, sizeof(awDialBr));
						u8 byMtNum = 0;
						UnPackTMtAliasArray((s8*)pbyAliasBuf, ptPackConfStore->m_wAliasBufLen, &tConfInfo, atMtAlias, awDialBr, byMtNum);
						s8 achConfName[MAXLEN_CONFNAME+1] = {0};
						gb2312_to_utf8(tConfInfo.GetConfName(), achConfName, MAXLEN_CONFNAME);
						tConfInfo.SetConfName(achConfName);
						//  [pengguofeng 5/10/2013] 修改AES加密信息,理由：old界面允许输中文
						s8 achEncKey[MAXLEN_KEY];
						memset(achEncKey, 0, sizeof(achEncKey));
						s32 byEncKeyLen = 0;
						TMediaEncrypt tMediaEnc = tConfInfo.GetMediaKey();
						tMediaEnc.GetEncryptKey((u8*)achEncKey, &byEncKeyLen);
						s8 achModEncKey[MAXLEN_KEY];
						u8 byModEncKeyLen =0;
						byModEncKeyLen = gb2312_to_utf8(achEncKey, achModEncKey, MAXLEN_KEY-1);
						if ( byModEncKeyLen > 0 )
						{
							tMediaEnc.SetEncryptKey((u8*)achModEncKey, byModEncKeyLen);
							tConfInfo.SetMediaKey(tMediaEnc);
						}
						// 修改cServMsg中MtAlias的部分
						s8 achMtAlias[MAXLEN_ALIAS];
						for ( u8 byMtId = 0;byMtId < byMtNum; byMtId++)
						{
							memset(achMtAlias, 0, sizeof(achMtAlias));
							if ( atMtAlias[byMtId].m_AliasType == mtAliasTypeH320ID )
							{
								//320终端名称不作转换，原因：界面要取了判断
							}
							else if ( atMtAlias[byMtId].m_AliasType == puAliasTypeIPPlusAlias)
							{
								// 不需要转换，理由：u32(ip) + E164(仅由ACSII码组成) [pengguofeng 4/17/2013]
								// 								gb2312_to_utf8(&atMtAlias[byMtId].m_achAlias[sizeof(u32)], achMtAlias, MAXLEN_ALIAS-sizeof(u32));
								// 								achMtAlias[MAXLEN_ALIAS-1] = 0;
								// 								memcpy(&atMtAlias[byMtId].m_achAlias[sizeof(u32)], achMtAlias, strlen(achMtAlias));
							}
							else
							{
								gb2312_to_utf8(atMtAlias[byMtId].m_achAlias, achMtAlias, MAXLEN_ALIAS-1);
								memcpy(atMtAlias[byMtId].m_achAlias, achMtAlias, strlen(achMtAlias));
							}
						}
						u16 wNewPackLen = 0;
						PackTMtAliasArray(atMtAlias, awDialBr, byMtNum, (s8*)pbyAliasBuf, wNewPackLen);
						LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ProcTimerWaitMpRegCheck]GBK temp trans from %d to %d\n",
							ptPackConfStore->m_wAliasBufLen, wNewPackLen);
						
						//把无关的先拷贝出来
						u16 wUnChgedLen = cServMsg.GetMsgBodyLen() - sizeof(tConfInfo) - 2 - ptPackConfStore->m_wAliasBufLen;
						s8 achTemp[SERV_MSG_LEN-SERV_MSGHEAD_LEN];
						memset(achTemp, 0, sizeof(achTemp));
						memcpy(achTemp, cServMsg.GetMsgBody()+ sizeof(tConfInfo) + 2 + ptPackConfStore->m_wAliasBufLen, wUnChgedLen);
						cServMsg.SetMsgBody((u8*)&tConfInfo, sizeof(tConfInfo));
						u16 wNetOrderPackLen = htons(wNewPackLen);
						cServMsg.CatMsgBody((u8*)&wNetOrderPackLen, 2);
						cServMsg.CatMsgBody(pbyAliasBuf, wNewPackLen);
						cServMsg.CatMsgBody((u8*)achTemp, wUnChgedLen);
					}
				}
				else
				{
					LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ProcTimerWaitMpRegCheck]Vcs Conf:%d not need to trans to Utf8\n", byLoop);
				}
#endif
			}

            if ( ptPackConfStore->m_tConfInfo.m_tStatus.IsTemplate() && bPowerOn)
            {
                // 如果是模版,则保存  
				TTemplateInfo  tTemInfo;
                g_cMcuVcApp.Msg2TemInfo(cServMsg, tTemInfo);
				
				//设置标志位[3/22/2012 chendaiwei]
				tTemInfo.m_tConfInfo.m_tStatus.SetTakeFromFile(TRUE);
                g_cMcuVcApp.AddTemplate(tTemInfo);

                g_cMcuVcApp.SetConfRegState( byLoop + 1, FALSE );
                SendMsgToAllMcs(MCU_MCS_TEMSCHCONFINFO_NOTIF, cServMsg); 
	
                CConfId cConfId = tTemInfo.m_tConfInfo.GetConfId();
				NotifyVCSPackInfo(cConfId);

                continue;
            }
            else if (!ptPackConfStore->m_tConfInfo.m_tStatus.IsTemplate() &&
                     bHasMpMtAdp && 
					 // 对于备板，其会议由主板会议决定，无需根据自身会议创会，耗费资源
					 MCU_MSSTATE_STANDBY != g_cMSSsnApp.GetCurMSState() &&
                     //zbq [02/02/2010] N+1备份允许主机恢复自身会议；若与回滚冲突，以N+1为高优先级；
                     //g_cNPlusApp.GetLocalNPlusState() != MCU_NPLUS_MASTER_CONNECTED &&
                     //g_cNPlusApp.GetLocalNPlusState() != MCU_NPLUS_MASTER_IDLE &&
					 MCS_CONF == ptPackConfStore->m_tConfInfo.GetConfSource() )//zjj20090910
            {                
                byInsID = AssignIdleConfInsID(byInsID+1);
                if(0 != byInsID)
                {
                    cServMsg.SetConfIdx(byLoop+1);
                    ::OspPost(MAKEIID( AID_MCU_VC, byInsID ), MCU_CREATECONF_FROMFILE, 
                        cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
                    CApp *pcApp = &g_cMcuVcApp;
                    CMcuVcInst *pInst = (CMcuVcInst *)pcApp->GetInstance( byInsID );
                    pInst->NextState(STATE_WAITFOR);

                    ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "MCU_CREATECONF_FROMFILE send to Ins.%d, byLoop.%d\n", byInsID, byLoop);
                }
            }
		}
	}

	if (!bHasMpMtAdp)
	{
		SetTimer( MCUVC_WAIT_MPREG_TIMER, TIMESPACE_WAIT_MPREG, FALSE);
		if ( 0 == g_cMcuVcApp.GetMpNum())
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[MCU]: NO Mp regitered, Waiting......\n" );
		}
		if ( 0 == g_cMcuVcApp.GetMtAdpNum(PROTOCOL_TYPE_H323))
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[MCU]: NO MtAdp regitered, Waiting......\n" );
		}
	}
	else
	{
		//  发送power_on消息给Nplus业务,以启动NPlus业务[6/5/2012 chendaiwei]
		PowerOnNPlusApp();
	
	}
	
	return;
}


/*====================================================================
    函数名      ProcMsSynRecoverConfTimer
    功能        ：主备情况，主板恢复会议后要给备板同步数据
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    12/09/12    4.7         周翼亮        创建
====================================================================*/
void CMcuVcInst::ProcMsSynRecoverConfTimer( const CMessage * pcMsg )
{	
	KillTimer( MCUVC_RECOVERCONF_SYN_TIMER );
	if ( NULL == pcMsg ) 
	{
		StaticLog("[ProcMsSynRecoverConfTimer]pcMsg isNull !\n");
		return;
	}
	CServMsg cServMsg(pcMsg->content,pcMsg->length);
	if ( cServMsg.GetMsgBodyLen() > 0 )//Timer是具体会议发过来的，判断byStart是否为1
	{
		u8 byStart = *(u8*)cServMsg.GetMsgBody();
		if (byStart == 1)
		{
			SetTimer(MCUVC_RECOVERCONF_SYN_TIMER,MS_SYN_MIN_SPAN_TIMEOUT);
		}
		else//timer消息，发过来是错误的
		{
			StaticLog("[ProcMsSynRecoverConfTimer] error timer,byStart:%d\n",byStart);
		}
	}
	else//这次timer不是具体会议发过来的，此时要给MSManager发主备同步,有可能会有多次因为有些会议需要等外设注册才恢复
	{
		if (g_cMSSsnApp.IsDoubleLink())
		{
			ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ProcMsSynRecoverConfTimer]Conferences recover succeed,tell MSmanager to synac !\n" );
			OspPost(MAKEIID(AID_MCU_MSMANAGERSSN, 1),MCU_MCU_SYN_TIMER);
		}
	}
	

}

/*====================================================================
    函数名      ：PowerOnNPlusApp
    功能        ：发送power_on消息给Nplus业务
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	12/06/06    4.7         chendaiei     create
====================================================================*/
void CMcuVcInst::PowerOnNPlusApp( void )
{
    // [3/18/2013 liaokang] 支持主备N+1备双备份
// 	//N+1备份 与 热备份互斥
// 	if (!g_cMSSsnApp.IsDoubleLink())
// 	{
    //初始化N+1备份状态
    BOOL32 bNPlusMode = g_cNPlusApp.InitNPlusState();
    if (bNPlusMode)
    {
        OspPost(MAKEIID(AID_MCU_NPLUSMANAGER, CInstance::DAEMON), OSP_POWERON);
    }
//	} 
	
	return;
}

/*====================================================================
    函数名      ：ProcTimerScheduledCheck
    功能        ：预约会议定时检查处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/08/01    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcTimerScheduledCheck( const CMessage * pcMsg )
{
	CServMsg cServMsg;
	ConfPrint(LOG_LVL_DETAIL,MID_MCU_CONF,"[ProcTimerScheduledCheck] state.%d time(NULL).%d StartTime.%d\n",
		CurState(),time(NULL),m_tConf.GetStartTime());	

	switch( CurState() )
	{
	case STATE_SCHEDULED:

		//周期性预约会议
		if( m_tConf.IsCircleScheduleConf() )
		{
			//当前是否符合开启条件
			BOOL32 bScheduleConfNeedStart = IsCircleScheduleConfNeedStart();
			if (  bScheduleConfNeedStart )//打包会议信息，开启即时会议
			{
				//临时修改confinfo为即时会议打包信息，开启即时会议后恢复
				TConfInfo tOrigInfo = m_tConf;
				m_tConf.m_tStatus.SetOngoing();
				m_tConf.SetStartTime(time(NULL));
				//清掉周期性预约会议模式
				m_tConf.ClearSchedulConfMode();
				g_cMcuVcApp.ConfInfoMsgPack(this, cServMsg);
				cServMsg.SetSrcMtId( CONF_CREATE_SCH );
				cServMsg.SetConfIdx(m_byConfIdx);

				u8 byInsID = AssignIdleConfInsID(GetInsID()+1);
				if(0 != byInsID)
				{
					::OspPost(MAKEIID( AID_MCU_VC, byInsID ), MCU_SCHEDULE_CONF_START, 
						cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ProcTimerScheduledCheck]MCU_SCHEDULE_CONF_START send to Ins.%d\n", byInsID);
					
					
				}
				else//没有空闲的instance，无法开启
				{
					cServMsg.SetErrorCode( ERR_MCU_CONFNUM_EXCEED );
					SendMsgToAllMcs(MCU_MCS_ALARMINFO_NOTIF,cServMsg);
					ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[ProcTimerScheduledCheck] no idle confinst!\n");
					
				}
				//恢复本预约会议的confinfo信息
				m_tConf = tOrigInfo;
				
			}
		
			
			//更新本预约会议的下次开启时间
			TKdvTime tNextOngoingtime = GetNextOngoingTime(m_tConf,m_tConfEx.GetDurationDate());
			TKdvTime tNullTime;//构造为memset为0
			//下次开启时间为空，表明再也开不了即时会议了，结会
			if ( tNextOngoingtime == tNullTime )
			{
				//结会，给mcs回提示
				cServMsg.SetErrorCode( ERR_MCU_CIRCLESCHEDULECONF_WILLNOT_START );
				SendMsgToAllMcs(MCU_MCS_ALARMINFO_NOTIF,cServMsg);
				ConfPrint( LOG_LVL_WARNING, MID_MCU_CONF, "[ProcTimerScheduledCheck]CircleScheduleConference %s cannot start ongoing again,releaseconf!\n", m_tConf.GetConfName() );
				KillTimer(MCUVC_SCHEDULED_CHECK_TIMER);
				ReleaseConf();
				NextState(STATE_IDLE);        
				return;
			}

			//当前开启成功即时会议，且下次开启时间不为空，更新下次开启时间到confinfoex，通知mcs，存文件
			TKdvTime tCurNextTime = m_tConfEx.GetNextStartTime();
			//即使没有本次没开启成功，但是下次开启时间变了，也要更新
			if ( bScheduleConfNeedStart || !(tCurNextTime == tNextOngoingtime) )
			{
				m_tConfEx.SetNextStartTime(&tNextOngoingtime);
				//通知mcs
				g_cMcuVcApp.ConfInfoMsgPack(this, cServMsg);
				SendMsgToAllMcs( MCU_MCS_TEMSCHCONFINFO_NOTIF, cServMsg );
				//更新文件的nextstarttime
				BOOL32 bRetTmp = g_cMcuVcApp.SaveConfToFile( m_byConfIdx, FALSE );
				if (!bRetTmp)
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[ProcTimerScheduledCheck]SaveConfToFile error!!!\n");
				}
			}
		
			//继续settimer检测
			time_t nTimeNow = time(NULL);
			long lTimerInterval = TIMESPACE_SCHEDULED_CHECK;
			time_t nNextStartTime;
			m_tConfEx.GetNextStartTime().GetTime(nNextStartTime);
			if ( (nTimeNow + 60) > nNextStartTime )
			{
				lTimerInterval = ( nNextStartTime - nTimeNow )*1000;
			}
			SetTimer( MCUVC_SCHEDULED_CHECK_TIMER, lTimerInterval );
			break;
		
		}
		else //非周期性预约会议
		{
			time_t temptime = m_tConf.GetStartTime();
			//时间校验,当前时间已经过了会议开启的时间半小时或持续时间+开启时间（可能是mpc时间更新导致），结会，通知mcs
			if ( (m_tConf.GetDuration() == 0 && time( NULL ) > temptime + 30 * 60 ) || 
				( m_tConf.GetDuration() != 0 && time( NULL ) > temptime + m_tConf.GetDuration() * 60 ) 
				)
			{
				cServMsg.SetErrorCode(ERR_MCU_STARTTIME_WRONG);
				SendMsgToAllMcs(MCU_MCS_ALARMINFO_NOTIF,cServMsg);
				ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[ProcTimerScheduledCheck] starttime error!\n");
				KillTimer(MCUVC_SCHEDULED_CHECK_TIMER);
				ReleaseConf();
				NextState(STATE_IDLE);
				return;
			}
			
			//未到开始时间
			if( time( NULL ) < m_tConf.GetStartTime() )	
			{
				ConfPrint(LOG_LVL_DETAIL,MID_MCU_CONF,"[ProcTimerScheduledCheck] SetTimer for time(NULL).%d < StartTime.%d\n",time(NULL),m_tConf.GetStartTime());	
				time_t nTimeNow = time(NULL);
				long lTimerInterval = TIMESPACE_SCHEDULED_CHECK;
				if ( (nTimeNow + 60) > m_tConf.GetStartTime())
				{
					lTimerInterval = ( m_tConf.GetStartTime() - nTimeNow )*1000;
				}
				SetTimer( MCUVC_SCHEDULED_CHECK_TIMER, lTimerInterval );
			break;
				break;
			}
			else //可以开启即时会议
			{
				// guzh [5/17/2007] 标记为即时会议
				m_tConf.m_tStatus.SetOngoing();
				g_cMcuVcApp.ConfInfoMsgPack(this, cServMsg);
				
				cServMsg.SetSrcMtId( CONF_CREATE_SCH );
				cServMsg.SetConfIdx(m_byConfIdx);
				
				//不要使用别名转发；虽然此消息能正确发出，但在ReleaseConf()）中，别名又会被删除
				post( MAKEIID( GetAppID(), GetInsID() ), MCU_SCHEDULE_CONF_START, cServMsg.GetServMsg(), cServMsg.GetServMsgLen() );
				
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "CMcuVcInst: A Scheduled conference %s started!\n", m_tConf.GetConfName() );
				
				//release conference
				ReleaseConf( TRUE );
				
				NEXTSTATE( STATE_IDLE );
			}
			
		}
		break;
	default:
		ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}
}

/*====================================================================
    函数名      ：ProcTimerOngoingCheck
    功能        ：进行中会议定时检查是否结束处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/08/01    1.0         LI Yi         创建
	03/11/15    3.0         胡昌威        修改
====================================================================*/
void CMcuVcInst::ProcTimerOngoingCheck( const CMessage * pcMsg )
{
	CServMsg	cServMsg;
	u16 wLeftMin;

	switch( CurState() )
	{
	case STATE_ONGOING:
		//会议结束前一刻钟提示所有会控与主席终端
		if( time( NULL ) > m_tConf.GetStartTime() + m_tConf.GetDuration() * 60 - 15*60 )	//not stop
		{
			wLeftMin = m_tConf.GetDuration() - (time( NULL ) - m_tConf.GetStartTime())/60;

			if( wLeftMin == 15 || wLeftMin == 10 || wLeftMin == 5 
				|| wLeftMin == 4 || wLeftMin == 3|| wLeftMin == 2 || wLeftMin == 1 )
			{
				wLeftMin = htons( wLeftMin );
				cServMsg.SetMsgBody( (u8*)&wLeftMin, 2);  

				BroadcastToAllSubMtJoinedConf( MCU_MT_CONFWILLEND_NOTIF, cServMsg );   
				SendMsgToAllMcs( MCU_MCS_CONFTIMELEFT_NOTIF, cServMsg );
			}
		}

        //检查是否到了结束时间
		if( time( NULL ) < m_tConf.GetStartTime() + m_tConf.GetDuration() * 60 )	//not stop
		{
			SetTimer( MCUVC_ONGOING_CHECK_TIMER, TIMESPACE_ONGOING_CHECK );
			break;
		}
		
		//结束会议
		ReleaseConf( TRUE );
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "Conference %s released at stop time!\n", m_tConf.GetConfName() );

		NEXTSTATE( STATE_IDLE );
		break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}
}

/*====================================================================
    函数名      ：ProcTimerInviteUnjoinedMt
    功能        ：定时邀请未与会终端处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/01/03    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcTimerInviteUnjoinedMt( const CMessage * pcMsg )
{
	CServMsg	cServMsg;
    TMt tMt;
	u8  byLoop;

#ifdef _DEBUG
	s8	achStr[64];
	m_tConf.GetConfId().GetConfIdString( achStr, sizeof( achStr ) );
	log( LOGLVL_DEBUG1, "CMcuVcInst: Conference %s (confid=%s) now invite all unjoined MT!\n", 
		m_tConf.GetConfName(), achStr );
#endif

	switch( CurState() )
	{
	case STATE_ONGOING:

		//send invite message to all connected MTs
		cServMsg.SetConfId( m_tConf.GetConfId() );
		cServMsg.SetNoSrc();
		cServMsg.SetTimer( TIMESPACE_WAIT_AUTOINVITE );
		cServMsg.SetMsgBody( NULL, 0 );
		for( byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
		{
			if(!m_tConfAllMtInfo.MtInConf( byLoop ) )
			{
				continue;
			}
			if(m_tConfAllMtInfo.MtJoinedConf(byLoop))
			{
				continue;
			}
            // libo [3/30/2005]
            if (m_ptMtTable->GetAddMtMode(byLoop) == ADDMTMODE_CHAIRMAN)
			{
				continue;
			}
            // libo [3/30/2005]end

			if( CONF_CALLMODE_TIMER == m_ptMtTable->GetCallMode( byLoop ) )
			{
				u32 dwLeftTimes = m_ptMtTable->GetCallLeftTimes( byLoop );

				//无穷次呼叫，则直接进行呼叫
				if( DEFAULT_CONF_CALLTIMES == m_tConf.m_tStatus.GetCallTimes() )
				{
					tMt = m_ptMtTable->GetMt( byLoop );
					InviteUnjoinedMt( cServMsg, &tMt );
				}
				//有限次呼叫，检测剩余呼叫次数
				else if( dwLeftTimes > 0 )
				{
					dwLeftTimes--;
					m_ptMtTable->SetCallLeftTimes( byLoop, dwLeftTimes );
					tMt = m_ptMtTable->GetMt( byLoop );
					InviteUnjoinedMt( cServMsg, &tMt );
				}
			}			
		}		
		
		SetTimer( MCUVC_INVITE_UNJOINEDMT_TIMER, 1000*m_tConf.m_tStatus.GetCallInterval() );	
		
		break;
	default:
		ConfPrint( LOG_LVL_ERROR, MID_MCU_CALL, "VcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}
}

/*====================================================================
    函数名      ：ProcCommonOperAck
    功能        ：终端或外设操作同意应答统一处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/14    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcCommonOperAck( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );

	switch( CurState() )
	{
	case STATE_ONGOING:
		if (cServMsg.GetSrcSsnId() != 0)
		{
			//send messge
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
		}
		break;

	default:
		ConfPrint( LOG_LVL_ERROR, MID_PUB_ALWAYS, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}
}

/*====================================================================
    函数名      ：ProcCommonOperNack
    功能        ：终端或外设操作拒绝应答统一处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/14    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcCommonOperNack( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );

	switch( CurState() )
	{
	case STATE_ONGOING:
		{
			// vrs新录播直接释放相关信息
			TMt	tMt = m_ptMtTable->GetMt( cServMsg.GetSrcMtId() );
			if (!tMt.IsNull() && tMt.GetType() == TYPE_MT && tMt.GetMtType() == MT_TYPE_VRSREC)
			{
				// vrs回复nack，需要上报MCU_MCS_RECORDEREXCPT_NOTIF消息提示
				ReleaseVrsMt(tMt.GetMtId(), cServMsg.GetErrorCode());
				return;
			}

			// [pengjie 2010/9/25] 对于会议或终端录像，如果录像机回了NACK，不能只上报界面，还要释放之前占用的回传资源
			if(pcMsg->event == REC_MCU_STARTREC_NACK)
			{
				if (cServMsg.GetMsgBodyLen() >= sizeof(TMt))
				{
					TMt tRecMt = *(TMt *)cServMsg.GetMsgBody();
					if( tRecMt.GetEqpId() == 0 )//tRecMt.IsNull() ) // 会议录像
					{
						//tRecMt = m_tConf.GetSpeaker();
						
						// [11/10/2010 liuxu]会议录像请求失败，将申请得到的Bas资源释放
						if (IsRecNeedAdapt())
						{
							ResetRecAdptParam();
						}	
					}
					else
					{
						FreeRecvSpy(tRecMt, MODE_BOTH);
					}			
				}
			}
			// End

			TAudioTypeDesc atAudDesc[MAXNUM_CONF_AUDIOTYPE];
			u8 byConfAudNum= m_tConfEx.GetAudioTypeDesc(atAudDesc);
			//zjj20130823 老录像机不支持多音频会议，所以要用不同的音频格式尝试放像，直到会议的音频格式遍历完
			if( REC_MCU_STARTPLAY_NACK == pcMsg->event && 24022 == cServMsg.GetErrorCode() &&
				 m_tPlayEqpAttrib.GetNackTryNum() < (byConfAudNum-1) )
			{
				m_tPlayEqpAttrib.SetNackTryNum( m_tPlayEqpAttrib.GetNackTryNum() + 1 );				

				TRecProg tRecProg;
				memset(&tRecProg, 0, sizeof(TRecProg));
				TEqp tEqp = m_tPlayEqpAttrib.GetEqp();				
				cServMsg.SetMsgBody((u8 *)&tEqp, sizeof(tEqp));
				cServMsg.CatMsgBody((u8 *)&tRecProg, sizeof(tRecProg));

				s8 szRecName[MAX_FILE_NAME_LEN] = {0};
				strncpy( szRecName, m_tPlayEqpAttrib.GetRecName(), MAX_FILE_NAME_LEN - 1 );    
				cServMsg.CatMsgBody((u8 *)szRecName, strlen(szRecName) + 1);

				StartPlayReq( cServMsg,m_tPlayEqpAttrib.GetNackTryNum() );

				ConfPrint( LOG_LVL_KEYSTATUS, MID_PUB_ALWAYS, "REC_MCU_STARTPLAY_NACK.%d\n",cServMsg.GetErrorCode() );
				m_tPlayEqpAttrib.Print();
				return;
			}

			//send messge
			if ( cServMsg.GetSerialNO() != 0 )
			{
				SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
			}
		}
		break;

	default:
		ConfPrint( LOG_LVL_ERROR, MID_PUB_ALWAYS, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}
}

/*====================================================================
    函数名      ：DaemonProcAppTaskRequest
    功能        ：GUARD模块探测消息处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/04/21    1.0         杨昀         创建
====================================================================*/
void CMcuVcInst::DaemonProcAppTaskRequest( const CMessage * pcMsg )
{
	post( pcMsg->srcid, MCU_APPTASKTEST_ACK, pcMsg->content, pcMsg->length );
}

/*====================================================================
    函数名      ：DaemonProcCommonNotif
    功能        ：终端或外设普通通知处理
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/20    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::DaemonProcCommonNotif( const CMessage * pcMsg )
{
	CServMsg cServMsg( pcMsg->content, pcMsg->length );
	
	switch( pcMsg->event )
	{
	case REC_MCU_EXCPT_NOTIF:
		SendMsgToAllMcs( MCU_MCS_RECORDEREXCPT_NOTIF, cServMsg );

		break;
	default:
		break;
	}
}

/*====================================================================
    函数名      ：ReleaseMtRes
    功能        ：释放MT占用的资源
    算法实现    ：
    引用全局变量：
    输入参数说明：BOOL32 bForced	[in]忽略MT类型
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/07/22    3.0         胡昌威        创建
	2/4/2009	4.5			薛亮		  修改 
====================================================================*/
void CMcuVcInst::ReleaseMtRes( u8 byMtId )
{
    u8 byDriId = m_ptMtTable->GetDriId(byMtId);

	//  [7/28/2011 chendaiwei]如果该终端占用了高清接入点，需要减少当前正在使用的高清接入点数
	//  并且设置该终端为高清接入的标志位为FALSE
	if ( g_cMcuVcApp.IsOccupyHDAccessPoint(m_byConfIdx, byMtId) )
	{
		BOOL32 bIsMcu = (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_MMCU || m_ptMtTable->GetMtType(byMtId) == MT_TYPE_SMCU) ? TRUE : FALSE;
		g_cMcuVcApp.DecMpcCurrentHDMtNum(m_byConfIdx, byMtId,bIsMcu);
	}

	TCapSupport tCapSupport;
	m_ptMtTable->GetMtCapSupport(byMtId,&tCapSupport);

	g_cMcuVcApp.DecAudMtAdpNum(m_byConfIdx, byMtId);

	// [3/11/2011 xliang] 8000G, 8000A 内置/外置统一处理
	// [3/23/2011 xliang] 即使是MCU，可能计数还没有补加前就挂断，这时它的计数是-1，而不是-2.这里不再用bIsMcu做参照
// 	BOOL32 bIsMcu = FALSE;
// 	u8 byMtType = m_ptMtTable->GetMtType(byMtId);
// 	if( ( MT_TYPE_MMCU == byMtType || MT_TYPE_SMCU == byMtType ) && !bNeglectMtType )
// 	{
// 		bIsMcu = TRUE;
// 	}

	BOOL32 bHdMt = FALSE;

	if( tCapSupport.GetMainVideoType() == MEDIA_TYPE_H264 &&
		(tCapSupport.GetMainVideoResolution() == VIDEO_FORMAT_HD1080 ||
		tCapSupport.GetMainVideoResolution() == VIDEO_FORMAT_HD720 )&&
		( byDriId == MCU_BOARD_MPC || 
		byDriId == MCU_BOARD_MPCD ) )
	{
		bHdMt = TRUE;
	}
	
	g_cMcuVcApp.DecMtAdpMtNum( byDriId, m_byConfIdx, byMtId, bHdMt );

	
//#ifdef _8KE_
// 	BOOL32 bHdMt = FALSE;
// 	if( tCapSupport.GetMainVideoType() == MEDIA_TYPE_H264 &&
// 		(tCapSupport.GetMainVideoResolution() == VIDEO_FORMAT_HD1080 ||
// 		tCapSupport.GetMainVideoResolution() == VIDEO_FORMAT_HD720 )
// 		)
// 	{
// 		bHdMt = TRUE;
// 	}
// 
// 	g_cMcuVcApp.DecMtAdpMtNum( byDriId, m_byConfIdx, byMtId, bHdMt);
// 	

//#else


	// xliang [10/27/2008] 判断是否是HD MT 且mcu内置接入
	/*
	if( tCapSupport.GetMainVideoType() == MEDIA_TYPE_H264 &&
		(tCapSupport.GetMainVideoResolution() == VIDEO_FORMAT_HD1080 ||
		tCapSupport.GetMainVideoResolution() == VIDEO_FORMAT_HD720 )&&
		( byDriId == MCU_BOARD_MPC || 
		byDriId == MCU_BOARD_MPCD ) )
	{
		g_cMcuVcApp.DecMtAdpMtNum( byDriId, m_byConfIdx, byMtId, TRUE);
	}
	else
	{
		// [pengjie 2010/2/8] Modify 这里判断该终端是不是MCU
		BOOL32 bIsMcu = FALSE;
		u8 byMtType = m_ptMtTable->GetMtType(byMtId);
		if( MT_TYPE_MMCU == byMtType || MT_TYPE_SMCU == byMtType && !bNeglectMtType )
		{
			bIsMcu = TRUE;
		}
		// End
		g_cMcuVcApp.DecMtAdpMtNum( byDriId, m_byConfIdx, byMtId, FALSE, FALSE, bIsMcu );
	}
	*/
	// xliang [2/4/2009] 对于终端类型是MCU的情形，计数值还需-1
	// [pengjie 2010/2/8] 不管是终端还是mcu都只调一次DecMtAdpMtNum()，在传入参数中区分mcu/mt处理，
	//    不然调用多次会在接入能力满了的条件下，会有问题（会多减）
// 	u8 byMtType = m_ptMtTable->GetMtType(byMtId);
// 	if( (MT_TYPE_MMCU == byMtType || MT_TYPE_SMCU == byMtType)
// 		&& !bNeglectMtType )
	// 	{
	// 		g_cMcuVcApp.DecMtAdpMtNum( byDriId, m_byConfIdx, byMtId, FALSE, TRUE );
// 	}
//#endif
	u8 byMpId = m_ptMtTable->GetMpId( byMtId );
	g_cMcuVcApp.DecMpMtNum( byMpId, m_byConfIdx, byMtId, m_tConf.GetBitRate() );
	
	g_cMcuVcApp.UpdateAgentAuthMtNum();
}

/*====================================================================
    函数名      ：ReleaseConf
    功能        ：从会议表中删除该会议；
	              通知外设，MC，MT和SMCU；
				  停止会议中所有交换；
				  停止所有定时器（MASTER）；
				  删除文件（SCHEDULE）；
				  回到IDLE状态
    算法实现    ：
    引用全局变量：
    输入参数说明：无
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/01/08    1.0         LI Yi         创建
	03/11/13    3.0         胡昌威        修改
	05/12/20	4.0			张宝卿		  T120集成
====================================================================*/
void CMcuVcInst::ReleaseConf( BOOL32 bRemoveFromFile )
{
	CServMsg	cServMsg;
	TPeriEqpStatus tPeriEqpStatus;
//	u8  byVmpConfIdx = 0;     //  hdu选看画面合成时，结束会议时保存vmp confIdx,
	                          //  以便停止hdu时正确获得选看vmp的会议索引号
	                          
	//delete file
	//对于VCS会议不保存当前会议信息于文件
	if( bRemoveFromFile && 
		( CurState() == STATE_SCHEDULED || CurState() == STATE_ONGOING )
		&& m_tConf.GetConfSource() != VCS_CONF)
	{
		if(!g_cMcuVcApp.RemoveConfFromFile( m_tConf.GetConfId() ))
        {
			m_tConf.GetConfId().Print();
			ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[ReleaseConf] remove conf from file failed \n");
        }
		
	
	}

    // xsl [11/16/2006] 是否支持gk计费
    if ( 0 != g_cMcuAgent.GetGkIpAddr() &&g_cMcuAgent.GetIsGKCharge() &&  
         0 != g_cMcuVcApp.GetRegGKDriId() &&
         m_tConf.IsSupportGkCharge() && m_tConf.m_tStatus.IsGkCharge() )
    {
        //向GK发送停止计费请求
        g_cMcuVcApp.ConfChargeByGK( m_byConfIdx, g_cMcuVcApp.GetRegGKDriId(), TRUE );
        
    }

	cServMsg.SetConfId( m_tConf.GetConfId() );
	cServMsg.SetNoSrc();

    //Notify all meeting consoles
    u8 byMode = CONF_TAKEMODE_ONGOING;
    if(STATE_SCHEDULED == CurState())
    {
        byMode = CONF_TAKEMODE_SCHEDULED;
    }
//    cServMsg.SetMsgBody(&byMode, sizeof(byMode));
//    SendMsgToAllMcs( MCU_MCS_RELEASECONF_NOTIF, cServMsg );
    
	
    TConfMapData tMapData;
    if(m_byConfIdx < MIN_CONFIDX || m_byConfIdx > MAX_CONFIDX)
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[ReleaseConf] invalid confidx :%d\n", m_byConfIdx);
    }
    else
    {
        tMapData = g_cMcuVcApp.GetConfMapData(m_byConfIdx);
    }
	//在GK上注销 
	if( !tMapData.IsTemUsed() && m_tConf.m_tStatus.IsRegToGK() > 0 && g_cMcuVcApp.GetRegGKDriId() > 0 )
	{
		TMtAlias tMtAlias;
		tMtAlias.SetE164Alias( m_tConf.GetConfE164() );
		cServMsg.SetConfId( m_tConf.GetConfId() );
		cServMsg.SetConfIdx( m_byConfIdx );
		cServMsg.SetDstDriId( g_cMcuVcApp.GetRegGKDriId() );
		cServMsg.SetMsgBody( (u8*)&tMtAlias, sizeof( tMtAlias ) );
		g_cMtAdpSsnApp.SendMsgToMtAdpSsn( g_cMcuVcApp.GetRegGKDriId(), MCU_MT_UNREGISTERGK_REQ, cServMsg );

		//注销的会议注册记录后 同步 其他适配模块板的 注册MCU及会议实体 注册信息
		g_cMpManager.UpdateRRQInfoAfterURQ( m_byConfIdx );
	}
    
	if( STATE_SCHEDULED == CurState() )
	{
		//释放端口
//		for( u8 byIndex = 1; byIndex <= MAXNUM_CONF_MT; byIndex++ )
//		{
//			if( m_tConfAllMtInfo.MtInConf( byIndex ) )
//			{
//				ReleaseMtRes( byIndex );
//			}
//		}
		ClearHduSchemInfo();
		g_cMcuVcApp.RemoveConf( m_byConfIdx );

        // [12/08/2006]
        cServMsg.SetMsgBody(&byMode, sizeof(byMode));
        SendMsgToAllMcs( MCU_MCS_RELEASECONF_NOTIF, cServMsg );

        //clear map info
        g_cMcuVcApp.SetConfMapInsId(m_byConfIdx, 0);
		
		DeleteAlias();
		
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF,"schedule Conference %s was released!\n", m_tConf.GetConfName() );

		ClearVcInst();
//		MCU_SAFE_DELETE(m_ptMtTable)
		return;
	}

	///////////////////////////////////////////////
	//以下只有即时会议需要处理    

	// 发Trap消息
	TConfNotify tConfNotify;
	memset(&tConfNotify, 0, sizeof(tConfNotify));
	CConfId cConfId;
	cConfId = m_tConf.GetConfId( );
	memcpy( tConfNotify.m_abyConfId, &cConfId, 16 );
	
	const s32 nNtyConfNameLen = sizeof(tConfNotify.m_abyConfName);
	const s32 nConfNameLen = strlen(m_tConf.GetConfName()) + 1;
	const s32 nMaxCpyLen = min(nNtyConfNameLen, nConfNameLen);
	memcpy( tConfNotify.m_abyConfName, m_tConf.GetConfName(), nMaxCpyLen );
	tConfNotify.m_abyConfName[nNtyConfNameLen - 1] = '\0';
    
    SendTrapMsg( SVC_AGT_CONFERENCE_STOP, (u8*)&tConfNotify, sizeof(tConfNotify) );
 	
	//杀死所有时钟
	KillTimer( MCUVC_REFRESH_MCS_TIMER );
	KillTimer( MCUVC_INVITE_UNJOINEDMT_TIMER );
	KillTimer( MCUVC_POLLING_CHANGE_TIMER );
    KillTimer( MCUVC_TWPOLLING_CHANGE_TIMER );
	KillTimer( MCUVC_MCUSRC_CHECK_TIMER );
	KillTimer( MCUVC_HDUBATCHPOLLI_CHANGE_TIMER );
	//[03/04/2010] zjl modify (电视墙多通道轮询代码合并)
	//KillTimer( MCUVC_HDUPOLLING_CHANGE_TIMER );
	u8 byTimerIdx;
	for(byTimerIdx = 0; byTimerIdx < MAXNUM_TVWALL_CHNNL; byTimerIdx++)
	{
		KillTimer(MCUVC_TWPOLLING_CHANGE_TIMER + byTimerIdx);
	}
	KillTimer( MCUVC_VCMTOVERTIMER_TIMER );
	KillTimer( MCUVC_VCS_CHAIRPOLL_TIMER );
	//杀死vmp相关时钟
	//KillTimer(MCUVC_VMP_WAITVMPRSP_TIMER);//vmp应答时钟
	for(byTimerIdx = 0; byTimerIdx < MAXNUM_CONF_VMP; byTimerIdx++)
	{
		KillTimer(MCUVC_VMP_WAITVMPRSP_TIMER + byTimerIdx);
	}
	KillTimer(MCUVC_VMPPOLLING_CHANGE_TIMER);//轮询改变时钟
	KillTimer(MCUVC_CHANGE_VMPCHAN_SPEAKER_TIMER);//改变发言人调整vmp等待时钟
	KillTimer(MCUVC_CHANGE_VMPCHAN_CHAIRMAN_TIMER);//改变主席调整vmp等待时钟
	KillTimer(MCUVC_MTSEIZEVMP_TIMER);//VMP 抢占终端进行抢占定时
	KillTimer(MCUVC_VMPBATCHPOLL_TIMER);//VMP 批量轮询定时
	KillTimer(MCUVC_WAIT_LASTVMPROLLCALLFINISH_TIMER);//点下级终端的等待时钟

	//拆除所有交换桥

	//lukunpeng 2010/06/07
	TMt tLocalVidBrdSrc = GetLocalVidBrdSrc();
	TMt tLocalAudBrdSrc = GetLocalAudBrdSrc();
	u8 bySrcChnnl = (tLocalVidBrdSrc == m_tPlayEqp) ? m_byPlayChnnl : 0;
	if(!tLocalVidBrdSrc.IsNull())
	{
		g_cMpManager.RemoveSwitchBridge( tLocalVidBrdSrc, bySrcChnnl, MODE_VIDEO );
	}
	
	//停止双流
	ClearH239TokenOwnerInfo( NULL );
	StopDoubleStream( TRUE, TRUE );

	//拆音频桥
	if( !tLocalAudBrdSrc.IsNull() )
	{
		u8 byAudCapNum = 1;
		//支持多格式混音多条N桥
		if (tLocalAudBrdSrc == m_tMixEqp)
		{
			bySrcChnnl = GetMixerNModeChn();
			TAudioTypeDesc atAudTypeDesc[MAXNUM_CONF_AUDIOTYPE];
			byAudCapNum = m_tConfEx.GetAudioTypeDesc(atAudTypeDesc);
		}
		for (u8 byLoop = 0; byLoop < byAudCapNum; byLoop++)
		{
			g_cMpManager.RemoveSwitchBridge( tLocalAudBrdSrc, bySrcChnnl + byLoop, MODE_AUDIO );
			if ( m_tConf.GetConfAttrb().IsSatDCastMode() )
			{
				g_cMpManager.StopDistrConfCast(tLocalAudBrdSrc, MODE_AUDIO, bySrcChnnl + byLoop);
			}
		}
	}

	if (!GetSecVidBrdSrc().IsNull())
	{
		g_cMpManager.RemoveSwitchBridge(GetSecVidBrdSrc(), 0, MODE_VIDEO);
	}

	//组播会议组播数据
	if( m_tConf.GetConfAttrb().IsMulticastMode() && !tLocalVidBrdSrc.IsNull() )
	{
		g_cMpManager.StopMulticast( tLocalVidBrdSrc, bySrcChnnl );
	}

	//停止所有交换
    if (m_tConf.GetConfAttrb().IsSatDCastMode())
    {
        if (!tLocalVidBrdSrc.IsNull())
        {
            g_cMpManager.StopDistrConfCast(tLocalVidBrdSrc, MODE_VIDEO, bySrcChnnl);
        }    
		//卫星会议：拆除单播交换
        StopSwitchToAllSubMtJoinedConf( MODE_BOTH );
    }
    else
    {
        StopSwitchToAllSubMtJoinedConf( MODE_BOTH );
    }

	StopSwitchToAllMonitor(TRUE);
	StopSwitchToAllMcInConf();	
	StopSwitchToAllPeriEqpInConf();

	//停止混音
	if (!m_tMixEqp.IsNull())
	{
		g_cMcuVcApp.GetPeriEqpStatus( m_tMixEqp.GetEqpId(), &tPeriEqpStatus );

		if( m_tConf.m_tStatus.IsMixing() || m_tConf.m_tStatus.IsVACing() )
		{
			StopMixing();
		}
		//如果当前会议占用混音器，且出于等待开启状态，需要向混音器发送STOP消息。避免外设实际处于混音状态中，
		//而MCU侧认为该外设处于READY状态中[11/8/2012 chendaiwei]
		else if( tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState != TMixerGrpStatus::READY)
		{
			CServMsg cStopMsg;
			cStopMsg.SetConfId(m_tConf.GetConfId());
			cStopMsg.SetEventId(MCU_MIXER_STOPMIX_REQ);
			cStopMsg.SetMsgBody((u8 *)&m_byMixGrpId, 1);
			SendMsgToEqp(m_tMixEqp.GetEqpId(), MCU_MIXER_STOPMIX_REQ, cStopMsg);
		}

		//放弃混音组[11/8/2012 chendaiwei]
		tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState = TMixerGrpStatus::READY;
		tPeriEqpStatus.SetConfIdx( 0 );
		g_cMcuVcApp.SetPeriEqpStatus( m_tMixEqp.GetEqpId(), &tPeriEqpStatus );

		cServMsg.SetMsgBody((u8 *)&tPeriEqpStatus, sizeof(tPeriEqpStatus));
		SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);
	}

	//停止画面合成
	//zhouyiliang 20120411 画面合成刚点start，还没收到vmp的响应，结会，此时的vmpmode为none
	//但是同样应该发stop
	TEqp tVmpEqp;
	for (u8 byVmpId=VMPID_MIN; byVmpId<=VMPID_MAX; byVmpId++)
	{
		g_cMcuVcApp.GetPeriEqpStatus( byVmpId , &tPeriEqpStatus );
		if (tPeriEqpStatus.GetConfIdx() == m_byConfIdx)
		{
			tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
			if (CONF_VMPMODE_NONE != g_cMcuVcApp.GetVMPMode(tVmpEqp) || 
				( !tVmpEqp.IsNull() && TVmpStatus::IDLE != tPeriEqpStatus.m_tStatus.tVmp.m_byUseState )  )
			{
				SendMsgToEqp( byVmpId, MCU_VMP_STOPVIDMIX_REQ, cServMsg );
				
				//停vmp,初始化所有信息
				ProcVMPStopSucRsp(byVmpId);
			}
		}
	}
	ChangeVidBrdSrc(NULL);
    
    //停止多画面电视墙
    if ( CONF_VMPTWMODE_NONE != m_tConf.m_tStatus.GetVmpTwMode() )
    {
        SendMsgToEqp( m_tVmpTwEqp.GetEqpId(), MCU_VMPTW_STOPVIDMIX_REQ, cServMsg );

        //释放vpu资源
        g_cMcuVcApp.GetPeriEqpStatus( m_tVmpTwEqp.GetEqpId(), &tPeriEqpStatus );
        tPeriEqpStatus.m_tStatus.tVmp.m_byUseState = FALSE;
        tPeriEqpStatus.SetConfIdx( 0 );
        g_cMcuVcApp.SetPeriEqpStatus( m_tVmpTwEqp.GetEqpId(), &tPeriEqpStatus );
    }
	
	//停止会议录像：停止向录像机交换
	if( m_tConf.m_tStatus.IsRecording() /*&& HasJoinedSpeaker()*/ )
	{
        StopSwitchToPeriEqp( m_tRecEqp.GetEqpId(), m_byRecChnnl, TRUE );
	}
	
	//停止所有终端录像：停止向录像机交换
	RemoveMtFromRec(NULL, TRUE);

	//停止放像
	if( !m_tConf.m_tStatus.IsNoPlaying() )
	{
		if (IsVrsRecMt(m_tPlayEqp))
		{
			ReleaseVrsMt(m_tPlayEqp.GetMtId(), 0, FALSE);
		}
		else
		{
			cServMsg.SetMsgBody( ( u8 * )&m_tPlayEqp, sizeof( m_tPlayEqp ) );	//set TEqp
			cServMsg.SetChnIndex( m_byPlayChnnl );
			SendMsgToEqp( m_tPlayEqp.GetEqpId(), MCU_REC_STOPPLAY_REQ, cServMsg );
		}
	}

	//丢包重传停止
	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
 	if( tConfAttrb.IsResendLosePack()/*m_tConf.m_tStatus.IsPrsing()*/ )
 	{
		//停止当前会议所有prs通道
		StopAllPrsChn();
		//释放当前会议所有prs通道
		ReleaseAllPrsChn();	
	}

	//停止轮询
	TPollInfo *ptPollInfo = m_tConf.m_tStatus.GetPollInfo();
	if( ptPollInfo->GetMediaMode() == MODE_VIDEO)
	{
		ChangeVidBrdSrc( NULL );
	}
    
	//停止hdu批量轮询
	if ( POLL_STATE_NONE != m_tHduBatchPollInfo.GetStatus() )
	{
		u8 byHduChlNum = 0;
		u8 byHduEqpId = 0;
		u8 byChnlIdx = 0;
		u8 byChnlPollNum = m_tHduBatchPollInfo.GetChnlPollNum();
		TPeriEqpStatus tHduStatus;
        for ( ; byHduChlNum < min(byChnlPollNum,MAXNUM_HDUCFG_CHNLNUM); byHduChlNum ++ )
        {
			byHduEqpId = m_tHduBatchPollInfo.m_tChnlBatchPollInfo[byHduChlNum].GetEqpId();
			byChnlIdx = m_tHduBatchPollInfo.m_tChnlBatchPollInfo[byHduChlNum].GetChnlIdx();
			if (byChnlIdx >= MAXNUM_HDU_CHANNEL)
			{
				continue;
			}
			if ( byHduEqpId >= HDUID_MIN && byHduEqpId <= HDUID_MAX )
			{
                g_cMcuVcApp.GetPeriEqpStatus( byHduEqpId, &tHduStatus );
				if ( 0 == tHduStatus.m_byOnline )    // hdu不在线
				{
					tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].SetNull();
					g_cMcuVcApp.SetPeriEqpStatus( byHduEqpId, &tHduStatus );
					cServMsg.SetMsgBody( (u8*)&tHduStatus, sizeof(tHduStatus) );
					SendMsgToAllMcs( MCU_MCS_MCUPERIEQPSTATUS_NOTIF,  cServMsg);
				}
			}
			else
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_CFG, "[ProcMcsMcuHduBatchPollMsg] stop hdu(%d) batch poll error!\n", byHduEqpId);
				continue;
			}
        }
		
		m_tHduBatchPollInfo.SetNull();
		m_tConf.m_tStatus.m_tConfMode.SetHduInBatchPoll( POLL_STATE_NONE );
		
		TConfAttrbEx tConfAttrbEx = m_tConf.GetConfAttrbEx();
		tConfAttrbEx.SetSchemeIdxInBatchPoll( 0 );
		m_tConf.SetConfAttrbEx( tConfAttrbEx );
		
        m_tHduPollSchemeInfo.SetNull();
        ConfStatusChange();            // 通知会控会议状态改变

		//通知所有会控
		cServMsg.SetMsgBody( ( u8 * )&m_tConf, sizeof( m_tConf ) );
		if(m_tConf.HasConfExInfo())
		{
			u8 abyConfInfExBuf[CONFINFO_EX_BUFFER_LENGTH] = {0};
			u16 wPackDataLen = 0;
			PackConfInfoEx(m_tConfEx,abyConfInfExBuf,wPackDataLen);
			cServMsg.CatMsgBody(abyConfInfExBuf, wPackDataLen);
		}	
		SendMsgToAllMcs( MCU_MCS_CONFINFO_NOTIF, cServMsg );
		
		KillTimer( MCUVC_HDUBATCHPOLLI_CHANGE_TIMER );
	}

	//停止向电视墙交换
	u8  byLoop = 0,  byEqpId = 0;
	u8  byMtConfIdx = 0;
	TPeriEqpStatus tTvwallStatus, tHduStatus;
	memset(&tTvwallStatus, 0x0, sizeof(tTvwallStatus));
	memset(&tHduStatus, 0x0, sizeof(tHduStatus));

	//停止HDU
	for ( byEqpId=HDUID_MIN; byEqpId <= HDUID_MAX; byEqpId++ )
	{
		if (g_cMcuVcApp.IsPeriEqpValid(byEqpId) && IsValidHduEqp(g_cMcuVcApp.GetEqp(byEqpId)))
		{			
			g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tHduStatus);
			u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byEqpId));
			if (0 == byHduChnNum)
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU, "[ReleaseConf] GetHduChnNumAcd2Eqp failed!\n");
				continue;
			}

			for(byLoop = 0; byLoop < min(byHduChnNum,MAXNUM_HDU_CHANNEL); byLoop++)
			{
				byMtConfIdx = tHduStatus.m_tStatus.tHdu.GetConfIdx(byLoop);
				// [2013/04/08 chenbing] 会议号为空或者会议号不同时跳过 
				if(byMtConfIdx && m_byConfIdx != byMtConfIdx)
				{
					ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU, "[ReleaseConf] byMtConfIdx is NUll or CurrentConfIdx != HduChnMtConfIdx!\n");
					continue;
				}

				// [2013/03/11 chenbing] 对四风格通道进行初始化恢复 
				if ( HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byLoop) )
				{
					u8 byNewHduMode = HDUCHN_MODE_ONE;
					for (u8 bySubChnId=0; bySubChnId<HDU_MODEFOUR_MAX_SUBCHNNUM; bySubChnId++)
					{
						// 通道正在运行则拆除交换
						if ( THduChnStatus::eRUNNING == tHduStatus.m_tStatus.tHdu.GetChnStatus(byLoop, bySubChnId))
						{
							//拆除交换, 可能需要恢复终端分辨率,所以必须调用ChangeHduSwitch,不能调用StopSwitchToPeriEqp
							ChangeHduSwitch(NULL, byEqpId, byLoop, bySubChnId, TW_MEMBERTYPE_MCSSPEC, TW_STATE_STOP, MODE_VIDEO);
						}
					
						//结会时会将会议InstId清除，外设返回的消息无法处理，所以，需要在此做特殊清除处理
						//初始化通道状态
						tHduStatus.m_tStatus.tHdu.SetChnStatus(byLoop, bySubChnId, THduChnStatus::eREADY);
						//清除会议号
						tHduStatus.m_tStatus.tHdu.SetConfIdx(0, byLoop, bySubChnId);
						//清除成员类型
						tHduStatus.m_tStatus.tHdu.SetMemberType(0, byLoop, bySubChnId);
						//清除终端
						tHduStatus.m_tStatus.tHdu.SetChnNull(byLoop, bySubChnId);
						//McuId置0
						tHduStatus.m_tStatus.tHdu.SetMcuId(0, byLoop, bySubChnId);
						//清除预案号
						tHduStatus.m_tStatus.tHdu.SetSchemeIdx(0, byLoop, bySubChnId);
					}

					// 通知外设切换风格
					CServMsg cSMsg;
					cSMsg.SetEqpId(byEqpId);
					cSMsg.SetChnIndex(byLoop);
					cSMsg.SetConfId(m_tConf.GetConfId());
					cSMsg.SetMsgBody((u8 *)&byNewHduMode, sizeof(u8));
					SendChangeHduModeReq(cSMsg);
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "Send MCU_HDU_CHGHDUVMPMODE_REQ Success m_byConfIdx(%d) byChnMtConfIdx(%d)!\n",
						m_byConfIdx, byMtConfIdx);
				}
				else
				{
					// 通道正在运行则拆除交换
					if ( THduChnStatus::eRUNNING == tHduStatus.m_tStatus.tHdu.GetChnStatus(byLoop))
					{
						//拆除交换,不用调整终端分辨率,所以直接调用StopSwitchToPeriEqp
						StopSwitchToPeriEqp(byEqpId, byLoop, TRUE, MODE_BOTH);
					}

					tHduStatus.m_tStatus.tHdu.SetChnNull(byLoop);
					tHduStatus.m_tStatus.tHdu.SetMemberType(0, byLoop);
					//McuId置0
					tHduStatus.m_tStatus.tHdu.SetMcuId(0, byLoop);
					//清除会议号
					tHduStatus.m_tStatus.tHdu.SetConfIdx(0, byLoop);
					//清除预案号
					tHduStatus.m_tStatus.tHdu.SetSchemeIdx(0, byLoop);
					//清除音视频模式
					g_cMcuVcApp.SetChnnlMMode(byEqpId, byLoop, MODE_NONE);
				}

				//结束会议直接在此反转状态为eREADY
				if(tHduStatus.m_tStatus.tHdu.GetChnStatus(byLoop) != THduChnStatus::eREADY)
				{
					tHduStatus.m_tStatus.tHdu.SetChnStatus(byLoop, 0, THduChnStatus::eREADY);
				}
				// 清除通道模式
				g_cMcuVcApp.SetChnnlMMode(byEqpId, byLoop, 0);
				//McuId置0
				tHduStatus.m_tStatus.tHdu.SetMcuId(0, byLoop);
				//切换四风格为一风格
				tHduStatus.m_tStatus.tHdu.SetChnCurVmpMode(byLoop, HDUCHN_MODE_ONE);
			}

            g_cMcuVcApp.SetPeriEqpStatus(byEqpId, &tHduStatus);
			
			if (1 == tHduStatus.m_byOnline)
			{
				cServMsg.SetMsgBody((u8 *)&tHduStatus, sizeof(tHduStatus));				
				SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);
			}
		}
	}

	//停止电视墙
	for ( byEqpId=TVWALLID_MIN; byEqpId <= TVWALLID_MAX; byEqpId++ )
	{
		if (g_cMcuVcApp.IsPeriEqpValid(byEqpId) && 
			EQP_TYPE_TVWALL == g_cMcuVcApp.GetEqpType(byEqpId))
		{			
			g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tTvwallStatus);
			//zjj20091217 既然结束恢复就不要再判断是否在线了一律清楚,否则掉线等待恢复的hdu的信息无法清除
            //if (1 == tTvwallStatus.m_byOnline)
            {                
                u8 byMemberNum = tTvwallStatus.m_tStatus.tTvWall.byChnnlNum;
				for(byLoop = 0; byLoop < min(byMemberNum,MAXNUM_PERIEQP_CHNNL); byLoop++)
				{
                    byMtConfIdx = tTvwallStatus.m_tStatus.tTvWall.atVideoMt[byLoop].GetConfIdx();
					if (m_byConfIdx == byMtConfIdx)
					{
						if (1 == tTvwallStatus.m_byOnline)
						{
							StopSwitchToPeriEqp(byEqpId, byLoop);
						}
						
                        tTvwallStatus.m_tStatus.tTvWall.atVideoMt[byLoop].byMemberType = 0;
                        tTvwallStatus.m_tStatus.tTvWall.atVideoMt[byLoop].SetNull();
                        tTvwallStatus.m_tStatus.tTvWall.atVideoMt[byLoop].SetConfIdx(0);
					}
				}
                g_cMcuVcApp.SetPeriEqpStatus(byEqpId, &tTvwallStatus);
				
				if (1 == tTvwallStatus.m_byOnline)
				{
					cServMsg.SetMsgBody((u8 *)&tTvwallStatus, sizeof(tTvwallStatus));
					SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);
				}
                
            }
		}
	}

	//拆除所有与会终端的dump
	TMt tMcuMt;
	for( byLoop = 0; byLoop < m_ptMtTable->m_byMaxNumInUse; byLoop++)
	{
		tMcuMt = m_ptMtTable->GetMt(byLoop + 1);
		if(!tMcuMt.IsNull())
		{
			if( m_ptMtTable->IsMtAudioSending( tMcuMt.GetMtId() ) )
			{
				g_cMpManager.StopRecvMt( tMcuMt, MODE_AUDIO );
			}
			if( m_ptMtTable->IsMtVideoSending( tMcuMt.GetMtId() ) )
			{
				g_cMpManager.StopRecvMt( tMcuMt, MODE_VIDEO );
			}			
		}	
	}

	//挂断所有终端(将所有可能正在处理呼叫的终端也挂断)
	cServMsg.SetConfIdx( m_byConfIdx );
	cServMsg.SetConfId( m_tConf.GetConfId() );
	cServMsg.SetDstMtId( 0 );
	cServMsg.SetMsgBody( NULL, 0 );
	g_cMtAdpSsnApp.BroadcastToAllMtAdpSsn( MCU_MT_DELMT_CMD, cServMsg);
	
	//释放端口
	for( u8 byIndex = 1; byIndex <= MAXNUM_CONF_MT; byIndex++ )
	{	
		if( m_tConfAllMtInfo.MtInConf( byIndex ) )
		{
			ReleaseMtRes( byIndex );

            //停止向外网终端h460穿越打洞
            StopH460PinHoleNotifyByMtId( byIndex );

            // xsl [10/11/2006] 释放端口的同时释放终端交换地址信息
            g_cMcuVcApp.ReleaseMtPort( m_byConfIdx, byIndex );
            m_ptMtTable->ClearMtSwitchAddr( byIndex );
		}
	}

	cServMsg.SetConfIdx( m_byConfIdx );
	g_cMpSsnApp.BroadcastToAllMpSsn( MCU_MP_RELEASECONF_NOTIFY,cServMsg.GetServMsg(),cServMsg.GetServMsgLen());

	//如果是数据会议
	if ( CONF_DATAMODE_VAONLY != m_tConf.GetConfAttrb().GetDataMode() )
	{
		//且已经召开
		if ( m_tConfInStatus.IsDataConfOngoing() )
		{
			//告知DCS删除该会议
			SendMcuDcsReleaseConfReq();
		}
	}
	
    // [12/08/2006]
    cServMsg.SetMsgBody(&byMode, sizeof(byMode));
    SendMsgToAllMcs( MCU_MCS_RELEASECONF_NOTIF, cServMsg );

	//从数据区清除
	g_cMcuVcApp.RemoveConf( m_byConfIdx );

    //clear map info
    g_cMcuVcApp.SetConfMapInsId(m_byConfIdx, 0);

	DeleteAlias();
	ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "Ongoing Conference %s was released!\n", m_tConf.GetConfName() );

    //通知n+1备份服务器更新会议信息
    if (MCU_NPLUS_MASTER_CONNECTED == g_cNPlusApp.GetLocalNPlusState())
    {
        ProcNPlusConfInfoUpdate(FALSE);
    }

	RlsAllBasForConf();

	g_cMcuVcApp.NplusRemoveVmpModuleByConfIdx(m_byConfIdx);

	//清空会议实例
	ClearVcInst();
	
// 	u8 byMtNum = 0;
// 	u8 bySMcuNum = 0;
// 	for(u8 byLp = 0; byLoop < MAXNUM_DRI; byLoop++ )
// 	{
// 		if( g_cMcuVcApp.m_atMtAdpData[byLp].m_bConnected && 
//                 PROTOCOL_TYPE_H323 == g_cMcuVcApp.m_atMtAdpData[byLp].m_byProtocolType )
// 		{
// 			g_cMcuVcApp.GetMtNumOnDri(byLp+1, TRUE, byMtNum, bySMcuNum);
// 			g_cMcuVcApp.m_atMtAdpData[byLp].m_wMtNum = (byMtNum + bySMcuNum);
// 		}
// 	}

	//通知所有会议,当前可能有终端
	post( MAKEIID( GetAppID(), CInstance::EACH ), MCUVC_INVITE_UNJOINEDMT_TIMER );

	return;
}

/*====================================================================
    函数名      ：AdjustMtSendBR
    功能        ：调节终端发送码率
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMtId    要调节的MT
				  u16 wBitrate 目标码率
				  u8 byMode    视频类型 MODE_VIDEO / MODE_SECVIDEO
				  BOOL32 bForceFlowCtrlSrc TRUE表明直接调源码率，FALSE表明还要进行是否要适配的校验
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/03/20    3.0         胡昌威        修改
====================================================================*/
void CMcuVcInst::AdjustMtVideoSrcBR( u8 byMtId, u16 wBitrate, u8 byMode, BOOL32 bForceFlowCtrlSrc)
{
    LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[AdjustMtVideoSrcBR]MT.%d, BitRate.%d, Mode.%d, bForceFlowCtrlSrc.%d!\n",
        byMtId, wBitrate, byMode,bForceFlowCtrlSrc);

	if( CurState() == STATE_ONGOING )
	{
		CServMsg cServMsg;
		TLogicalChannel tLogicalChannel;		
		if( MODE_VIDEO == byMode )
		{
			TMt tMtSrc;
			m_ptMtTable->GetMtSrc( byMtId, &tMtSrc, MODE_VIDEO );
			
			//lukunpeng 2010/06/07 音视频源非local化整理
			tMtSrc = GetLocalMtFromOtherMcuMt(tMtSrc);			

			//zjj20101111 由于时序问题E1终端被呼入时可能视频源还未赋值所以保护一下
			if ( m_ptMtTable->GetMtTransE1(byMtId) &&
				 //m_ptMtTable->GetMtBRBeLowed(byMtId) &&
				 (tMtSrc.IsNull() || byMtId == tMtSrc.GetMtId())
			 )
			{
				tMtSrc = GetLocalVidBrdSrc();
			}			

			if( tMtSrc.GetType() == TYPE_MT && 
				tMtSrc.GetMtId() > 0 &&
				m_ptMtTable->GetMtLogicChnnl( tMtSrc.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE ) )
			{				
				tLogicalChannel.SetFlowControl( wBitrate );
				cServMsg.SetMsgBody( (u8*)&tLogicalChannel, sizeof( tLogicalChannel ) );			

                //zbq[07/28/2009] 双流flowctrl修正：不响应非免适配终端的flowctrl，AdpParam自然调整

                if (IsHDConf(m_tConf) &&
                    tMtSrc == GetLocalVidBrdSrc() &&
                    //m_cMtRcvGrp.IsMtNeedAdp(byMtId)
					IsNeedAdapt(tMtSrc, m_ptMtTable->GetMt(byMtId), MODE_VIDEO) 
					&& !bForceFlowCtrlSrc
					)
                {
					
                }
                else
                {
                    SendMsgToMt( tMtSrc.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cServMsg );
                }
			}
		}
		else
		{
			if( TYPE_MT == m_tDoubleStreamSrc.GetType() && 
				m_tConfAllMtInfo.MtJoinedConf( m_tDoubleStreamSrc.GetMtId() ) && 
				m_ptMtTable->GetMtLogicChnnl( m_tDoubleStreamSrc.GetMtId(), LOGCHL_SECVIDEO, &tLogicalChannel, FALSE ) )
			{
				tLogicalChannel.SetFlowControl( wBitrate );
				cServMsg.SetMsgBody( (u8*)&tLogicalChannel, sizeof( tLogicalChannel ) );
				
                //zbq[07/28/2009] 双流flowctrl修正：不响应非免适配终端的flowctrl，AdpParam自然调整
                if (IsHDConf(m_tConf) &&
                    //m_cMtRcvGrp.IsMtNeedAdp(byMtId, FALSE)
					IsNeedAdapt(m_tDoubleStreamSrc, m_ptMtTable->GetMt(byMtId), MODE_SECVIDEO)
					&& !bForceFlowCtrlSrc
					)
                {
                }
                else
                {
                    SendMsgToMt( m_tDoubleStreamSrc.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cServMsg );
                }
			}
		}
	}

	return;
}

/*====================================================================
    函数名      ：StartMtSendbyNeed
    功能        ：在需要的时候让终端开始发
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt & tSrc 要停发的终端
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/02/14    3.0         胡昌威        创建
====================================================================*/
void CMcuVcInst::StartMtSendbyNeed( TSwitchChannel* ptSwitchChannel )
{
	if( CurState() == STATE_ONGOING )
	{	
		TMt tSrc =  ptSwitchChannel->GetSrcMt();

		if( !m_tConfAllMtInfo.MtJoinedConf( tSrc.GetMtId() ) )
		{
			return;
		}
		
		if( tSrc.GetType() == TYPE_MT && !ptSwitchChannel->IsNull() )
		{
			u8  byMode;
			if (ptSwitchChannel->GetRcvPort() % PORTSPAN == 2)
			{
				byMode = MODE_AUDIO;
			}
			else if (ptSwitchChannel->GetRcvPort() % PORTSPAN == 0)
			{
				byMode = MODE_VIDEO;
			}
			else
			{
				return;
			}

            u32 dwVmpIp = 0;
            u8 byEqpType = 0;
            if (!m_tVmpEqp.IsNull())
            {
                g_cMcuAgent.GetPeriInfo(m_tVmpEqp.GetEqpId(), &dwVmpIp, &byEqpType);
            }

			//lukunpeng 2010/06/07 音视频源非local化整理
            if (tSrc == GetLocalVidBrdSrc() &&
                IsDelayVidBrdVCU() &&
                dwVmpIp == ptSwitchChannel->GetDstIP())
            {
                NotifyMtSend( tSrc.GetMtId(), byMode, TRUE );

                NotifyFastUpdate(tSrc, 0, TRUE);
                ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[StartMtSendbyNeed] NotifyFastUpdate Mt.%d util here due to Tandberg!\n", tSrc.GetMtId());
            }
            else
            {
				if( !(tSrc == GetLocalVidBrdSrc()) )
				{
					NotifyMtSend( tSrc.GetMtId(), byMode, TRUE );
				}
            }
        }
    }
    return;
}

/*====================================================================
函数名      ：StopMtSendbyNeed
功能        ：在需要的时候让终端停发
算法实现    ：
引用全局变量：
输入参数说明：const TMt & tSrc 要停发的终端
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
04/02/14    3.0         胡昌威        创建
====================================================================*/
void CMcuVcInst::StopMtSendbyNeed( TSwitchChannel* ptSwitchChannel )
{
	if( CurState() == STATE_ONGOING )
	{
		TMt tSrc =  ptSwitchChannel->GetSrcMt();

		ConfPrint(LOG_LVL_DETAIL, MID_MCU_MPMGR, "[StopMtSendbyNeed] tSrc<McuId.%d, MtId.%d> SrcIP:%x SrcPort:%d\n",
												tSrc.GetMcuId(), tSrc.GetMtId(),
												ptSwitchChannel->GetSrcIp(), ptSwitchChannel->GetDstPort());

		// 卫星会议：卫星终端SubType不正确，这里重新取 [pengguofeng 1/17/2013]
		if ( m_tConf.GetConfAttrb().IsSatDCastMode())
		{
			tSrc = m_ptMtTable->GetMt(tSrc.GetMtId());
		}

		if(tSrc.GetMtType() != TYPE_MT || !m_tConfAllMtInfo.MtJoinedConf( tSrc.GetMtId() ) )
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_MPMGR, "[StopMtSendbyNeed] tSrc is not Mt or not join conf!\n");
			return;
		}
		
		if( tSrc.GetType() == TYPE_MT )
		{
			u8  byMode;
			if (ptSwitchChannel->GetRcvPort() % PORTSPAN == 2)
			{
				byMode = MODE_AUDIO;
			}
			else if (ptSwitchChannel->GetRcvPort() % PORTSPAN == 0)
			{
				byMode = MODE_VIDEO;
			}
			else
			{
				return;
			}

			u16 wRcvPort = ptSwitchChannel->GetRcvPort();
//			u8  byMpId  = m_ptMtTable->GetMpId( tSrc.GetMtId() );
			u32 dwSrcIp = m_ptMtTable->GetIPAddr( tSrc.GetMtId() );
            u32 dwDstIp = ptSwitchChannel->GetDstIP();

//			if( byMode == MODE_AUDIO )
//			{
//			    NotifyMtSend( tSrc.GetMtId(), byMode, FALSE );
//			}
//			else
			{
                //只有移除交换后才通知终端停止发送码流，防止错误的flowcontrol 0
				if( !m_ptSwitchTable->IsValidSwitchSrcIp( dwSrcIp, wRcvPort, byMode ) )
				{
					u16 wPort = 0;
					u32 dwIp = 0;
					m_ptMtTable->GetMtSwitchAddr( GetLocalVidBrdSrc().GetMtId(),dwIp,wPort );
					if (byMode == MODE_AUDIO)
					{
						wPort += 2;
					}

					//zbq[09/10/2008] 广播逻辑下广播源切换有时序问题，此处临时规避
					//lukunpeng 2010/06/07 音视频源非local化整理
					if (MT_TYPE_MT == GetLocalVidBrdSrc().GetMtType() &&
						GetLocalVidBrdSrc().GetMtId() == m_ptMtTable->GetMtIdByIp(dwSrcIp) &&
						wPort == wRcvPort						
						)
					{
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_MPMGR, "[StopMtSendbyNeed] Src<%s@%d> remove slapped due to it's vidsrc.(removed dst<%s@%d> switch)\n", 
									  StrOfIP(dwSrcIp), wRcvPort, StrOfIP(dwDstIp), ptSwitchChannel->GetDstPort() );						
					}
					else
					{
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_MPMGR, "[StopMtSendbyNeed] Src<%s@%d> Is a invalid switch src.(removed dst<%s@%d> switch)\n", 
									   StrOfIP(dwSrcIp), wRcvPort, StrOfIP(dwDstIp), ptSwitchChannel->GetDstPort() );
						NotifyMtSend( tSrc.GetMtId(), byMode, FALSE );
					}
				}
				else
				{
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_MPMGR, "[StopMtSendbyNeed] Src<%s@%d> Is a valid switch src.(removed dst<%s@%d> switch)\n", 
                                StrOfIP(dwSrcIp), wRcvPort, StrOfIP(dwDstIp), ptSwitchChannel->GetDstPort() );

                    // xsl [8/1/2006] 若4M以上会议，移除画面合成通道后，终端还在向其他*发送码流，则修改终端发送码率
//                     if (m_tConf.GetBitRate() > MAXBITRATE_MTSEND_INVMP)
//                     {
//                         u32 dwVmpIp; 
//                         u8 byPeriType;
//                         if (SUCCESS_AGENT == g_cMcuAgent.GetPeriInfo(m_tVmpEqp.GetEqpId(), &dwVmpIp, &byPeriType) &&
//                             ntohl(dwVmpIp) == dwDstIp)
//                         {
//                             NotifyMtSend(tSrc.GetMtId(), MODE_VIDEO);
//                         }
//                         else if (SUCCESS_AGENT == g_cMcuAgent.GetPeriInfo(m_tVmpTwEqp.GetEqpId(), &dwVmpIp, &byPeriType) &&
//                                 ntohl(dwVmpIp) == dwDstIp)
//                         {
//                             NotifyMtSend(tSrc.GetMtId(), MODE_VIDEO);
//                         }
//                     }

					/*20110609 zjl 如果当前交换源信息已经不存在交换表里，在上面会flowcontrol 0
								   否则(表明该终端源还在业务里)都尝试恢复调整一次终端码率，究竟调成多少由NotifyMtSend接口内部判断*/
					NotifyMtSend(tSrc.GetMtId(), byMode);
				}
			}
		}
	}	
}

/*=============================================================================
函 数 名： NotifyRecStartPlaybyNeed
功    能： 
算法实现： 
全局变量： 
参    数： void
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2007/2/27  4.0			周广程                  创建
=============================================================================*/
void CMcuVcInst::NotifyRecStartPlaybyNeed( TSwitchChannel* ptSwitchChannel )
{
	CServMsg cServMsg;
	cServMsg.SetChnIndex( m_byPlayChnnl );
	BOOL32 bSendMsg = FALSE;
	if( ptSwitchChannel->GetSrcMt() == m_tPlayEqp && m_tConf.m_tStatus.IsNoPlaying() )
	{
		u8  byMode;
		if (ptSwitchChannel->GetRcvPort() % PORTSPAN == 2)
		{
			byMode = MODE_AUDIO;
		}
		else if (ptSwitchChannel->GetRcvPort() % PORTSPAN == 0)
		{
			byMode = MODE_VIDEO;
		}
		else if ( ptSwitchChannel->GetRcvPort() % PORTSPAN == 4 )
		{
			byMode = MODE_SECVIDEO;
		}
		else
		{
			return;
		}
			
		if( m_tPlayEqpAttrib.IsDStreamPlay() && m_tPlayEqpAttrib.IsDStreamFile() )
		{
			if( byMode == MODE_AUDIO || byMode == MODE_VIDEO )
			{
				//音频和第一路视频不作处理
			}
			else
			{
				bSendMsg = TRUE;
			}
		}
		else
		{
			if( byMode == MODE_AUDIO )
			{
				//如果正在进行VMP广播，则仍向REC发送通知，否则音频不作处理
				if ( g_cMcuVcApp.IsBrdstVMP(m_tVmpEqp) )
				{
					bSendMsg = TRUE;
				}
            }
            else
            {
				bSendMsg = TRUE;
			}
		}
	}

	if (bSendMsg)
	{
		KillTimer( MCUVC_RECPLAY_WAITMPACK_TIMER );
		m_tConf.m_tStatus.SetPlaying();
		if (m_tPlayEqp.GetType() == TYPE_MT && m_tPlayEqp.GetMtType() == MT_TYPE_VRSREC)
		{
			m_ptMtTable->SetRecChlState(m_tPlayEqp.GetMtId(), TRecChnnlStatus::STATE_PLAYING);
			// 通知vrs新录播发送码流 flowcontrol
			TLogicalChannel tLogicalChannel;
            if ( m_ptMtTable->GetMtLogicChnnl(m_tPlayEqp.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE))
            {
				u16 wMStremBR = m_tPlayEqpAttrib.GetMStremBR();
				tLogicalChannel.SetFlowControl(wMStremBR);//如何获取合适的码率
				cServMsg.SetMsgBody((u8 *)&tLogicalChannel, sizeof(tLogicalChannel));
				SendMsgToMt(m_tPlayEqp.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cServMsg);
				ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_MT2,"[NotifyRecStartPlaybyNeed] adjust VrsPlayMt sendBandwith to %d!\n", wMStremBR);
            } 
		}
		else
		{
			SendMsgToEqp( m_tPlayEqp.GetEqpId() , MCU_EQP_SWITCHSTART_NOTIF, cServMsg);
		}
	}
}

/*====================================================================
    函数名      ：NotifyMtSend
    功能        ：通知直连下级MT发送码流，同时通知互斥终端停发
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byDstMtId, 要通知的MT
				  u8 byMode, 发送模式，缺省为MODE_BOTH
				  BOOL32 bStart, TRUE-开始 FALSE-停止
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/12/19    1.0         LI Yi         创建
	04/02/14    3.0         胡昌威        修改
====================================================================*/
void CMcuVcInst::NotifyMtSend( u8 byDstMtId, u8 byMode, BOOL32 bStart )
{
	CServMsg	cServMsg;
	TLogicalChannel tLogicalChannel;
	u16  wBitRate;

    u8 byManuId = m_ptMtTable->GetManuId( byDstMtId );
	if(byManuId != MT_MANU_KDC && byManuId != MT_MANU_KDCMCU) // xsl [8/7/2006] 支持mcu flowcontrol
	{
        //非keda厂商在节省带宽、视频、发送码流时
        if((MODE_BOTH == byMode || MODE_VIDEO == byMode) && bStart && g_cMcuVcApp.IsSavingBandwidth())
        {
            NotifyOtherMtSend(byDstMtId, TRUE);
        }
		return;
	}

	ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT, "[NotifyMtSend] KeDaMt Notif Mt(%d, %d) Start Send\n",
		m_ptMtTable->GetMt(byDstMtId).GetMcuId(), m_ptMtTable->GetMt(byDstMtId).GetMtId());

	//通知终端开始发送。如果发送的是音频，将码率设为64k
	if( byMode == MODE_AUDIO || byMode == MODE_BOTH )
	{
		if( m_ptMtTable->GetMtLogicChnnl( byDstMtId, LOGCHL_AUDIO, &tLogicalChannel, FALSE ) )
		{
			if( bStart )
			{
				u16 wAudioBand = GetAudioBitrate( tLogicalChannel.GetChannelType() );
				tLogicalChannel.SetFlowControl( wAudioBand );
				cServMsg.SetMsgBody( (u8*)&tLogicalChannel, sizeof( tLogicalChannel ) );
				SendMsgToMt( byDstMtId, MCU_MT_FLOWCONTROL_CMD, cServMsg );
				
				TMt tDstMt;
				tDstMt.SetNull();
				cServMsg.SetMsgBody( (u8*)&tDstMt, sizeof(tDstMt) );
				SendMsgToMt( byDstMtId, MCU_MT_SEENBYOTHER_NOTIF, cServMsg );
			}
			else
			{
				wBitRate =  0;		
				tLogicalChannel.SetFlowControl( wBitRate );
				cServMsg.SetMsgBody( (u8*)&tLogicalChannel, sizeof( tLogicalChannel ) );
				SendMsgToMt( byDstMtId, MCU_MT_FLOWCONTROL_CMD, cServMsg );	
			}
		}
	}

	//如果为视频，将该终端的码率设为会议码率
	if( byMode == MODE_VIDEO || byMode == MODE_BOTH || byMode == MODE_VIDEO2SECOND)
	{
		if( m_ptMtTable->GetMtLogicChnnl( byDstMtId, LOGCHL_VIDEO, &tLogicalChannel, FALSE ) )
		{
			if( bStart )
			{
				TLogicalChannel tDSLogicChnnl;

                // xsl [1/21/2006] 如果有双流源，折半，没有则全速；
                // zbq [6/23/2009] 进一步：有双流源，但该终端非主流源，也不接收双流，则全速；
                u16 wDialBitrate = m_ptMtTable->GetSndBandWidth(byDstMtId);
                if (m_tDoubleStreamSrc.IsNull() && m_tSecVidBrdSrc.IsNull()
					&& ( MT_MANU_KDCMCU != m_ptMtTable->GetManuId(byDstMtId)
						 || !m_ptMtTable->GetMtLogicChnnl( byDstMtId, LOGCHL_SECVIDEO, &tDSLogicChnnl, FALSE)))
                {
                    tLogicalChannel.SetFlowControl( wDialBitrate );
                }
                else
                {
//                     TLogicalChannel tDSFwdChn;
// 					
//                     if (!(GetLocalVidBrdSrc() == m_ptMtTable->GetMt(byDstMtId)) &&
//                         !m_ptMtTable->GetMtLogicChnnl(byDstMtId, LOGCHL_SECVIDEO, &tDSFwdChn, TRUE))
//                     {
//                         tLogicalChannel.SetFlowControl( wDialBitrate );
//                     }
//                     else
//                     {
//                         tLogicalChannel.SetFlowControl( GetDoubleStreamVideoBitrate(wDialBitrate ));
//                     }
					/*20110609 zjl Bug00055467
					  bug场景：双流源为低速呼入，其他与会终端均为高速
					           有终端选看双流源终端视频，但是双流源第一路视频码率未下调

					  分析：   根据上面注释掉的判断逻辑，双流源既不是视频广播源也不接受自身双流，所以没有按双流折半码率
					  修改：   前提：本级有终端在发双流

					           1.如果当前调控终端是视频广播源，则按双流码率折半计算。
								 因为视频广播源有可能在接收双流，也可能会接收自己的视频码流。

							   2.如果当前调控终端是双流源自己，按双流码率折半计算
					*/
					if (GetLocalVidBrdSrc() == m_ptMtTable->GetMt(byDstMtId)
						|| m_tDoubleStreamSrc == m_ptMtTable->GetMt(byDstMtId)
						|| m_tSecVidBrdSrc == m_ptMtTable->GetMt(byDstMtId))
					{
						if (MODE_VIDEO2SECOND == byMode)
						{
							tLogicalChannel.SetFlowControl(GetDoubleStreamVideoBitrate(wDialBitrate, FALSE));
						}
						else
						{
							tLogicalChannel.SetFlowControl( GetDoubleStreamVideoBitrate(wDialBitrate ));
						}
					}
					else
					{
						tLogicalChannel.SetFlowControl( wDialBitrate );
					}
                }

				cServMsg.SetMsgBody( (u8*)&tLogicalChannel, sizeof( tLogicalChannel ) );
				SendMsgToMt( byDstMtId, MCU_MT_FLOWCONTROL_CMD, cServMsg );

				TMt tDstMt;
				tDstMt.SetNull();
				cServMsg.SetMsgBody( (u8*)&tDstMt, sizeof(tDstMt) );
				SendMsgToMt( byDstMtId, MCU_MT_SEENBYOTHER_NOTIF, cServMsg );
			}
			else
			{               
				tLogicalChannel.SetFlowControl( 0 );
				cServMsg.SetMsgBody( (u8*)&tLogicalChannel, sizeof( tLogicalChannel ) );
				SendMsgToMt( byDstMtId, MCU_MT_FLOWCONTROL_CMD, cServMsg );	
			}
		}
	}
}

/*====================================================================
    函数名      ：NotifyMtReceive
    功能        ：通知终端(停止)接收码流
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 bySrcMtId, 接收源终端号
				  u8 byDstMtId, 要通知的MT
				  BOOL32 bStart, 开始接收还是停止接收
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/12/19    1.0         LI Yi         创建
	04/03/05    3.0         胡昌威        修改
====================================================================*/
void CMcuVcInst::NotifyMtReceive(  const TMt & tSrc, u8 byDstMtId )
{
	TMt TNullMt, tSeeSrc;
	TNullMt.SetNull();//源为NULL接收外设
	TNullMt.SetMcuIdx( tSrc.GetMcuId() );
	TMt tDstMt = m_ptMtTable->GetMt( byDstMtId );
	CServMsg cServMsg;

	ConfPrint(LOG_LVL_DETAIL, MID_MCU_MT, "[NotifyMtReceive]mt(%d) see src(mtid:%d, mttype:%d, mtsubtype:%d)\n",
		    byDstMtId, tSrc.GetMtId(), tSrc.GetType(), tSrc.GetMtType());
	if( tSrc.GetType() == TYPE_MT  )
	{
		tSeeSrc = tSrc;
	}
    else if (TYPE_MCUPERI == tSrc.GetType() &&
             EQP_TYPE_BAS == tSrc.GetEqpType() &&
             IsNeedAdapt(GetLocalVidBrdSrc(), m_ptMtTable->GetMt(byDstMtId), MODE_VIDEO) &&
			 GetLocalVidBrdSrc().GetType() != TYPE_MCUPERI)
    {
        tSeeSrc = GetLocalVidBrdSrc();
    }
	else
	{
		tSeeSrc = TNullMt;
	}

	cServMsg.SetMsgBody( (u8*)&tSeeSrc, sizeof(tSeeSrc) );
	SendMsgToMt( tDstMt.GetMtId(), MCU_MT_YOUARESEEING_NOTIF, cServMsg );
}

/*=============================================================================
  函 数 名： NotifyOtherMtSend
  功    能： 通知其他厂商终端是否发送视频码流
  算法实现： 
  全局变量： 
  参    数：  u8 byDstMtId
             BOOL32 bStart
  返 回 值： void 
=============================================================================*/
void CMcuVcInst::NotifyOtherMtSend( u8 byDstMtId, BOOL32 bStart )
{
	// [12/11/2009 xliang] no flowcontrol cmd to aethra's MT when in none-cascade environment
	TMt tMt = m_ptMtTable->GetMt(byDstMtId);
	
	if( m_ptMtTable->GetManuId(byDstMtId) == MT_MANU_AETHRA &&
		tMt.GetMtType() != MT_TYPE_MMCU && tMt.GetMtType() != MT_TYPE_SMCU )
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[NotifyOtherMtSend] no flowcontrol cmd to aethra's MT.%d when in none-cascade environment!\n", byDstMtId);
		return;
	}

	
	CServMsg	cServMsg;
    TLogicalChannel tLogicalChannel;
    u16  wBitRate = 0;

    if( m_ptMtTable->GetMtLogicChnnl( byDstMtId, LOGCHL_VIDEO, &tLogicalChannel, FALSE ) )
    {
        if( bStart )
        { 
			TLogicalChannel tDSLogicChnnl;
            //  xsl [1/21/2006] 如果有双流源，折半，没有则全速
			//可能由于双流模式不匹配，导致上级无双流源，但级联MCU双流通道开启[1/6/2013 chendaiwei]
            u16 wDialBitrate = m_ptMtTable->GetSndBandWidth(byDstMtId);
			if (!m_tDoubleStreamSrc.IsNull() || (MT_MANU_KDCMCU == m_ptMtTable->GetManuId(byDstMtId)
				&& m_ptMtTable->GetMtLogicChnnl( byDstMtId, LOGCHL_SECVIDEO, &tDSLogicChnnl, FALSE )))
            {
                tLogicalChannel.SetFlowControl( GetDoubleStreamVideoBitrate(wDialBitrate) );
            }
            else
            {
                tLogicalChannel.SetFlowControl( wDialBitrate );
            }		
        }
        else
        {
			
            if (IsOtherMtCanBeStopSend(byDstMtId))
            {
                tLogicalChannel.SetFlowControl( wBitRate );
            }
            else
            {
                //维持本来该有的状态，保护整理一下
                u16 wDialBitrate = m_ptMtTable->GetSndBandWidth(byDstMtId);
                if (!m_tDoubleStreamSrc.IsNull())
                {
                    tLogicalChannel.SetFlowControl( GetDoubleStreamVideoBitrate(wDialBitrate) );
                }
                else
                {
                    tLogicalChannel.SetFlowControl( wDialBitrate );
                }
            }
        }        

        cServMsg.SetMsgBody( (u8*)&tLogicalChannel, sizeof( tLogicalChannel ) );
        SendMsgToMt( byDstMtId, MCU_MT_FLOWCONTROL_CMD, cServMsg );     
    }

    return;
}

/*=============================================================================
函 数 名： IsNeedChangeFpsMt
功    能： 判断是否是需要调整帧率的终端（如7820/7920），因为这些终端帧率可能
达到50/60帧，而有些地方是不支持这么高的帧率的（如画面合成前适配）
算法实现： 
全局变量： 
参    数： u8 byMtId
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
20100423    4.6 		pengjie                create
=============================================================================*/
BOOL32 CMcuVcInst::IsNeedChangeFpsMt( u8 byMtId )
{
	if( byMtId == 0 || byMtId > MAXNUM_CONF_MT )
	{
		return FALSE;
	}
	// 科达高清终端支持降帧率
	TMt tMt = m_ptMtTable->GetMt(byMtId);
	if (IsKedaMt(tMt, TRUE))
	/*if( 0 == strcmp( "Kdv7820_A", m_ptMtTable->GetProductId(byMtId)) ||
		0 == strcmp( "Kdv7920_A", m_ptMtTable->GetProductId(byMtId)) ||
		0 == strcmp( "H600_L", m_ptMtTable->GetProductId(byMtId) ) ||
		0 == strcmp( "H600_H", m_ptMtTable->GetProductId(byMtId) ) ||
		0 == strcmp( "H700", m_ptMtTable->GetProductId(byMtId) ) ||
		0 == strcmp( "H900", m_ptMtTable->GetProductId(byMtId) )
		)*/
	{
		return TRUE;
	}
	return FALSE;
}

/*=============================================================================
函 数 名： IsNeedAdjustSpyFps
功    能： 多回传是否需要调帧率
算法实现： 
全局变量： 
参    数： const TMt &tSrc           回传源
const TSimCapSet &tDstCap 上级要求的回传能力
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
20110104    4.6 		zjl                    create
=============================================================================*/
BOOL32 CMcuVcInst::IsNeedAdjustSpyFps(const TMt &tSrc, const TSimCapSet &tDstCap)
{
	if (tSrc.IsNull() || tDstCap.IsNull())
	{
		return FALSE;
	}
	
	TMt tLocalSrc = GetLocalMtFromOtherMcuMt(tSrc);
	
	//非科达终端不支持调帧率
	if (MT_MANU_KDC != m_ptMtTable->GetManuId(tLocalSrc.GetMtId()) &&
		MT_MANU_KDCMCU != m_ptMtTable->GetManuId(tLocalSrc.GetMtId()))
	{
		return FALSE;
	}
	
	//需要适配的不调帧率
	if (IsNeedSpyAdpt(tLocalSrc, tDstCap, MODE_VIDEO))
	{
		return FALSE;
	}
	
	//校验终端型号
	if (!IsNeedChangeFpsMt(tLocalSrc.GetMtId()))
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_MT, "[IsNeedAdjustSpyFps] !IsNeedChangeFpsMt!\n");
		return FALSE;
	}
	
	TSimCapSet tSrcCap = m_ptMtTable->GetSrcSCS(tLocalSrc.GetMtId());
	if (tSrcCap.GetVideoMediaType() == MEDIA_TYPE_H264 &&
		tDstCap.GetVideoMediaType() == MEDIA_TYPE_H264)
	{
		//源能力：h264 cif 30fps 目的能力:h264 cif 25fps 不调帧率
		if(VIDEO_FORMAT_CIF == tSrcCap.GetVideoResolution() && 
			VIDEO_FORMAT_CIF == tDstCap.GetVideoResolution() &&
			tDstCap.GetUserDefFrameRate() == 25 && 
			tSrcCap.GetUserDefFrameRate() == 30)
		{
			return FALSE;
		}
		else
		{
			if (tDstCap.GetVideoCap().IsH264CapLower(tSrcCap.GetVideoResolution(), tSrcCap.GetUserDefFrameRate()))
			{
				if (tDstCap.GetVideoCap().IsH264CapLower(tDstCap.GetVideoResolution(), tSrcCap.GetUserDefFrameRate()))
				{
					return TRUE;						
				}
				else
				{
					return FALSE;
				}
			}
			else
			{
				return FALSE;
			}
		}
	}	
	return FALSE;
}
/*=============================================================================
函 数 名： IsOtherMtCanBeStopSend
功    能： 非keda终端是否真正的可以停止码流发送（同样暂只针对视频）
算法实现： 常规情况下，KEDA终端通过IsValidSwitchSrcIp来判断是否需要停止发送；
           节省带宽情况下，非KEDA终端需要通过业务逻辑需求决定是否可以适时节省带宽；
全局变量： 
参    数： u8 byMtId
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2010/1/13  4.0			张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcInst::IsOtherMtCanBeStopSend(u8 byDstMtId)
{
    if (MT_MANU_KDC == m_ptMtTable->GetManuId(byDstMtId) ||
        MT_MANU_KDCMCU == m_ptMtTable->GetManuId(byDstMtId))
    {
        return FALSE;
    }

    TMtStatus tMtStatus;
    TMt tDstMt = m_ptMtTable->GetMt(byDstMtId);

    //非被选看
    for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
    {
        if (!m_tConfAllMtInfo.MtJoinedConf(byMtId))
        {
            continue;
        }
        if (!m_ptMtTable->GetMtStatus(byMtId, &tMtStatus))
        {
            continue;
        }
        
        if (tMtStatus.GetSelectMt(MODE_VIDEO) == tDstMt)
        {
            return FALSE;
        }
    }

	if( m_ptMtTable->GetMtStatus(byDstMtId, &tMtStatus) )
	{
    
		//非TVWall
		if (tMtStatus.IsInTvWall())
		{
			return FALSE;
		}

		//非HDU
		if(tMtStatus.IsInHdu())
		{
			return FALSE;
		}

		//Rec
		if( !tMtStatus.m_tRecState.IsNoRecording() )
		{
			return FALSE;
		}
	}

    //非VMP
    if (g_cMcuVcApp.GetVMPMode(m_tVmpEqp) != CONF_VMPMODE_NONE)
    {
        TPeriEqpStatus tEqpStatus;
        g_cMcuVcApp.GetPeriEqpStatus(m_tVmpEqp.GetEqpId(), &tEqpStatus);
        if (MAXNUM_VMP_MEMBER != tEqpStatus.m_tStatus.tVmp.GetVmpParam().GetChlOfMtInMember(tDstMt))
        {
            return FALSE;
        }
    }

	TMt tSrc;
	TMonitorData tMonitorData;
	u16 wLoop = 0;
	TLogicalChannel tLogicalChannel;
	u8 byChannelNum = 0;
	for( u8 byIndex = 1; byIndex <= (MAXNUM_MCU_MC + MAXNUM_MCU_VC); byIndex++ )
	{
		if( g_cMcuVcApp.IsMcConnected( byIndex ) )
		{			
			if( g_cMcuVcApp.GetMcLogicChnnl( byIndex, MODE_VIDEO, &byChannelNum, &tLogicalChannel ) )
			{
				while( byChannelNum-- != 0 )
				{
					if( g_cMcuVcApp.GetMcSrc( byIndex, &tSrc, byChannelNum, MODE_VIDEO )  &&
						tSrc == tDstMt )
					{
						return FALSE;
					}
				}
			}
			for( wLoop = 0; wLoop < MAXNUM_MONITOR_NUM; wLoop ++ )
			{
				if( !g_cMcuVcApp.GetMonitorData(byIndex, wLoop, tMonitorData) && 
					tMonitorData.GetMode() != MODE_VIDEO && tMonitorData.GetMode() != MODE_BOTH )
				{
					continue;
				}
				if( !tMonitorData.m_tSrc.IsNull() && tMonitorData.m_tSrc == tDstMt )
				{
					return FALSE;
				}				
			}
		}
	}

    return TRUE;
}

/*=============================================================================
函 数 名： IsNeedAdjustMtSndBitrate
功    能： 是否需要调整终端的发送码率
算法实现： 
全局变量： 
参    数： u8 byMtId
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/3/22  4.0			许世林                  创建
=============================================================================*/
BOOL32 CMcuVcInst::IsNeedAdjustMtSndBitrate(u8 byMtId, u16 &wSndBitrate,u8 byMediaMode /*= MODE_VIDEO*/)
{   
	//4.7.2 多音频格式会议下，对于源发送码率根据会议音频最大码率来调整
	//调整后源发送码率=呼叫码率(GetDialBitrate)+源音频格式码率-会议音频最大码率
	if ( byMediaMode == MODE_SECVIDEO )
	{
		TAudioTypeDesc tAudDesc[MAXNUM_CONF_AUDIOTYPE];
		if ( m_tConfEx.GetAudioTypeDesc(tAudDesc) < 2 )
		{
			return FALSE;
		}
		
		TLogicalChannel tLogicChn;
		if ( !m_ptMtTable->GetMtLogicChnnl(byMtId,LOGCHL_SECVIDEO,&tLogicChn,FALSE) )
		{
			ConfPrint(LOG_LVL_ERROR,MID_MCU_CONF, "[IsNeedAdjustMtSndBitrate2]GetMtLogicChnnl SECVIDEO byMtId:%d failed!\n",byMtId);
			return FALSE;
		}

		//目前GetDialBitrate拿到的码率是呼叫码率减去当前发送音频格式的码率
		//因此需要加上然后再减去最大的音频码率
		u16 wCurDsSndBiteRate = m_ptMtTable->GetSndBandWidth(m_tDoubleStreamSrc.GetMtId());
		wCurDsSndBiteRate = GetDoubleStreamVideoBitrate(wCurDsSndBiteRate,FALSE);
		
		TLogicalChannel tAudLogicChn;
		u16 wRawBiteRate = m_ptMtTable->GetDialBitrate(byMtId); //模板勾选的码率减去当前发送音频格式的码率
		if ( m_ptMtTable->GetMtLogicChnnl(byMtId,LOGCHL_AUDIO,&tAudLogicChn,FALSE) )
		{
			wRawBiteRate += GetAudioBitrate(tAudLogicChn.GetChannelType());
		}
		u16 wSndWidth = wRawBiteRate - GetMaxAudioBiterate(m_tConfEx);
		wSndBitrate = GetDoubleStreamVideoBitrate(wSndWidth,FALSE);
		
		if ( wSndBitrate>0 && wSndBitrate < wCurDsSndBiteRate  )
		{
			ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"[IsNeedAdjustMtSndBitrate]ajust ds wSndBitrate from:%d to %d\n",wCurDsSndBiteRate,wSndBitrate);
			return TRUE;
		}

		return FALSE;
	}

	wSndBitrate = 0xffff;
    TMt tSrcMt = m_ptMtTable->GetMt(byMtId);    
    TMtStatus tStatus;   

	//多音频时，主流源的码率需要计算出原始码率然后减去音频最大码率
	u16 wSrcMtBitRate = m_ptMtTable->GetDialBitrate(byMtId);
	BOOL32 bIsChange = FALSE;
	TAudioTypeDesc tAudDesc[MAXNUM_CONF_AUDIOTYPE];
	TLogicalChannel tVidLogicChn;
	if ( m_tConfEx.GetAudioTypeDesc(tAudDesc) >=2  &&
		m_ptMtTable->GetMtLogicChnnl(byMtId,LOGCHL_VIDEO,&tVidLogicChn,FALSE) 
		)
	{
		u16 wRawBiteRate= m_ptMtTable->GetDialBitrate(byMtId); //模板勾选的码率减去主格式音频码率后的值
		TLogicalChannel tAudLogicChn;
		if ( m_ptMtTable->GetMtLogicChnnl(byMtId,LOGCHL_AUDIO,&tAudLogicChn,FALSE) )
		{
			wRawBiteRate += GetAudioBitrate( tAudLogicChn.GetChannelType() );
		}
		wSrcMtBitRate = wRawBiteRate - GetMaxAudioBiterate(m_tConfEx);
		if ( !m_tDoubleStreamSrc.IsNull() )
		{
			wSrcMtBitRate = GetDoubleStreamVideoBitrate(wSrcMtBitRate);
		}
		bIsChange = TRUE;
	}
    
	if (tSrcMt == GetLocalVidBrdSrc()/*GetLocalSpeaker()*/ || tSrcMt == m_tDoubleStreamSrc)
    {        
        //由于非keda终端需要将码率交换回去，所以计算最低接收带宽时需要考虑源终端
        u8 bySrcMtId = 0;
        if (MT_MANU_KDC == m_ptMtTable->GetManuId(byMtId)
			|| MT_MANU_KDCMCU == m_ptMtTable->GetManuId(byMtId))
        {
            bySrcMtId = byMtId;
        }

        //双速会议调节
        if (0 != m_tConf.GetSecBitRate())
        {
            u16 wMinBitRate = m_ptMtTable->GetDialBitrate(byMtId);
            u16 wMtBitRate;
            
            for (u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++)
            {
                if (m_tConfAllMtInfo.MtJoinedConf(byLoop) && bySrcMtId != byLoop)
                {
                    m_ptMtTable->GetMtStatus(byLoop, &tStatus);

                    wMtBitRate = m_ptMtTable->GetMtReqBitrate(byLoop, TRUE);
                    if (wMtBitRate != 0 &&                         
                        (wMtBitRate*(g_cMcuVcApp.GetBitrateScale()+100)/100) >= m_ptMtTable->GetDialBitrate(byMtId) &&
                        wMtBitRate < wMinBitRate)
                    {
                        wMinBitRate = wMtBitRate;
                    }

                    // guzh [3/13/2007] 双流源还可能被选看
					//lukunpeng 2010/06/07 音视频源非local化整理
                    if ( tSrcMt == m_tDoubleStreamSrc &&
                         !(tSrcMt == GetLocalVidBrdSrc()) &&
                         tStatus.GetSelectMt(MODE_VIDEO) == tSrcMt &&
                         wMtBitRate < wMinBitRate )
                    {
                        wMinBitRate = wMtBitRate;
                    }
                }
            }    
            if (!bIsChange && wMinBitRate == m_tConf.GetBitRate())
            {
                return FALSE;
            }
            wSndBitrate = wMinBitRate;            
        }
        else
        {
            //这里只取同格式终端最小码率 (有适配时需适配的终端通过适配器交换)
            // guzh [9/19/2007] FIXME：辅格式发言，最低计算可能存在问题，第二个参数是否应该传递src的格式
            wSndBitrate = GetLeastMtReqBitrate(TRUE, m_tConf.GetMainVideoMediaType(), bySrcMtId);
        }        
    
		//与源wSrcMtBitRate取小一下
		wSndBitrate = min(wSndBitrate,wSrcMtBitRate);
		if (!(tSrcMt == m_tSecVidBrdSrc))
		{
			return TRUE;
		}
    }   

	if (tSrcMt == m_tSecVidBrdSrc)
	{
		if (0 == m_tConf.GetSecBitRate())
        {
            wSndBitrate = GetLeastMtReqBitrate(FALSE, m_tConf.GetMainVideoMediaType(), byMtId);
        }
		//return TRUE;
	}

	TMt tDstMt;

    //是否被其他终端选看
	u16 wMinBitRate = 0xffff;
	u16 wMtReqBit = 0;
    for(u8 byIdx = 1; byIdx <= MAXNUM_CONF_MT; byIdx++)
    {       
		//自己是低速且在收双流，自己的videoMt是自己
        if (/*byMtId != byIdx &&*/ m_tConfAllMtInfo.MtJoinedConf(byIdx))
        {
            if (m_ptMtTable->GetMtStatus(byIdx, &tStatus))
            {
				tDstMt = m_ptMtTable->GetMt(byIdx);
//                 if (GetLocalMtFromOtherMcuMt(tStatus.GetSelectMt(MODE_VIDEO)) == tSrcMt)
//                 {                
//                     // guzh [9/19/2007] FIXME：考虑被多个终端选看的情况
// 					// zgc [2008-01-22] 已修改FIXME
//                     wMtReqBit = m_ptMtTable->GetMtReqBitrate(byIdx, TRUE);
// 					wMinBitRate = ( wMinBitRate <= wMtReqBit ) ? wMinBitRate : wMtReqBit;
//                 }
				//选看时，终端状态VideoMt也会设置成选看源，如果有其他非选看操作(广播已在上面return), 可根据各个目的终端下调码率
				//上级主双比率5：5下级3：7下级发双流，停双流，上级调下级，以比率3的值调导致下级上传比率为3（实际停双流
				//应恢复成10）[11/28/2012 chendaiwei]
				if (GetLocalMtFromOtherMcuMt(tStatus.GetVideoMt()) == tSrcMt &&
					m_ptMtTable->IsLogicChnnlOpen(byIdx,LOGCHL_VIDEO,TRUE) &&
					!( (m_ptMtTable->GetMtType(tSrcMt.GetMtId()) == MT_TYPE_MMCU 
					    || m_ptMtTable->GetMtType(tSrcMt.GetMtId()) == MT_TYPE_SMCU)
					   && tSrcMt.GetMtId() == byIdx)
					)
				{
				    wMtReqBit = m_ptMtTable->GetMtReqBitrate(byIdx, TRUE);
 					wMinBitRate = ( wMinBitRate <= wMtReqBit ) ? wMinBitRate : wMtReqBit;
				}

				//双选看
				if ((m_ptMtTable->GetMtSelMtByMode(byIdx, MODE_VIDEO2SECOND) == tSrcMt && !IsNeedSelAdpt(tSrcMt, tDstMt, MODE_VIDEO2SECOND))
					&& m_ptMtTable->IsLogicChnnlOpen(byIdx, LOGCHL_SECVIDEO, TRUE))
				{
					wMtReqBit = m_ptMtTable->GetMtReqBitrate(byIdx, FALSE);
					wMinBitRate = ( wMinBitRate <= wMtReqBit ) ? wMinBitRate : wMtReqBit;
				}
            }
        }
    }	
	if ( wMinBitRate < 0xffff )
	{
		wSndBitrate = min(wSndBitrate, wMinBitRate);
	}

	//取小一下
	wSndBitrate = min(wSndBitrate,wSrcMtBitRate);
	if(IsSupportMultiSpy())
	{
		CSendSpy *ptSndSpy = NULL;
		for (u8 bySpyIdx = 0; bySpyIdx < MAXNUM_CONF_SPY; bySpyIdx++)
		{
			ptSndSpy = m_cLocalSpyMana.GetSendSpy(bySpyIdx);
			if (NULL == ptSndSpy)
			{
				continue;
			}
			if (ptSndSpy->GetSpyMt().IsNull() || ptSndSpy->GetSimCapset().IsNull() || !(ptSndSpy->GetSpyMt() == tSrcMt))
			{
				continue;
			}
			if (0 != ptSndSpy->GetSimCapset().GetVideoMaxBitRate() &&
				ptSndSpy->GetSimCapset().GetVideoMaxBitRate() < wSndBitrate )
			{
				wSndBitrate = ptSndSpy->GetSimCapset().GetVideoMaxBitRate();
				return TRUE;
			}
			break;
		}
	}

    return wSndBitrate != 0xffff;
}


/*==============================================================================
函数名    :  CheckDualMode		
功能      :  双流发起源判断
算法实现  :  
参数说明  :  
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2009-10-10                   薛亮
==============================================================================*/
BOOL32 CMcuVcInst::CheckDualMode(TMt &tMt)
{
	BOOL32 bRet = FALSE;
    
    //[5/30/2011 zhushengze]Imax模板只支持发言人发双流
	if ( CONF_DUALMODE_EACHMTATWILL == m_tConf.GetConfAttrb().GetDualMode()          
		|| ( CONF_DUALMODE_SPEAKERONLY == m_tConf.GetConfAttrb().GetDualMode() 
			&& (
				tMt == GetLocalSpeaker()	// xliang [10/10/2009] 级联场景下，因为时序问题，该判断失效
				|| ( m_bMMcuSpeakerValid && tMt.GetMtType() == MT_TYPE_MMCU ) // 添加此判断解决时序问题
				|| MT_MANU_POLYCOM == m_ptMtTable->GetManuId(tMt.GetMtId()) 
				)
			)
		)
	{
		bRet = TRUE;
	}

	// vrs新录播放像支持
	if (tMt.GetType() == TYPE_MT && tMt.GetMtType() == MT_TYPE_VRSREC)
	{
		if (m_ptMtTable->GetRecChlType(tMt.GetMtId()) == TRecChnnlStatus::TYPE_PLAY)
		{
			bRet = TRUE;
		}
	}

	// zbq [05/13/2010] VCS双流支持 策略调整
    if (VCS_CONF == m_tConf.GetConfSource())
    {
        //最上级MCU只要双流使能即可
		//zjj20110126 当下级mcu挂断再呼入时m_tCascadeMMCU.IsNull()的判断失效,所以再加一个判断(判断创会者)
        if (m_tCascadeMMCU.IsNull() && CONF_CREATE_MT != m_byCreateBy )
        {
            if (!m_cVCSConfStatus.IsConfDualEnable())
            {
                bRet = FALSE;
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_VCS, "[CheckDualMode] IsConfDualEnable False !\n");
            }
            else
            {
				if( tMt == m_tConf.GetSpeaker() )
				{
					bRet = TRUE;
				}
				else
				{
					if( tMt.IsLocal() && m_ptMtTable->GetMtType( tMt.GetMtId() ) == MT_TYPE_SMCU &&
						!m_tConf.GetSpeaker().IsLocal() &&
						GetFstMcuIdFromMcuIdx( m_tConf.GetSpeaker().GetMcuId() ) == tMt.GetMtId()
						)
					{
						bRet = TRUE;
					}
					else
					{
						bRet = FALSE;
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_VCS, "[CheckDualMode] tMt(%d.%d) is not Speaker(%d.%d)!\n",
								tMt.GetMcuId(),tMt.GetMtId(),
								m_tConf.GetSpeaker().GetMcuId(),m_tConf.GetSpeaker().GetMtId()
								);
					}					
				}
            }
        }        
        else
        {
			bRet = TRUE;
        }
    }

	return bRet;
}

/*=============================================================================
  函 数 名： IsMtSendingVideo
  功    能： 判断发双流终端是否发送第一路码流
  算法实现： 开双流时调节第一路码率，关双流时恢复第一路码率
  全局变量： 
  参    数： u8 byMtId
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcInst::IsDStreamMtSendingVideo(TMt tMt)
{
	TLogicalChannel tLogicalChannel;
	if (m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE))
	{
		return (tLogicalChannel.GetCurrFlowControl() > 0);
	}
	return FALSE;

	/*TMtStatus tStatus;	

	//是否广播源
	if (tMt == GetLocalSpeaker())
	{
		return TRUE;
	}

	//是否在录像
	m_ptMtTable->GetMtStatus(tMt.GetMtId(), &tStatus);
	if (tStatus.m_tRecState.IsRecording())
	{
		return TRUE;
	}

	//是否在回传通道里
    if (!m_tCascadeMMCU.IsNull())
    {
        TConfMcInfo *ptInfo = m_ptConfOtherMcTable->GetMcInfo(GetMcuIdxFromMcuId(m_tCascadeMMCU.GetMtId()));
        if (NULL != ptInfo &&
            m_tConfAllMtInfo.MtJoinedConf(ptInfo->m_tSpyMt.GetMcuIdx(), ptInfo->m_tSpyMt.GetMtId()) &&
            tMt == ptInfo->m_tSpyMt) 
        {   
            return TRUE;
        }        
    }   

	//是否被其他终端选看
	for (u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++)
    {
        if (byLoop == m_tDoubleStreamSrc.GetMtId() || !m_tConfAllMtInfo.MtJoinedConf(byLoop))
        {
            continue;
        }      
		
		if (m_ptMtTable->GetMtStatus(byLoop, &tStatus))
        {
            if (tStatus.GetSelectMt(MODE_VIDEO) == tMt)
            {               
                return TRUE;
            }
        }
    }

	return FALSE;*/
}

/*====================================================================
    函数名      ：ChangeSelectSrc
    功能        ：改变选看源
    算法实现    ：MODE_VIDEO，MODE_AUDIO任何一个模式下交换建立不成功
                 （包括走适配情况），都会返回失败
    引用全局变量：
    输入参数说明：
                  tSrcMt： [in] 源终端 
                  tDstMt： [in] 目的终端
                  byMode:  [in] MODE_VIDEO,MODE_AUDIO,MODE_BOTH
    返回值说明  ：TRUE = 选看彼此交换建立成功, FALSE = 不成功
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/06/02    3.6         LI BO         创建
    06/04/24    4.0         张宝卿        检测源和终端的能力集
====================================================================*/
BOOL CMcuVcInst::ChangeSelectSrc(TMt tSrcMt, TMt tDstMt, u8 byMode)
{
    TSwitchInfo  tSwitchInfo;
    tSwitchInfo.SetDstMt(tDstMt);
    tSwitchInfo.SetSrcMt(tSrcMt);
    
    if ( m_tConf.m_tStatus.IsMixing() && 
		!(tDstMt == m_tConf.GetChairman() && CONF_POLLMODE_BOTH_CHAIRMAN == m_tConf.m_tStatus.GetPollMode()) )
    {
		if (MODE_AUDIO == byMode)
		{
			return FALSE;
		}
        tSwitchInfo.SetMode(MODE_VIDEO);
    }

	tSwitchInfo.SetMode(byMode);

    //zbq[01/03/2008]禁止下级选看上级
    if ( !tDstMt.IsLocal() ||
         (tDstMt.IsLocal() && m_ptMtTable->GetMtType(tDstMt.GetMtId()) == MT_TYPE_SMCU) )
    {
		ConfPrint(LOG_LVL_WARNING, MID_MCU_MCS, "[ChangeSelectSrc] DstMt<%d,%d> isn't local, ignore it\n", tDstMt.GetMcuId(), tDstMt.GetMtId());
        return FALSE;
    }
    
    //取源终端与目的终端的能力集
    TSimCapSet tSrcSCS;
    if (tSrcMt.IsLocal())
    {
        tSrcSCS = m_ptMtTable->GetSrcSCS( tSrcMt.GetMtId() );
    }
    else
    {
        TMt tLocalSrcMt = GetLocalMtFromOtherMcuMt(tSrcMt);
        tSrcSCS = m_ptMtTable->GetSrcSCS( tLocalSrcMt.GetMtId() );
    }    
    //TSimCapSet tDstSCS = m_ptMtTable->GetDstSCS( tDstMt.GetMtId() );
    
    //选看模式和对应能力集不匹配
   // BOOL32 bAccord2Adp = FALSE;
    u8 bySwitchMode = tSwitchInfo.GetMode();
//     if ( !IsSelModeAndCapMatched( bySwitchMode, tSrcSCS, tDstSCS, bAccord2Adp ) ) 
//     {
//         ConfPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[ChangeSelectSrc]Select mode.%d failed!\n", tSwitchInfo.GetMode() );
//         return FALSE;
//     }
	BOOL32 bVidAdp = FALSE;
	BOOL32 bAudAdp = FALSE;

	BOOL32 bVidSwitchOk = TRUE;
    BOOL32 bAudSwitchOk = TRUE;

	if (MODE_VIDEO == bySwitchMode || MODE_BOTH == bySwitchMode)
	{
		if (IsNeedSelAdpt(tSrcMt, tDstMt, MODE_VIDEO))
		{
			if (g_cMcuVcApp.IsSelAccord2Adp())
			{
				bVidAdp = TRUE;
			}
			else
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_MCS, "[ChangeSelectSrc:Vid] IsSelAccord2Adp is 0!\n");
				bVidSwitchOk = FALSE;
			}					
		}
	}
	if(MODE_AUDIO == bySwitchMode || MODE_BOTH == bySwitchMode)
	{
		if (IsNeedSelAdpt(tSrcMt, tDstMt, MODE_AUDIO))
		{
			if (g_cMcuVcApp.IsSelAccord2Adp())
			{
				bAudAdp = TRUE;
			}
			else
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_MCS, "[ChangeSelectSrc:Aud] IsSelAccord2Adp is 0!\n");
				bAudSwitchOk = FALSE;
			}
		}
	}
    tSwitchInfo.SetMode( bySwitchMode );

    // 这里需要考虑是否是广播交换, zgc, 2008-06-03
	//lukunpeng 2010/06/07 音视频源非local化整理
    if( tSrcMt == GetLocalVidBrdSrc() &&
        ( !( (tSrcMt==m_tRollCaller && GetLocalMtFromOtherMcuMt(tDstMt)==GetLocalMtFromOtherMcuMt(m_tRollCallee)) 
          || (tSrcMt==GetLocalMtFromOtherMcuMt(m_tRollCallee) && tDstMt==m_tRollCaller) ) ) &&
        ( MODE_VIDEO == tSwitchInfo.GetMode() || MODE_BOTH == tSwitchInfo.GetMode() ) )
    {
		ConfPrint( LOG_LVL_WARNING, MID_MCU_MCS, "[ChangeSelectSrc] Dst(Mt.%d) receive Src(Mt.%d) as video broadcast src!\n", 
			       tDstMt.GetMtId(), tSrcMt.GetMtId() );

        StartSwitchFromBrd( tSrcMt, 0, 1, &tDstMt );
        
        if ( MODE_BOTH == tSwitchInfo.GetMode() )
        {
            tSwitchInfo.SetMode( MODE_AUDIO );
        }
        else
        {
            // 这里可以直接return，因为在这种情况下实际并没有发生选看
            return TRUE;
        }
	}
// guzh [2/28/2007] 记录选看
//     TMtStatus tMtStatus;
//     m_ptMtTable->GetMtStatus( tDstMt.GetMtId(), &tMtStatus );
//     tMtStatus.SetSelectMt( tSrcMt, tSwitchInfo.GetMode() );
//     m_ptMtTable->SetMtStatus( tDstMt.GetMtId(), &tMtStatus );
    
    CServMsg    cServMsgHdr;
    cServMsgHdr.SetEventId(MCS_MCU_STARTSWITCHMT_REQ);
	TSwitchInfo tTempSwitchInfo;
    TMtStatus tMtStatus;

	if(bVidSwitchOk && (MODE_BOTH == tSwitchInfo.GetMode() || MODE_VIDEO == tSwitchInfo.GetMode()))
	{
		if (bVidAdp)
		{
			bVidSwitchOk = StartSelAdapt(tSwitchInfo.GetSrcMt(), tSwitchInfo.GetDstMt(), MODE_VIDEO);
		}
		else
		{			
			memcpy(&tTempSwitchInfo, &tSwitchInfo, sizeof(tTempSwitchInfo));
			tTempSwitchInfo.SetMode(MODE_VIDEO);
			SwitchSrcToDst(tTempSwitchInfo, cServMsgHdr);	
		}
        //songkun,20110711,Bug00058197，交换建立不成功，不再设置其选看源，保证恢复时可以看VMP
        if (bVidSwitchOk)
        {
            m_ptMtTable->GetMtStatus( tDstMt.GetMtId(), &tMtStatus );
            tMtStatus.SetSelectMt( tSrcMt, MODE_VIDEO);
            m_ptMtTable->SetMtStatus( tDstMt.GetMtId(), &tMtStatus );
        }
	}
	
	if (bAudSwitchOk && (MODE_BOTH == tSwitchInfo.GetMode() || MODE_AUDIO == tSwitchInfo.GetMode()))
	{
		if (bAudAdp)
		{
			bAudSwitchOk = StartSelAdapt(tSwitchInfo.GetSrcMt(), tSwitchInfo.GetDstMt(), MODE_AUDIO);
		}
		else
		{
			memcpy(&tTempSwitchInfo, &tSwitchInfo, sizeof(tTempSwitchInfo));
			tTempSwitchInfo.SetMode(MODE_AUDIO);
			SwitchSrcToDst(tTempSwitchInfo, cServMsgHdr);	
		}
        //交换建立不成功，不再设置其选看源
        if (bAudSwitchOk)
        {
            m_ptMtTable->GetMtStatus( tDstMt.GetMtId(), &tMtStatus );
            tMtStatus.SetSelectMt( tSrcMt, MODE_AUDIO);
            m_ptMtTable->SetMtStatus( tDstMt.GetMtId(), &tMtStatus );
        }
	}

	//[2011/09/15/zhangli]因适配资源不足等原因导致建交换失败，释放回传
	if (!bVidSwitchOk)
	{
		FreeRecvSpy(tSrcMt, MODE_VIDEO);
	}

	if (!bAudSwitchOk)
	{
		FreeRecvSpy(tSrcMt, MODE_AUDIO);
	}

	ConfPrint( LOG_LVL_WARNING, MID_MCU_MCS, "Mt.%d select set Mt.%d, mode.%d\n", tDstMt.GetMtId(), tSrcMt.GetMtId(), tSwitchInfo.GetMode() );

    //选看成功否返回，用于判断是否恢复看广播，可能看vmp或看自己
    return bVidSwitchOk & bAudSwitchOk;
}


/*====================================================================
    函数名      ：StopSelectSrc
    功能        ：停止终端选看
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt tDstMt, u8 byMode, u8 byIsRestore
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	07/11/14	4.0			张宝卿         创建
====================================================================*/
void CMcuVcInst::StopSelectSrc( TMt tDstMt, u8 byMode, u8 byIsRestore,u8 byIsStopSwitch )
{
    TMt tNullMt;
	tNullMt.SetNull();
    TMtStatus tSrcStatus;

	TMt tVidSrc;
	TMt tAudioSrc;
	TMtStatus tMtStatus; 
	m_ptMtTable->GetMtStatus( tDstMt.GetMtId(), &tMtStatus );

	if( byMode == MODE_VIDEO || byMode == MODE_BOTH )
	{
		//重新调整选看源前记录选看源，这步要在ReleaseResbySel之前记录
		tVidSrc = tMtStatus.GetSelectMt( MODE_VIDEO );
	}

	if( byMode == MODE_AUDIO || byMode == MODE_BOTH )
	{
		//重新调整选看源前记录选看源，这步要在RestoreRcvMediaBrdSrc之前记录
		tAudioSrc = tMtStatus.GetSelectMt( MODE_AUDIO );
	}

	if (MODE_VIDEO2SECOND == byMode)
	{
		tVidSrc = m_ptMtTable->GetMtSelMtByMode(tDstMt.GetMtId(), byMode);
	}

	//  [pengguofeng 3/2/2013]停止主席选看的时候，有可能发言人因为没有足够的卫星回传带宽，没能作为视频广播源
	//　此时有必要给发言人恢复一下
	/*if ( m_tConf.GetConfAttrb().IsSatDCastMode()
		&& (byMode == MODE_VIDEO || byMode == MODE_BOTH )
		&& tDstMt == m_tConf.GetChairman()
		&& IsMultiCastMt(tVidSrc.GetMtId()))
	{
		TMt tSpeaker = m_tConf.GetSpeaker();
		if ( IsMultiCastMt(tSpeaker.GetMtId())
			&& !IsSatMtSend(tSpeaker)
			&& !(tSpeaker == GetLocalVidBrdSrc())
			&& !IsSatMtOverConfDCastNum(tSpeaker, emStopChairSel, 0xff, 0xff, 0xff, 0xff, 0xff, tVidSrc.GetMtId()))
		{
			ChangeVidBrdSrc(&tSpeaker);
		}
	}*/
	//跨格式选看释放对应的适配资源
	ReleaseResbySel(tDstMt, byMode );

    //change mode if mixing
    if ( MODE_BOTH == byMode )
    {
        if( m_tConf.m_tStatus.IsMixing() && 
			!(tDstMt == m_tConf.GetChairman() && CONF_POLLMODE_BOTH_CHAIRMAN == m_tConf.m_tStatus.GetPollMode()) 
           )
        {
            byMode = MODE_VIDEO;
        }
    }
	 
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_MCS, "Mcu%dMt%d Cancel Select See，mode %d.\n", tDstMt.GetMcuId(), tDstMt.GetMtId(), byMode);
    
    // guzh [7/28/2006] 选看的目标可能是下级终端
    tDstMt = GetLocalMtFromOtherMcuMt(tDstMt);
	if( !m_tConfAllMtInfo.MtJoinedConf( tDstMt.GetMtId() ) )
	{
		ConfPrint( LOG_LVL_DETAIL, MID_MCU_MCS, "[StopSelectSrc] Dst Mt%u-%u not joined conference!\n", 
			             tDstMt.GetMcuId(), tDstMt.GetMtId() );
		return;
	}

    // xsl [7/21/2006] 恢复终端接收地址
    /*if (m_tConf.GetConfAttrb().IsSatDCastMode())
    {
        if (MODE_AUDIO == byMode || MODE_BOTH == byMode)
        {
            ChangeSatDConfMtRcvAddr(tDstMt.GetMtId(), LOGCHL_AUDIO);
        }

        if (MODE_VIDEO == byMode || MODE_BOTH == byMode)
        {
            ChangeSatDConfMtRcvAddr(tDstMt.GetMtId(), LOGCHL_VIDEO);
        }                
    }*/           

	m_ptMtTable->RemoveMtSelMtByMode(tDstMt.GetMtId(), byMode);
	//zhouyiliang 20130222 停选看清selectmt同时清一下mtsrc，否则可能导致restore广播（过bas）交换的时候不拆老的选看交换
	m_ptMtTable->SetMtSrc(tDstMt.GetMtId(),&tNullMt,byMode);

	// xliang [1/9/2009] 区分起初选看的是MT还是EQP(目前是VMP)
	if ( tVidSrc.GetType() == TYPE_MT 
		&& ( byMode == MODE_VIDEO || byMode == MODE_BOTH ) 
		)
	{
		// xliang [12/12/2008] 选看状态重置后，判断是否是在MPU中的取消选看
		//是，则降该MT的分辨率
		if( ChgMtVidFormatRequired(tVidSrc) )
		{
			TVMPParam_25Mem  tVMPParam   = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
			ChangeMtVideoFormat(tVidSrc, FALSE);
		}
		// 重新调整选看源的发送码率，zgc, 2008-01-22
		m_ptMtTable->GetMtStatus(tVidSrc.GetMtId(), &tSrcStatus);
		if ( tVidSrc.IsLocal() &&
			m_tConfAllMtInfo.MtJoinedConf( tVidSrc.GetMtId() ) 
			&& tSrcStatus.IsSendVideo() 
			&& (MODE_VIDEO == byMode || MODE_BOTH == byMode)
			)
		{
			NotifyMtSend( tVidSrc.GetMtId(), MODE_VIDEO );
		}
	}
	else if( EQP_TYPE_VMP == tVidSrc.GetEqpType() )
	{
		// 普通终端选看vmp支持
		if (!g_cMcuVcApp.IsBrdstVMP(tVidSrc))
		{
			// 拆桥交换
			u8 bySrcChnnl = GetVmpOutChnnlByDstMtId( tDstMt.GetMtId(), tVidSrc.GetEqpId());
			if (0xFF != bySrcChnnl) 
			{
				//判断是否有别的终端在选看此通道,没有才拆桥
				u8 bySelectCount = GetMtNumSeeVmp(tVidSrc.GetEqpId(), bySrcChnnl, tDstMt.GetMtId());
				if (bySelectCount == 0)
				{
					g_cMpManager.RemoveSwitchBridge(tVidSrc, bySrcChnnl, MODE_VIDEO);
				}
			}
			// 调整mpu后向通道码率
			AdjustVmpSelBitRate(tVidSrc);
		}

		if (tDstMt == m_tConf.GetChairman())
		{
			//m_tConf.m_tStatus.SetVmpSeebyChairman(FALSE);
			/* 状态同步刷新到TPeriStatus中
			TPeriEqpStatus tVmpStatus;
			g_cMcuVcApp.GetPeriEqpStatus( m_tVmpEqp.GetEqpId() , &tVmpStatus );
			tVmpStatus.m_tStatus.tVmp.m_tVMPParam = m_tConf.m_tStatus.GetVmpParam();
			g_cMcuVcApp.SetPeriEqpStatus( m_tVmpEqp.GetEqpId() , &tVmpStatus );*/
			
			// [12/25/2009 xliang] 通知主席终端
			CServMsg cServMsg;
			SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_STARTSWITCHVMPMT_NACK,cServMsg);
		}
		/*if( tDstMt == m_tConf.GetChairman() )
		{
			m_tConf.m_tStatus.SetVmpSeebyChairman(FALSE);

			//20110623 zjl  取消主席选看vmp时，如果不是vmp广播则拆vmp输出桥
			if (!m_tConf.m_tStatus.IsBrdstVMP())
			{				
				u8 bySrcChnnl = GetVmpOutChnnlByDstMtId( tDstMt.GetMtId() );
				if (0xFF != bySrcChnnl) 
				{
					g_cMpManager.RemoveSwitchBridge(m_tVmpEqp, bySrcChnnl, MODE_VIDEO);
				}
			}		
			
			// 状态同步刷新到TPeriStatus中
			TPeriEqpStatus tVmpStatus;
			g_cMcuVcApp.GetPeriEqpStatus( m_tVmpEqp.GetEqpId() , &tVmpStatus );
			tVmpStatus.m_tStatus.tVmp.m_tVMPParam = m_tConf.m_tStatus.GetVmpParam();
			g_cMcuVcApp.SetPeriEqpStatus( m_tVmpEqp.GetEqpId() , &tVmpStatus );
			
			// [12/25/2009 xliang] 通知主席终端
			CServMsg cServMsg;
			SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_STARTSWITCHVMPMT_NACK,cServMsg);
		}*/
	}

	u8 byRestoreMode = byMode;

	if( byIsRestore && !m_tCascadeMMCU.IsNull() && m_tCascadeMMCU == m_tConf.GetSpeaker() &&
		(byMode == MODE_AUDIO || byMode == MODE_BOTH) )
	{
		TConfMcInfo *ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(GetMcuIdxFromMcuId(m_tCascadeMMCU.GetMtId()));
		
		if( ptConfMcInfo != NULL						
			&& ptConfMcInfo->m_tConfAudioInfo.m_byMixerCount == 1
			&& ptConfMcInfo->m_tConfAudioInfo.m_tMixerList[0].m_tSpeaker.IsMcuIdLocal()
			&& ptConfMcInfo->m_tConfAudioInfo.m_tMixerList[0].m_tSpeaker.GetMtId() == tDstMt.GetMtId()
			)
		{	
			//zjl 20110510 StopSwitchToSubMt 接口重载替换 
			//StopSwitchToSubMt( tDstMt.GetMtId(), MODE_AUDIO );
			StopSwitchToSubMt(1, &tDstMt, MODE_AUDIO);

			if( byMode == MODE_BOTH )
			{
				byRestoreMode = MODE_VIDEO;
			}
			else
			{
				byRestoreMode = MODE_NONE;
				byIsRestore = FALSE;
			}
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF,"[StopSelectSrc] Mt(%d) is GlobalSpeaker,so not restore audio switch to it.\n",
				tDstMt.GetMtId() );

		}
	}

	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();	
	//[2011/08/23/zhangli]拆除RTCP交换放到前面，RestoreRcvMediaBrdSrc里有可能恢复终端到广播的RTCP交换，不能放在RestoreRcvMediaBrdSrc后面调
	if((byMode == MODE_VIDEO || byMode == MODE_BOTH || byMode == MODE_VIDEO2SECOND)
		&& !tVidSrc.IsNull() && tConfAttrb.IsResendLosePack())
	{
		u8 bySrcChnnl = (EQP_TYPE_VMP == tVidSrc.GetEqpType()) ? (GetVmpOutChnnlByDstMtId(tDstMt.GetMtId(), tVidSrc.GetEqpId())) : 0;
		
		if (0xff != bySrcChnnl)
		{
			u8 byRtcpMode = byMode == MODE_VIDEO2SECOND ? MODE_VIDEO2SECOND : MODE_VIDEO;
			BuildRtcpSwitchForSrcToDst(tDstMt, tVidSrc, byRtcpMode, 0, bySrcChnnl, FALSE);
			
			u8 byVmpSubType = GetVmpSubType(m_tVmpEqp.GetEqpId());
			if ( EQP_TYPE_VMP == tVidSrc.GetEqpType() &&
				(VMP_8KH == byVmpSubType || VMP_8KI == byVmpSubType))
			{
				// 8kh 与 8ki vmp都有可能关闭第0路编码，需特殊处理
				u8 bySpecialSrcChnnl = GetVmpSpecialOutChnnlByDstMtId(tDstMt.GetMtId());
				if ( bySpecialSrcChnnl != 0xFF )
				{
					BuildRtcpSwitchForSrcToDst(tDstMt, tVidSrc, byRtcpMode, 0, bySpecialSrcChnnl, FALSE);
				}
			}	
		}
		else
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StopSelectSrc]get tDstMt:(%d,%d) vmp outchnnl failed\n", tDstMt.GetMcuId(),tDstMt.GetMtId());
		}
	}
	
	if(byMode == MODE_AUDIO || byMode == MODE_BOTH)
	{
		if(tConfAttrb.IsResendLosePack() && !tAudioSrc.IsNull())
		{
			BuildRtcpSwitchForSrcToDst(tDstMt, tAudioSrc, MODE_AUDIO, 0, 0, FALSE);
		}
	}

	//若有发言人，重新选看发言人
	if (byIsRestore)
	{
		if (MODE_VIDEO2SECOND == byMode)
		{
			RestoreRcvSecMediaBrdSrc(1, &tDstMt);
		}
		else
		{
			RestoreRcvMediaBrdSrc( tDstMt.GetMtId(), byRestoreMode );
		}
		byIsStopSwitch = FALSE;
	}

    // zgc, 2008-05-28, 不需要重新接受广播源则直接停交换
    if( byIsStopSwitch )
    {
        //zbq[11/01/2009] 点名人 刷新保护
        BOOL32 bSelSelf = TRUE;
        if (ROLLCALL_MODE_NONE != m_tConf.m_tStatus.GetRollCallMode() &&
            tDstMt.GetMtId() == m_tRollCaller.GetMtId())
        {
            bSelSelf = FALSE;
        }
		
		//zjl 20110510 StopSwitchToSubMt 接口重载替换 
        //StopSwitchToSubMt( tDstMt.GetMtId(), byMode, SWITCH_MODE_SELECT, TRUE, TRUE, bSelSelf );
		StopSwitchToSubMt(1, &tDstMt, byMode, TRUE, TRUE, bSelSelf);
    }

	// [11/13/2009 pengjie] 级联多回传，释放回传带宽，回收回传资源
	if( ( byMode == MODE_VIDEO || byMode == MODE_BOTH || byMode == MODE_VIDEO2SECOND) &&
		!tVidSrc.IsNull() )
	{
		FreeRecvSpy( tVidSrc, MODE_VIDEO );
	}

	if( byMode == MODE_AUDIO || byMode == MODE_BOTH )
	{			
		if( !tAudioSrc.IsNull()	)
		{
			FreeRecvSpy( tAudioSrc, MODE_AUDIO );
		}
// 		tNullMt.SetNull();
// 		tMtStatus.SetSelectMt(tNullMt, MODE_AUDIO);
// 		tMtStatus.RemoveSelByMcsMode( MODE_AUDIO );
// 		m_ptMtTable->SetMtStatus( tDstMt.GetMtId(), &tMtStatus );
	}

    MtStatusChange( &tDstMt, TRUE );

	//通知界面终端双选看源切变
	if (MODE_VIDEO2SECOND == byMode)
	{
		MtSecSelSrcChange(tDstMt);
		AdjustFitstSrcMtBit(tDstMt.GetMtId(), TRUE, TRUE);
	}
}

/*====================================================================
函数名      ：AdjustFitstSrcMtBit
功能        ：双选看时调终端第一路视频码率，终端不存在双选看，则恢复第一路视频源的发送码率；否则为降低
算法实现    ：
引用全局变量：
输入参数说明：u8 byMtId 终端ID
			  BOOL32 bIsFirstBrdAdp 第一路视频是发言人的话是否过适配
			  这个参数需要通过外面传参，因为在终端双流接收通道打开后第一路视频接收码率会降低，
			  可能之前不过适配降低后再判断就过适配了
			  BOOL32 bIsCancelSel 是否为取消选看，如果=TRUE，则重新取一次bIsFirstBrdAdp值
返回值说明  ：无
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/09/01  4.7         zhangli         create
====================================================================*/
void CMcuVcInst::AdjustFitstSrcMtBit(u8 byMtId, BOOL32 bIsFirstBrdAdp, BOOL32 bIsCancelSel/* = FALSE*/)
{
	//调第一个源的码率，主流
	TMt tMt = m_ptMtTable->GetMt(byMtId);
	if (tMt.IsNull())
	{
		return;
	}
	
	TMtStatus tMtStatus;
	if (!m_ptMtTable->GetMtStatus(byMtId, &tMtStatus))
	{
		return;
	}
	
	TMt tFirstSrcMt = tMtStatus.GetVideoMt();
	
	if (tFirstSrcMt.IsNull())
	{
		return;
	}
	
	if (TYPE_MT == tFirstSrcMt.GetType())
	{
		if (tFirstSrcMt == tMt)
		{
			return;
		}
		
		if (bIsCancelSel)
		{
			bIsFirstBrdAdp = IsNeedSelAdpt(GetVidBrdSrc(), tMt, MODE_VIDEO);
		}

		TLogicalChannel tLogicalChannel;
		if (tFirstSrcMt == tMtStatus.GetSelectMt(MODE_VIDEO) && IsNeedSelAdpt(tFirstSrcMt, tMt, MODE_VIDEO))
		{
			RefreshSelBasParam(tFirstSrcMt, tMt, MODE_VIDEO);
		}
		else if (tFirstSrcMt == GetVidBrdSrc() && bIsFirstBrdAdp)
		{
			RefreshBrdBasParamForSingleMt(tMt.GetMtId(), MODE_VIDEO);
		}
		else if (m_ptMtTable->GetMtLogicChnnl(tFirstSrcMt.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE))
		{
			u16 wChanBitrate = GetDoubleStreamVideoBitrate(m_ptMtTable->GetDialBitrate(tFirstSrcMt.GetMtId()), TRUE);
			if (tLogicalChannel.GetFlowControl() > wChanBitrate)
			{
				CServMsg cServMsg;
				tLogicalChannel.SetFlowControl(wChanBitrate);
				cServMsg.SetMsgBody((u8*)&tLogicalChannel, sizeof(tLogicalChannel));
				SendMsgToMt(tFirstSrcMt.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cServMsg);
			}
		}
	}
}

/*====================================================================
    函数名      ：ChangeChairman
    功能        ：改变主席（包括单纯撤销）；
	              通知MC，MT和下级MCU；
				  如果新、旧主席直连，通知其自身改变状态
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt * ptNewChairman, 新主席，NULL表示单纯撤销
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/01/04    1.0         LI Yi         创建
	03/11/25    3.0         胡昌威        修改
====================================================================*/
void CMcuVcInst::ChangeChairman( TMt * ptNewChairman, BOOL32 bAdjustSwitch )
{
	CServMsg	cServMsg;
	TMt		tOldChairman = m_tConf.GetChairman();
	cServMsg.SetConfId( m_tConf.GetConfId() );
	//TMt    tSpeakerSrc;
	BOOL32 bHasOldChairman = FALSE;

    TPeriEqpStatus tTWStatus;
    TPeriEqpStatus tHduStatus;
	TPeriEqpStatus tVmpStatus;

    u8 byChnlIdx;
    u8 byEqpId;

	if(ptNewChairman != NULL)
    {
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "ChangeChariman to Mt(%d,%d)\n", ptNewChairman->GetMcuId(), ptNewChairman->GetMtId());
		*ptNewChairman = GetLocalMtFromOtherMcuMt(* ptNewChairman);
    }
			    
	//取消原主席
	if( HasJoinedChairman() )
	{	
		bHasOldChairman = TRUE;

		cServMsg.SetMsgBody( ( u8 * )&tOldChairman, sizeof( tOldChairman ) );
		cServMsg.SetNoSrc();
		SendMsgToMt( tOldChairman.GetMtId(), MCU_MT_CANCELCHAIRMAN_NOTIF,cServMsg );
		m_tConf.SetNoChairman();
		ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_MT, "Old chairman MT%u was cancelled!\n", tOldChairman.GetMtId() );

		//20110107_tzy 申请主席，自动将主席放入混音组情况下，取消主席同样自动将其踢出混音组
		if (g_cMcuVcApp.IsChairAutoSpecMix())
		{
			TMt tLocalChair = GetLocalMtFromOtherMcuMt(tOldChairman);
			if (m_tConf.m_tStatus.IsSpecMixing() && 
				m_ptMtTable->IsMtInMixGrp(tLocalChair.GetMtId()) &&				
				m_ptMtTable->IsMtAutoInSpec( tLocalChair.GetMtId() ) &&
				!(GetLocalSpeaker() == tLocalChair))
			{
				BOOL32 bStopNoMem = (ptNewChairman == NULL);
				RemoveSpecMixMember(&tLocalChair, 1, FALSE,bStopNoMem);
			}
		}
		/* xliang [4/2/2009] 主席选看VMP此时失效
		if(m_tConf.m_tStatus.IsVmpSeeByChairman())
		{
			m_tConf.m_tStatus.SetVmpSeebyChairman(FALSE);
			/* 状态同步刷新到TPeriStatus中
			g_cMcuVcApp.GetPeriEqpStatus( m_tVmpEqp.GetEqpId() , &tVmpStatus );
			tVmpStatus.m_tStatus.tVmp.m_tVMPParam = m_tConf.m_tStatus.GetVmpParam();
			g_cMcuVcApp.SetPeriEqpStatus( m_tVmpEqp.GetEqpId() , &tVmpStatus );*
			//清交换及选看源状态
			StopSelectSrc(tOldChairman,MODE_VIDEO);
		}*/
		//zjl20110426 取消或切换主席时，如果当前发言人模式是选看主席，则停选看操作
		if (CONF_SPEAKERSRC_CHAIR == m_tConf.GetConfAttrb().GetSpeakerSrc() &&
			 (NULL == ptNewChairman || 
				  (NULL != ptNewChairman && 
					   !(*ptNewChairman == tOldChairman)
					  )
				)
			)
		{
			u8 bySelMode = m_tConf.GetConfAttrb().GetSpeakerSrcMode();
			u8 byStopOldSwitch = (u8)TRUE;
			//切主席的时候，不应该先停交换，否则会出现发言人闪下自己图像的情况
			if (NULL != ptNewChairman && !ptNewChairman->IsNull())
			{
				byStopOldSwitch = FALSE;
			}
			StopSelectSrc(m_tConf.GetSpeaker(), bySelMode,byStopOldSwitch,byStopOldSwitch);
		}
		/* zgc, 2008-05-05, 这里的代码不需要，在最后调整主席交换的函数里统一处理
		//如果发言人的源是主席
		if( HasJoinedSpeaker() )
		{
			// 视频
			m_ptMtTable->GetMtSrc( GetLocalSpeaker().GetMtId(), &tSpeakerSrc, MODE_VIDEO );
			if( tSpeakerSrc == tOldChairman && 
				m_tConf.GetConfAttrb().GetSpeakerSrc() == CONF_SPEAKERSRC_CHAIR && 
				ptNewChairman == NULL &&
				// 如果非会议内部逻辑选看，则不要停止, zgc, 2008-04-14
				SPEAKER_SRC_CONFSEL == GetSpeakerSrcSpecType( MODE_VIDEO ) )
			{
                TMt tLocalSpeaker = GetLocalSpeaker();
				if( m_ptMtTable->GetManuId( tLocalSpeaker.GetMtId() ) == MT_MANU_KDC )
				{
					//StopSwitchToSubMt( tLocalSpeaker.GetMtId(), MODE_BOTH, SWITCH_MODE_SELECT, TRUE );
					StopSwitchToSubMt( tLocalSpeaker.GetMtId(), MODE_VIDEO, SWITCH_MODE_SELECT, TRUE );

                    // 如果当前有混音，把N-1模式的混音交换恢复建立给发言人 [12/20/2006-zbq]
					// 音频单独处理，zgc, 2008-04-14					
                    //if ( m_tConf.m_tStatus.IsMixing() )
                    //{
                    //   SwitchMixMember( &tLocalSpeaker, FALSE );
                    //}
					
				}
				else
				{
                    //非kdc厂商回传自身视频, 节省带宽时，通知mt发送码流
                    if(g_cMcuVcApp.IsSavingBandwidth())
                    {
                        NotifyOtherMtSend(tLocalSpeaker.GetMtId(), TRUE);
                    }                    
					
					// 音频单独处理，zgc, 2008-04-25
					//u8 byMode = m_tConf.m_tStatus.IsMixing() ? MODE_VIDEO : MODE_BOTH;
					//StartSwitchToSubMt( tLocalSpeaker, 0, tLocalSpeaker.GetMtId(), byMode, SWITCH_MODE_SELECT, TRUE );
					StartSwitchToSubMt( tLocalSpeaker, 0, tLocalSpeaker.GetMtId(), MODE_VIDEO, SWITCH_MODE_SELECT, TRUE );
				}
			}

			//音频单独处理
			m_ptMtTable->GetMtSrc( GetLocalSpeaker().GetMtId(), &tSpeakerSrc, MODE_AUDIO );
			if( tSpeakerSrc == tOldChairman && 
				m_tConf.GetConfAttrb().GetSpeakerSrc() == CONF_SPEAKERSRC_CHAIR && 
				ptNewChairman == NULL &&
				m_tConf.GetConfAttrb().GetSpeakerSrcMode() == MODE_BOTH &&
				// 如果非会议自动设定，则不要停止, zgc, 2008-04-14
				SPEAKER_SRC_CONFSEL == GetSpeakerSrcSpecType( MODE_AUDIO ) )
			{
                TMt tLocalSpeaker = GetLocalSpeaker();
				if( m_ptMtTable->GetManuId( tLocalSpeaker.GetMtId() ) == MT_MANU_KDC )
				{
					StopSwitchToSubMt( tLocalSpeaker.GetMtId(), MODE_AUDIO, SWITCH_MODE_SELECT, TRUE );
					
                    // 如果当前有混音，把N-1模式的混音交换恢复建立给发言人 [12/20/2006-zbq]
                    if ( m_tConf.m_tStatus.IsMixing() )
                    {
                        SwitchMixMember( &tLocalSpeaker, FALSE );
                    }
				}
				else
				{
                    //非kdc厂商回传自身视频, 节省带宽时，通知mt发送码流
                    //if(g_cMcuVcApp.IsSavingBandwidth())
                    //{
                    //    NotifyOtherMtSend(tLocalSpeaker.GetMtId(), TRUE);
                    //}
					//u8 byMode = m_tConf.m_tStatus.IsMixing() ? MODE_VIDEO : MODE_BOTH;
					//StartSwitchToSubMt( tLocalSpeaker, 0, tLocalSpeaker.GetMtId(), byMode, SWITCH_MODE_SELECT, TRUE );
					
					if ( !m_tConf.m_tStatus.IsMixing() )
					{
						StartSwitchToSubMt( tLocalSpeaker, 0, tLocalSpeaker.GetMtId(), MODE_AUDIO, SWITCH_MODE_SELECT, TRUE );
					}
				}
			}
		}*/

        //强制广播下，恢复其视频源[01/24/2007-zbq]
        if ( m_tConf.m_tStatus.IsMustSeeSpeaker() )
        {            
            TMtStatus tStatus;
			m_ptMtTable->GetMtStatus( tOldChairman.GetMtId(),&tStatus );
            //指定恢复接收音频广播媒体源
			if( !tStatus.GetSelectMt(MODE_VIDEO).IsNull() )
			{
				StopSelectSrc( tOldChairman,MODE_VIDEO );
			}
			else
			{
				RestoreRcvMediaBrdSrc( tOldChairman.GetMtId(), MODE_VIDEO );
			}
		
		
			if( !tStatus.GetSelectMt(MODE_AUDIO).IsNull() )
			{
				StopSelectSrc( tOldChairman,MODE_AUDIO );
			}
			else
			{
				RestoreRcvMediaBrdSrc( tOldChairman.GetMtId(), MODE_AUDIO );
			} 
        }        

        for (byEqpId = TVWALLID_MIN; byEqpId <= TVWALLID_MAX; byEqpId++)
        {
            if (EQP_TYPE_TVWALL == g_cMcuVcApp.GetEqpType(byEqpId))
            {
                for (byChnlIdx = 0; byChnlIdx < MAXNUM_PERIEQP_CHNNL; byChnlIdx++)
                {
                    if (g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tTWStatus) &&
                        tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType == TW_MEMBERTYPE_CHAIRMAN &&
                        tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].GetConfIdx() == m_byConfIdx)
                    {
                        ChangeTvWallSwitch(&tOldChairman, byEqpId, byChnlIdx, TW_MEMBERTYPE_CHAIRMAN, TW_STATE_STOP);
                    }
                }
            }
        }

		for (byEqpId = HDUID_MIN; byEqpId <= HDUID_MAX; byEqpId++)
        {
			if(IsValidHduEqp(g_cMcuVcApp.GetEqp(byEqpId)))
            {
				u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byEqpId));
				if (0 == byHduChnNum)
				{
					ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU, "[ChangeChairman] GetHduChnNumAcd2Eqp failed!\n");
					continue;
				}

                for (byChnlIdx = 0; byChnlIdx < min(byHduChnNum,MAXNUM_HDU_CHANNEL); byChnlIdx++)
                {
                    if (g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tHduStatus) &&
                        tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].byMemberType == TW_MEMBERTYPE_CHAIRMAN &&
                        tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].GetConfIdx() == m_byConfIdx &&
						NULL == ptNewChairman)
                    {
						// [2013/03/11 chenbing] HDU多画面目前不支持主席跟随,子通道置0
                        ChangeHduSwitch(NULL, byEqpId, byChnlIdx, 0, TW_MEMBERTYPE_CHAIRMAN, TW_STATE_STOP);
                    }
                }
            }
        }


		//适应远摇中兴MCU的特殊情况，向所有的中兴MCU发一次取消主席请求
        if (g_cMcuVcApp.IsApplyChairToZxMcu())
		{
			for ( u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId  ++ )
			{
				if ( m_tConfAllMtInfo.MtJoinedConf(byMtId) &&
					MT_MANU_ZTEMCU == m_ptMtTable->GetManuId(byMtId) )
				{            
					CServMsg cSerMsg;
					SendMsgToMt( byMtId, MCU_MT_CANCELCHAIRMAN_CMD, cSerMsg );                
				}
			}
		}
	}

	//设置新主席
	if( ptNewChairman != NULL )
	{	
		cServMsg.SetMsgBody( ( u8 * )ptNewChairman, sizeof( TMt ) );
		cServMsg.SetNoSrc();
		SendMsgToMt( ptNewChairman->GetMtId(), MCU_MT_SPECCHAIRMAN_NOTIF,cServMsg );
		m_tConf.SetChairman( *ptNewChairman );
		TMtAlias tChaiManAlias ;
		if ( m_ptMtTable->GetDialAlias(ptNewChairman->GetMtId(),&tChaiManAlias) ) 
		{
			m_tConf.SetChairAlias( tChaiManAlias );
		}
	
		// 普通终端选看画面合成,变为主席后,需要同步刷新到TPeriStatus
		TMtStatus tMtStatus;
		m_ptMtTable->GetMtStatus(ptNewChairman->GetMtId(), &tMtStatus);
		TMt tSelectSrc = tMtStatus.GetSelectMt(MODE_VIDEO);
		/*if ((TYPE_MCUPERI == tSelectSrc.GetType() && EQP_TYPE_VMP == tSelectSrc.GetEqpType()))
		{
			m_tConf.m_tStatus.SetVmpSeebyChairman(TRUE);
			/* 状态同步刷新到TPeriStatus中
			g_cMcuVcApp.GetPeriEqpStatus( m_tVmpEqp.GetEqpId() , &tVmpStatus );
			tVmpStatus.m_tStatus.tVmp.m_tVMPParam = m_tConf.m_tStatus.GetVmpParam();
			g_cMcuVcApp.SetPeriEqpStatus( m_tVmpEqp.GetEqpId() , &tVmpStatus );*
		}*/

		ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_CONF, "New chairman MT%u is specified!\n", ptNewChairman->GetMtId() );

        //适应远摇中兴MCU的特殊情况，向所有的中兴MCU发一次申请主席请求 [zbq 06-04-20]
        if (g_cMcuVcApp.IsApplyChairToZxMcu())
		{
			CServMsg cSerMsg;
			for ( u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId  ++ )
			{
				if ( m_tConfAllMtInfo.MtJoinedConf(byMtId) &&
					MT_MANU_ZTEMCU == m_ptMtTable->GetManuId(byMtId) )
				{     
					SendMsgToMt( byMtId, MCU_MT_APPLYCHAIRMAN_CMD, cSerMsg );                
				}
			}
		}
		//201110107_tzy 申请主席成功后自动进行定制混音
		if (g_cMcuVcApp.IsChairAutoSpecMix())
		{
			ChairmanAutoSpecMix();
		}
	}

    //通知所有会控
    TBasicConfInfo tBasicConfInfo;
    tBasicConfInfo.SetSpeaker(m_tConf.GetSpeaker());
    tBasicConfInfo.SetChairman(m_tConf.GetChairman());
	cServMsg.SetMsgBody( ( u8 * )&tBasicConfInfo, sizeof( tBasicConfInfo ) );
	SendMsgToAllMcs( MCU_MCS_SIMCONFINFO_NOTIF, cServMsg );
	
	//通知所有终端
	//简化通知终端使用的会议信息结构 2005-10-11
	TConfStatus tConfStatus = m_tConf.GetStatus();
	TSimConfInfo tSimConfInfo;
	tSimConfInfo.m_tSpeaker  = GetLocalSpeaker();
	tSimConfInfo.m_tChairMan = m_tConf.GetChairman();
	tSimConfInfo.SetVMPMode(tConfStatus.GetVMPMode());
    // guzh [11/6/2007] 
	tSimConfInfo.SetMixMode(tConfStatus.GetMixerMode());

	cServMsg.SetMsgBody( ( u8 * )&tSimConfInfo, sizeof( tSimConfInfo ) );
	BroadcastToAllSubMtJoinedConf( MCU_MT_SIMPLECONF_NOTIF, cServMsg );
    if (NULL != ptNewChairman)
    {
        TMt tSpeaker = m_tConf.GetSpeaker();
        m_tConf.SetSpeaker(GetLocalSpeaker());
        cServMsg.SetMsgBody((u8 *)&m_tConf, sizeof(TConfInfo));
        SendMsgToMt(ptNewChairman->GetMtId(), MCU_MT_CONF_NOTIF, cServMsg);
        m_tConf.SetSpeaker(tSpeaker);
    }

	if (bAdjustSwitch)
	{
		//zbq[09/24/2007] 主席终端的后视频向通道打开，调整相关交换
		TLogicalChannel tLogicChan;
		// 音频通道
		if ( NULL == ptNewChairman ||
			( NULL != ptNewChairman &&
			   m_ptMtTable->GetMtLogicChnnl(ptNewChairman->GetMtId(), LOGCHL_AUDIO, &tLogicChan, FALSE)))
		{
			AdjustChairmanAudSwitch();
		}
		// 视频通道
		if ( NULL == ptNewChairman ||
			( NULL != ptNewChairman &&
			m_ptMtTable->GetMtLogicChnnl(ptNewChairman->GetMtId(), LOGCHL_VIDEO, &tLogicChan, FALSE)))
		{
			TMt *ptOldChairman = NULL;
			if ( bHasOldChairman )
			{
				ptOldChairman = &tOldChairman;
			}
			AdjustChairmanVidSwitch( ptOldChairman );
		}
	}
	

    //n+1备份更新主席信息
    if (MCU_NPLUS_MASTER_CONNECTED == g_cNPlusApp.GetLocalNPlusState())
    {
        ProcNPlusChairmanUpdate();
    }

	//给主席发送vmp信息
	SendVmpParamToChairMan();

    return;
}


/*====================================================================
    函数名      ：AdjustChairmasSwitch
    功能        ：调整当前主席的相关交换：四个跟随建立
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    07/09/24    4.0         张宝卿        创建
====================================================================*/
void CMcuVcInst::AdjustChairmanSwitch( TMt *ptOldChair )
{
	// 此接口未被使用，废除
    //zbq [10/11/2007] 本处理取消主席 共用
    /*if ( !HasJoinedChairman() )
    {
        ConfLog( FALSE, "[AdjustChairmanSwitch] No chairman, ignore it\n" );
        return;
    }*/
    
    TMt tChairMan = m_tConf.GetChairman();

	//发言人看主席时；发言人源的调整, zgc, 2008-02-25
	u8 bySelMode = m_tConf.GetConfAttrb().GetSpeakerSrcMode();
	ChangeSpeakerSrc( bySelMode, emReasonChangeChairman );

	// zgc, 2007-12-24,
	// 以下VMP及VMPTW加入跟随通道的处理 从 加入电视墙跟随通道之上移到 
	// 后向逻辑通道是否打开判断之上，因为 ChangeVmpChannelParam 和 ChangeVmpTwChannelParam
	// 是双向处理函数，不需要判断后向逻辑通道是否打开
	//加入画面合成跟随通道
    if (g_cMcuVcApp.GetVMPMode(m_tVmpEqp) != CONF_VMPMODE_NONE)
    {
        // xsl [10/27/2006]卫星分散会议时需要判断回传通道数
        if (m_tConf.GetConfAttrb().IsSatDCastMode() &&
            m_tConf.m_tStatus.GetVmpParam().IsTypeInMember(VMP_MEMBERTYPE_CHAIRMAN)
			&& !IsSatMtSend(tChairMan))
        {
            if (/*IsOverSatCastChnnlNum(tChairMan.GetMtId())*/
				//IsSatMtOverConfDCastNum(tChairMan))
				!IsSatMtCanContinue(tChairMan.GetMtId(),emChairMan))
            {
                ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[ChangeChairman] over max upload mt num. nack!\n");            
                NotifyMcsAlarmInfo(0, ERR_MCU_DCAST_OVERCHNNLNUM);
                return;
            }
        }    
        
		TVMPParam tVmpParm = m_tConf.m_tStatus.GetVmpParam();
        if (IsChangeVmpParam() &&
            // zbq [05/31/2007] 若所有VMP通道都不是主席跟随，不需要调整通道风格
            ( tVmpParm.IsTypeInMember(VMP_MEMBERTYPE_CHAIRMAN) ||
			 tVmpParm.IsMtInMember( tChairMan ) || 
			 ( ptOldChair != NULL && tVmpParm.IsMtInMember( *ptOldChair ) ) )
		)
        {
            ChangeVmpChannelParam(&tChairMan, VMP_MEMBERTYPE_CHAIRMAN, ptOldChair);
        }
        else
        {
            SetTimer(MCUVC_CHANGE_VMPCHAN_CHAIRMAN_TIMER, TIMESPACE_CHANGEVMPPARAM, VMP_MEMBERTYPE_CHAIRMAN);
        }
    }
    
    //加入多画面电视墙跟随通道
    if (m_tConf.m_tStatus.GetVmpTwMode() != CONF_VMPTWMODE_NONE)
    {
		TVMPParam tVmpTwParm = m_tConf.m_tStatus.GetVmpTwParam();
        // xsl [10/27/2006]卫星分散会议时需要判断回传通道数
        if (m_tConf.GetConfAttrb().IsSatDCastMode() &&
            tVmpTwParm.IsTypeInMember(VMPTW_MEMBERTYPE_CHAIRMAN)
			&& IsMultiCastMt(tChairMan.GetMtId())
			&& !IsSatMtSend(tChairMan))
        {
            if (/*IsOverSatCastChnnlNum(tChairMan.GetMtId())*/
				!IsSatMtCanContinue(tChairMan.GetMtId(),emChairMan))
            {
                ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[ChangeChairman] over max upload mt num. nack!\n");            
                NotifyMcsAlarmInfo(0, ERR_MCU_DCAST_OVERCHNNLNUM);
                return;
            }
        }    
        
        ChangeVmpTwChannelParam(&tChairMan, VMPTW_MEMBERTYPE_CHAIRMAN);
    }

    TLogicalChannel tLogicChan;
    if ( !m_ptMtTable->GetMtLogicChnnl(tChairMan.GetMtId(), LOGCHL_VIDEO, &tLogicChan, FALSE))
    {
        ConfPrint( LOG_LVL_WARNING, MID_MCU_MT, "[AdjustChairmanSwitch] ChairMt.%d's RL chan unexist, ignore it\n", tChairMan.GetMtId() );
        return;
    }
        
	/*
    if( HasJoinedSpeaker() && 
        HasJoinedChairman() && 
        m_tConf.GetConfAttrb().GetSpeakerSrc() == CONF_SPEAKERSRC_CHAIR )
    {
        if( //!m_tConf.m_tStatus.IsBrdstVMP() &&
            //!( m_tConf.m_tStatus.GetPollMode() == CONF_POLLMODE_VIDEO ) && 
            ( m_tConf.GetConfAttrb().GetSpeakerSrcMode() == MODE_VIDEO || 
            m_tConf.GetConfAttrb().GetSpeakerSrcMode() == MODE_BOTH ) )
        {
            u8 bySelMode = m_tConf.GetConfAttrb().GetSpeakerSrcMode();
            ChangeSelectSrc(tChairMan, GetLocalSpeaker(), bySelMode);
        }
    }
	*/

    /*
    //如果有发言人，则把发言人当前视频源号发给主席(若终端要知道当前视频源号，需要增加非标消息通知)        
    if (m_tConf.HasSpeaker())
    {
        CServMsg cServMsgTmp;
        TMt tMtSpeaker = m_tConf.GetSpeaker();
        u8 byCurrVidSrcNo = m_ptMtTable->GetCurrVidSrcNo(tMtSpeaker.GetMtId());

        cServMsgTmp.SetSrcMtId(tMtSpeaker.GetMtId());
        cServMsgTmp.SetMsgBody((u8 *)ptNewChairman, sizeof(TMt));
        cServMsgTmp.CatMsgBody((u8 *)&byCurrVidSrcNo, sizeof(u8));
        MtVideoSourceSwitched(cServMsgTmp);
    }
    */
  
    //加入电视墙跟随通道
	TPeriEqpStatus tTWStatus;
    u8 byChnlIdx;
    u8 byEqpId;
    for (byEqpId = 1; byEqpId <= MAXNUM_MCU_PERIEQP; byEqpId++)
    {
        if (EQP_TYPE_TVWALL == g_cMcuVcApp.GetEqpType(byEqpId))
        {
            for (byChnlIdx = 0; byChnlIdx < MAXNUM_PERIEQP_CHNNL; byChnlIdx++)
            {
                if (g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tTWStatus) &&
                    tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType == TW_MEMBERTYPE_CHAIRMAN &&
                    tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].GetConfIdx() == m_byConfIdx)
                {
                    // xsl [10/27/2006]卫星分散会议时需要判断回传通道数
                    if (m_tConf.GetConfAttrb().IsSatDCastMode()
						&& IsMultiCastMt(tChairMan.GetMtId())
						&& !IsSatMtSend(tChairMan))
                    {
                        if (/*IsOverSatCastChnnlNum(tChairMan.GetMtId())*/
							//IsSatMtOverConfDCastNum(tChairMan, emTvWall, 0xff,0xff, 0xff, byEqpId, byChnlIdx)
							!IsSatMtCanContinue())
                        {
                            ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[ChangeChairman] over max upload mt num. nack!\n");            
                            NotifyMcsAlarmInfo(0, ERR_MCU_DCAST_OVERCHNNLNUM);
                            return;
                        }
                    }    
                    
                    ChangeTvWallSwitch(&tChairMan, byEqpId, byChnlIdx, TW_MEMBERTYPE_CHAIRMAN, TW_STATE_CHANGE);
                }
            }
        }
    }
    
    return;
}

/*=============================================================================
函 数 名： AdjustChairmanVidSwitch
功    能： 调整主席视频交换
算法实现： 
全局变量： 
参    数： TMt *ptOldChair = NULL
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2008/4/21   4.0			周广程                  创建
=============================================================================*/
void CMcuVcInst::AdjustChairmanVidSwitch( TMt *ptOldChair )
{
	//zbq [10/11/2007] 本处理取消主席 共用
    /*if ( !HasJoinedChairman() )
    {
        ConfLog( FALSE, "[AdjustChairmanSwitch] No chairman, ignore it\n" );
        return;
    }*/
    
    TMt tChairMan = m_tConf.GetChairman();

	//发言人看主席时；发言人源的调整, zgc, 2008-02-25
	u8 bySelMode = m_tConf.GetConfAttrb().GetSpeakerSrcMode();
	// 增加对发言人源的码流模式的判断，防止误调整，zgc, 2008-04-21
	if ( bySelMode == MODE_VIDEO || bySelMode == MODE_BOTH )
	{
		ChangeSpeakerSrc( MODE_VIDEO, emReasonChangeChairman );
	}

	// zgc, 2007-12-24,
	// 以下VMP及VMPTW加入跟随通道的处理 从 加入电视墙跟随通道之上移到 
	// 后向逻辑通道是否打开判断之上，因为 ChangeVmpChannelParam 和 ChangeVmpTwChannelParam
	// 是双向处理函数，不需要判断后向逻辑通道是否打开
	//加入画面合成跟随通道
	u8 byVmpCount = GetVmpCountInVmpList();
	if (byVmpCount > 0)
	{
		//卫星会议不支持自动合成，非自动画面合成不支持主席跟随，此处无需判断卫星回传数

		// VCS会议不需要在此处调整vmp，vcs不存在主席变化，除主席终端掉线切备用主席时
		// 有备用主席时，主席掉线后备用主席变主席，此时主席终端的掉线状态还未置，会将它当成普通终端处理
		if (VCS_CONF != m_tConf.GetConfSource())
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_VMP, "[AdjustChairmanVidSwitch] begin to call FUNCTION[ChangeVmpChannelParam]!\n");
			ChangeVmpChannelParam(&tChairMan, VMP_MEMBERTYPE_CHAIRMAN, ptOldChair);
		}
	}
	/*TVMPParam_25Mem tVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
    if (tVmpParam.GetVMPMode() != CONF_VMPMODE_NONE)
    {
        // xsl [10/27/2006]卫星分散会议时需要判断回传通道数
        if (m_tConf.GetConfAttrb().IsSatDCastMode() &&
            m_tConf.m_tStatus.GetVmpParam().IsTypeInMember(VMP_MEMBERTYPE_CHAIRMAN)
			&& IsMultiCastMt(tChairMan.GetMtId())
			&& !IsSatMtSend(tChairMan))
        {
            if (/*IsOverSatCastChnnlNum(tChairMan.GetMtId())*
				IsSatMtOverConfDCastNum(tChairMan))
            {
                ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[ChangeChairman] over max upload mt num. nack!\n");            
                NotifyMcsAlarmInfo(0, ERR_MCU_DCAST_OVERCHNNLNUM);
                return;
            }
        }   
		
		if (VCS_CONF == m_tConf.GetConfSource())
		{
			// VCS会议不需要在此处调整vmp，vcs不存在主席变化，除主席终端掉线切备用主席时
			// 有备用主席时，主席掉线后备用主席变主席，此时主席终端的掉线状态还未置，会将它当成普通终端处理
		}
        else if (IsChangeVmpParam() &&
            // zbq [05/31/2007] 若所有VMP通道都不是主席跟随，不需要调整通道风格
            ( tVmpParam.IsTypeInMember(VMP_MEMBERTYPE_CHAIRMAN) ||
			 tVmpParam.IsMtInMember( tChairMan ) || 
			 ( ptOldChair != NULL && tVmpParam.IsMtInMember( *ptOldChair ) ) )
		)
        {
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_VMP, "[AdjustChairmanVidSwitch] begin to call FUNCTION[ChangeVmpChannelParam]!\n");
            ChangeVmpChannelParam(&tChairMan, VMP_MEMBERTYPE_CHAIRMAN, ptOldChair);
        }
        else
        {
            //SetTimer(MCUVC_CHANGE_VMPCHAN_CHAIRMAN_TIMER, TIMESPACE_CHANGEVMPPARAM, VMP_MEMBERTYPE_CHAIRMAN);
        }
    }*/
    
    //加入多画面电视墙跟随通道
    if (m_tConf.m_tStatus.GetVmpTwMode() != CONF_VMPTWMODE_NONE)
    {
        // xsl [10/27/2006]卫星分散会议时需要判断回传通道数
        if (m_tConf.GetConfAttrb().IsSatDCastMode() &&
            m_tConf.m_tStatus.GetVmpTwParam().IsTypeInMember(VMPTW_MEMBERTYPE_CHAIRMAN)
			&& IsMultiCastMt(tChairMan.GetMtId())
			&& !IsSatMtSend(tChairMan))
        {
            if (/*IsOverSatCastChnnlNum(tChairMan.GetMtId())*/
				//IsSatMtOverConfDCastNum(tChairMan))
				!IsSatMtCanContinue())
            {
                ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[ChangeChairman] over max upload mt num. nack!\n");            
                NotifyMcsAlarmInfo(0, ERR_MCU_DCAST_OVERCHNNLNUM);
                return;
            }
        }    
        
        ChangeVmpTwChannelParam(&tChairMan, VMPTW_MEMBERTYPE_CHAIRMAN);
    }


	if(tChairMan.IsNull())	
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[AdjustChairmanVidSwitch] no new chairman, ignore further process!\n");
		return;
	}
    TLogicalChannel tLogicChan;
    if ( !m_ptMtTable->GetMtLogicChnnl(tChairMan.GetMtId(), LOGCHL_VIDEO, &tLogicChan, FALSE))
    {
        ConfPrint( LOG_LVL_WARNING, MID_MCU_MT, "[AdjustChairmanVidSwitch] ChairMt.%d's video RL chan unexist, ignore it\n", tChairMan.GetMtId() );
        return;
    }
  
    //加入电视墙跟随通道
	TPeriEqpStatus tTWStatus;
    u8 byChnlIdx;
    u8 byEqpId;
    for (byEqpId = TVWALLID_MIN; byEqpId <= TVWALLID_MAX; byEqpId++)
    {
        if (EQP_TYPE_TVWALL == g_cMcuVcApp.GetEqpType(byEqpId))
        {
            for (byChnlIdx = 0; byChnlIdx < MAXNUM_PERIEQP_CHNNL; byChnlIdx++)
            {
                if (g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tTWStatus) &&
                    tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType == TW_MEMBERTYPE_CHAIRMAN &&
                    tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].GetConfIdx() == m_byConfIdx)
                {
                    // xsl [10/27/2006]卫星分散会议时需要判断回传通道数
                    if (m_tConf.GetConfAttrb().IsSatDCastMode()
						&& IsMultiCastMt(tChairMan.GetMtId())
						&& !IsSatMtSend(tChairMan))
                    {
                        if (/*IsOverSatCastChnnlNum(tChairMan.GetMtId())*/
							//IsSatMtOverConfDCastNum(tChairMan))
							!IsSatMtCanContinue())
                        {
                            ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[ChangeChairman] over max upload mt num. nack!\n");            
                            NotifyMcsAlarmInfo(0, ERR_MCU_DCAST_OVERCHNNLNUM);
                            return;
                        }
                    }    
                    
                    ChangeTvWallSwitch(&tChairMan, byEqpId, byChnlIdx, TW_MEMBERTYPE_CHAIRMAN, TW_STATE_CHANGE);
                }
            }
        }
    }
    
    //加入HDU跟随通道
	TPeriEqpStatus tHduStatus;
    u8 byHduChnlIdx;
    u8 byHduEqpId;
    for (byHduEqpId = HDUID_MIN; byHduEqpId <= HDUID_MAX; byHduEqpId++)
    {
		if(IsValidHduEqp(g_cMcuVcApp.GetEqp(byHduEqpId)))
        {
			u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byHduEqpId));
			if (0 == byHduChnNum)
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU, "[AdjustChairmanVidSwitch] GetHduChnNumAcd2Eqp failed!\n");
				continue;
			}

            for (byHduChnlIdx = 0; byHduChnlIdx < min(byHduChnNum,MAXNUM_HDU_CHANNEL); byHduChnlIdx++)
            {
                if (g_cMcuVcApp.GetPeriEqpStatus(byHduEqpId, &tHduStatus) &&
                    tHduStatus.m_tStatus.tHdu.atVideoMt[byHduChnlIdx].byMemberType == TW_MEMBERTYPE_CHAIRMAN &&
                    tHduStatus.m_tStatus.tHdu.atVideoMt[byHduChnlIdx].GetConfIdx() == m_byConfIdx)
                {
                    // xsl [10/27/2006]卫星分散会议时需要判断回传通道数
                    if (m_tConf.GetConfAttrb().IsSatDCastMode())
                    {
                        if (!IsSatMtCanContinue(tChairMan.GetMtId(),emChairMan))
                        {
							ChangeHduSwitch(NULL, byHduEqpId, byHduChnlIdx, 0, TW_MEMBERTYPE_CHAIRMAN, TW_STATE_STOP);
                            ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[ChangeChairman] over max upload mt num. nack! by hdu\n");            
                            NotifyMcsAlarmInfo(0, ERR_MCU_DCAST_OVERCHNNLNUM);
                            return;
                        }
                    }    
                    // [2013/03/11 chenbing] HDU多画面目前不支持主席跟随,子通道置0
                    ChangeHduSwitch(&tChairMan, byHduEqpId, byHduChnlIdx, 0, TW_MEMBERTYPE_CHAIRMAN, TW_STATE_START);
                }
            }
        }
    }
	
    return;
}

/*=============================================================================
函 数 名： AdjustChairmanAudSwitch
功    能： 调整主席音频交换
算法实现： 
全局变量： 
参    数： void
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2008/4/21   4.0		周广程                  创建
=============================================================================*/
void CMcuVcInst::AdjustChairmanAudSwitch( void )
{
	//发言人看主席时；发言人源的调整, zgc, 2008-02-25
	u8 bySelMode = m_tConf.GetConfAttrb().GetSpeakerSrcMode();

    // 增加对发言人源的码流模式的判断，防止误调整，zgc, 2008-04-21
	if ( bySelMode == MODE_BOTH )
	{
		ChangeSpeakerSrc( MODE_AUDIO, emReasonChangeChairman );
	}
}


/*==============================================================================
函数名    :  StopMpuVmpBrd
功能      :  停止MPUVMP广播
算法实现  :  
参数说明  :  void
返回值说明:  void
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2010-02-05                  薛亮								create
==============================================================================*/
void CMcuVcInst::StopVmpBrd(TEqp tVmpEqp)
{
	//停PRS
	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
 	if (tConfAttrb.IsResendLosePack()/*m_tConf.m_tStatus.IsPrsing()*/)
 	{
		StopPrsForVmp(tVmpEqp);
	}

	u8 byMaxOutChnl = 0;
	u8 byVmpSubType = GetVmpSubType(tVmpEqp.GetEqpId());
	TKDVVMPOutParam tVMPOutParam = g_cMcuVcApp.GetVMPOutParam(tVmpEqp);
	// MPU2类型vmp有9路后适配
	if (MPU2_VMP_ENHACED == byVmpSubType ||
		MPU2_VMP_BASIC == byVmpSubType)
	{
		byMaxOutChnl = tVMPOutParam.GetVmpOutCount();//需根据后适配情况确定个数
	}
	else if( VMP == byVmpSubType )//vpu有1到2路(双速或双格式会议2路)
	{ 
		byMaxOutChnl = 2;
	}
	else	// MPU类型vmp有4路后适配,8KG有4路后适配,8KH有5路后适配
	{
		byMaxOutChnl = MAXNUM_MPU_OUTCHNNL;
	}
	//立即拆桥
	for(u8 bySrcChnnl = 0; bySrcChnnl < byMaxOutChnl; bySrcChnnl++)
	{
		g_cMpManager.RemoveSwitchBridge(tVmpEqp, bySrcChnnl, MODE_VIDEO);
	}


	if (m_tConf.GetConfAttrb().IsSatDCastMode() )
	{		
		g_cMpManager.StopDistrConfCast(tVmpEqp, MODE_VIDEO, 0);
	}

	if ( m_tConf.GetConfAttrb().IsMulticastMode() )
	{							
		g_cMpManager.StopMulticast(tVmpEqp, 0, MODE_VIDEO);
	}

	if (!m_tConf.m_tStatus.IsNoRecording() )
	{
		StopSwitchToPeriEqp(m_tRecEqp.GetEqpId(), m_byRecChnnl, FALSE, MODE_VIDEO);
	}
	
	if( VMP == byVmpSubType )
	{
		g_cMpManager.StopSwitchToBrd( tVmpEqp, 0 );
	}
	
	
	// xliang [3/14/2009] tell Mt(s) which saw VMP before to watch themselves at this moment 
	// except for chairman's watching VMP 
	/*TMt tLoopMt;
	TMt tCurSrc;
	for( u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
    {
        if( m_tConfAllMtInfo.MtJoinedConf( byLoop ) )
        {
			m_ptMtTable->GetMtSrc( byLoop, &tCurSrc, MODE_VIDEO ); 
			if( tCurSrc == m_tVmpEqp )	//该终端看的是之前的广播源(VMP)
			{
				tLoopMt = m_ptMtTable->GetMt( byLoop );

				if( tLoopMt == m_tConf.GetChairman() 
					&& m_tConf.m_tStatus.IsVmpSeeByChairman() )
				{
					//SwitchNewVmpToSingleMt(tLoopMt);	//之前不拆，所以这里不用额外补
				}
				else
				{
					NotifyMtReceive( tLoopMt, byLoop );	//watch self
				}
			}
			
        }
    }*/
}

/*==============================================================================
函数名    :  StartMpuVmpBrd
功能      :  开始MPU-VMP广播
算法实现  :  
参数说明  :  void
返回值说明:  void
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2009-8-31                  薛亮								create
==============================================================================*/
void CMcuVcInst::StartVmpBrd(TEqp tVmpEqp)
{
	TMtStatus tMtStatus;
	TMt tSelectedMt;
	//lukunpeng 2010/06/07 音视频源非local化整理
	TMt tLocalVidBrdSrc =  GetLocalVidBrdSrc();
	//PRS
	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
	if (tConfAttrb.IsResendLosePack())
	{
		StartPrsForVmp(tVmpEqp);
	}
	
	u8 byMaxOutChnl = 0;
	u8 byVmpSubType = GetVmpSubType(tVmpEqp.GetEqpId());
	TKDVVMPOutParam tVMPOutParam = g_cMcuVcApp.GetVMPOutParam(tVmpEqp);
	// MPU2类型vmp有9路后适配
	if (MPU2_VMP_ENHACED == byVmpSubType ||
		MPU2_VMP_BASIC == byVmpSubType)
	{
		byMaxOutChnl = tVMPOutParam.GetVmpOutCount();//需根据后适配情况确定个数
	}
	else if( VMP == byVmpSubType )
	{
		if( 0 != m_tConf.GetSecBitRate() || MEDIA_TYPE_NULL != m_tConf.GetSecVideoMediaType() )
		{
			byMaxOutChnl = 2;
		}
		else
		{
			byMaxOutChnl = 1;
		}		
	}
	else	// MPU类型vmp有4路后适配,8KG有4路后适配,8KH有5路后适配
	{
		byMaxOutChnl = MAXNUM_MPU_OUTCHNNL;
	}
	//建立交换桥
	u8 bySrcChnnl = 0;
	for (; bySrcChnnl < byMaxOutChnl; bySrcChnnl++)
	{
		g_cMpManager.SetSwitchBridge(tLocalVidBrdSrc, bySrcChnnl, MODE_VIDEO); 
	}

	//建vmp通道到各终端的交换,对终端分组建交换
	StartVmpSwitchGrp2AllMt(tVmpEqp);

	//  [12/1/2009 pengjie] Modify 改变视频广播源后，重新建立新的视频广播源到录像机的交换
	if (!m_tConf.m_tStatus.IsNoRecording())
	{
		AdjustConfRecordSrcStream(MODE_VIDEO, TRUE);
	}
	// End
	
}

/*====================================================================
    函数名      ：ChangeVidBrdSrc
    功能        ：改变视频广播源（包括单纯撤销）；
	              通知MC，MT
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt * ptNewVidBrdSrc, 新的视频广播源，NULL表示单纯撤销
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/25    3.0         胡昌威        创建
====================================================================*/
void CMcuVcInst::ChangeVidBrdSrc(TMt * ptVidBrdSrc, u16 wOldVidBrdSpyPort )
{
	
	
	
	TMt *ptNewVidBrdSrc = ptVidBrdSrc;
	if( NULL == ptNewVidBrdSrc || ptNewVidBrdSrc->IsNull() )
	{
		ptNewVidBrdSrc = NULL;
	}
	else
	{
		TMt tTmpLocalMt = GetLocalMtFromOtherMcuMt(*ptNewVidBrdSrc);
		TLogicalChannel tTmpChnInfo;
		if (TYPE_MCUPERI != tTmpLocalMt.GetType() &&
			!m_ptMtTable->GetMtLogicChnnl(tTmpLocalMt.GetMtId(), LOGCHL_VIDEO, &tTmpChnInfo, FALSE))
		{				
			ptNewVidBrdSrc = NULL;
		}
	}
	
	CRecvSpy tSpyResource; 
	u16 wSpyStartPort = SPY_CHANNL_NULL;
	if( NULL != ptNewVidBrdSrc && m_cSMcuSpyMana.GetRecvSpy( *ptNewVidBrdSrc, tSpyResource ) )
	{
		wSpyStartPort = tSpyResource.m_tSpyAddr.GetPort();
	}
	TMt tOldLocalVidSrc = GetLocalVidBrdSrc();
	TMt tOldVidSrc = GetVidBrdSrc();
	
	
	
	if( NULL == ptNewVidBrdSrc )
	{
		SetVidBrdSrcNull();		
	}
	else
	{
		SetVidBrdSrc(*ptNewVidBrdSrc);
	}
	TMt tNewLocalVidSrc = GetLocalVidBrdSrc();
	TMt tNewVidSrc = GetVidBrdSrc();
	
	//不是切换，转发板直接切换源不等关键帧切换
	BOOL32 bStopOldVidSrcNow = tOldVidSrc.IsNull();
	
	u16 wOldSpyStartPort = wOldVidBrdSpyPort;
	u8 bySrcChnnl = 0;
	CServMsg cServMsg;
	
	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
	if( !tOldVidSrc.IsNull() )
	{
		if( tOldVidSrc.GetType() == TYPE_MCUPERI && tOldVidSrc.GetEqpType() == EQP_TYPE_VMP )
		{
			StopVmpBrd(tOldVidSrc);//该函数从stopmpuvmpbrd而来，需要修改		
		}
		else
		{
			if( wOldSpyStartPort == SPY_CHANNL_NULL && m_cSMcuSpyMana.GetRecvSpy( tOldVidSrc, tSpyResource ) )
			{
				wOldSpyStartPort = tSpyResource.m_tSpyAddr.GetPort();
			}
			bySrcChnnl = (tOldVidSrc == m_tPlayEqp ? m_byPlayChnnl : 0);
		
			
			if (!m_tDoubleStreamSrc.IsNull() 
				&& !tOldLocalVidSrc.IsNull() 
				&& TYPE_MT == tOldLocalVidSrc.GetType())
			{
				TLogicalChannel tLogicalChannel;
				if (TRUE == m_ptMtTable->GetMtLogicChnnl(tOldLocalVidSrc.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE))
				{
				  tLogicalChannel.SetFlowControl(m_ptMtTable->GetSndBandWidth( tOldLocalVidSrc.GetMtId()));
				  cServMsg.SetMsgBody((u8*)&tLogicalChannel, sizeof(tLogicalChannel));
				  SendMsgToMt(tOldLocalVidSrc.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cServMsg);
				}
			}
      
			
      
			if(NULL == ptNewVidBrdSrc  || ptNewVidBrdSrc->GetEqpType() == EQP_TYPE_VMP) 
			{      
				if (tConfAttrb.IsResendLosePack())
				{		      	
					StopBrdPrs(MODE_VIDEO);						
				}
				if( NULL == ptNewVidBrdSrc || m_tConf.GetConfAttrb().IsSatDCastMode())
				{
					g_cMpManager.StopSwitchToBrd(tOldLocalVidSrc, bySrcChnnl, wOldSpyStartPort);
				}
				if( m_tConf.m_tStatus.IsVidAdapting() )
				{
					StopBrdAdapt(MODE_VIDEO,NULL == ptNewVidBrdSrc);
					m_tConf.m_tStatus.SetAdaptMode(ADAPT_MODE_VID, FALSE);


					if ( g_cMcuVcApp.IsVASimultaneous() && NULL != ptNewVidBrdSrc )
					{
						TMt atDstMt[MAXNUM_CONF_MT];
						u8 byDstMtNum = 0;
						TMtStatus tTempMtStatus;
						for (u8 byMtIdx = 1; byMtIdx < MAXNUM_CONF_MT; byMtIdx++)
						{
							if (!m_tConfAllMtInfo.MtJoinedConf(byMtIdx))
							{
								continue;
							}
							if (byMtIdx == m_tConf.GetSpeaker().GetMtId())
							{
								continue;
							}
							// vrs新录播过滤
							if (m_ptMtTable->GetMtType(byMtIdx) == MT_TYPE_VRSREC)
							{
								continue;
							}


							if (m_tConf.GetChairman().GetMtId() == byMtIdx
								&& CONF_POLLMODE_BOTH_CHAIRMAN == m_tConf.m_tStatus.GetPollMode())
							{
								continue;
							}

							TMt tTempMt = m_ptMtTable->GetMt(byMtIdx);
							if (IsNeedAdapt(GetAudBrdSrc(), tTempMt, MODE_AUDIO))
							{
								continue;
							}

							if ( !IsNeedAdapt( tOldLocalVidSrc,tTempMt, MODE_VIDEO ) )
							{
								continue;
							}
							
							m_ptMtTable->GetMtStatus(tTempMt.GetMtId(), &tTempMtStatus);

							if (!tTempMtStatus.GetSelectMt(MODE_AUDIO).IsNull())
							{
								continue;
							}	 

							ConfPrint(LOG_LVL_DETAIL,MID_MCU_CONF,"[ChangeVidBrdSrc]tTempMt:%d-%d need audio StartSwitchToAll\n",tTempMt.GetMcuId(), tTempMt.GetMtId());

							atDstMt[byDstMtNum] = tTempMt;
							byDstMtNum ++;
						}

						if (byDstMtNum > 0)
						{							
							u16 wSpyPort = SPY_CHANNL_NULL;
							TMt tAudSrc = GetAudBrdSrc();
							if( m_cSMcuSpyMana.GetRecvSpy( tAudSrc, tSpyResource ) )
							{
								wSpyPort = tSpyResource.m_tSpyAddr.GetPort();
							}
							TSwitchGrp tSwitchGrp;		
							tSwitchGrp.SetSrcChnl(0);
							tSwitchGrp.SetDstMtNum(byDstMtNum);
							tSwitchGrp.SetDstMt(atDstMt);
							StartSwitchToAll(tAudSrc, 1, &tSwitchGrp, MODE_AUDIO, SWITCH_MODE_BROADCAST,FALSE, FALSE, wSpyPort);
						}
					}
				}
			}
      
			if(NULL == ptNewVidBrdSrc )
			{
				bySrcChnnl = (tOldVidSrc == m_tPlayEqp ? m_byPlayChnnl : 0);
				if (m_tConf.GetConfAttrb().IsSatDCastMode())
				{					
					g_cMpManager.StopDistrConfCast(tOldLocalVidSrc, MODE_VIDEO, bySrcChnnl);
				}

				if ( m_tConf.GetConfAttrb().IsMulticastMode() )
				{							
					g_cMpManager.StopMulticast(tOldVidSrc, bySrcChnnl, MODE_VIDEO);
				}
			}
      
    
			if (!m_tConf.m_tStatus.IsNoRecording()
						&& !IsRecNeedAdapt(MODE_VIDEO) )
			{
				StopSwitchToPeriEqp(m_tRecEqp.GetEqpId(), m_byRecChnnl, FALSE, MODE_VIDEO);
			}
      
			if( !tOldVidSrc.IsLocal() && !(GetSecVidBrdSrc() == tOldVidSrc))
			{
				bySrcChnnl = (tOldVidSrc == m_tPlayEqp) ? m_byPlayChnnl : 0;

				if( wOldVidBrdSpyPort == SPY_CHANNL_NULL &&
					m_cSMcuSpyMana.GetRecvSpy( tOldVidSrc, tSpyResource ) )
				{
					wOldVidBrdSpyPort = tSpyResource.m_tSpyAddr.GetPort();
				}
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ChangeVidBrdSrc] Remove LastVidBrd<McuId.%d, MtId.%d> Bridge!\n", tOldVidSrc.GetMcuId(), tOldVidSrc.GetMtId());
				g_cMpManager.RemoveSwitchBridge( tOldLocalVidSrc, bySrcChnnl, MODE_VIDEO,FALSE, wOldVidBrdSpyPort );
			}					
		}
	}
	
	if (m_tConf.GetConfSource() != VCS_CONF &&
		ptNewVidBrdSrc != NULL )
	{
		TMtStatus tMtStatus;
		TMt tSelSrc;
		BOOL32 bBrdSrcIsVmp = (ptNewVidBrdSrc->GetEqpType() == EQP_TYPE_VMP);
		
		for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
		{
			if (!m_tConfAllMtInfo.MtJoinedConf(byMtId))
			{
				continue;
			}
			
			if (!m_tCascadeMMCU.IsNull() && m_tCascadeMMCU.GetMtId() == byMtId)
			{
				continue;
			}
			// vrs新录播过滤
			if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC)
			{
				continue;
			}

			m_ptMtTable->GetMtStatus(byMtId, &tMtStatus);			
			u8 byMode = tMtStatus.GetSelByMcsDragMode();	
			tSelSrc = tMtStatus.GetSelectMt( MODE_VIDEO );
			
			if (m_tConf.GetChairman().GetMtId() == byMtId && 
				!(tSelSrc == *ptNewVidBrdSrc )
				)
			{
						continue;
			}			
			
			if( tNewLocalVidSrc == m_ptMtTable->GetMt(byMtId) &&
					GetLocalSpeaker() == m_ptMtTable->GetMt(byMtId) )
			{
				continue;
			}

			if( !tSelSrc.IsNull() && 
					( !bBrdSrcIsVmp ||  
						m_tConf.m_tStatus.GetRollCallMode() == ROLLCALL_MODE_NONE || 
							( byMtId != m_tRollCaller.GetMtId() && m_tRollCallee.IsLocal() &&
								byMtId != m_tRollCallee.GetMtId() ) ) 
				)
			{
					StopSelectSrc(m_ptMtTable->GetMt(byMtId), MODE_VIDEO);
			}	
		}
	}


	if (NULL != ptNewVidBrdSrc)
	{
		if( ptNewVidBrdSrc->GetType() == TYPE_MCUPERI && ptNewVidBrdSrc->GetEqpType() == EQP_TYPE_VMP )
		{
			StartVmpBrd(*ptNewVidBrdSrc);
		}
		else
		{

			//20100509 fxh 对于终端发言人进行切换时，若存在格式切换，或者同格式分辨率由高到低需要直接切换广播源，不使用平滑切换
			//否则将导致短时间内，直接从广播源接收的终端收到不同格式或者分辨率过高的码流，导致其解码出问题
			TLogicalChannel tOldChnlInfo, tNewChnInfo;
			if ( !tOldLocalVidSrc.IsNull() &&
				TYPE_MT == tNewLocalVidSrc.GetMcuType() &&
				m_ptMtTable->GetMtLogicChnnl(tNewLocalVidSrc.GetMtId(), LOGCHL_VIDEO, &tNewChnInfo, FALSE) &&
				TYPE_MT == tOldLocalVidSrc.GetMcuType() && 
				m_ptMtTable->GetMtLogicChnnl(tOldLocalVidSrc.GetMtId(), LOGCHL_VIDEO, &tOldChnlInfo, FALSE))
			{
				if (//tNewChnInfo.GetMediaType() != tOldChnlInfo.GetMediaType() ||
					tNewChnInfo.GetChannelType() != tOldChnlInfo.GetChannelType() ||
					IsResG(tOldChnlInfo.GetVideoFormat(), tNewChnInfo.GetVideoFormat()))
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MPMGR, "[ChangeVidBrdSrc]vidsrc change from (mediatype:%d, format:%d) to (mediatype:%d, format:%d), so no smooth swith\n",
						 tOldChnlInfo.GetMediaType(), tOldChnlInfo.GetVideoFormat(), tNewChnInfo.GetMediaType(), tNewChnInfo.GetVideoFormat());
					bStopOldVidSrcNow = TRUE;

				}
			}	

			if (!m_tDoubleStreamSrc.IsNull() &&
				!tNewLocalVidSrc.IsNull() && TYPE_MT == tNewLocalVidSrc.GetType())
			{
				u16 wDialBitrate = 0;
				TLogicalChannel tLogicalChannel;
				if (TRUE == m_ptMtTable->GetMtLogicChnnl(tNewLocalVidSrc.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE))
				{
					wDialBitrate = m_ptMtTable->GetSndBandWidth(tNewLocalVidSrc.GetMtId());
					tLogicalChannel.SetFlowControl(GetDoubleStreamVideoBitrate(wDialBitrate));
					cServMsg.SetMsgBody((u8*)&tLogicalChannel, sizeof(tLogicalChannel));
					SendMsgToMt(tNewLocalVidSrc.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cServMsg);
				} 
			}

			if (tConfAttrb.IsResendLosePack())
			{			 	
				StartBrdPrs(MODE_VIDEO);
			}

			bySrcChnnl = (tNewLocalVidSrc == m_tPlayEqp) ? m_byPlayChnnl : 0;
			g_cMpManager.SetSwitchBridge(tNewLocalVidSrc, bySrcChnnl, MODE_VIDEO, FALSE, wSpyStartPort);


			if (IsDelayVidBrdVCU())
			{
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ChangeVidBrd] IsDelayVidBrdVCU!\n");                
			}
			else
			{                
				if (tNewLocalVidSrc.GetType() == TYPE_MT)
				{			
					NotifyMtSend(tNewLocalVidSrc.GetMtId(), MODE_VIDEO);
				}
				else
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ChangeVidBrd] ptNewVidBrdSrc->GetType().%d is not Mt!\n", 
										tNewLocalVidSrc.GetType());
				}
			}

			StartBrdAdapt(MODE_VIDEO);
			if (!m_tConf.m_tStatus.IsNoRecording())
			{
				//AdjustRecordSrcStream( MODE_VIDEO );
				AdjustConfRecordSrcStream(MODE_VIDEO, TRUE);
			}

			if (m_tConf.GetConfAttrb().IsMulticastMode() )
			{
				if ( !m_tConf.GetConfAttrb().IsMulcastLowStream())
				{
					u16 wSrcChnnl = bySrcChnnl;

					if( SPY_CHANNL_NULL != wSpyStartPort )
					{
						wSrcChnnl = wSpyStartPort;
					}
					g_cMpManager.StartMulticast(tNewLocalVidSrc, wSrcChnnl, MODE_VIDEO);
					m_ptMtTable->SetMtMulticasting(tNewLocalVidSrc.GetMtId());
				}
				else
				{
					TEqp tLowBRBas;
					tLowBRBas.SetNull();
					u8 byLowBRBasChnId = 0;
					u8 byOutNum = 0;
					u8 byOutIdx = 0;
					if (GetLowBrUseBasOutPutInfo(tLowBRBas, byLowBRBasChnId, byOutNum,  byOutIdx))
					{
						tLowBRBas.SetConfIdx(m_byConfIdx);	// must set confIdx
						g_cMpManager.StartMulticast(tLowBRBas, byLowBRBasChnId* byOutNum + byOutIdx, MODE_VIDEO);
						m_ptMtTable->SetMtMulticasting(tLowBRBas.GetEqpId());
					}					
				}
			}

			if ( m_tConf.GetConfAttrb().IsSatDCastMode())
			{			
				g_cMpManager.StartDistrConfCast(tNewVidSrc, MODE_VIDEO, bySrcChnnl);
			}

			g_cMpManager.StartSwitchToBrd(tNewLocalVidSrc, bySrcChnnl, bStopOldVidSrcNow, wSpyStartPort);

			StartSwitchToAllSubMtJoinedConf(tNewVidSrc, bySrcChnnl, tOldVidSrc, bStopOldVidSrcNow, wSpyStartPort);

		}
	}
	else
	{
		//zjj20120927 Bug00108523
		if( VCS_CONF != m_tConf.GetConfSource() || !ISGROUPMODE(m_cVCSConfStatus.GetCurVCMode()) )
		{
			RestoreAllSubMtJoinedConfWatchingSrcMt(tOldVidSrc, MODE_VIDEO,FALSE);
		}
	}
	
		
	// [pengjie 2010/9/29] 会议录像无广播源时跳过该段录像支持
	if( !m_tConf.m_tStatus.IsNoRecording() )
	{
		AdjustConfRecByBrdSrc();
	}
    // End	
//    CServMsg cServMsg;
//    u8	bySrcChnnl = 0;
//	//  [12/9/2009 pengjie] 级联多回传支持 这里为了传进来的指针不被修改该，所以重新保存了一下该变量
//	
//	TMt *ptNewVidBrdSrc = NULL;
//	TMt tUnLocalNewVidBrdSrc;
//    BOOL32 bStopOldVidSrcNow = FALSE;   // 是否立即切换广播源
////	BOOL32 bNewVmpBrd = FALSE;			// 是否是新VMP广播
//	u16 wSpyStartPort = SPY_CHANNL_NULL;
//	u16 wOldSpyStartPort = SPY_CHANNL_NULL;
//
//	TMt tMt;
//	if( ptVidBrdSrc != NULL )
//	{
//		tMt = *ptVidBrdSrc;
//		//zhouyiliang 20120312 如果传了个非法的tMt指针进来，应该当成NULL一样来处理
//		if ( tMt.IsNull() )
//		{
//			ptNewVidBrdSrc = NULL;
//		}
//		else
//		{	
//			//电话终端支持,终端视频逻辑通道未开时,广播源设空.拆旧广播源交换
//			TMt tTmpLocalMt = GetLocalMtFromOtherMcuMt(tMt);
//			TLogicalChannel tTmpChnInfo;
//			if (TYPE_MCUPERI != tTmpLocalMt.GetType() &&
//				!m_ptMtTable->GetMtLogicChnnl(tTmpLocalMt.GetMtId(), LOGCHL_VIDEO, &tTmpChnInfo, FALSE))
//			{
//				//后向逻辑通道未打开,不能做广播源
//				ptNewVidBrdSrc = NULL;
//			}
//			else
//			{
//				ptNewVidBrdSrc = &tMt;
//				CRecvSpy tSpyResource; 
//				if( m_cSMcuSpyMana.GetRecvSpy( *ptNewVidBrdSrc, tSpyResource ) )
//				{
//					wSpyStartPort = tSpyResource.m_tSpyAddr.GetPort();
//				}
//			}
//		}
//		
//	}
//
//	TMt tOldLocalVidSrc = GetLocalVidBrdSrc();
//	TMt tOldVidSrc = GetVidBrdSrc();
//
//	if (ptVidBrdSrc == NULL || NULL == ptNewVidBrdSrc)
//	{
//		SetVidBrdSrcNull();
//
//		// 2011-8-11 add by pgf: Bug00061176:会议组播时，取消发言人导致画面合成至组播地址的交换被拆除
//		if ( m_tConf.GetConfAttrb().IsMulticastMode() && !tOldVidSrc.IsNull() )
//		{
//			g_cMpManager.StopMulticast(tOldVidSrc, 0, MODE_VIDEO);
//		}
//		// 2011-8-11 add end
//	}
//	else
//	{
//		SetVidBrdSrc(*ptNewVidBrdSrc);
//	}
//
//	tUnLocalNewVidBrdSrc.SetNull();
//    if (ptNewVidBrdSrc != NULL)
//    {
//		tUnLocalNewVidBrdSrc = *ptNewVidBrdSrc;
//        *ptNewVidBrdSrc = GetLocalMtFromOtherMcuMt(*ptNewVidBrdSrc);
//    }
//    
//	//　停止广播原有视频源
//    if (tOldVidSrc.IsNull())
//    {
//        bStopOldVidSrcNow = TRUE;
//    }
//    else
//    {
//        //zbq [12/31/2009] 标清会议：为保护T3终端不绿屏(bug25388)，增加一种强切逻辑. 后续考虑进一步优化.
//        
//        /*说明：1、Grp.A 是T3终端. 稳态接收适配后的MP4码流；
//                2、Src切换到MP4时，按计划从T点收码流的Grp.A，会因为平滑切换收到SrcA的几帧H263，且有关键帧，故绿屏；
//                3、负面影响：本强切将导致切换时Grp.B起始等待提前，即总体上导致等待间隔有100ms数量级的增加；
//        /*
//
//        稳态：
//           H263 SrcA - (open)S1     
//                               \    /-> Grp.B(H263)
//                                T -
//                               /    \-> Bas(Chn.Vid)-> Grp.A(MP4)
//                             S2
//
//        切换暂态：
//           H263 SrcA - (open)S1
//                               \   /-> Grp.A(MP4)
//                                T -
//                               /   \-> Bas(Chn.Vid)-> Grp.B(H263)
//        ew－MP4 SrcB - -(cut)S2
//      
//        */
//
//		wOldSpyStartPort = wOldVidBrdSpyPort;
//		CRecvSpy tSpyResource; 
//		if( wOldVidBrdSpyPort == SPY_CHANNL_NULL && m_cSMcuSpyMana.GetRecvSpy( tOldVidSrc, tSpyResource ) )
//		{
//			wOldSpyStartPort = tSpyResource.m_tSpyAddr.GetPort();
//		}
//
//		if( ptVidBrdSrc == NULL || NULL == ptNewVidBrdSrc )
//		{
//			wSpyStartPort = wOldSpyStartPort;
//		}
//
//		//lukunpeng 2010/07/28 停到广播源的交换
//		//判断是否是新VMP广播停止（此处新VMP包括8000E-VMP）
//		if( tOldVidSrc.GetEqpType() == EQP_TYPE_VMP && GetVmpSubType(tOldVidSrc.GetEqpId()) != VMP )
//		{
//			//new vmp stop broardcast
//			StopMpuVmpBrd(tOldVidSrc);
//		}
//		else
//		{
//			bySrcChnnl = (tOldVidSrc == m_tPlayEqp ? m_byPlayChnnl : 0);
//			if (NULL == ptNewVidBrdSrc)
//			{
//				g_cMpManager.StopSwitchToBrd(tOldLocalVidSrc, bySrcChnnl, wOldSpyStartPort);
//			}
//			// 停止广播源发送
//			//g_cMpManager.StopSwitchToBrd(tOldLocalVidSrc, bySrcChnnl, wOldSpyStartPort);
//
//			// [10/19/2010 xliang] stop old vmp second vid switch
//			if( MEDIA_TYPE_NULL != m_tConf.GetSecVideoMediaType() 
//				&& ( tOldVidSrc.GetEqpType() == EQP_TYPE_VMP && VMP == GetVmpSubType(tOldVidSrc.GetEqpId()) )
//				)
//			{
//				g_cMpManager.RemoveSwitchBridge(tOldVidSrc, bySrcChnnl+1, MODE_VIDEO);
//
//				TMt atMtDst[MAXNUM_CONF_MT];
//				memset( atMtDst, 0, sizeof(atMtDst) );
//				u8 byMtNum = 0;
//
//				for(u8 byLoop =1; byLoop <= MAXNUM_CONF_MT; byLoop ++)
//				{
//					TSimCapSet tSimCapSet = m_ptMtTable->GetDstSCS( byLoop );
//					if(tSimCapSet.GetVideoMediaType() == m_tConf.GetSecVideoMediaType() )
//					{
//						atMtDst[byMtNum] = m_ptMtTable->GetMt( byLoop );
//						byMtNum++;
//						//StopSwitchToSubMt( byLoop, MODE_VIDEO, SWITCH_MODE_BROADCAST );
//					}
//				}
//
//				if( byMtNum > 0 )
//				{
//					StopSwitchToSubMt( byMtNum, atMtDst, MODE_VIDEO );
//				}
//			}
//		}
//
//// 		//[nizhijun 2012/06/29] 录像机适配录像，如果源是VMP，不走BAS，直接收VMP的相关码流。
//// 		//老广播源如果是VMP，并且是适配录像情况下，拆除VMP到录像机交换
//// 		if ( ptNewVidBrdSrc == NULL &&
//// 			 tOldLocalVidSrc == m_tVmpEqp &&
//// 			IsRecNeedAdapt(MODE_VIDEO)
//// 			)
//// 		{
//// 			StopSwitchToPeriEqp(m_tRecEqp.GetEqpId(), m_byRecChnnl, FALSE,MODE_VIDEO, SWITCH_MODE_SELECT);
//// 		}
//
//// 		// [1/12/2011 liuxu] 适配录像相关
//// 		if (tOldVidSrc == m_tVmpEqp)
//// 		{
//// 			// 适配录像时,停止vmp到录像机适配器的交换
//// 			if (IsRecNeedAdapt())
//// 			{
//// 				// 获取vmp合适的通道
//// 				// [8/5/2011 liuxu] 改为会议主格式
//// 				TVideoStreamCap tStrCap = m_tConf.GetMainSimCapSet().GetVideoCap();
//// 				u8 byVmpChnnlToRec = GetVmpOutChnnlByRes(tStrCap.GetResolution(), 
//// 					tStrCap.GetMediaType(),
//// 					tStrCap.GetUserDefFrameRate(),
//// 					tStrCap.GetH264ProfileAttrb());
//// 
//// 				// 停止vmp到广播端口的交换
//// 				g_cMpManager.StopSwitchToBrd(m_tVmpEqp, byVmpChnnlToRec);
//// 
//// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, 
//// 					"Vmp stopped, then Stop Vmp[Eqp.%d, ByChnnl.%d] switch to Brd\n",
//// 					m_tVmpEqp.GetEqpId(), 
//// 					byVmpChnnlToRec);	
//// 			}
//// 		}
//// 		// liuxu add end
//
//		//20100509 fxh 对于终端发言人进行切换时，若存在格式切换，或者同格式分辨率由高到低需要直接切换广播源，不使用平滑切换
//		//否则将导致短时间内，直接从广播源接收的终端收到不同格式或者分辨率过高的码流，导致其解码出问题
//		TLogicalChannel tOldChnlInfo, tNewChnInfo;
//		if (ptNewVidBrdSrc != NULL &&
//			TYPE_MT == ptNewVidBrdSrc->GetMcuType() &&
//			m_ptMtTable->GetMtLogicChnnl(ptNewVidBrdSrc->GetMtId(), LOGCHL_VIDEO, &tNewChnInfo, FALSE) &&
//			TYPE_MT == tOldLocalVidSrc.GetMcuType() && 
//			m_ptMtTable->GetMtLogicChnnl(tOldLocalVidSrc.GetMtId(), LOGCHL_VIDEO, &tOldChnlInfo, FALSE))
//		{
//			if (//tNewChnInfo.GetMediaType() != tOldChnlInfo.GetMediaType() ||
//				tNewChnInfo.GetChannelType() != tOldChnlInfo.GetChannelType() ||
//				IsResG(tOldChnlInfo.GetVideoFormat(), tNewChnInfo.GetVideoFormat()))
//			{
//				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MPMGR, "[ChangeVidBrdSrc]vidsrc change from (mediatype:%d, format:%d) to (mediatype:%d, format:%d), so no smooth swith\n",
//					         tOldChnlInfo.GetMediaType(), tOldChnlInfo.GetVideoFormat(), tNewChnInfo.GetMediaType(), tNewChnInfo.GetVideoFormat());
//				bStopOldVidSrcNow = TRUE;
//				
//			}
//		}		
//
//		//启用适配并且开启了双流, 恢复老的第一路发送源的发送码率,没有适配器则根据FlowControl调整
//        //flowctrl modify - 是否还有必要恢复老的第一路发送源的发送码率？被切掉的VidSrc要停止发码流的。
//        // guzh [8/24/2007] 回答上面的问题，这里是有必要flowctrl到原来标准码率的。因为广播源可能还在回传、或者录像、VMP中，所以要先恢复
//        if (!m_tDoubleStreamSrc.IsNull() 
//			&& !tOldLocalVidSrc.IsNull() 
//			&& TYPE_MT == tOldLocalVidSrc.GetType())
//        {
//            TLogicalChannel tLogicalChannel;
//            if (TRUE == m_ptMtTable->GetMtLogicChnnl(tOldLocalVidSrc.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE))
//            {
//                tLogicalChannel.SetFlowControl(m_ptMtTable->GetSndBandWidth( tOldLocalVidSrc.GetMtId()));
//                cServMsg.SetMsgBody((u8*)&tLogicalChannel, sizeof(tLogicalChannel));
//                SendMsgToMt(tOldLocalVidSrc.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cServMsg);
//            }
//        }
//        
//		TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
//		if (tConfAttrb.IsResendLosePack())
//		{
//			//[nizhijun 2012/07/10] 新广播源如果是VMP，也需要停第一路视频广播源的重传
//			//停止第一路视频广播源的重传
//			if( ptNewVidBrdSrc == NULL ||
//				(ptNewVidBrdSrc != NULL && ptNewVidBrdSrc->GetEqpType() == EQP_TYPE_VMP)	
//			   )
//			{
//				//通道是否开启在接口内会判断
//				StopBrdPrs(MODE_VIDEO);
//			}   
//
//			//vmp.2 双速单格式会议，停止vmp第二路码流的prs
//			if (tOldLocalVidSrc.GetEqpType() == EQP_TYPE_VMP)
//			{
//				if (0 != m_tConf.GetSecBitRate() && 
//					MEDIA_TYPE_NULL == m_tConf.GetSecVideoMediaType())
//				{
//					StopPrsForVmp(tOldLocalVidSrc);
//					//StopPrs(PRSCHANMODE_VMP2, TRUE);
//				}
//			}
//		}        
//
//		if (ptNewVidBrdSrc != NULL)
//		{		
//			if (ptNewVidBrdSrc->GetEqpType() == EQP_TYPE_VMP)
//			{
//				//停视频适配器时会停唇音同步的交换，当开启画面合成时，需要重新建立到各个终端的音频交换
//				if (m_tConf.m_tStatus.IsVidAdapting())
//				{
//					StopBrdAdapt(MODE_VIDEO,FALSE);
//					m_tConf.m_tStatus.SetAdaptMode(ADAPT_MODE_VID, FALSE);
//
//					//只对于唇音同步，才考虑重建交换
//					if ( g_cMcuVcApp.IsVASimultaneous() )
//					{
//						TMt atDstMt[MAXNUM_CONF_MT];
//						u8 byDstMtNum = 0;
//						for (u8 byMtIdx = 1; byMtIdx < MAXNUM_CONF_MT; byMtIdx++)
//						{
//							if (!m_tConfAllMtInfo.MtJoinedConf(byMtIdx))
//							{
//								continue;
//							}
//							if (byMtIdx == m_tConf.GetSpeaker().GetMtId())
//							{
//								continue;
//							}
//							
//							// 带音频主席轮询时,跳过主席终端
//							if (m_tConf.GetChairman().GetMtId() == byMtIdx
//								&& CONF_POLLMODE_BOTH_CHAIRMAN == m_tConf.m_tStatus.GetPollMode())
//							{
//								continue;
//							}
//							
//							TMt tTempMt = m_ptMtTable->GetMt(byMtIdx);
//							if (IsNeedAdapt(GetAudBrdSrc(), tTempMt, MODE_AUDIO))
//							{
//								continue;
//							}
//
//							//非视频适配不存在唇音同步，过滤
//							if ( !IsNeedAdapt( tOldLocalVidSrc,tTempMt, MODE_VIDEO ) )
//							{
//								continue;
//							}
//							
//							//有音频选看源，跳过重建音频广播交换[6/21/2012 chendaiwei]
//							TMtStatus tTempMtStatus;
//							m_ptMtTable->GetMtStatus(tTempMt.GetMtId(), &tTempMtStatus);
//							
//							if (!tTempMtStatus.GetSelectMt(MODE_AUDIO).IsNull())
//							{
//								continue;
//							}	 
//							
//							ConfPrint(LOG_LVL_DETAIL,MID_MCU_CONF,"[ChangeVidBrdSrc]tTempMt:%d-%d need audio StartSwitchToAll\n",tTempMt.GetMcuId(), tTempMt.GetMtId());
//							//zjl 20110510 StartSwitchToAll 替换 StartSwitchToSubMt
//							//StartSwitchToSubMt(tAudSrc, 0, byMtIdx, MODE_AUDIO, SWITCH_MODE_BROADCAST, FALSE, FALSE, FALSE, wSpyPort);
//							atDstMt[byDstMtNum] = tTempMt;
//							byDstMtNum ++;
//						}
//						
//						if (byDstMtNum > 0)
//						{
//							CRecvSpy tAudSpy;
//							u16 wSpyPort = SPY_CHANNL_NULL;
//							TMt tAudSrc = GetAudBrdSrc();
//							if( m_cSMcuSpyMana.GetRecvSpy( tAudSrc, tAudSpy ) )
//							{
//								wSpyPort = tAudSpy.m_tSpyAddr.GetPort();
//							}
//							TSwitchGrp tSwitchGrp;		
//							tSwitchGrp.SetSrcChnl(0);
//							tSwitchGrp.SetDstMtNum(byDstMtNum);
//							tSwitchGrp.SetDstMt(atDstMt);
//							StartSwitchToAll(tAudSrc, 1, &tSwitchGrp, MODE_AUDIO, SWITCH_MODE_BROADCAST,FALSE, FALSE, wSpyPort);
//						}
//					}
//				}
//			}
//
//			//zjl 退出画面合成时，拆除VMP桥
//			if (tOldLocalVidSrc.GetEqpType() == EQP_TYPE_VMP && *ptNewVidBrdSrc == GetLocalSpeaker() )
//			{
//				u8 byVmpSubType = GetVmpSubType(tOldLocalVidSrc.GetEqpId());
//				TKDVVMPOutParam tVMPOutParam = g_cMcuVcApp.GetVMPOutParam(tOldLocalVidSrc);
//				if(byVmpSubType != VMP)
//				{
//					u8 byMaxOutChnl = 0;
//					// MPU2类型vmp有9路后适配
//					if (MPU2_VMP_ENHACED == byVmpSubType ||
//						MPU2_VMP_BASIC == byVmpSubType)
//					{
//						byMaxOutChnl = tVMPOutParam.GetVmpOutCount();//需根据后适配情况确定个数
//					}// MPU类型vmp有4路后适配
//					else
//					{
//						byMaxOutChnl = MAXNUM_MPU_OUTCHNNL;
//					}
//					for(u8 byChnnl = 0; byChnnl < byMaxOutChnl; byChnnl++)
//					{
//						g_cMpManager.RemoveSwitchBridge(tOldLocalVidSrc, byChnnl, MODE_VIDEO);
//					}
//				}
//			}
//		}
//     
//        //TLogicalChannel tLogicalChannel;
//
//        //　只停那些收看广播源的终端
//        if (NULL == ptNewVidBrdSrc)
//        {
//			if (m_tConf.m_tStatus.IsVidAdapting())
//			{
//				//StopAllBasSwitch(MODE_VIDEO);
//				StopBrdAdapt(MODE_VIDEO);
//				m_tConf.m_tStatus.SetAdaptMode(ADAPT_MODE_VID, FALSE);
//			}
//			//zjj20120927 Bug00108523
//			if( VCS_CONF != m_tConf.GetConfSource() || !ISGROUPMODE(m_cVCSConfStatus.GetCurVCMode()) )
//			{
//				RestoreAllSubMtJoinedConfWatchingSrcMt(tOldVidSrc, MODE_VIDEO,FALSE);
//			}
//
//		
//            // 如果是卫星分散组播，则停止
//            if (m_tConf.GetConfAttrb().IsSatDCastMode())
//            {
//				bySrcChnnl = (tOldVidSrc == m_tPlayEqp ? m_byPlayChnnl : 0);
//                g_cMpManager.StopDistrConfCast(tOldLocalVidSrc, MODE_VIDEO, bySrcChnnl);
//
//                TMt tLoopMt;
//                // // 顾振华 [4/25/2006] 通知终端看自己
//				// 有选看的终端不能看自己 [pengguofeng 1/21/2013]
///*                for( u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
//                {
//                    if( m_tConfAllMtInfo.MtJoinedConf( byLoop ))
//                    {
//                        tLoopMt = m_ptMtTable->GetMt( byLoop );
//                        NotifyMtReceive( tLoopMt, byLoop );
//                    }
//                }*/
//            }            
//        }
//	
//		//画面合成停止广播时重启媒体类型适配,新广播源不是vmp
//        if (TYPE_MCUPERI == tOldLocalVidSrc.GetType() && tOldLocalVidSrc.GetEqpType() == EQP_TYPE_VMP &&
//			(ptNewVidBrdSrc == NULL || ptNewVidBrdSrc->GetEqpType() != EQP_TYPE_VMP) &&
//            m_tConf.GetConfAttrb().IsUseAdapter())
//        {         
//			if (!m_tConf.m_tStatus.IsVidAdapting())
//			{
//				StartBrdAdapt(MODE_VIDEO);
//			}   
//        }
//
//        //停止向录像机交换
//        if (!m_tConf.m_tStatus.IsNoRecording()
//			&& !IsRecNeedAdapt(MODE_VIDEO) )			// [10/29/2010 liuxu] 非自定义录像时不需要停止
//        {
//            StopSwitchToPeriEqp(m_tRecEqp.GetEqpId(), m_byRecChnnl, FALSE, MODE_VIDEO);
//        }
//
//        //停止向码率适配器交换 - modify bas 2
//        //if (m_tConf.m_tStatus.IsVidAdapting())
////         if (EQP_CHANNO_INVALID != m_byVidBasChnnl)
////         {
////             //zbq[08/07/2007] 切换源而非删除源，不停BAS的交换；其新建交换可在MP业务或DS业务过滤掉
////             if ( NULL == ptNewVidBrdSrc )
////             {
////                 StopSwitchToPeriEqp(m_tVidBasEqp.GetEqpId(), m_byVidBasChnnl, FALSE, MODE_VIDEO);
////             }
////         }
//
//        //if (m_tConf.m_tStatus.IsBrAdapting())
////         if (EQP_CHANNO_INVALID != m_byBrBasChnnl)
////         {
////             //zbq[08/07/2007] 切换源而非删除源，不停BAS的交换；其新建交换可在MP业务或DS业务过滤掉
////             if ( NULL == ptNewVidBrdSrc )
////             {
////                 StopSwitchToPeriEqp(m_tBrBasEqp.GetEqpId(), m_byBrBasChnnl, FALSE, MODE_VIDEO);
////             }
////         }
//		//zjj20100113拆除前一个终端广播源的桥
//		if( !(tOldVidSrc.GetEqpType() == EQP_TYPE_VMP) &&  !tOldVidSrc.IsLocal() && !(GetSecVidBrdSrc() == tOldVidSrc))
//		{
//			//u16 wOldBrdSrcSpyPort = SPY_CHANNL_NULL;
//			CRecvSpy tSpyResource2;
//			bySrcChnnl = (tOldVidSrc == m_tPlayEqp) ? m_byPlayChnnl : 0;
//
//			if( wOldVidBrdSpyPort == SPY_CHANNL_NULL &&
//				m_cSMcuSpyMana.GetRecvSpy( tOldVidSrc, tSpyResource2 ) )
//			{
//				wOldVidBrdSpyPort = tSpyResource2.m_tSpyAddr.GetPort();
//			}
//			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ChangeVidBrdSrc] Remove LastVidBrd<McuId.%d, MtId.%d> Bridge!\n", tOldVidSrc.GetMcuId(), tOldVidSrc.GetMtId());
//			g_cMpManager.RemoveSwitchBridge( tOldLocalVidSrc, bySrcChnnl, MODE_VIDEO,FALSE, wOldVidBrdSpyPort );
//		}
//	}
//    //zjl[2009/11/16]切换发言人时(因为画面合成也会广播,所以把画面合成排除)，清除所有终端的选看状态(发言人除外)
//	//zjj20091102 vcs会议在切换会议模式时都会清，这里不清
//	// [12/25/2009 xliang] 增加清主席选看VMP处理
//	if (m_tConf.GetConfSource() != VCS_CONF &&
//		ptNewVidBrdSrc != NULL )
//	{
//		TMtStatus tMtStatus;
//		TMt tSelSrc;
//		BOOL32 bBrdSrcIsVmp = (ptNewVidBrdSrc->GetEqpType() == EQP_TYPE_VMP);
//		
//		for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
//		{
//			if (!m_tConfAllMtInfo.MtJoinedConf(byMtId))
//			{
//				continue;
//			}
//			
//			// [2011/09/16] zhangli 跳过上级mcu，防止上传终端被冲掉
//			if (!m_tCascadeMMCU.IsNull() && m_tCascadeMMCU.GetMtId() == byMtId)
//			{
//				continue;
//			}
//
//			m_ptMtTable->GetMtStatus(byMtId, &tMtStatus);			
//			u8 byMode = tMtStatus.GetSelByMcsDragMode();	// [12/25/2009 xliang] 不适用于主席选看VMP
//			tSelSrc = tMtStatus.GetSelectMt( MODE_VIDEO );
//			
//			// 主席有选看源,就跳过主席
//			if (m_tConf.GetChairman().GetMtId() == byMtId && 
//				!(tSelSrc == *ptNewVidBrdSrc )
//				)
//			{
//				// 选看源是vmp时,若该vmp变为广播源，需要清主席选看vmp状态
//				if (!tSelSrc.IsNull())
//				{
//					// 主席选看非vmp终端
//					if (EQP_TYPE_VMP == tSelSrc.GetEqpType() &&
//						EQP_TYPE_VMP == ptNewVidBrdSrc->GetEqpType() &&
//						tSelSrc.GetEqpId() == ptNewVidBrdSrc->GetEqpId())
//					{
//						// 此时需要清主席选看，其余情况都保留
//					}
//					else
//					{
//						continue;
//					}
//				}
//				/* 主席选看轮询中,跳过主席
//				if (CONF_POLLMODE_BOTH_CHAIRMAN == m_tConf.m_tStatus.GetPollMode() ||
//					CONF_POLLMODE_VIDEO_CHAIRMAN == m_tConf.m_tStatus.GetPollMode())
//				{
//					continue;
//				}*/
//			}
//
//			//zjj20100422 如果终端选看或选听的终端是广播源就不要停选看和选听了,
//			//直接删除回传选看模式,减少回传目的数
//			//if( MODE_BOTH == byMode || byMode == MODE_VIDEO && NULL != ptVidBrdSrc &&
//			//	m_cSMcuSpyMana.IsMtInSpyMember( *ptVidBrdSrc ) )
//			//{
//			/*if( !tSelSrc.IsNull() 
//				&& tSelSrc.GetType() != TYPE_MCUPERI 
//				&& ( ptVidBrdSrc && !ptVidBrdSrc->IsNull()  && *ptVidBrdSrc == tSelSrc ) 
//			  )
//			{					
//				//[nizhijun 2010/12/02] 发言人与终端的选看源是同一个，释放BAS通道,并拆除交换
//				StopSelAdapt(tSelSrc,m_ptMtTable->GetMt(byMtId),MODE_VIDEO);
//				FreeRecvSpy(tSelSrc, MODE_VIDEO);
//				tMtStatus.RemoveSelByMcsMode( MODE_VIDEO );
//				TMt tTempMt;
//				tTempMt.SetNull();
//				tMtStatus.SetSelectMt( tTempMt,MODE_VIDEO );
//				m_ptMtTable->SetMtStatus( byMtId, &tMtStatus );
//				tTempMt = m_ptMtTable->GetMt(byMtId);
//				MtStatusChange( &tTempMt, TRUE );		
//			}*/
//			//}
//
//// 			//20130111 zhouyiliang发言人，如果新的广播源不是发言人需要停掉发言人的选看（广播优先级，发言<= 视频轮询<=vmp广播）
//// 			if ( GetLocalSpeaker() == m_ptMtTable->GetMt(byMtId) && (GetLocalSpeaker() == *ptNewVidBrdSrc) )
//// 			{
//// 				continue;
//// 			}
//			// 20120608 yhz 主席轮询在上面已经跳过,此处主席轮询判断有问题,非主席终端选看也会被跳过
//			if ( !(GetLocalSpeaker() == m_ptMtTable->GetMt(byMtId) && !bBrdSrcIsVmp) && //广播源是vmp时,仍要停发言人选看
//				( !bBrdSrcIsVmp ||  
//						m_tConf.m_tStatus.GetRollCallMode() == ROLLCALL_MODE_NONE || 
//							( byMtId != m_tRollCaller.GetMtId() && m_tRollCallee.IsLocal() &&
//								byMtId != m_tRollCallee.GetMtId() ) ) 
//				)
//			{
//				if( !tSelSrc.IsNull() )
//				{
//					if( EQP_TYPE_VMP == tSelSrc.GetEqpType() )
//					{
//						byMode = MODE_VIDEO;
//						//非主席终端选看画面合成全部都要清
//						if ( (bBrdSrcIsVmp && m_tConf.GetChairman().GetMtId() == byMtId) || 
//								m_tConf.GetChairman().GetMtId() != byMtId
//							)
//						{
//							StopSelectSrc(m_ptMtTable->GetMt(byMtId), byMode);
//
//							ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "byMtId.%u ( chairman mtid is :%d), stop watching VMP because other Mt's speaking or vmp is broadcasting!\n",
//							byMtId,m_tConf.GetChairman().GetMtId() ); 
//						}
//							
//					}
//					else
//					{
//						//只停视频选看[6/14/2012 chendaiwei]
//						StopSelectSrc(m_ptMtTable->GetMt(byMtId), MODE_VIDEO);
//					}
//				}
//			}	
//		}
//	}
//	
//    //　开始广播新视频源
//    if (NULL != ptNewVidBrdSrc)
//    {
// //       RefreshRcvGrp();
//		
//		//[nizhijun 2012/06/29] 录像机适配录像，如果源是VMP，不走BAS，直接收VMP的相关码流。
//// 		// [1/12/2011 liuxu] vmp广播时,如果在适配录像,需要建立vmp到广播端口的交换
//// 		if (*ptNewVidBrdSrc == m_tVmpEqp)
//// 		{
//// 			if (IsRecNeedAdapt())
//// 			{
//// 				// [8/5/2011 liuxu] 改为会议主格式
//// 				TVideoStreamCap tStrCap = m_tConf.GetMainSimCapSet().GetVideoCap();
//// 				u8 byVmpChnnlToRec = GetVmpOutChnnlByRes(tStrCap.GetResolution(), 
//// 					tStrCap.GetMediaType(),
//// 					tStrCap.GetUserDefFrameRate(),
//// 					tStrCap.GetH264ProfileAttrb());
//// 				
//// 				// 判断通道是否合法
//// 				if (0xFF == byVmpChnnlToRec)
//// 				{
//// 					ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "[ProBasMcuSelAdpRsp]GetVmpOutChnnlByRes for Adapt rec failed, please check it\n");
//// 					return;
//// 				}
//// 				
//// 				// 适配录像时, vmp需要建立到广播端口的交换
//// 				// 因为适配录像是从广播端口接收的
//// 				g_cMpManager.StartSwitchToBrd(m_tVmpEqp, byVmpChnnlToRec, TRUE);
//// 
//// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, 
//// 					"[ChangeVidBrdSrc]Start VMP[Eqp.%d, Chnnl.%d] brd when Adapt Rec\n", 
//// 					m_tVmpEqp.GetEqpId(), 
//// 					byVmpChnnlToRec);
//// 			}
//// 		}
//// 		// liuxu add end
//		
//		// xliang [2/5/2009] 新VMP广播码流走新逻辑
//		if( ptNewVidBrdSrc->GetEqpType() == EQP_TYPE_VMP && GetVmpSubType(ptNewVidBrdSrc->GetEqpId()) != VMP )
//		{
//			// new vmp start broadcast
//			// 卫星会议：从发言人终端切到VMP广播，则要停止发言人的广播交换 [pengguofeng 2/18/2013]
//			if ( m_tConf.GetConfAttrb().IsSatDCastMode() && !tOldLocalVidSrc.IsNull()
//				&& tOldLocalVidSrc.GetMtType() == MT_TYPE_MT
//				)
//			{
//				g_cMpManager.StopSwitchToBrd(tOldLocalVidSrc, bySrcChnnl, wOldSpyStartPort);
//			}
//			StartMpuVmpBrd(*ptNewVidBrdSrc);
//		}
//		else //是老vmp或其他外设/MT
//		{
//
//			//启用适配并且开启了双流, 强制降低新的第一路发送源的发送码率,没有适配器则根据FlowControl调整
//			if (!m_tDoubleStreamSrc.IsNull() &&
//				!ptNewVidBrdSrc->IsNull() && TYPE_MT == ptNewVidBrdSrc->GetType())
//			{
//				u16 wDialBitrate = 0;
//				TLogicalChannel tLogicalChannel;
//				if (TRUE == m_ptMtTable->GetMtLogicChnnl(ptNewVidBrdSrc->GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE))
//				{
//					wDialBitrate = m_ptMtTable->GetSndBandWidth(ptNewVidBrdSrc->GetMtId());
//					tLogicalChannel.SetFlowControl(GetDoubleStreamVideoBitrate(wDialBitrate));
//					cServMsg.SetMsgBody((u8*)&tLogicalChannel, sizeof(tLogicalChannel));
//					SendMsgToMt(ptNewVidBrdSrc->GetMtId(), MCU_MT_FLOWCONTROL_CMD, cServMsg);
//				} 
//			 }
// 
//
//			//改变丢包重传源
//			TConfAttrb tTempConfAttr = m_tConf.GetConfAttrb();
//			if (tTempConfAttr.IsResendLosePack())
//			{
//				//开启视频广播prs
//				StartBrdPrs(MODE_VIDEO);
//				
//				//vmp.2, 启动vmp第二路的prs
//				if (0 != m_tConf.GetSecBitRate() && 
//					MEDIA_TYPE_NULL == m_tConf.GetSecVideoMediaType() &&                
//					ptNewVidBrdSrc->GetEqpType() == EQP_TYPE_VMP)
//				{
//					StartPrsForVmp(*ptNewVidBrdSrc);
//					//ChangePrsSrc(*ptNewVidBrdSrc, PRSCHANMODE_VMP2);
//				}
//			}
//
//			//建立交换桥
//			bySrcChnnl = (*ptNewVidBrdSrc == m_tPlayEqp) ? m_byPlayChnnl : 0;
//			g_cMpManager.SetSwitchBridge(*ptNewVidBrdSrc, bySrcChnnl, MODE_VIDEO, FALSE, wSpyStartPort);
//        
//			// xsl [1/21/2006] 双速或双格式会议广播源为vmp时，搭建第二路交换桥
//			if (ptNewVidBrdSrc->GetEqpType() == EQP_TYPE_VMP &&
//				((0 != m_tConf.GetSecBitRate() || MEDIA_TYPE_NULL != m_tConf.GetSecVideoMediaType())))
//			{
//				g_cMpManager.SetSwitchBridge(*ptNewVidBrdSrc, bySrcChnnl+1, MODE_VIDEO, FALSE, wSpyStartPort);           
//			}
//
//            //zbq[04/15/2009]
//            if (IsDelayVidBrdVCU())
//            {
//				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ChangeVidBrd] IsDelayVidBrdVCU!\n");
//                //Vmp轮询跟随状态下要抓到Tandberg的关键帧，延迟到VMP交换建好发youareseeing和fastupdate
//            }
//            else
//            {
//                //通知终端开始发送
//                if (ptNewVidBrdSrc->GetType() == TYPE_MT)
//                {			
//                    NotifyMtSend(ptNewVidBrdSrc->GetMtId(), MODE_VIDEO);
//			    }
//				else
//				{
//					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ChangeVidBrd] ptNewVidBrdSrc->GetType().%d is not Mt!\n", 
//												ptNewVidBrdSrc->GetType());
//				}
//            }
//
//			//切换发言人时，调整录像交换要移到NotifyMtSend后
//			//必须先等NotifyMtSend源端码率为非0才能判断是否要起适配，否则会误判不过适配
//			//2.StartBrdAdapt会先清除适配参数再根据会议能力和终端速率刷新参数，并且对低速过适配录像进行码率刷新
//			StartBrdAdapt(MODE_VIDEO);
//			if (!m_tConf.m_tStatus.IsNoRecording())
//			{
//				//AdjustRecordSrcStream( MODE_VIDEO );
//				AdjustConfRecordSrcStream(MODE_VIDEO, TRUE);
//			}
//
//            //zbq[07/15/2009] 防止按低码率呼入 误判
//  //          RefreshRcvGrp();
//
//			//组播会议组播数据
//			if (m_tConf.GetConfAttrb().IsMulticastMode() )
//			{
//				if ( !m_tConf.GetConfAttrb().IsMulcastLowStream())
//				{
//					u16 wSrcChnnl = bySrcChnnl;
//					if( !tUnLocalNewVidBrdSrc.IsLocal() && IsLocalAndSMcuSupMultSpy(tUnLocalNewVidBrdSrc.GetMcuId()) )
//					{
//						CRecvSpy tSpyResource;
//						if(m_cSMcuSpyMana.GetRecvSpy( tUnLocalNewVidBrdSrc, tSpyResource ))
//						{
//							wSrcChnnl  = tSpyResource.m_tSpyAddr.GetPort();
//						}
//					}
//					g_cMpManager.StartMulticast(*ptNewVidBrdSrc, wSrcChnnl, MODE_VIDEO);
//					m_ptMtTable->SetMtMulticasting(ptNewVidBrdSrc->GetMtId());
//				}
//				else
//				{
//					// [5/5/2011 xliang] 低速组播逻辑
//					if(ptNewVidBrdSrc->GetType() == TYPE_MCUPERI && ptNewVidBrdSrc->GetEqpType() == EQP_TYPE_VMP)
//					{
//						// 对于OldVMP 第2路交换到组播地址
//						g_cMpManager.StartMulticast(*ptNewVidBrdSrc, 1, MODE_VIDEO);
//						m_ptMtTable->SetMtMulticasting(ptNewVidBrdSrc->GetEqpId());
//					}
//					else
//					{
//						// 对于发言广播，则由适配器交换到组播地址
//						TEqp tLowBRBas;
//						tLowBRBas.SetNull();
//						u8 byLowBRBasChnId = 0;
//						u8 byOutNum = 0;
//						u8 byOutIdx = 0;
//						if (GetLowBrUseBasOutPutInfo(tLowBRBas, byLowBRBasChnId, byOutNum,  byOutIdx))
//						{
//							tLowBRBas.SetConfIdx(m_byConfIdx);	// must set confIdx
//							g_cMpManager.StartMulticast(tLowBRBas, byLowBRBasChnId* byOutNum + byOutIdx, MODE_VIDEO);
//							m_ptMtTable->SetMtMulticasting(tLowBRBas.GetEqpId());
//						}
//					}
//				}
//			}
//
//                       
//			// 顾振华@2006.04.12 如果是卫星分散组播
//			/*if (m_tConf.GetConfAttrb().IsSatDCastMode())
//			{
//				g_cMpManager.StartDistrConfCast(*ptNewVidBrdSrc, MODE_VIDEO, bySrcChnnl);
//            
//				TMt atDstMt[MAXNUM_CONF_MT];
//				memset(atDstMt, 0, sizeof(atDstMt));
//				u8 byDstMtNum = 0;
//
//				TMtStatus tMtStatus;
//				for( u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
//				{
//					if ( m_tConfAllMtInfo.MtJoinedConf( byLoop ) )
//					{                    
//						// xsl [7/21/2006]若在选看，拆掉交换，告诉其从组播地址接收
//						if (m_ptMtTable->GetMtStatus(byLoop, &tMtStatus))
//						{
//							TMt tTmpMt = tMtStatus.GetSelectMt(MODE_VIDEO);
//							if (!tTmpMt.IsNull())
//							{
//								//zjl 20110510 StopSwitchToSubMt 接口重载替换
//								//StopSwitchToSubMt(byLoop, MODE_VIDEO, SWITCH_MODE_SELECT); 
//								atDstMt[byDstMtNum] = m_ptMtTable->GetMt(byLoop);
//								byDstMtNum++;
//
//								ChangeSatDConfMtRcvAddr(byLoop, LOGCHL_VIDEO);
//							}
//						}
//
//						// 通知终端接收源
//						NotifyMtReceive( *ptNewVidBrdSrc, byLoop );
//					}
//				}
//
//				if (byDstMtNum > 0)
//				{
//					StopSwitchToSubMt(byDstMtNum, atDstMt, MODE_VIDEO);
//				}
//			}
//			else*/
//			{
//				// 开始向各终端交换
//				// guzh [3/21/2007] 改用新接口
//				StartSwitchToAllSubMtJoinedConf(tUnLocalNewVidBrdSrc, bySrcChnnl, tOldVidSrc, bStopOldVidSrcNow, wSpyStartPort);
//			}
//		}
//    }

//	// [pengjie 2010/9/29] 会议录像无广播源时跳过该段录像支持
//	if( !m_tConf.m_tStatus.IsNoRecording() )
//	{
//		AdjustConfRecByBrdSrc();
//	}
//    // End	
//
//	return;
}

/*====================================================================
    函数名      ：ChangeAudBrdSrc
    功能        ：改变音频广播源（包括单纯撤销）；
	              通知MC，MT和
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt * ptNewAudBrdSrc, 新的音频广播源，NULL表示单纯撤销
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/25    3.0         胡昌威        创建
====================================================================*/
void CMcuVcInst::ChangeAudBrdSrc( TMt * ptAudBrdSrc,u16 wOldAudBrdSpyPort )
{
	TMt tOldAudBrdSrc = GetAudBrdSrc();
	TMt tOldLocalAudBrdSrc = GetLocalAudBrdSrc();

	u8	bySrcChnnl = (tOldAudBrdSrc == m_tPlayEqp) ? m_byPlayChnnl : 0;
	//tianzhiyong 2010/02/24
	if (tOldAudBrdSrc == m_tMixEqp)//为混音器
	{
		bySrcChnnl = GetMixerNModeChn();
		ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[ChangeAudBrdSrc]: EQPID=[%d] NmodeChnIndx=[%d]\n",
			m_tMixEqp.GetEqpId(),GetMixerNModeChn() );
	}

	if (ptAudBrdSrc == NULL)
	{
		SetAudBrdSrcNull();
		// 2011-8-11 add by pgf: Bug00061176:会议组播时，取消发言人导致画面合成至组播地址的交换被拆除
		if ( m_tConf.GetConfAttrb().IsMulticastMode() && !tOldAudBrdSrc.IsNull() )
		{
			g_cMpManager.StopMulticast(tOldAudBrdSrc, 0, MODE_AUDIO);
		}
		// 2011-8-11 add end
	}
	else
	{
		SetAudBrdSrc(*ptAudBrdSrc);
	}

	//  [12/9/2009 pengjie] 级联多回传支持 这里为了传进来的指针不被修改该，所以重新保存了一下该变量
	TMt tMt;
	TMt *ptNewAudBrdSrc = NULL;
	TMt tUnLocalNewSrc;
	tUnLocalNewSrc.SetNull();

	u16 wSpyStartPort = SPY_CHANNL_NULL;
	if( ptAudBrdSrc != NULL )
	{
		//lukunpeng 2010/06/08 音视频广播源非local化代码整理
		tMt = *ptAudBrdSrc;
		ptNewAudBrdSrc = &tMt;
		CRecvSpy tSpyResource; 
		if( m_cSMcuSpyMana.GetRecvSpy( *ptNewAudBrdSrc, tSpyResource ) )
		{
			wSpyStartPort = tSpyResource.m_tSpyAddr.GetPort();
		}
	}
	// End

	if( ptNewAudBrdSrc != NULL)
	{
		tUnLocalNewSrc = *ptNewAudBrdSrc;
		*ptNewAudBrdSrc = GetLocalMtFromOtherMcuMt( *ptNewAudBrdSrc );
	}
	// End


	BOOL32 bIsBrdSrcNoKedaAndDumb = FALSE;
	//zjj20120627 非科达终端(外厂商或kdc的mcu)做发言人哑音处理
	if( GetAudBrdSrc().GetType() != TYPE_MCUPERI && MT_MANU_KDC != m_ptMtTable->GetManuId(GetLocalAudBrdSrc().GetMtId())
		&& m_ptMtTable->IsMtAudioDumb( GetLocalAudBrdSrc().GetMtId() ) )
	{
		bIsBrdSrcNoKedaAndDumb = TRUE;
	}

    //停止广播原有音频源
    if( !tOldLocalAudBrdSrc.IsNull() )
    {
        //停止第一路音频广播源的重传
        if( ptNewAudBrdSrc == NULL)
        {
			StopBrdPrs(MODE_AUDIO);

			//老源如果是终端或者放像机，则停适配器
			if ( tOldLocalAudBrdSrc.GetType() == TYPE_MT  || 
				 m_tPlayEqp == tOldLocalAudBrdSrc
				)
			{
				if (m_tConf.m_tStatus.IsAudAdapting())
				{
					StopBrdAdapt(MODE_AUDIO);
					m_tConf.m_tStatus.SetAdaptMode(ADAPT_MODE_AUD, FALSE);
					ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"[ChangeAudBrdSrc]stop bas brd,tOldSrc:%d-%d\n",
							tOldLocalAudBrdSrc.GetType(),tOldLocalAudBrdSrc.GetMtId()
							);
				}
			}
        }
		//停多格式混音拆动态prs通道
		if ( tOldLocalAudBrdSrc == m_tMixEqp)
		{
			StopPrsForMixer();
		}

		u16 wMMcuIdx = INVALID_MCUIDX;
		if ( !m_tCascadeMMCU.IsNull() )
		{
			wMMcuIdx = GetMcuIdxFromMcuId( m_tCascadeMMCU.GetMtId() );
		}
        // zbq [08/23/2007] 当前源在回传通道里，则不能拆桥
        if ( !m_tCascadeMMCU.IsNull() &&
            m_ptConfOtherMcTable->GetMcInfo(wMMcuIdx/*m_tCascadeMMCU.GetMtId()*/) != NULL &&
			m_ptConfOtherMcTable->GetMcInfo(wMMcuIdx/*m_tCascadeMMCU.GetMtId()*/)->m_tSpyMt == tOldLocalAudBrdSrc )
        {
        }
        else
        {
			u16 wOldBrdSrcSpyPort = SPY_CHANNL_NULL;
			CRecvSpy tSpyResource;
            bySrcChnnl = (tOldAudBrdSrc == m_tPlayEqp) ? m_byPlayChnnl : 0;

			//多格式混音拆桥
			u8 byAudCapNum = 1;
			TAudioTypeDesc atAudTypeDesc[MAXNUM_CONF_AUDIOTYPE];
			if (tOldAudBrdSrc == m_tMixEqp)
			{
				bySrcChnnl = GetMixerNModeChn();
				byAudCapNum = m_tConfEx.GetAudioTypeDesc(atAudTypeDesc);
				ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[ChangeAudBrdSrc]: EQPID=[%d] NmodeChnIndx=[%d]\n",
					m_tMixEqp.GetEqpId(),GetMixerNModeChn() );
			}
			wOldBrdSrcSpyPort = wOldAudBrdSpyPort;
			if( SPY_CHANNL_NULL == wOldBrdSrcSpyPort &&
				m_cSMcuSpyMana.GetRecvSpy( tOldAudBrdSrc, tSpyResource ) )
			{
				wOldBrdSrcSpyPort = tSpyResource.m_tSpyAddr.GetPort();
			}

			for (u8 byLoop = 0; byLoop < byAudCapNum; byLoop++)
			{
				g_cMpManager.RemoveSwitchBridge( tOldLocalAudBrdSrc, bySrcChnnl + byLoop, MODE_AUDIO, FALSE, wOldBrdSrcSpyPort);
			}
        }
        
        //只停那些收看广播源的终端
        if( ptNewAudBrdSrc == NULL || bIsBrdSrcNoKedaAndDumb)
        {			
			
			RestoreAllSubMtJoinedConfWatchingSrcMt( tOldAudBrdSrc, MODE_AUDIO,FALSE );			
            
            // 如果是卫星分散组播，则停止
            if (m_tConf.GetConfAttrb().IsSatDCastMode())
            {
                g_cMpManager.StopDistrConfCast(tOldLocalAudBrdSrc, MODE_AUDIO, bySrcChnnl);
            }
        }

        //停止向录像机交换
        if( !m_tConf.m_tStatus.IsNoRecording() )
        {
			StopSwitchToRecorder(m_tRecEqp, m_byRecChnnl, FALSE, MODE_AUDIO);
			/*if (m_tRecEqp.GetType() == TYPE_MT && m_tRecEqp.GetMtType() == MT_TYPE_VRSREC)
			{
				//vrs新录播支持
				StopSwitchToSubMt(1, &m_tRecEqp, MODE_AUDIO, FALSE);
			}
			else
			{
				StopSwitchToPeriEqp( m_tRecEqp.GetEqpId(), m_byRecChnnl, FALSE, MODE_AUDIO );
			}*/
        }
    }

	CSendSpy cSendSpy;
	//清音频选看[6/14/2012 chendaiwei]
	if (m_tConf.GetConfSource() != VCS_CONF &&
		ptNewAudBrdSrc != NULL )
	{
		TMtStatus tMtStatus;
		TMt tSelSrc;
		

		for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
		{
			if (!m_tConfAllMtInfo.MtJoinedConf(byMtId))
			{
				continue;
			}
			
			// [2011/09/16] zhangli 跳过上级mcu，防止上传终端被冲掉
			// 广播源是mixer,并且上级MCU在混音器中，停到上级MCU音频交换 [5/31/2013 chendaiwei]
			if (!m_tCascadeMMCU.IsNull() && m_tCascadeMMCU.GetMtId() == byMtId && 
				!(*ptNewAudBrdSrc == m_tMixEqp && m_ptMtTable->IsMtInMixing(byMtId)))
			{
				continue;
			}

			m_ptMtTable->GetMtStatus(byMtId, &tMtStatus);
			tSelSrc = tMtStatus.GetSelectMt( MODE_AUDIO );

			// 主席新策略,主席有选看选听时,切发言人不冲主席选看选听
			if( m_tConf.GetChairman().GetMtId() == byMtId && !tSelSrc.IsNull() &&
				!(tSelSrc == tUnLocalNewSrc) 
			   )
			{			
				continue;				
			}

			if( m_tCascadeMMCU.GetMtId() == byMtId && 
					( !m_cLocalSpyMana.GetSpyChannlInfo(tSelSrc,cSendSpy) || cSendSpy.GetSpyMode() == MODE_AUDIO || cSendSpy.GetSpyMode() == MODE_BOTH )
					)
			{
				continue;
			}

			if( !tSelSrc.IsNull() )
			{
				StopSelectSrc(m_ptMtTable->GetMt(byMtId), MODE_AUDIO);
			}
		}
	}

    //开始广播新音频源
    if (ptNewAudBrdSrc != NULL)
    {				
		bySrcChnnl = (*ptNewAudBrdSrc == m_tPlayEqp) ? m_byPlayChnnl : 0;

		//新源是混音器，停适配器
		if (*ptNewAudBrdSrc == m_tMixEqp &&
			m_tConf.m_tStatus.IsAudAdapting()
			)
		{
			StopBrdAdapt(MODE_AUDIO);
			m_tConf.m_tStatus.SetAdaptMode(ADAPT_MODE_AUD, FALSE);
		}

		//多格式混音建桥
		u8 byAudCapNum = 1;
		TAudioTypeDesc atAudTypeDesc[MAXNUM_CONF_AUDIOTYPE];
        if (m_tConf.m_tStatus.IsMixing() && *ptNewAudBrdSrc == m_tMixEqp)
        {
			bySrcChnnl = GetMixerNModeChn();
			byAudCapNum = m_tConfEx.GetAudioTypeDesc(atAudTypeDesc);
			ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[ChangeAudBrdSrc SetSwitchBridge]:EQPID=[%d] NmodeChnIndx=[%d]\n",
				m_tMixEqp.GetEqpId(),GetMixerNModeChn() );
        }
		for (u8 byLoop = 0; byLoop < byAudCapNum; byLoop++)
		{
			g_cMpManager.SetSwitchBridge(*ptNewAudBrdSrc, bySrcChnnl + byLoop, MODE_AUDIO, FALSE, wSpyStartPort);
		}
        
        //通知终端开始发送
        if (ptNewAudBrdSrc->GetType() == TYPE_MT)
        {			
            NotifyMtSend(ptNewAudBrdSrc->GetMtId(), MODE_AUDIO);
        }

        //改变丢包重传源
		TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
        if (tConfAttrb.IsResendLosePack())
        {
			StartBrdPrs(MODE_AUDIO);
			if (*ptNewAudBrdSrc == m_tMixEqp && m_tConf.m_tStatus.IsMixing() && byAudCapNum > 1)
			{
				StartPrsForMixer();
			}
 
        }

        //开始媒体类型适配 - modify bas 2
        if (ptNewAudBrdSrc->GetType() == TYPE_MT ||
			( TYPE_MCUPERI == ptNewAudBrdSrc->GetType() && EQP_TYPE_RECORDER == ptNewAudBrdSrc->GetEqpType() )
			)
        {
            if (m_tConf.GetConfAttrb().IsUseAdapter())
            {		
				//正在音频适配，拆除到适配器交换,等changereq回ack后再建立到适配器交换
				if ( m_tConf.m_tStatus.IsAudAdapting() )
				{
					CBasChn *pBasChn[MAXNUM_PERIEQP] = {NULL};
					u8		byBasChnNum = 0;
					if ( GetBasBrdChnGrp(byBasChnNum, pBasChn,MODE_AUDIO) )
					{
						u8 bySrcChn = m_tPlayEqp == GetLocalAudBrdSrc() ? m_byPlayChnnl : 0;
						TEqp tBas;
						u8 byBasChnID =0;
						u8 bySwitchMode = SWITCH_MODE_BROADCAST;
						for (u8 byBasLoop =0 ; byBasLoop<byBasChnNum; byBasLoop++  )
						{
							if ( pBasChn[byBasLoop] )
							{
								tBas =  pBasChn[byBasLoop]->GetBas();
								byBasChnID = pBasChn[byBasLoop]->GetChnId();
								StopSwitchToPeriEqp(tBas.GetEqpId(), byBasChnID, FALSE, MODE_AUDIO);
							}
						}
					}
				}	
			//	StopSwitchToAllSubMtJoinedConf(MODE_AUDIO);
				StartBrdAdapt(MODE_AUDIO);
            }
        }

        //开始向录像机交换
        if (!m_tConf.m_tStatus.IsNoRecording())
        {
			AdjustConfRecordSrcStream(MODE_AUDIO, TRUE);
        }

        //组播会议组播数据
        if (m_tConf.GetConfAttrb().IsMulticastMode())
        {
			u16 wSrcChnnl = bySrcChnnl;
			if( !tUnLocalNewSrc.IsLocal() && IsLocalAndSMcuSupMultSpy(tUnLocalNewSrc.GetMcuId()) )
			{
				CRecvSpy tSpyResource;
				if(m_cSMcuSpyMana.GetRecvSpy( tUnLocalNewSrc, tSpyResource ))
				{
					wSrcChnnl  = tSpyResource.m_tSpyAddr.GetPort();
				}
			}
            g_cMpManager.StartMulticast(*ptNewAudBrdSrc, wSrcChnnl, MODE_AUDIO);
            m_ptMtTable->SetMtMulticasting(ptNewAudBrdSrc->GetMtId());
        }
        // 顾振华@2006.4.13开始音频分散组播。
        if (m_tConf.GetConfAttrb().IsSatDCastMode())
        {
            g_cMpManager.StartDistrConfCast(*ptNewAudBrdSrc, MODE_AUDIO, bySrcChnnl);
            
			TMt atDstMt[MAXNUM_CONF_MT];
			memset(atDstMt, 0, sizeof(atDstMt));
			u8 byDstMtNum = 0;
            // xsl [7/21/2006]若在选看，拆掉交换，告诉其从组播地址接收
            /*TMtStatus tMtStatus;
            for( u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
            {
                if( m_tConfAllMtInfo.MtJoinedConf( byLoop ))
                {                
					// [2011/09/16] zhangli 跳过上级mcu，防止上传终端被冲掉
					if (!m_tCascadeMMCU.IsNull() && m_tCascadeMMCU.GetMtId() == byLoop)
					{
						continue;
					}

                    if (m_ptMtTable->GetMtStatus(byLoop, &tMtStatus))
                    {
                        TMt tTmpMt = tMtStatus.GetSelectMt(MODE_AUDIO);
                        if (!tTmpMt.IsNull())
                        {
							//zjl 20110510 StopSwitchToSubMt 接口重载替换
                            //StopSwitchToSubMt(byLoop, MODE_AUDIO, SWITCH_MODE_SELECT, FALSE);                            
                            atDstMt[byDstMtNum] = m_ptMtTable->GetMt(byLoop);
							byDstMtNum ++;

							ChangeSatDConfMtRcvAddr(byLoop, LOGCHL_AUDIO);
                        }
                    }
                }
            }

			if (byDstMtNum > 0)
			{
				StopSwitchToSubMt(byDstMtNum, atDstMt, MODE_AUDIO, FALSE);
			}

            // xsl [9/21/2006] 通知一下终端状态, 解决有发言人情况下停止混音终端状态通知问题
           MtStatusChange(NULL, TRUE);*/ 
        }
        //else
        {
            //开始向各终端交换
            if (!m_tConf.m_tStatus.IsMixing())
            {
				//zjl20101028 原来在ChangeVidBrdSrc中调用，如此切换视频广播源时视频和音频到适配器的交换绑定，导致单视频会议轮询音频有问题
				// 2011-8-25 add by pgf: 增加过滤条件，仅当音视频同源的时候，才给其建立唇音交换
				if ( tUnLocalNewSrc == GetVidBrdSrc() )
				{
					StartSwitchAud2Perieqp(tUnLocalNewSrc);		
				}

				//zjj20120627 非科达终端(外厂商或kdc的mcu)做发言人哑音处理
				if( bIsBrdSrcNoKedaAndDumb )
				{
					ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ChangeAudBrdSrc]:AudBrdSrc.%d is dumb\n",
								GetLocalAudBrdSrc().GetMtId() );
					TMt tDstMt = GetLocalAudBrdSrc();
					if( m_ptMtTable->GetMtType(tDstMt.GetMtId()) == MT_TYPE_SMCU )
					{
						StopSwitchToSubMt(1, &tDstMt, MODE_AUDIO, FALSE);		
					}								
				}
				else
				{
					StartSwitchToAllSubMtJoinedConf(tUnLocalNewSrc, bySrcChnnl,wSpyStartPort);
				}
            }
        }
	}

	// [pengjie 2010/9/29] 会议录像无广播源时跳过该段录像支持
	if( !m_tConf.m_tStatus.IsNoRecording() )
	{
		AdjustConfRecByBrdSrc();
	}
    // End	

	return;
}

/*=============================================================================
函 数 名： IsSpeakerCanBrdVid
功    能： 
算法实现： 
全局变量： 
参    数： void
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2008/3/5   4.0		周广程                  创建
=============================================================================*/
BOOL32 CMcuVcInst::IsSpeakerCanBrdVid( const TMt* ptNewSpeaker/* = NULL*/ )
{
	//改变视频交换, 强制广播时不改变画面合成比发言人优先级高的策略
	if ( g_cMcuVcApp.IsBrdstVMP(m_tVmpEqp) )
	{
		return FALSE;
	}

	if ( !m_tConf.m_tStatus.IsNoPlaying() && !m_tConf.m_tStatus.IsPlayPause() )
	{
		// [8/5/2011 liuxu] 录像机放像从暂停状态切换为播放状态时, 可以广播码流
		if ( !ptNewSpeaker || !IsRecEqp(*ptNewSpeaker) )
		{
			return FALSE;
		}		
	}

	if ( CONF_POLLMODE_VIDEO == m_tConf.m_tStatus.GetPollMode() )
	{
		return FALSE;
	}

	// KDV-BUG2004: 点名人或被点名人被强制为发言人，而在MTC上终端状态未改变
	// 对于由于点名造成的发言人变化，且是VMP合成模式，则不允许发言人广播视频，
	// 目的是为了减少建广播交换的码流开销
	// zgc, 2008-05-21, 					
	if ( ROLLCALL_MODE_VMP == m_tConf.m_tStatus.GetRollCallMode() )
	{
		return FALSE;
	}

	return TRUE;
}

/*=============================================================================
函 数 名： IsSpeakerCanBrdAud
功    能： 
算法实现： 
全局变量： 
参    数： void
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2008/3/5   4.0		周广程                  创建
=============================================================================*/
BOOL32 CMcuVcInst::IsSpeakerCanBrdAud( const TMt* ptNewSpeaker/* = NULL*/ )
{
	if (VCS_CONF == m_tConf.GetConfSource() &&
		!m_tMixEqp.IsNull())
	{
		TPeriEqpStatus tPeriEqpStatus;
		g_cMcuVcApp.GetPeriEqpStatus( m_tMixEqp.GetEqpId(), &tPeriEqpStatus );
		u8  byState = tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState;
		if (TMixerGrpStatus::WAIT_START_SPECMIX == byState ||
			TMixerGrpStatus::WAIT_START_AUTOMIX == byState)
		{
			return FALSE;
		}
	}

	if ( !m_tConf.m_tStatus.IsNoMixing() 
		&& !m_tConf.m_tStatus.IsMustSeeSpeaker() )
	{
		return FALSE;
	}

	if ( !m_tConf.m_tStatus.IsNoPlaying() && !m_tConf.m_tStatus.IsPlayPause() )
	{
		// [8/5/2011 liuxu] 录像机放像从暂停状态切换为播放状态时, 可以广播码流
		if ( !ptNewSpeaker || !IsRecEqp(*ptNewSpeaker) )
		{
			return FALSE;
		}
	}

	// KDV-BUG2004: 点名人或被点名人被强制为发言人，而在MTC上终端状态未改变
	// zgc, 2008-05-21, 对于由于点名造成的发言人变化，不允许发言人广播音频
	// 因为点名操作里是必然要开混音器混音的
	if ( ROLLCALL_MODE_NONE != m_tConf.m_tStatus.GetRollCallMode() )
	{
		return FALSE;
	}

	return TRUE;
}


/*=============================================================================
函 数 名： ChangeSpeakerSrc
功    能： 
算法实现： 
全局变量： 
参    数：  u8 byMode
           emChangeSpeakerSrcReason emReason
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2008/4/12   4.0			周广程                  创建
2011/07/06  4.6         彭国锋                修改
=============================================================================*/
void CMcuVcInst::ChangeSpeakerSrc( u8 byMode, emChangeSpeakerSrcReason emReason, u16 wSpyStartPort )
{
	// 2011/07/06 modify by peng guofeng 
	// 移到此处，减少计算次数
	if ( byMode == MODE_BOTH )
	{
		ChangeSpeakerSrc( MODE_AUDIO, emReason );
		ChangeSpeakerSrc( MODE_VIDEO, emReason );
		return;
	}
	// 2011/07/06 modify end

	if ( !HasJoinedSpeaker() || m_tConf.GetSpeaker().GetType() == TYPE_MCUPERI )
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ChangeSpeakerSrc] No speaker or speaker is perieqp.\n" );
		if(	MODE_VIDEO == byMode && emReasonChangeBrdSrc == emReason && 
			GetLocalVidBrdSrc().GetType() == TYPE_MT )
		{
			TMt tMt = m_ptMtTable->GetMt( GetLocalVidBrdSrc().GetMtId() );
			m_ptMtTable->SetMtSrc( GetLocalVidBrdSrc().GetMtId(),&tMt,MODE_VIDEO );
		}
		return;
	}

	if ( emReason == emReasonUnkown )
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[ChangeSpeakerSrc] Change reason is unkown!\n" );
		return;
	}
	
	TMt tLocalSpeaker = GetLocalMtFromOtherMcuMt( m_tConf.GetSpeaker() );
	TMt tLocalChairman = GetLocalMtFromOtherMcuMt( m_tConf.GetChairman() ); 
	TMt tLocalLastSpeaker = GetLocalMtFromOtherMcuMt( m_tLastSpeaker ); 
	
	u8 bySelMode = m_tConf.GetConfAttrb().GetSpeakerSrcMode();
	u8 byTempMode = MODE_NONE;
	
	if ( byMode == MODE_VIDEO && (bySelMode == MODE_BOTH || bySelMode == MODE_VIDEO) )
	{
		byTempMode = MODE_VIDEO;
	}
	if ( byMode == MODE_AUDIO && bySelMode == MODE_BOTH )
	{
		byTempMode = MODE_AUDIO;
	}

	if ( byTempMode == MODE_NONE && emReason != emReasonChangeBrdSrc )
	{
		return;
	}
	
	u8 bySpeakerSrcType = m_tConf.GetConfAttrb().GetSpeakerSrc();

	if ( (bySpeakerSrcType == CONF_SPEAKERSRC_LAST && emReason == emReasonChangeChairman) ||
		(bySpeakerSrcType == CONF_SPEAKERSRC_SELF && emReason != emReasonChangeBrdSrc) ||
		( m_tConf.m_tStatus.IsMixing() && byMode == MODE_AUDIO && emReason != emReasonChangeBrdSrc ) )
	{
		//发言人选看上一次发言人模式下，主席发生change不需要进行调整;
		//发言人看自己且不是广播源变化引起的，不需要进行调整;
		//会议在混音时，音频交换不需要调整，广播源变化除外;
		return;
	}
	

	BOOL32 bRet = TRUE;

	// 获得发言人当前源的情况
	TMtStatus tStatus;
	m_ptMtTable->GetMtStatus( tLocalSpeaker.GetMtId(), &tStatus );

	//zjj20120920 主席做发言人选看，主席选看优先级高，不用调整
	if( !m_tConf.GetChairman().IsNull() && m_tConf.GetChairman().GetMtId() == tLocalSpeaker.GetMtId() &&
		!tStatus.GetSelectMt(byMode).IsNull() )
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ChangeSpeakerSrc] Speaker(Mt.%d) is chariman and has selectmt(mode.%d).not adjust\n", 
					tLocalSpeaker.GetMtId(), byMode );
		return;
	}

	//zhouyiliang 20121102 点名人模式或者被点名人模式,vmp先开启再点名
	//要先停vmp，但是等到notify来后会changevidbrdsrc
	//changevidbrdsrc会调用ChangeSpeakerSrc，导致当前发言人选看失效
	if ( byMode == MODE_VIDEO && !tStatus.GetSelectMt(byMode).IsNull() &&
			( m_tConf.m_tStatus.GetRollCallMode() == ROLLCALL_MODE_CALLER || m_tConf.m_tStatus.GetRollCallMode() == ROLLCALL_MODE_CALLEE )
		)
	{
		
		ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"[ChangeSpeakerSrc]Rollcaller mode or Rollcallee mode,speaker already has selectedmt!\n");
		return;
	}


	TMt tOldSrc;
//	u8 byOldSrcChn = 0;
	u8 bySpeakerSrcSpecType = SPEAKER_SRC_NOTSEL;
	BOOL32 bIsSel = FALSE;

	m_ptMtTable->GetMtSrc( tLocalSpeaker.GetMtId(), &tOldSrc, byMode );
	//byOldSrcChn = ( tOldSrc == m_tPlayEqp ) ? m_byPlayChnnl : 0;
	bySpeakerSrcSpecType = GetSpeakerSrcSpecType( byMode );
	if ( !tOldSrc.IsNull() && !(tOldSrc == tLocalLastSpeaker) && 
		(tStatus.GetSelByMcsDragMode() == MODE_BOTH ||
		 tStatus.GetSelByMcsDragMode() == byMode /* ||
		 // [pengjie 2010/4/12] 主席选看画面合成应该也算是选看吧？<yhz搞不明白这段逻辑为什么>
		 (IsVmpSeeByChairman() && HasJoinedChairman())*/) )
	{
		bIsSel = TRUE;
	}

	// 选看，但标志位未置，说明选看时不是发言人，这里需要设置正确的标志
	if ( bIsSel && bySpeakerSrcSpecType == SPEAKER_SRC_NOTSEL )
	{
		SetSpeakerSrcSpecType( byMode, SPEAKER_SRC_MCSDRAGSEL );
		bySpeakerSrcSpecType = GetSpeakerSrcSpecType( byMode );
	}

	// 由广播源变化引起的调整
	BOOL32 bCancelBrdSrc = TRUE;
	if ( emReason == emReasonChangeBrdSrc && 
		(( byMode == MODE_AUDIO && !IsAudBrdSrcNull() ) ||
		 ( byMode == MODE_VIDEO && !IsVidBrdSrcNull() )) )
	{
		bCancelBrdSrc = FALSE;

		u8 byBrdSrcChn = 0;
		TMt tBrdSrc;

		if ( byMode == MODE_AUDIO)
		{
			tBrdSrc = GetLocalAudBrdSrc();
		}
		else
		{
			tBrdSrc = GetLocalVidBrdSrc();
		}
		// 广播源不是发言人，建从广播源到发言人的广播交换
		//[nizhijun 2012/05/11]如果当前发言人的源就是广播源就不需要重新建交换
		TMt tSpeakerSrc;
		m_ptMtTable->GetMtSrc(tLocalSpeaker.GetMtId(), &tSpeakerSrc, byMode);
		if ( !(tSpeakerSrc == tBrdSrc) && !(tBrdSrc == tLocalSpeaker) )
		{				
			byBrdSrcChn = ( tBrdSrc == m_tPlayEqp ) ? m_byPlayChnnl : 0;

			if ( byMode == MODE_VIDEO )
			{
				// 2011-9-13 add by pgf:老VMP判断辅格式
				// 如果本地发言人的接收通道和会议的辅格式一致，那么老VMP就把第1通道的交换打给发言人(否则打第0通道)
				u8 bySpeakerId = tLocalSpeaker.GetMtId();
				TLogicalChannel tSpeakerChnnl;
				m_ptMtTable->GetMtLogicChnnl(bySpeakerId, LOGCHL_VIDEO, &tSpeakerChnnl, TRUE);

				if ( tBrdSrc == m_tVmpEqp && GetVmpSubType(m_tVmpEqp.GetEqpId()) == VMP
					&& m_tConf.GetSecVideoMediaType() != MEDIA_TYPE_NULL
					&& m_tConf.GetSecVideoMediaType() == tSpeakerChnnl.GetChannelType())
				{
					bRet = StartSwitchFromBrd(m_tVmpEqp, 1, 1, &tLocalSpeaker);
				}
				else
				{
					bRet = StartSwitchFromBrd( tBrdSrc, byBrdSrcChn, 1, &tLocalSpeaker );
				}
			}
			else
			{
				//zjl 20110510 StartSwitchToAll 替换 StartSwitchToSubMt
				//bRet = StartSwitchToSubMt( tBrdSrc, byBrdSrcChn, tLocalSpeaker.GetMtId(), MODE_AUDIO );
				TSwitchGrp tSwitchGrp;
				tSwitchGrp.SetSrcChnl(byBrdSrcChn);
				tSwitchGrp.SetDstMtNum(1);
				tSwitchGrp.SetDstMt(&tLocalSpeaker);			
				bRet = StartSwitchToAll(tBrdSrc, 1, &tSwitchGrp, MODE_AUDIO);
			}
			if ( bRet )
			{
				SetSpeakerSrcSpecType( byMode, SPEAKER_SRC_NOTSEL );
				return;
			}
			ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[ChangeSpeakerSrc] Speaker(Mt.%d) receive broarcastsrc(id.%d)(mode.%d) failed.\n", 
					tLocalSpeaker.GetMtId(), tBrdSrc.GetMtId(), byMode );
		}
	}
	//20130116只有当前广播源是当前发言人的时候模板选的发言人看主席，看老发言人才生效
	BOOL32 bBrdSrcIsSpeaker = FALSE; //当前广播源是否当前发言人,
	if ( byTempMode == MODE_VIDEO  && GetVidBrdSrc() == m_tConf.GetSpeaker())
	{
		bBrdSrcIsSpeaker = TRUE;					
	}
	
	if ( byTempMode == MODE_AUDIO  && GetAudBrdSrc() == m_tConf.GetSpeaker())
	{
		bBrdSrcIsSpeaker = TRUE;					
	}
	//广播源编码引起的changespeakersrc且当前广播源不是发言人自己，有选看先停掉选看
	if ( !bBrdSrcIsSpeaker && emReason == emReasonChangeBrdSrc )
	{
		if( m_tConf.GetSpeaker().IsLocal() )
		{
			TMt tSelMt = tStatus.GetSelectMt( byTempMode );	
			if( !tSelMt.IsNull()  )
			{
				//当前广播源就是当前发言人时需要restore，否则不需要（可能出现闪下自己）
				StopSelectSrc( tLocalSpeaker,byTempMode,FALSE,FALSE );
			}
		}
	}

	// 发言人选看主席的模式
	if(bBrdSrcIsSpeaker && bySpeakerSrcType == CONF_SPEAKERSRC_CHAIR 	&& byTempMode != MODE_NONE &&
		HasJoinedChairman() && !(tLocalSpeaker == tLocalChairman) )
	{
	
		// 如果原来发言人选看码流源就是当前的主席终端，则不必重新选看
		if ( !tOldSrc.IsNull() && bIsSel && tOldSrc == tLocalChairman )
		{
			return;
		}
		//zjj20100414 现在只考虑发言人是本地终端
		if( m_tConf.GetSpeaker().IsLocal() )
		{
			TMt tSelMt = tStatus.GetSelectMt( byTempMode );
			if( !tSelMt.IsNull() && !( tSelMt == m_tConf.GetChairman() ) )
			{
				StopSelectSrc( tLocalSpeaker,byTempMode,FALSE,FALSE );
			}
		}                                       
		
		if( // 选看不成要恢复，防止死屏 或 重置了广播通道，在下面恢复
			ChangeSelectSrc( m_tConf.GetChairman(), tLocalSpeaker, byTempMode ) )//有主席看主席
		{
			SetSpeakerSrcSpecType( byTempMode, SPEAKER_SRC_CONFSEL );
			return;				
		}
		ConfPrint( LOG_LVL_WARNING, MID_MCU_CONF, "[ChangeSpeakerSrc] Speaker(Mt.%d) select chairman(mt.%d)(mode.%d) failed.\n",
					tLocalSpeaker.GetMtId(), tLocalChairman.GetMtId(), byTempMode );
		
	
	
	}
	
	// 发言人选看上一次发言人模式
	if ( bBrdSrcIsSpeaker && bySpeakerSrcType == CONF_SPEAKERSRC_LAST && byTempMode != MODE_NONE 
		&& !m_tLastSpeaker.IsNull() && !(tLocalSpeaker == tLocalLastSpeaker)
		)
	{
		// 如果原来发言人选看码流源就是上一次发言人，则不必重新选看
		if ( !tOldSrc.IsNull() && bIsSel && tOldSrc == tLocalLastSpeaker )
		{
			return;
		}
		
		//zjj20100414 现在只考虑发言人是本地终端
		if( m_tConf.GetSpeaker().IsLocal() )
		{
			TMt tSelMt = tStatus.GetSelectMt( byTempMode );
			if( !tSelMt.IsNull() && !( tSelMt == m_tLastSpeaker ) )
			{
				StopSelectSrc( tLocalSpeaker,byTempMode,FALSE,FALSE );
			}
		}
		
		//[2011/12/27/zhangli]如果是多回传，且上一个发言人不是本级的，发言人已经被FreeRecvSpy，不建交换
		if (!m_tLastSpeaker.IsLocal() && IsLocalAndSMcuSupMultSpy(m_tLastSpeaker.GetMcuIdx()))
		{
			ConfPrint( LOG_LVL_WARNING, MID_MCU_CONF, "[ChangeSpeakerSrc] last Speaker(%d,%d) isn't local, so new speaker(%d,%d) can't select lastspeaker\n",
				m_tLastSpeaker.GetMcuId(), m_tLastSpeaker.GetMtId(), 
				tLocalSpeaker.GetMcuId(), tLocalSpeaker.GetMtId());
		}
		else
		{
			//选看不成要恢复，防止死屏 或 重置了广播通道，在下面恢复
			if (ChangeSelectSrc( m_tLastSpeaker, tLocalSpeaker, byTempMode ))
			{
				SetSpeakerSrcSpecType( byTempMode, SPEAKER_SRC_CONFSEL );
				return;	
			}
			
			ConfPrint( LOG_LVL_WARNING, MID_MCU_CONF, "[ChangeSpeakerSrc] Speaker(Mt.%d) select lastspeaker(mt.%d)(mode.%d) failed.\n",
				tLocalSpeaker.GetMtId(), tLocalLastSpeaker.GetMtId(), byTempMode );
		}
		
	
	}

	// 发言人是主席,且在主席轮询中,不能停主席选看轮询
	BOOL32 bSpeakerIsChairmanInPoll = FALSE;
	if (HasJoinedChairman() && (tLocalChairman == tLocalSpeaker))
	{
		if (CONF_POLLMODE_BOTH_CHAIRMAN == m_tConf.m_tStatus.GetPollMode() ||
					CONF_POLLMODE_VIDEO_CHAIRMAN == m_tConf.m_tStatus.GetPollMode())
		{
			bSpeakerIsChairmanInPoll = TRUE;
		}
	}
	//zjj20100414 现在只考虑发言人是本地终端
	//发言人看自己的图像就要先停发言人选看
	if( bBrdSrcIsSpeaker && m_tConf.GetSpeaker().IsLocal() &&
		CONF_SPEAKERSRC_SELF == bySpeakerSrcType &&
		emReason == emReasonChangeBrdSrc &&
		byTempMode != MODE_NONE &&
		!bSpeakerIsChairmanInPoll && //主席选看轮询中,将主席拖为发言人,不能停主席选看
		!( IsVmpSeeByChairman() && HasJoinedChairman() && (tLocalChairman == tLocalSpeaker) ) 
		)
	{
		// [2011/09/16] zhangli 如果发言人是上级mcu，不停选看
		if (!m_tCascadeMMCU.IsNull() && m_tCascadeMMCU == m_tConf.GetSpeaker())
		{
			ConfPrint( LOG_LVL_DETAIL, MID_MCU_CONF, "[ChangeSpeakerSrc] speaker is MMCU,not stop switch!\n" );
		}
		else
		{

			TMt tSelMt = tStatus.GetSelectMt( byTempMode );
			if( !tSelMt.IsNull() && !( tSelMt == tLocalSpeaker ) )
			{
				u8 byRestore = bBrdSrcIsSpeaker;
				StopSelectSrc( tLocalSpeaker,byTempMode,byRestore,TRUE );
				if ( bBrdSrcIsSpeaker )
				{
					NotifyMtReceive(tLocalSpeaker, tLocalSpeaker.GetMtId());
					return;
				}
			
			}	

		}
	}	
	
	// 这里负责处理发言人看自己以及上面处理失败时的保护
	if ( !tOldSrc.IsNull() && bIsSel &&
		SPEAKER_SRC_MCSDRAGSEL == bySpeakerSrcSpecType )
	{
		// 如果是发言人看自己且不是由于广播源变化（不包括取消广播源）引起的调整，
		// 则在之前不会引起修改发言人源交换的操作，这里不需要重新选看
		// [pengjie 2010/4/12] 如果是主席选看画面合成，主席再发言，这时发言人源的交换也不动，还是看画面合成
		if ( bySpeakerSrcType != CONF_SPEAKERSRC_SELF || 
			( emReason == emReasonChangeBrdSrc && !bCancelBrdSrc && MODE_VIDEO == byMode  &&
			! bSpeakerIsChairmanInPoll && //主席选看轮询中,将主席拖为发言人,不能停主席选看
			!(IsVmpSeeByChairman() && HasJoinedChairman() && (tLocalChairman == tLocalSpeaker)) ) )
		{
			bRet = FALSE;
			if( bySpeakerSrcType != CONF_SPEAKERSRC_SELF )
			{			
				bRet = ChangeSelectSrc( tOldSrc, tLocalSpeaker, byMode );
			}
			if ( !bRet )
			{
				RestoreRcvMediaBrdSrc( tLocalSpeaker.GetMtId(), byMode,wSpyStartPort );
				SetSpeakerSrcSpecType( byMode, SPEAKER_SRC_NOTSEL );
			}
		}
	}
	else
	{
		StopSelectSrc( tLocalSpeaker, byMode, FALSE, FALSE);
		RestoreRcvMediaBrdSrc( tLocalSpeaker.GetMtId(), byMode,wSpyStartPort );
		SetSpeakerSrcSpecType( byMode, SPEAKER_SRC_NOTSEL );
	}	
}

/*=============================================================================
函 数 名： ChangeOldSpeakerSrc
功    能： 修改被取消的老发言人的源，必须在重设上一次发言人之前调用
算法实现： 
全局变量： 
参    数： u8 byMode
		   TMt tOldSpeaker
		   BOOL32 bIsHaveNewSpeaker 
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2008/4/15   4.0			周广程                  创建
2011/07/06  4.6         彭国锋                  修改
=============================================================================*/
void CMcuVcInst::ChangeOldSpeakerSrc( u8 byMode, TMt tOldSpeaker, BOOL32 bIsHaveNewSpeaker )
{
	// 2011/07/06 modify by peng guofeng 
	// 移到此处，减少计算次数
	if ( byMode == MODE_BOTH )
	{
		ChangeOldSpeakerSrc( MODE_AUDIO, tOldSpeaker, bIsHaveNewSpeaker );
		ChangeOldSpeakerSrc( MODE_VIDEO, tOldSpeaker, bIsHaveNewSpeaker );
		return;
	}
	// 2011/07/06 modify end

	if ( tOldSpeaker.IsNull() )
	{
		return;
	}


	TMtStatus tStatus;
	//zjj20120920 主席做发言人选看，主席选看优先级高，不用调整
	if( tOldSpeaker.IsLocal() && m_ptMtTable->GetMtStatus( tOldSpeaker.GetMtId(),&tStatus ) &&
		!m_tConf.GetChairman().IsNull() && m_tConf.GetChairman().GetMtId() == tOldSpeaker.GetMtId() &&
		!tStatus.GetSelectMt(byMode).IsNull() && GetSpeakerSrcSpecType( byMode ) != SPEAKER_SRC_CONFSEL )
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ChangeOldSpeakerSrc] OldSpeaker(Mt.%d) is chariman and has selectmt(mode.%d).not adjust\n", 
					tOldSpeaker.GetMtId(), byMode );
		return;
	}
	
	TMt tLocalOldSpeaker = GetLocalMtFromOtherMcuMt( tOldSpeaker );
	
	BOOL32 bIsJoinedMt = FALSE;
	if( tLocalOldSpeaker.GetType() == TYPE_MT && m_tConfAllMtInfo.MtJoinedConf( tLocalOldSpeaker.GetMtId() ) )
	{
		bIsJoinedMt = TRUE;
	}
	
	TMt tLocalChairman = GetLocalMtFromOtherMcuMt(m_tConf.GetChairman());
	TMt tLocalLastSpeaker = GetLocalMtFromOtherMcuMt(m_tLastSpeaker);
	// 停止向原发言人的交换
    if ( bIsJoinedMt /*&& !bIsHaveNewSpeaker*/ )  // 取消发言人 [ mqs 理解：单纯地撤销发言人！]
    {
		TMt tSrc;
        m_ptMtTable->GetMtSrc( tLocalOldSpeaker.GetMtId(), &tSrc, byMode);

		u8 bySpeakerSrcSpecType = GetSpeakerSrcSpecType( byMode );
		u8 bySpeakerSrc = m_tConf.GetConfAttrb().GetSpeakerSrc();
		u8 bySpeakerSrcMode = m_tConf.GetConfAttrb().GetSpeakerSrcMode();

		if ( !tSrc.IsNull() && bySpeakerSrcSpecType == SPEAKER_SRC_CONFSEL &&
			((tSrc == tLocalChairman && bySpeakerSrc == CONF_SPEAKERSRC_CHAIR) ||
			// 2011-12-2 mod by pgf: 因为下级成员可以作发言人，所以此处不能用本地化的发言人和选看源比较
			(tSrc == m_tLastSpeaker/*tLocalLastSpeaker*/ && bySpeakerSrc == CONF_SPEAKERSRC_LAST)) &&
			 ( byMode == MODE_VIDEO || (byMode == MODE_AUDIO && bySpeakerSrcMode == MODE_BOTH) ) )
		{
			// 2011-11-29 add by pgf:　停老发言人的选看源
			StopSelectSrc(tLocalOldSpeaker, byMode);

			if (m_ptMtTable->GetManuId( tLocalOldSpeaker.GetMtId() ) == MT_MANU_KDC)
			{
				//zjl 20110510 StopSwitchToSubMt 接口重载替换
				//StopSwitchToSubMt( tLocalOldSpeaker.GetMtId(), byMode, SWITCH_MODE_BROADCAST, TRUE);
				StopSwitchToSubMt(1, &tLocalOldSpeaker, byMode, TRUE);
			}
			else
			{
				//非kdc厂商回传自身视频, 节省带宽时，通知mt发送码流
				// 增加视频限制, zgc, 2008-04-25
				if(g_cMcuVcApp.IsSavingBandwidth() && byMode == MODE_VIDEO )
				{
					NotifyOtherMtSend( tLocalOldSpeaker.GetMtId(), TRUE );
				}     
				//zjl 20110510 StartSwitchToAll 替换 StartSwitchToSubMt
				//StartSwitchToSubMt( tLocalOldSpeaker, 0, tLocalOldSpeaker.GetMtId(), byMode, SWITCH_MODE_BROADCAST, TRUE);
				TSwitchGrp tSwitchGrp;
				tSwitchGrp.SetSrcChnl(0);
				tSwitchGrp.SetDstMtNum(1);
				tSwitchGrp.SetDstMt(&tLocalOldSpeaker);				
				StartSwitchToAll(tLocalOldSpeaker, 1, &tSwitchGrp, byMode, SWITCH_MODE_BROADCAST, TRUE);
			}	
		}
    }
	
	// 重建VMP或视频轮询到老发言人的视频交换
	if ( bIsJoinedMt && byMode == MODE_VIDEO )
	{
		memset( &tStatus,0,sizeof(tStatus) );
		m_ptMtTable->GetMtStatus( tLocalOldSpeaker.GetMtId(), &tStatus );
		//		BOOL32 bIsSelMode = ( tStatus.GetSelByMcsDragMode() == MODE_VIDEO || tStatus.GetSelByMcsDragMode() == MODE_BOTH );
		// [pengjie 2010/4/12] 主席选看画面合成应该也算上吧？
		BOOL32 bIsSelMode = FALSE;
		if( !tStatus.GetSelectMt(MODE_VIDEO).IsNull() ||
			(IsVmpSeeByChairman() && HasJoinedChairman() && tLocalChairman == tLocalOldSpeaker))
		{
			bIsSelMode = TRUE;
		}
		// 增加对选看方式的判断, zgc, 2008-04-25
		if ( !bIsSelMode || ( bIsSelMode && GetSpeakerSrcSpecType( byMode ) == SPEAKER_SRC_CONFSEL ) )
		{
			RestoreRcvMediaBrdSrc( tLocalOldSpeaker.GetMtId(), MODE_VIDEO );  
		}
	}

	// 恢复标志为无选看
	SetSpeakerSrcSpecType( byMode, SPEAKER_SRC_NOTSEL );
}
/*=============================================================================
函 数 名： GetSpeakerSrcSpecType
功    能： 会议发言人的源是否是由会议自动指定
算法实现： 
全局变量： 
参    数： u8 byMode
返 回 值： u8
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2008/4/14   4.0		周广程                  创建
=============================================================================*/
u8 CMcuVcInst::GetSpeakerSrcSpecType(u8 byMode)
{
	switch( byMode )
	{
	case MODE_VIDEO:
		return m_bySpeakerVidSrcSpecType;

	case MODE_AUDIO:
		return m_bySpeakerAudSrcSpecType;

	default:
		ConfPrint( LOG_LVL_WARNING, MID_MCU_CONF, "[GetSpeakerSrcSpecType] Mode(%d) is error,return NOTSEL!\n", byMode );
		break;
	}

	return SPEAKER_SRC_NOTSEL;
}

/*=============================================================================
函 数 名： SetSpeakerSrcSpecType
功    能： 
算法实现： 
全局变量： 
参    数： u8 byMode
           u8 bySpecType
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2008/4/14   4.0		周广程                  创建
=============================================================================*/
void CMcuVcInst::SetSpeakerSrcSpecType(u8 byMode, u8 bySpecType )
{
	switch( byMode )
	{
	case MODE_VIDEO:
		m_bySpeakerVidSrcSpecType = bySpecType;
		break;
	case MODE_AUDIO:
		m_bySpeakerAudSrcSpecType = bySpecType;
		break;
	case MODE_BOTH:
		m_bySpeakerVidSrcSpecType = bySpecType;
		m_bySpeakerAudSrcSpecType = bySpecType;
		break;
	default:

		ConfPrint( LOG_LVL_WARNING, MID_MCU_MCS, "[SetSpeakerSrcSpecType] Mode(%d) is error,set failed!\n", byMode );
		break;
	}
	return;
}

/*=============================================================================
函 数 名： AdjustOldSpeakerSwitch
功    能： 调整被取消的老发言人的交换
算法实现： 
全局变量： 
参    数：  TMt tOldSpeaker				: 老发言人，未经过GetLocal的调整
			BOOL32 bIsHaveNewSpeaker	: 是否有新发言人
返 回 值： void  
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2008/3/4   4.0		周广程                  创建
=============================================================================*/
void CMcuVcInst::AdjustOldSpeakerSwitch( TMt tOldSpeaker, BOOL32 bIsHaveNewSpeaker, BOOL32 bInSameSMcu ,const TMt& tNewSpeaker)
{

	if ( tOldSpeaker.IsNull() )
	{
		return;
	}

	CServMsg cServMsg;
	cServMsg.SetMsgBody( ( u8 * )&tOldSpeaker, sizeof( tOldSpeaker ) );
	cServMsg.SetNoSrc();

	if( tOldSpeaker.GetType() == TYPE_MT )     // mqs [07/01/2011] 发取消原发言人通知
	{
		if(tOldSpeaker.IsLocal())
		{
			SendMsgToMt( tOldSpeaker.GetMtId() , MCU_MT_CANCELSPEAKER_NOTIF,cServMsg );
		}
	}
	else if( tOldSpeaker.GetType() == TYPE_MCUPERI )
	{
		if (IsRecEqp(tOldSpeaker))
		{
			if ( !m_tConf.m_tStatus.IsNoPlaying())
			{
				if (!m_tConf.m_tStatus.IsPlayPause())
				{
					cServMsg.SetChnIndex( m_byPlayChnnl );	// xliang [8/19/2008] Chanel index一定要设
					
					SendMsgToEqp( tOldSpeaker.GetEqpId(), MCU_REC_STOPPLAY_REQ, cServMsg );
					m_tConf.m_tStatus.SetNoPlaying();
					ConfModeChange();
				}else
				{
				}
			}
		}
	}

    //pgf在老发言人从组播地址接收前停老发言人的组播发送，避免有组播地址收到自己的声音
    TMt tAudBrdSrc = GetLocalAudBrdSrc();
    if ( m_tConf.GetConfAttrb().IsSatDCastMode() &&
         tAudBrdSrc == tOldSpeaker)
    {
        g_cMpManager.StopDistrConfCast(tOldSpeaker, MODE_AUDIO);
    }

	// 老发言人的码流源重整逻辑, zgc, 2008-04-15
	ChangeOldSpeakerSrc( MODE_BOTH, tOldSpeaker, bIsHaveNewSpeaker );

	/*
	TMt tSpeakerSrc;
	// 停止向原发言人的交换
    if ( bIsJoinedMt && !bIsHaveNewSpeaker )  // 取消发言人
    {
        m_ptMtTable->GetMtSrc( tLocalOldSpeaker.GetMtId(), &tSpeakerSrc, MODE_VIDEO);
		
        if ((tSpeakerSrc == GetLocalMtFromOtherMcuMt(m_tConf.GetChairman()) && m_tConf.GetConfAttrb().GetSpeakerSrc() == CONF_SPEAKERSRC_CHAIR) || 
            ((tSpeakerSrc == GetLocalMtFromOtherMcuMt(m_tLastSpeaker)) && m_tConf.GetConfAttrb().GetSpeakerSrc() == CONF_SPEAKERSRC_LAST))
        {				
			if (m_ptMtTable->GetManuId( tLocalOldSpeaker.GetMtId() ) == MT_MANU_KDC)
			{
				StopSwitchToSubMt( tLocalOldSpeaker.GetMtId(), MODE_VIDEO, SWITCH_MODE_BROADCAST, TRUE);
			}
			else
			{
				//非kdc厂商回传自身视频, 节省带宽时，通知mt发送码流
				if(g_cMcuVcApp.IsSavingBandwidth())
				{
					NotifyOtherMtSend( tLocalOldSpeaker.GetMtId(), TRUE );
				}     

				StartSwitchToSubMt( tLocalOldSpeaker, 0, tLocalOldSpeaker.GetMtId(), MODE_VIDEO, SWITCH_MODE_BROADCAST, TRUE);
			}	
        }
					
		// 增加对音频的处理, zgc, 2008-02-02
		m_ptMtTable->GetMtSrc( tLocalOldSpeaker.GetMtId(), &tSpeakerSrc, MODE_AUDIO );
		if ( ((tSpeakerSrc == GetLocalMtFromOtherMcuMt(m_tConf.GetChairman()) && m_tConf.GetConfAttrb().GetSpeakerSrc() == CONF_SPEAKERSRC_CHAIR) || 
            ((tSpeakerSrc == GetLocalMtFromOtherMcuMt(m_tLastSpeaker)) && m_tConf.GetConfAttrb().GetSpeakerSrc() == CONF_SPEAKERSRC_LAST))
			&& MODE_BOTH == m_tConf.GetConfAttrb().GetSpeakerSrcMode() )
        {
			if (m_ptMtTable->GetManuId( tLocalOldSpeaker.GetMtId()) == MT_MANU_KDC )
			{
				StopSwitchToSubMt( tLocalOldSpeaker.GetMtId(), MODE_AUDIO, SWITCH_MODE_BROADCAST, TRUE );
			}
			else
			{
				//非kdc厂商回传自身视频, 节省带宽时，通知mt发送码流
				if( g_cMcuVcApp.IsSavingBandwidth() )
				{
					NotifyOtherMtSend( tLocalOldSpeaker.GetMtId(), TRUE );
				}     
				
				StartSwitchToSubMt( tLocalOldSpeaker, 0, tLocalOldSpeaker.GetMtId(), MODE_AUDIO, SWITCH_MODE_BROADCAST, TRUE );
			}
		}
    }
	
	// 重建VMP或视频轮询到老发言人的视频交换, zgc, 2008-02-02
	if ( bIsJoinedMt )
	{
		// 新发言人码流源调整逻辑修改, zgc, 2008-04-12
		TMtStatus tStatus;
		m_ptMtTable->GetMtStatus( tLocalOldSpeaker.GetMtId(), &tStatus );
		BOOL32 bIsSelMode = ( tStatus.GetSelByMcsDragMode() == MODE_VIDEO || tStatus.GetSelByMcsDragMode() == MODE_BOTH );
		if ( !bIsSelMode )
		{
			RestoreRcvMediaBrdSrc( tLocalOldSpeaker.GetMtId(), MODE_VIDEO );  
		}
	}
	*/
	
// 2011-7-12 发言人代码重整 by peng guofeng
	//取消强制混音
/*	if( m_tConf.m_tStatus.IsMixing() )
	{
		
		
		//lukunpeng [05/19/2010]规格已经需要把取消的发言人从混音组中去除
		// 对于VCS会议需要将取消的发言人从混音组中去除
// 		if (VCS_CONF == m_tConf.GetConfSource() &&
// 			!(tOldSpeaker == m_tConf.GetChairman())
// 			|| (VCS_CONF != m_tConf.GetConfSource()))
		// [pengjie 2010/5/7] 上面的判断是否有问题？
		 if ( VCS_CONF == m_tConf.GetConfSource() )
		{

			 if( !(tOldSpeaker == m_tConf.GetChairman()) )
			 {
				BOOL32 bIsCanStopMixing = TRUE;
				//TMt tSMcu = GetLocalMtFromOtherMcuMt(tOldSpeaker);

				//zjj20091102 如果开启电视墙一键混音，而且老发言人在电视墙中，就不能退出混音
				if( m_cVCSConfStatus.GetMtInTvWallCanMixing() &&
						( !IsMtNotInOtherHduChnnl( tOldSpeaker,0,0) ||
						!IsMtNotInOtherTvWallChnnl( tOldSpeaker,0,0 )  
						)
					)
				{
					bIsCanStopMixing = FALSE;
				}

				if (tOldSpeaker.IsLocal())
				{
					if( bIsCanStopMixing)
					{
						// VCS即使混音参数为空也不自动停混音
						//lukunpeng 2010/05/21 vcs老发言人出混音要用强制
						RemoveSpecMixMember(&tOldSpeaker, 1, TRUE, FALSE); 
					}				
				}
				else
				{
					if( IsMtNotInOtherHduChnnl( tOldSpeaker,0,0) &&
							IsMtNotInOtherTvWallChnnl( tOldSpeaker,0,0 ) 
						)
					{
						BOOL32 bNotStopMixNoMem = (bIsHaveNewSpeaker && bInSameSMcu);
						RemoveSpecMixMember(&tOldSpeaker,1,TRUE,!bNotStopMixNoMem);
					}

					//zjj20090911 VCS会议停止对下级终端的调度时，将回传通道也剔除出混音成员组
					if ( VCS_CONF == m_tConf.GetConfSource() &&
						( m_cVCSConfStatus.GetCurVCMode() == VCS_GROUPTW_MODE ||
							m_cVCSConfStatus.GetCurVCMode() == VCS_GROUPSPEAK_MODE ) &&//&&m_cVCSConfStatus.GetCurVCMT().IsNull() 
							bIsCanStopMixing
						)
					{
						RemoveSpecMixMember(&tOldSpeaker, 1, TRUE, FALSE);

						ConfPrint(LOG_LVL_DETAIL, MID_MCU_VCS,  "[AdjustOldSpeakerSwitch] vcs Cancel smcu Adudio switch\n" );
					}
				}

			 }
		}    
		else
		{
//			m_tConfInStatus.SetLastSpeakerInMixing(FALSE);
			// [pengjie 2010/5/7] 将老发言人清除混音，如果发言人是自动进了混音的话

			if (tOldSpeaker.IsLocal())
			{
				if ( m_ptMtTable->GetMtType( tOldSpeaker.GetMtId()) == MT_TYPE_SMCU)
				{
					TConfMcInfo *ptMcInfo = NULL;
					ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(GetMcuIdxFromMcuId(tOldSpeaker.GetMtId()));
					if( NULL != ptMcInfo )
					{
						//20110104_tzy 如果该MCU下原来上传终端自动进的混音，则将该MCU下上传终端移出下级混音器
						if(ptMcInfo != NULL && !ptMcInfo->m_tMMcuViewMt.IsNull() && 
							m_ptConfOtherMcTable->IsMtInMixing(ptMcInfo->m_tMMcuViewMt) && ptMcInfo->GetMtAutoInMix(ptMcInfo->m_tMMcuViewMt)
							&& (tNewSpeaker.IsNull() || (!tNewSpeaker.IsNull() && !(tNewSpeaker == ptMcInfo->m_tMMcuViewMt))))
						{
							RemoveSpecMixMember( &ptMcInfo->m_tMMcuViewMt,1,FALSE,!bIsHaveNewSpeaker );
						}
					}
				} 
				else
				{
					if (m_ptMtTable->IsMtAutoInSpec(tOldSpeaker.GetMtId()))
					{
						RemoveSpecMixMember(&tOldSpeaker,  1, FALSE, !bIsHaveNewSpeaker );
						m_tConfInStatus.SetLastSpeakerInMixing(FALSE);
					}
				}
			} 
			else
			{
				if (m_ptConfOtherMcTable->IsMtInMixing(tOldSpeaker))
				{
					TConfMcInfo *ptMcInfo = NULL;
					ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tOldSpeaker.GetMcuId());
					if ( NULL != ptMcInfo && ptMcInfo->GetMtAutoInMix(tOldSpeaker))
					{
						RemoveSpecMixMember(&tOldSpeaker, 1, FALSE, !bIsHaveNewSpeaker );
						m_tConfInStatus.SetLastSpeakerInMixing(FALSE);
					}
				}
			}
		}  
		
		// xsl [8/4/2006] 取消强制混音
		RemoveMixMember(&tLocalOldSpeaker, TRUE);
	}
*/
	//TvWall
/*	TPeriEqpStatus tTWStatus;
    u8 byChnlIdx;
    u8 byEqpId;
    //TvWall
	for (byEqpId = TVWALLID_MIN; byEqpId <= TVWALLID_MAX; byEqpId++)
	{
		if (EQP_TYPE_TVWALL == g_cMcuVcApp.GetEqpType(byEqpId))
		{
			if (g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tTWStatus))
			{
				u8 byMemberType;
				u8 byMtConfIdx;
				for (byChnlIdx = 0; byChnlIdx < MAXNUM_PERIEQP_CHNNL; byChnlIdx++)
				{
					byMemberType = tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType;
					byMtConfIdx = tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].GetConfIdx();
					if (TW_MEMBERTYPE_SPEAKER == byMemberType && m_byConfIdx == byMtConfIdx)
					{
						ChangeTvWallSwitch(&tOldSpeaker, byEqpId, byChnlIdx, TW_MEMBERTYPE_SPEAKER, TW_STATE_STOP);
					}
				}
			}
		}
    }
    
	//Hdu
	TPeriEqpStatus tHduStatus;
    u8 byHduChnlIdx;
    u8 byHduEqpId;
	for (byHduEqpId = HDUID_MIN; byHduEqpId <= HDUID_MAX; byHduEqpId++)
	{
		if (EQP_TYPE_HDU == g_cMcuVcApp.GetEqpType(byHduEqpId)
			|| EQP_TYPE_HDU_H == g_cMcuVcApp.GetEqpType(byHduEqpId)
			|| EQP_TYPE_HDU_L == g_cMcuVcApp.GetEqpType(byHduEqpId))
		{

			u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byHduEqpId));
			if (0 == byHduChnNum)
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU, "[AdjustOldSpeakerSwitch] GetHduChnNumAcd2Eqp failed!\n");
				continue;
			}

			if (g_cMcuVcApp.GetPeriEqpStatus(byHduEqpId, &tHduStatus))
			{
				u8 byMemberType;
				u8 byMtConfIdx;
				for (byHduChnlIdx = 0; byHduChnlIdx < byHduChnNum; byHduChnlIdx++)
				{
					byMemberType = tHduStatus.m_tStatus.tHdu.atVideoMt[byHduChnlIdx].byMemberType;
					byMtConfIdx = tHduStatus.m_tStatus.tHdu.atVideoMt[byHduChnlIdx].GetConfIdx();
					if (TW_MEMBERTYPE_SPEAKER == byMemberType && m_byConfIdx == byMtConfIdx && bIsHaveNewSpeaker == FALSE)
					{
						ChangeHduSwitch(&tOldSpeaker, byHduEqpId, byHduChnlIdx, TW_MEMBERTYPE_SPEAKER, TW_STATE_STOP);
					}
				}
			}
		}
    }    
*/
// 2011-7-12 发言人代码重整 end

    // xliang [1/21/2009] 由最后移至此处
    m_tConf.SetNoSpeaker();
	if ( tOldSpeaker.GetType() == TYPE_MT )
	{
		m_tLastSpeaker = tOldSpeaker;
	}

// 2011-7-12 发言人代码重整 by peng guofeng
	// xliang [12/12/2008] 判断是否是vmp通道被抢占情况下的取消发言人
	//是，则降该MT的分辨率。兼容以前用老VMP的情况
// 	if ( ChgMtVidFormatRequired(tOldSpeaker, TRUE) )
// 	{
// 		TVMPParam	tVMPParam   = m_tConf.m_tStatus.GetVmpParam();
// 		ChangeMtVideoFormat(tOldSpeaker, &tVMPParam );
// 	}
// 2011-7-12 发言人代码重整 end
	
	// 2011-7-12 发言人代码重整:代码移到ChgMtVidFormatRequired函数里去
/*	if ( m_tConf.m_tStatus.GetVmpTwMode() != CONF_VMPTWMODE_NONE && 
		m_tConf.m_tStatus.GetVmpTwParam().IsMtInMember(tOldSpeaker) )
    {
        TVMPParam tVmpTwParam = m_tConf.m_tStatus.GetVmpTwParam();
        ChangeMtVideoFormat(tOldSpeaker, &tVmpTwParam);
    }
*/
	// 2011-7-12 发言人代码重整 end
	/*
	TPeriEqpStatus tPeriEqpStatus; 
	g_cMcuVcApp.GetPeriEqpStatus( m_tVmpEqp.GetEqpId(), &tPeriEqpStatus );
	u8 byVmpSubType = tPeriEqpStatus.m_tStatus.tVmp.m_bySubType;
	

	if ( m_tConf.m_tStatus.GetVMPMode() != CONF_VMPMODE_NONE &&	//会议在vmp中
		m_tConf.m_tStatus.GetVmpParam().IsMtInMember(tOldSpeaker))	//老发言人MT在vmp合成成员中
	{	
		TVMPParam	tVMPParam   = m_tConf.m_tStatus.GetVmpParam();
		u8	byChlPos	= tVMPParam.GetChlOfMtInMember(tOldSpeaker);
		if(byVmpSubType != VMP)//用的VMP是HD能力的VMP
		{
			if( tVMPParam.GetVmpMember(byChlPos)->GetMemberType() == VMP_MEMBERTYPE_SPEAKER ) //该通道正好是发言人跟随通道
			{
				//该情况会重新ChangeVMPParam, 之后全体来一次分辨率调整，所以这里就不进行单独调整了
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[adjustOldSpeakerSwitch] no need to change format for old Speaker Mt.%, \
					because the channel it occupied is【VMP_MEMBERTYPE_SPEAKER】.\n", tOldSpeaker.GetMtId());
			}
			else
			{
				// xliang [4/21/2009]  退出VMP高清前适配通道，调整分辨率 
				ChangeMtVideoFormat(tOldSpeaker, &tVMPParam );
			}
		}
		else
		{
			ChangeMtVideoFormat(tOldSpeaker, &tVMPParam);
		}
	}
	else if ( m_tConf.m_tStatus.GetVmpTwMode() != CONF_VMPTWMODE_NONE && 
		m_tConf.m_tStatus.GetVmpTwParam().IsMtInMember(tOldSpeaker) )
    {
        TVMPParam tVmpTwParam = m_tConf.m_tStatus.GetVmpTwParam();
        ChangeMtVideoFormat(tOldSpeaker, &tVmpTwParam);
    }
	*/
	// xliang [12/17/2008] 下面的改变vmp分辨率参数整合到上面
    // xsl [8/28/2006] 改变vmp分辨率参数
	//     if ( m_tConf.m_tStatus.GetVMPMode() != CONF_VMPMODE_NONE && 
	//          m_tConf.m_tStatus.GetVmpParam().IsMtInMember(tOldSpeaker) )
	//     {
	//         TVMPParam tVmpParam = m_tConf.m_tStatus.GetVmpParam();
	// 		ChangeMtVideoFormat(tOldSpeaker.GetMtId(), &tVmpParam);
	//     }
	//     else if ( m_tConf.m_tStatus.GetVmpTwMode() != CONF_VMPTWMODE_NONE && 
	//               m_tConf.m_tStatus.GetVmpTwParam().IsMtInMember(tOldSpeaker) )
	//     {
	//         TVMPParam tVmpTwParam = m_tConf.m_tStatus.GetVmpTwParam();
	//         ChangeMtVideoFormat(tOldSpeaker.GetMtId(), &tVmpTwParam);
	//     }

	LogPrint(MID_MCU_CONF,LOG_LVL_DETAIL,"[AdjustOldSpeakerSwitch] bInSameSMcu.%d tNewSpeaker.[%d,%d]\n",bInSameSMcu,tNewSpeaker.GetMcuId(),tNewSpeaker.GetMtId());

	return;
}

/*=============================================================================
函 数 名： AdjustNewSpeakerSwitch
功    能： 调整新指定的发言人的交换
算法实现： 
全局变量： 
参    数：  TMt tNewSpeaker		: 新指定的发言人，未经过GetLocal的调整
			u16 wOldSpeakerSpyPort: 原发言人的回传端口
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2008/3/4    4.0			周广程                  创建
2011/10/11  4.6         彭国锋                  去除参数bAddToVmp
=============================================================================*/
void CMcuVcInst::AdjustNewSpeakerSwitch( TMt tNewSpeaker, /*BOOL32 bAddToVmp, */u16 wOldSpeakerSpyPort )
{
	
	TMt tLocalNewSpeaker;
	tLocalNewSpeaker.SetNull();
	if ( !tNewSpeaker.IsNull() )
	{
		tLocalNewSpeaker = GetLocalMtFromOtherMcuMt( tNewSpeaker );
	}
	
	if ( !tNewSpeaker.IsNull() )  
	{
		if(	tNewSpeaker.GetType() == TYPE_MT && tNewSpeaker.IsLocal() )	// mqs [01/07/2011] 指定直连终端作为新发言人
		{
			CServMsg cServMsg;
			cServMsg.SetMsgBody( ( u8 * )&tLocalNewSpeaker, sizeof( TMt ) );
			cServMsg.SetNoSrc();
			SendMsgToMt( tLocalNewSpeaker.GetMtId(), MCU_MT_SPECSPEAKER_NOTIF,cServMsg );
		}		
		m_tConf.SetSpeaker( tNewSpeaker );
	}

	//改变视频交换, 强制广播时不改变画面合成比发言人优先级高的策略
	if ( IsSpeakerCanBrdVid( &tNewSpeaker )
		 /* || (m_tConf.m_tStatus.IsMustSeeSpeaker() &&
		 CONF_VMPMODE_NONE != m_tConf.m_tStatus.GetVMPMode())*/)
	{
		if ( !tNewSpeaker.IsNull() )
		{
			TMtStatus tMtStatus;
			GetMtStatus( tNewSpeaker,tMtStatus );
// 			if ( tLocalNewSpeaker.GetType() == TYPE_MT )
// 			{
// 				m_ptMtTable->GetMtStatus( tLocalNewSpeaker.GetMtId(), &tMtStatus );
// 			}
            //pgf新发言人不收组播码流，避免收到自己码流
            if ( m_tConf.GetConfAttrb().IsSatDCastMode() &&
                 IsMultiCastMt(tNewSpeaker.GetMtId()) &&
                 tMtStatus.GetSelectMt(MODE_VIDEO).IsNull())
            {
//                 ChangeSatDConfMtRcvAddr(tNewSpeaker.GetMtId(), MODE_VIDEO, FALSE);
				StopSwitchToSubMt(1, &tNewSpeaker, MODE_VIDEO, FALSE);
            }
			if ( tMtStatus.IsSendVideo() || TYPE_MCUPERI == tLocalNewSpeaker.GetType() )
			{
				// xliang [7/9/2009] （非发言人）主席选看VMP这里要停掉
// 				if(m_tConf.m_tStatus.GetVmpParam().IsVMPSeeByChairman() 
// 					&& !(m_tConf.GetChairman() == tLocalNewSpeaker)
// 					)
// 				{
// 					ConfLog(FALSE, "Chairman.%u stop watching VMP because other Mt's speaking!\n",
// 						m_tConf.GetChairman().GetMtId());
// 					m_tConf.m_tStatus.SetVmpSeebyChairman(FALSE);
// 
// 					// 状态同步刷新到TPeriStatus中
// 					TPeriEqpStatus tVmpStatus;
// 					g_cMcuVcApp.GetPeriEqpStatus( m_tVmpEqp.GetEqpId() , &tVmpStatus );
// 					tVmpStatus.m_tStatus.tVmp.m_tVMPParam = m_tConf.m_tStatus.GetVmpParam();
// 					g_cMcuVcApp.SetPeriEqpStatus( m_tVmpEqp.GetEqpId() , &tVmpStatus );
// 					
// 					// [12/25/2009 xliang] 通知主席终端
// 					CServMsg cServMsg;
// 					SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_STARTSWITCHVMPMT_NACK,cServMsg);
// 
// 					StopSelectSrc(m_tConf.GetChairman(), MODE_VIDEO);
// 				}
				ChangeVidBrdSrc( &tNewSpeaker,wOldSpeakerSpyPort );
			}
			else
			{
				ChangeVidBrdSrc(NULL,wOldSpeakerSpyPort);
			}
		}
		else
		{
			ChangeVidBrdSrc(NULL,wOldSpeakerSpyPort);			
		}
	}

	//改变语音交换
	if ( IsSpeakerCanBrdAud( &tNewSpeaker ) )
	{
		if ( !tNewSpeaker.IsNull() )
		{
			TMtStatus tMtStatus;
			GetMtStatus( tNewSpeaker,tMtStatus );
            //pgf如果新发言人不收组播码流，避免收到自己码流
            if ( m_tConf.GetConfAttrb().IsSatDCastMode() &&
                 IsMultiCastMt(tNewSpeaker.GetMtId()) &&
                 tMtStatus.GetSelectMt(MODE_AUDIO).IsNull())
            {
//                 ChangeSatDConfMtRcvAddr(tNewSpeaker.GetMtId(), MODE_AUDIO, FALSE);
				StopSwitchToSubMt(1, &tNewSpeaker, MODE_AUDIO, FALSE);
            }
// 			if ( tLocalNewSpeaker.GetType() == TYPE_MT )
// 			{
// 				m_ptMtTable->GetMtStatus( tLocalNewSpeaker.GetMtId(), &tMtStatus );
// 			}
			if ( tMtStatus.IsSendAudio() || TYPE_MCUPERI == tLocalNewSpeaker.GetType() )
			{
				ChangeAudBrdSrc( &tNewSpeaker,wOldSpeakerSpyPort );
			}
			else
			{
				ChangeAudBrdSrc(NULL,wOldSpeakerSpyPort);
			}
		}
		else
		{
			ChangeAudBrdSrc(NULL,wOldSpeakerSpyPort);
		}
	}

// 2011-7-12 发言人代码重整 by peng guofeng
/*	if ( !tNewSpeaker.IsNull() && tNewSpeaker.GetType() == TYPE_MT )
	{
		//指定混音时参加混音
		if( m_tConf.m_tStatus.IsSpecMixing() )
		{
 
			TLogicalChannel tLogicChan;
			if (m_ptMtTable->GetMtLogicChnnl(tLocalNewSpeaker.GetMtId(), LOGCHL_AUDIO, &tLogicChan, TRUE))
			{
				if (tNewSpeaker.IsLocal())
				{
					// 20110104_tzy 本地普通终端不在混音器中直接进混音器
					// 20110616_mqs 添加条件判断：在级联会议下级拖上级MCU为发言人时，上级MCU进下级混音器
					if (m_ptMtTable->GetMtType(tNewSpeaker.GetMtId()) == MT_TYPE_MT
						|| m_ptMtTable->GetMtType(tNewSpeaker.GetMtId()) == MT_TYPE_MMCU)
					{
						if (!m_ptMtTable->IsMtInMixing(tNewSpeaker.GetMtId()))
						{
							AddSpecMixMember( &tNewSpeaker, 1, m_ptMtTable->GetMtType(tNewSpeaker.GetMtId()) == MT_TYPE_MT);
						}
					}
					//20110104_tzy 本地非普通(下级MCU)终端则取出上传通道中终端直接加入下级混音器
					if (m_ptMtTable->GetMtType(tNewSpeaker.GetMtId()) == MT_TYPE_SMCU)
					{
						TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(GetMcuIdxFromMcuId(tNewSpeaker.GetMtId()));
						if( NULL != ptMcInfo )
						{
 							if (!ptMcInfo->m_tMMcuViewMt.IsNull())
							{
								AddSpecMixMember( &ptMcInfo->m_tMMcuViewMt, 1, ptMcInfo->GetMtAutoInMix(ptMcInfo->m_tMMcuViewMt));
							}
							else
							{
								AddSpecMixMember( &tLocalNewSpeaker, 1, TRUE);
							}
						}
					}
				} 
				else
				{
					//20110318_tzy Bug00049808在MCS上召开级联会议，下级开启定制混音，上级再开启定制混音，拖下级的终端为发言人，下级原有的混音未被冲掉
					//不应仅判断该下级终端是否在混音，如果下级开了小会，并且该终端也在混音，
					//此时上级托该终端为发言人时也要重新进下级混音器，并冲掉下级其他混音终端
					if (!m_ptMtTable->IsMtInMixing(tLocalNewSpeaker.GetMtId())
						|| 
						( m_ptMtTable->IsMtInMixing(tLocalNewSpeaker.GetMtId()) && !m_ptConfOtherMcTable->IsMtInMixing(tNewSpeaker)))
					{
						AddSpecMixMember( &tNewSpeaker, 1, TRUE);
					} 
				}
			}
		}
		// 新发言人码流源调整逻辑, zgc, 2008-04-12
        if ( !IsSpeakerCanBrdVid() )
        {
            ChangeSpeakerSrc( MODE_VIDEO, emReasonChangeSpeaker );
        }
        if ( !IsSpeakerCanBrdAud() )
        {
            ChangeSpeakerSrc( MODE_AUDIO, emReasonChangeSpeaker );
        }
	}
	
	//加入画面合成
	// xliang [3/13/2009] change either format or param
	if (m_tConf.m_tStatus.GetVMPMode() != CONF_VMPMODE_NONE && bAddToVmp)
	{
        // [pengjie 2010/3/31] 这里如果是下级终端，应该使用未被Local化得tmt信息tNewSpeaker
		//if ( IsChangeVmpParam(&tLocalNewSpeaker) )
		if ( IsChangeVmpParam(&tNewSpeaker) )
		{
			if (m_tConf.m_tStatus.GetVmpParam().IsTypeInMember(VMP_MEMBERTYPE_SPEAKER)	//不是发言人跟随，不需全局调整通道
				|| IsDynamicVmp()														//自动画面合成情况，全局调整通道
				|| ( m_tConf.m_tStatus.GetVmpParam().GetVMPSchemeId() != 0 
					&& ( m_tConf.m_tStatus.GetVmpParam().IsMtInMember(tNewSpeaker) || m_tConf.m_tStatus.GetVmpParam().IsMtInMember(m_tLastSpeaker) )
				   )		//对于配置了VMP方案的也要全局调整，以刷新memstatus.(eg：发言人要改边框色)
				) 
			{
				//全局调整
				if(!IsDynamicVmp() && !m_tConf.m_tStatus.GetVmpParam().IsTypeInMember(VMP_MEMBERTYPE_SPEAKER))
				{
					// [8/24/2010 xliang] 对于配置了VMP方案的全局调整
					TVMPParam tVMPParam = m_tConf.m_tStatus.GetVmpParam();
					AdjustVmpParam(&tVMPParam);
					//AdjustVmpParam(&m_tConf.m_tStatus.GetVmpParam());
				}
				//若某通道内有新发言人或旧发言人，则立即changeParam; 否则定时再去尝试
				//zhouyiliang 20100928 自动VMP时，对于新老发言人在合成成员中的保存形式，都用非local化的mt不再区分单回传和多回传
				else if( (!tNewSpeaker.IsNull() && m_tConf.m_tStatus.GetVmpParam().IsMtInMember( tNewSpeaker )) 
					|| (!m_tLastSpeaker.IsNull() && m_tConf.m_tStatus.GetVmpParam().IsMtInMember( m_tLastSpeaker ) )
					)
				{
					//ChangeVmpChannelParam(&tLocalNewSpeaker, VMP_MEMBERTYPE_SPEAKER, &m_tLastSpeaker );
					ChangeVmpChannelParam(&tNewSpeaker, VMP_MEMBERTYPE_SPEAKER, &m_tLastSpeaker );
				}
				else
				{
					SetTimer(MCUVC_CHANGE_VMPCHAN_SPEAKER_TIMER, TIMESPACE_CHANGEVMPPARAM, VMP_MEMBERTYPE_SPEAKER);
				}
			}
			else
			{
				if( !tNewSpeaker.IsNull() && m_tConf.m_tStatus.GetVmpParam().IsMtInMember( tNewSpeaker ) )
				{
					TVMPParam	tVMPParam   = m_tConf.m_tStatus.GetVmpParam(); 
					if(GetVmpSubType(m_tVmpEqp.GetEqpId()) == MPU_SVMP)//用的VMP是MPU
					{
						
						// xliang [4/21/2009] 调整分辨率，让new speaker 进VMP前适配通道
						
						//u8	byVmpStyle  = tVMPParam.GetVMPStyle();
						//u8	byChlPos	= tVMPParam.GetChlOfMtInMember(tLocalNewSpeaker);
						
						if( !m_tConf.m_tStatus.IsBrdstVMP() )
						{
							// xliang [3/27/2009] 把之前被选看的成员交换都冲掉，这个冲掉在较后面体现，
							//所以这里先整理下前适配通道的信息：
							//先释放掉被选看Mt占的VMP前适配通道，随后让speaker去占前适配通道
							u8 byHdChnnlNum = MAXNUM_SVMP_HDCHNNL;
// 							if( byVmpSubType == MPU_DVMP || byVmpSubType == EVPU_DVMP)
// 							{	
// 								byHdChnnlNum = MAXNUM_DVMP_HDCHNNL;
// 							}
							//u8 byHdChnnlNum = m_tVmpChnnlInfo.m_byHDChnnlNum;
							if (tNewSpeaker.IsLocal())
							{
								TChnnlMemberInfo tChnnlMemInfo;
								u8 byLoop;
								for(byLoop = 0; byLoop < byHdChnnlNum; byLoop ++)
								{
									m_tVmpChnnlInfo.GetHdChnnlInfo(byLoop,&tChnnlMemInfo);
									if( tChnnlMemInfo.IsAttrSelected() )
									{
										// xliang [4/8/2009] 【被冲特例】被选看的MT是被新发言人选看，
										//                    这种情况该被选看MT的VIP身份
										//                    将获得保留，其交换不会被冲
										TMtStatus tMtStatus;
										u8 byMode = MODE_VIDEO;
										m_ptMtTable->GetMtStatus(tNewSpeaker.GetMtId(),&tMtStatus);
										if (tChnnlMemInfo.GetMt() == tMtStatus.GetSelectMt( byMode ))
										{
											continue;
										}
										m_tVmpChnnlInfo.ClearOneChnnl(tChnnlMemInfo.GetMt()); 
										//调Mt分辨率的动作置后
										//u8 byPos = tVMPParam.GetChlOfMtInMember(tChnnlMemInfo.GetMt());
										//ChangeMtVideoFormat(tChnnlMemInfo.GetMtId(),byVmpSubType,byVmpStyle,byPos);
									}
								}
							}
							
							//发言人尝试占前VMP适配通道
							ChangeMtVideoFormat(tNewSpeaker, &tVMPParam);
						}
						
					}
					else	//老VMP直接恢复分辨率
					{
						ChangeMtVideoFormat(tNewSpeaker, &tVMPParam, FALSE);	
					}
				}
			}
		}
			
	}
		
	//加入多画面电视墙
	if (m_tConf.m_tStatus.GetVmpTwMode() != CONF_VMPTWMODE_NONE && bAddToVmp)
	{
		ChangeVmpTwChannelParam(&tNewSpeaker, VMPTW_MEMBERTYPE_SPEAKER);
		
		// xsl [8/28/2006] 恢复画面合成分辨率
		if ( m_tConf.m_tStatus.GetVmpParam().IsMtInMember(tNewSpeaker) )
		{
			TVMPParam tVmpTwParam = m_tConf.m_tStatus.GetVmpTwParam();
			ChangeMtVideoFormat(tNewSpeaker, &tVmpTwParam, FALSE);
		}
	}
	
	//强制加入混音
	if( !tNewSpeaker.IsNull() && m_tConf.m_tStatus.IsMixing() )
	{
		AddMixMember( &tLocalNewSpeaker, DEFAULT_MIXER_VOLUME, TRUE );
	}
	
	//　TvWall　发言人跟随时，同步调整电视墙中的图像
	TPeriEqpStatus tTWStatus;
	u8 byChnlIdx;
	u8 byEqpId;
	for (byEqpId = TVWALLID_MIN; byEqpId <= TVWALLID_MAX; byEqpId++)
	{
		if (EQP_TYPE_TVWALL == g_cMcuVcApp.GetEqpType(byEqpId))
		{
			if (g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tTWStatus))
			{
				u8 byMemberType;
				u8 byMtConfIdx;
				for (byChnlIdx = 0; byChnlIdx < MAXNUM_PERIEQP_CHNNL; byChnlIdx++)
				{
					byMemberType = tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType;
					byMtConfIdx = tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].GetConfIdx();
					if (TW_MEMBERTYPE_SPEAKER == byMemberType && m_byConfIdx == byMtConfIdx)
					{
						//zjl[03/01/2010] 发言人跟随，指定下级终端为发言人时，需要级联调分辨率，所以所传源端必须是非local
						ChangeTvWallSwitch(&tNewSpeaker, byEqpId, byChnlIdx, TW_MEMBERTYPE_SPEAKER, TW_STATE_CHANGE);
					}
				}
			}
		}
	}

	//发言人跟随时，同步调整HDU中的图像
	TPeriEqpStatus tHduStatus;
	u8 byHduChnlIdx;
	u8 byHduEqpId;
	
	// [12/29/2010 liuxu][走读]这些判断应该放在hdu里
	for (byHduEqpId = HDUID_MIN; byHduEqpId <= HDUID_MAX; byHduEqpId++)
	{
		if (EQP_TYPE_HDU == g_cMcuVcApp.GetEqpType(byHduEqpId)
			|| EQP_TYPE_HDU_H == g_cMcuVcApp.GetEqpType(byHduEqpId)
			|| EQP_TYPE_HDU_L == g_cMcuVcApp.GetEqpType(byHduEqpId))
		{
			u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byHduEqpId));
			if (0 == byHduChnNum)
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU,  "[AdjustNewSpeakerSwitch] GetHduChnNumAcd2Eqp failed!\n");
				continue;
			}

			if (g_cMcuVcApp.GetPeriEqpStatus(byHduEqpId, &tHduStatus))
			{
				u8 byMemberType;
				u8 byMtConfIdx;
				for (byHduChnlIdx = 0; byHduChnlIdx < byHduChnNum; byHduChnlIdx++)
				{
					byMemberType = tHduStatus.m_tStatus.tHdu.atVideoMt[byHduChnlIdx].byMemberType;
					byMtConfIdx = tHduStatus.m_tStatus.tHdu.atVideoMt[byHduChnlIdx].GetConfIdx();
					if (TW_MEMBERTYPE_SPEAKER == byMemberType && m_byConfIdx == byMtConfIdx && !tNewSpeaker.IsNull())
					{
						ChangeHduSwitch(&tNewSpeaker, byHduEqpId, byHduChnlIdx, TW_MEMBERTYPE_SPEAKER, TW_STATE_CHANGE);
					}
				}
			}
		}
	}
*/
// 2011-7-12 发言人代码重整 end
	// 新发言人码流源调整逻辑, zgc, 2008-04-12
    if ( !IsSpeakerCanBrdVid( &tNewSpeaker ) )
    {
        ChangeSpeakerSrc( MODE_VIDEO, emReasonChangeSpeaker );
    }
    if ( !IsSpeakerCanBrdAud( &tNewSpeaker) )
    {
        ChangeSpeakerSrc( MODE_AUDIO, emReasonChangeSpeaker );
    }

// 2011-7-12 发言人代码优化 by peng guofeng
	// [2/28/2011 xliang] vmp时，会议是发言人选看主席模式，需要对主席额外处理（raise to vip/fall to civilian）
	// 这一部分处理要等到ChangeSpeakerSrc之后做
/*	if( CONF_VMPTWMODE_NONE != m_tConf.m_tStatus.GetVMPMode() 
		&& ( MPU_SVMP ==  GetVmpSubType(m_tVmpEqp.GetEqpId()) )
		&& CONF_SPEAKERSRC_CHAIR == m_tConf.GetConfAttrb().GetSpeakerSrc() 
		&& HasJoinedChairman() 
		&& ( tNewSpeaker.IsNull()							//发言人被取消了... fall to civilian
			|| !(tNewSpeaker == m_tConf.GetChairman()) )	//有新发言人且发言人和主席不相同...raise to vip
		)
	{
		TVMPParam tVmpParam = m_tConf.m_tStatus.GetVmpParam();
		ChangeMtVideoFormat(m_tConf.GetChairman(), &tVmpParam, FALSE, FALSE);
	}
*/
// 2011-7-12 发言人代码优化end

	return;
}

/*====================================================================
    函数名      ：ChangeSpeaker
    功能        ：改变发言人（包括单纯撤销）；
	              通知MC，MT
				  如果新、旧发言人直连，通知其自身改变状态
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt * ptNewSpeaker, 新发言人，NULL表示单纯撤销。这个TMt要求是真正的终端，不要GetLocal过
				  BOOL32 bPolling, 是否是Polling导致的发言人改变                  
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/01/04    1.0         LI Yi         创建
	03/11/25    3.0         胡昌威        修改
	05/1/27     3.6         Jason        修改
	11/07/06    4.6         彭国锋        修改
====================================================================*/
//fix 该接口输入参数是否冗余?CServMsg *pServMsg参数传入意义?
//参数多余，已经删除　by peng guofeng
void CMcuVcInst::ChangeSpeaker( TMt * ptNewSpeaker, BOOL32 bPolling, BOOL32 bAddToVmp,BOOL32 bNeedPreSetin, BOOL32 bIsRecPlayChange/* = FALSE*/)
{
	//非放像切发言人，才需要考虑优先级
	//放像机优先级最高，如果正在放像，不能切换发言人,目前只针对MCS会议进行过滤
	if ( !bIsRecPlayChange ) 
	{
		if( m_tConf.GetConfSource() == MCS_CONF &&
			(m_tConf.m_tStatus.IsPlaying() || m_tConf.m_tStatus.IsPlayReady()) &&
			ptNewSpeaker != NULL && !ptNewSpeaker->IsNull())
		{
			ConfPrint( LOG_LVL_WARNING, MID_MCU_CONF, "[ChangeSpeaker]Conf(%s) playing now!So Can't ChangeSpeaker(%d,%d)!\n", 
				m_tConf.GetConfName(),ptNewSpeaker->GetMcuIdx(),ptNewSpeaker->GetMtId());
			if (!bNeedPreSetin)
			{
				FreeRecvSpy(*ptNewSpeaker,MODE_BOTH);
			}
			return;
		}
	}
	TMt  tOldSpeaker = m_tConf.GetSpeaker();

	// pengjie[10/16/2009] 级联多回传，添加Presetin
	// lukunpeng 2010/06/07 由此建立新发言人的回传
	if( bNeedPreSetin 
		&& NULL != ptNewSpeaker 
		&& !ptNewSpeaker->IsLocal()
		&& IsLocalAndSMcuSupMultSpy(ptNewSpeaker->GetMcuId()))
	{
		TPreSetInReq tPreSetInReq;
		tPreSetInReq.m_tSpyMtInfo.SetSpyMt( *ptNewSpeaker );
		tPreSetInReq.m_bySpyMode = MODE_BOTH;
		TMtStatus tSpeakerStatus;
		if (GetMtStatus(*ptNewSpeaker,tSpeakerStatus))
		{
			//没音频减掉音频
			if (!tSpeakerStatus.IsSendAudio())
			{
				tPreSetInReq.m_bySpyMode &= MODE_VIDEO;
			}

			//没视频减掉视频
			if (!tSpeakerStatus.IsSendVideo())
			{
				tPreSetInReq.m_bySpyMode &= MODE_AUDIO;
			}
		}
		

		// [pengjie 2010/9/13] 获取当前业务要求的回传能力集
		TSimCapSet tReqSpyCap = GetMtSimCapSetByMode( GetFstMcuIdFromMcuIdx(ptNewSpeaker->GetMcuId()) );	
		//zjl20101116 如果当前终端已回传则能力集要与已回传目的能力集取小
	    
		if(!GetMinSpyDstCapSet(*ptNewSpeaker, tReqSpyCap))
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_SPY, "[ChangeSpeaker] Get Mt(mcuid.%d, mtid.%d) SimCapSet Failed !\n",
				ptNewSpeaker->GetMcuId(), ptNewSpeaker->GetMtId() );
			return;
		}

		tPreSetInReq.m_tSpyMtInfo.SetSimCapset( tReqSpyCap );
		// End

		//如果不是命令引起的改变发言人，先改为MCS_MCU_SPECSPEAKER_REQ，不影响正常使用
		tPreSetInReq.SetEvId(MCS_MCU_SPECSPEAKER_REQ);
		//tPreSetInReq.m_dwEvId = MCS_MCU_SPECSPEAKER_REQ;

		if( !tOldSpeaker.IsNull() )
		{			
			tPreSetInReq.m_tReleaseMtInfo.m_tMt = tOldSpeaker;
			tPreSetInReq.m_tReleaseMtInfo.m_byCanReleaseMode	= MODE_BOTH;
			tPreSetInReq.m_tReleaseMtInfo.SetCount(0);
			tPreSetInReq.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum =      
			tPreSetInReq.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum = 1;

			//如果发言人由于发言人跟随自动进入了画面合成,可释放视频目的数要加1
			if( GetVmpCountInVmpList() > 0 )
			{
				u8 bySpeakerNum = GetVmpChnnlNumBySpecMemberType(VMP_MEMBERTYPE_SPEAKER, &tOldSpeaker);
				if ( bySpeakerNum > 0)
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "VMP has %d chnnl of VMP_MEMBERTYPE_SPEAKER\n", bySpeakerNum);
					tPreSetInReq.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum += bySpeakerNum;
				}
			}
// 			u8 byChlPos = m_tConf.m_tStatus.m_tVMPParam.GetChlOfMtInMember(tOldSpeaker);
// 			if( /*m_tConf.m_tStatus.GetVMPMode() == CONF_VMPMODE_AUTO ||*/				
// 				MAXNUM_VMP_MEMBER != byChlPos &&				
// 				m_tConf.m_tStatus.m_tVMPParam.GetVmpMember(byChlPos)->GetMemberType() == VMP_MEMBERTYPE_SPEAKER				
// 				)
// 			{
// 				++tPreSetInReq.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum;
// 			}

			TPeriEqpStatus tStatus;
			u8 byChnlIdx;
			u8 byEqpId;
			//如果发言人由于发言人跟随自动进入了标清电视墙,可释放音视频目的数要加1
			for (byEqpId = TVWALLID_MIN; byEqpId <= TVWALLID_MAX; byEqpId++)
			{
				if (EQP_TYPE_TVWALL == g_cMcuVcApp.GetEqpType(byEqpId))
				{
					if (g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tStatus))
					{						
						for (byChnlIdx = 0; byChnlIdx < MAXNUM_PERIEQP_CHNNL; byChnlIdx++)
						{							
							if (TW_MEMBERTYPE_SPEAKER == tStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType &&
								tStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].GetConfIdx() == m_byConfIdx &&
								tStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].GetMcuId() == tOldSpeaker.GetMcuId() &&
								tStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].GetMtId() == tOldSpeaker.GetMtId()
								)
							{
								++tPreSetInReq.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum;
								++tPreSetInReq.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum;
							}
						}
					}
				}
			}

			//发言人跟随时，同步调整HDU中的图像
			u8 byHduChnNum = 0;
			//如果发言人由于发言人跟随自动进入了标清电视墙,可释放视音频目的数要加1
			for (byEqpId = HDUID_MIN; byEqpId <= HDUID_MAX; byEqpId++)
			{
				if(IsValidHduEqp(g_cMcuVcApp.GetEqp(byEqpId)))
				{
					byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byEqpId));
					if (0 == byHduChnNum)
					{						
						continue;
					}

					if (g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tStatus))
					{						
						for (byChnlIdx = 0; byChnlIdx < min(byHduChnNum,MAXNUM_HDU_CHANNEL); byChnlIdx++)
						{							
							if (TW_MEMBERTYPE_SPEAKER == tStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].byMemberType &&
								m_byConfIdx == tStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].GetConfIdx() &&
								tStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].GetMcuId() == tOldSpeaker.GetMcuId() &&
								tStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].GetMtId() == tOldSpeaker.GetMtId()
								)
							{
								++tPreSetInReq.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum;
								++tPreSetInReq.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum;
							}
						}
					}
				}
			}
			if( VCS_CONF == m_tConf.GetConfSource() )
			{
				//[2011/11/24/zhangli]多个vcs连同一mcu时，可释放基数应相应增加
				u8 byMtInMcNum = GetCanRlsNumInVcsMc(tOldSpeaker, MODE_VIDEO);
				tPreSetInReq.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum += byMtInMcNum;
					
// 				TMt tMcSrc;
// 				tMcSrc.SetNull();
// 				g_cMcuVcApp.GetMcSrc( m_cVCSConfStatus.GetCurSrcSsnId(), &tMcSrc, VCS_VCMT_MCCHLIDX, MODE_VIDEO );
// 				if( tMcSrc == tOldSpeaker )
// 				{
// 					++tPreSetInReq.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum;
// 				}
			}
		}

		OnMMcuPreSetIn( tPreSetInReq );
		return;
	}
	CServMsg cServMsg;
	cServMsg.SetConfId( m_tConf.GetConfId() );

    TMt tSpeakerMt;
    tSpeakerMt.SetNull();
	if(ptNewSpeaker != NULL)
    {
        tSpeakerMt = *ptNewSpeaker;
    }	
    ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ChangeSpeaker]Old speaker(mcuid:%d, mtid:%d) was cancelled and new speaker(mcuid:%d, mtid:%d) is specified!\n",
		tOldSpeaker.GetMcuId(), tOldSpeaker.GetMtId(), tSpeakerMt.GetMcuId(), tSpeakerMt.GetMtId());


	// 对于VCS会议均不采取自动将发言人加入画面合成
	if (VCS_CONF == m_tConf.GetConfSource())
	{
		bAddToVmp = FALSE;
	}


	//取消m_bMMcuSpeakerValid标记 
	if(m_bMMcuSpeakerValid && tOldSpeaker.GetMtType() == MT_TYPE_MMCU)
	{
		m_bMMcuSpeakerValid = FALSE;
	}

	//在带音频的轮询广播时，如有另一终端发言，轮询停止
	// [6/30/2011 liuxu] 添加新发言人是否为空判断
	BOOL32 bPollAjustVmp = FALSE;
	if( ptNewSpeaker && !ptNewSpeaker->IsNull() && !bPolling )
	{
		if( m_tConf.m_tStatus.GetPollMedia() == MODE_BOTH ||
			(m_tConf.m_tStatus.GetPollMedia() == MODE_VIDEO && tSpeakerMt == m_tPlayEqp)) //当前不带音频的会议轮询，会议放像时停掉轮询
		{
			// 停轮询处理时,暂不调整vmp,在调整新发言人时会调整vmp,若无调整,再对轮询跟随通道做单独调整
			bPollAjustVmp = TRUE;
			ProcStopConfPoll(!bPollAjustVmp);
		}
	}
	else if ( ptNewSpeaker == NULL )//20120831 zhouyiliang 带音频的轮询取消发言人时，马上启动下次轮询
	{
		if ( (CONF_POLLMODE_SPEAKER == m_tConf.m_tStatus.GetPollMode() || 
				CONF_POLLMODE_SPEAKER_BOTH == m_tConf.m_tStatus.GetPollMode())
			 && m_tConf.m_tStatus.GetPollState() == POLL_STATE_NORMAL)
		{
			SetTimer(MCUVC_POLLING_CHANGE_TIMER,500);
			// 由于轮询中取消发言人会立即轮询下一终端，此次的取消发言人处理就不调整vmp，防止连续两次快速调整vmp
			bAddToVmp = FALSE;
		}
	}


	//取消原发言人 // xsl [8/4/2006] 过滤新发言人与老发言人相同的情况
	if( m_tConf.HasSpeaker() && (NULL == ptNewSpeaker || (NULL != ptNewSpeaker && !(tOldSpeaker == *ptNewSpeaker))) )
	{
		BOOL32 bHasNewSpeaker = ( NULL != ptNewSpeaker ) ? TRUE : FALSE;
		
		BOOL32 bInSameSMcu = FALSE;
		if (bHasNewSpeaker && ptNewSpeaker)
		{
			bInSameSMcu = (tOldSpeaker.GetMcuId() == ptNewSpeaker->GetMcuId());
		}
		AdjustOldSpeakerSwitch( tOldSpeaker, bHasNewSpeaker, bInSameSMcu ,tSpeakerMt);
		// 清空其占用的前适配信息
		//TMt tRealMt = IsMcu(tOldSpeaker) ? GetSMcuViewMt(tOldSpeaker, TRUE) : tOldSpeaker;
		//m_tVmpChnnlInfo.ClearChnlByMt(tRealMt);

        //  xsl [6/20/2006] 取消发言人或替换发言人时，若双流为发言人开启，则停止双流
        if ( ( NULL == ptNewSpeaker || ( TYPE_MCUPERI != ptNewSpeaker->GetType()
				                         //zbq [09/27/2007] 发言人是录像机，也认为停双流
                                        || ( TYPE_MCUPERI == ptNewSpeaker->GetType() && EQP_TYPE_RECORDER == ptNewSpeaker->GetEqpType() ) ) )
             // zbq [08/26/2007] 发言人不一定是 m_tVidBrdSrc，比如在VMP广播时Type() /*m_tVidBrdSrc.GetType()*/
			 )
        {
            if (CONF_DUALMODE_SPEAKERONLY == m_tConf.GetConfAttrb().GetDualMode()               
				&& !m_tDoubleStreamSrc.IsNull() 
                // zbq [08/26/2007] 发言人不一定是 m_tVidBrdSrc，比如在VMP广播时的发言人
                // zbq [08/31/2007] 发言人要取本地发言人
                && 
				//本级双流源只能看到mcu,如果新发言人本地化与双流源不同则停止双流
				(  NULL == ptNewSpeaker || !(m_tDoubleStreamSrc == GetLocalMtFromOtherMcuMt(*ptNewSpeaker)))
				)
            {
                StopDoubleStream(TRUE, TRUE);
            }
        }
        
        //[zhushz 20110607]通知老发言人当前发言状态
        NotifyMtSpeakStatus(tOldSpeaker, emCanceled);
	}
	else
	{
//		m_tLastSpeaker.SetNull();
	}

	u16 wSpyStartPort = SPY_CHANNL_NULL;
	CRecvSpy tSpyResource;
	if( m_cSMcuSpyMana.GetRecvSpy( tOldSpeaker, tSpyResource ) )
	{
		wSpyStartPort = tSpyResource.m_tSpyAddr.GetPort();
	}
	//  [11/26/2009 pengjie] Modify 级联多回传支持,这里释放回传资源
	//lukunpeng 2010/06/07 在此函数入口处统一释放

	// [09/16/2010 liuxu] 这里是否有问题，可为null，也可为非null？
	// [01/05/2011 miaoqs] 这里当ptNewSpeaker == NULL时是单纯释放回传源；当ptNewSpeaker != NULL时需要调整回传源
	if ( ptNewSpeaker == NULL || ptNewSpeaker != NULL )
	{
		FreeRecvSpy( tOldSpeaker, MODE_BOTH);
	}
 	//  End
	AdjustNewSpeakerSwitch( tSpeakerMt, /*bAddToVmp, */wSpyStartPort );	
	
	// 2011/07/06 add by peng guofeng start

	// 1.切换Mixer的发言人成员
	ChgSpeakerInMixer(tOldSpeaker, &tSpeakerMt);

	// 2.切换TvWall的发言人成员
	ChgSpeakerInTvWall(tSpeakerMt);
	
	// 3.切换Hdu的发言人成员
	ChgSpeakerInHdu(tSpeakerMt);
	
	//指定全局发言人做下级mcu的回传源
	//vmp处理中需取mcu的新上传终端,单回传移到此处处理
	if( !tSpeakerMt.IsNull() && !tSpeakerMt.IsLocal() && !IsLocalAndSMcuSupMultSpy(tSpeakerMt.GetMcuId()) )
	{
		TConfMcInfo *ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(tSpeakerMt.GetMcuId());
		if(ptConfMcInfo != NULL)
		{
			TMt tMt; //自己
			tMt.SetMcuIdx(tSpeakerMt.GetMcuIdx());
			tMt.SetMtId(0);
			TMcMtStatus *ptStatus = ptConfMcInfo->GetMtStatus(tMt);
			if(ptStatus != NULL)
			{
				OnMMcuSetIn(tSpeakerMt, cServMsg.GetSrcSsnId(), SWITCH_MODE_BROADCAST);
			}
		}
	}

	// 4.调整发言人的视频显示
	//	2011-11-25 mod by pgf: 当下级只有一路回传带宽时，VMP和TvWALL同时开启发言人跟随，此时用下级终端B替换下级终端A
	//  发言，如果先操作VMP,由于它所带的可释放MODE: VIDEO,在PreSetInAck里计算带宽的时候，由于音频还未释放，所以会报回传带宽满
	BOOL32 bAjustVmp = ChgSpeakerInVmp(tOldSpeaker, tSpeakerMt, bAddToVmp);
	// 针对之前停轮询处理,未调整vmp,若ChgSpeakerInVmp处理中有调整,就无需再调,若无调整,则在此处刷新轮询跟随通道
	if (bPollAjustVmp && IsChangeVmpParam() && !bAjustVmp)
	{
		ChangeVmpChannelParam(NULL, VMP_MEMBERTYPE_POLL);
	}


	//通知下级建回传交换
	//zjl20101117切换发言人发SpyNotify
	if( !tSpeakerMt.IsLocal() )
	{
		if( IsLocalAndSMcuSupMultSpy(tSpeakerMt.GetMcuId()) )
		{
			TSimCapSet tSimCapSet = GetMtSimCapSetByMode( GetFstMcuIdFromMcuIdx(tSpeakerMt.GetMcuId()));	
			SendMMcuSpyNotify( tSpeakerMt, MCS_MCU_SPECSPEAKER_REQ, tSimCapSet);
		}
	}
	
	//lukunpeng 2010/07/23 终端申请发言/抢答代码合并
	//整理申请队列，FIXME: 跨级标识？
	BOOL32 bIsSendToChairman = FALSE;
    if (m_tApplySpeakQue.IsMtInQueue(tSpeakerMt) )
    {
        m_tApplySpeakQue.ProcQueueInfo(tSpeakerMt,bIsSendToChairman, FALSE);
        NotifyMcsApplyList( bIsSendToChairman );
    }

    //[zhushz 20110607]通知新发言人当前发言状态
	// 2011-8-4 add by pgf: FIX
	if ( ptNewSpeaker)
	// 2011-8-4 add end
	{
		NotifyMtSpeakStatus(tSpeakerMt, emAgreed);
	}

	//通知所有会控
	cServMsg.SetMsgBody( ( u8 * )&m_tConf, sizeof( m_tConf ) );
	if(m_tConf.HasConfExInfo())
	{
		u8 abyConfInfExBuf[CONFINFO_EX_BUFFER_LENGTH] = {0};
		u16 wPackDataLen = 0;
		PackConfInfoEx(m_tConfEx,abyConfInfExBuf,wPackDataLen);
		cServMsg.CatMsgBody(abyConfInfExBuf, wPackDataLen);
	}
	SendMsgToAllMcs( MCU_MCS_CONFINFO_NOTIF, cServMsg );
	
	//通知所有终端
	//简化通知终端使用的会议信息结构 2005-10-11
	TConfStatus tConfStatus = m_tConf.GetStatus();
	TSimConfInfo tSimConfInfo;
	tSimConfInfo.m_tSpeaker  = GetLocalSpeaker();
	tSimConfInfo.m_tChairMan = m_tConf.GetChairman();
    // guzh [11/6/2007] 
	tSimConfInfo.SetVMPMode(tConfStatus.GetVMPMode());
    // guzh [11/6/2007] 
	tSimConfInfo.SetMixMode(tConfStatus.GetMixerMode());
	cServMsg.SetMsgBody( ( u8 * )&tSimConfInfo, sizeof( tSimConfInfo ) );
	BroadcastToAllSubMtJoinedConf( MCU_MT_SIMPLECONF_NOTIF, cServMsg );

    //n+1备份更新发言人信息
    if (MCU_NPLUS_MASTER_CONNECTED == g_cNPlusApp.GetLocalNPlusState())
    {
        ProcNPlusSpeakerUpdate();
    }
	
	NotifyAllSMcuMediaInfo( 0,MODE_BOTH );
	return;
}

/*====================================================================
    函数名      ：ChangeSecSpeaker
    功能        ：改变双广播

    算法实现    ：
    引用全局变量：
    输入参数说明：TMt &tNewSpeaker, 要设置的发言人，如果为NULL，则为取消
				  BOOL32 bNeedPreSetin

    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2012/09/13	4.7			zhangli		  create
====================================================================*/
void CMcuVcInst::ChangeSecSpeaker(TMt &tNewSpeaker, BOOL32 bNeedPreSetin)
{
	if (!tNewSpeaker.IsNull() && tNewSpeaker == GetSecVidBrdSrc())
	{
		return;
	}

	//双广播暂不支持回传
	if (!tNewSpeaker.IsNull() && !tNewSpeaker.IsLocal())
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_SPY, "[ChangeSecSpeaker] tNewSpeaker(%d,%d) is not local!\n",
			tNewSpeaker.GetMcuId(), tNewSpeaker.GetMtId());
		return;
	}

	TMt tOldSecVid = GetSecVidBrdSrc();
	//多回传处理
	if (!tNewSpeaker.IsNull() && !tNewSpeaker.IsLocal() && bNeedPreSetin
		&& IsLocalAndSMcuSupMultSpy(tNewSpeaker.GetMcuId()))
	{
		TPreSetInReq tPreSetInReq;
		tPreSetInReq.m_tSpyMtInfo.SetSpyMt(tNewSpeaker);
		tPreSetInReq.m_bySpyMode = MODE_VIDEO;

		TSimCapSet tReqSpyCap = GetMtSimCapSetByMode(GetFstMcuIdFromMcuIdx(tNewSpeaker.GetMcuId()));
	    
		if(!GetMinSpyDstCapSet(tNewSpeaker, tReqSpyCap))
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_SPY, "[ChangeSecSpeaker] Get Mt(mcuid.%d, mtid.%d) SimCapSet Failed !\n",
				tNewSpeaker.GetMcuId(), tNewSpeaker.GetMtId() );
			return;
		}

		tPreSetInReq.m_tSpyMtInfo.SetSimCapset(tReqSpyCap);

		tPreSetInReq.SetEvId(MCS_MCU_SPECSPEAKER_REQ);

		if(!tOldSecVid.IsNull())
		{			
			tPreSetInReq.m_tReleaseMtInfo.m_tMt = tOldSecVid;
			tPreSetInReq.m_tReleaseMtInfo.m_byCanReleaseMode	= MODE_VIDEO;
			tPreSetInReq.m_tReleaseMtInfo.SetCount(0);
			tPreSetInReq.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum = 1;
		}

		OnMMcuPreSetIn(tPreSetInReq);
		return;
	}

	CServMsg cServMsg;
	cServMsg.SetConfId(m_tConf.GetConfId());

	if(!tNewSpeaker.IsNull())
    {
        m_tSecVidBrdSrc = tNewSpeaker;
    }
	else
	{
		m_tSecVidBrdSrc.SetNull();
	}

    ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ChangeSecSpeaker]Old speaker(mcuid:%d, mtid:%d) was cancelled and new speaker(mcuid:%d, mtid:%d) is specified!\n",
		tOldSecVid.GetMcuId(), tOldSecVid.GetMtId(), tNewSpeaker.GetMcuId(), tNewSpeaker.GetMtId());

	//调整老发言人
	if(!tOldSecVid.IsNull() && (tNewSpeaker.IsNull() || (!tNewSpeaker.IsNull() && !(tOldSecVid == tNewSpeaker))))
	{
		//NotifyMtSend(tOldSecVid.GetMtId(), MODE_VIDEO, FALSE);
		FreeRecvSpy(tOldSecVid, MODE_VIDEO);
	}

	TMt atDstMt[MAXNUM_CONF_MT];
	u8 byDstMtNum = 0;
	TLogicalChannel tLogicChnl;

	if (tNewSpeaker.IsNull())
	{
		if (!(GetSecVidBrdSrc() == GetVidBrdSrc()))
		{
			g_cMpManager.RemoveSwitchBridge(tOldSecVid, 0, MODE_VIDEO);
		}

		u8 byMtId = 1;
		for (byMtId = 1; byMtId <= MAXNUM_CONF_MT; ++byMtId)
		{
			if(!m_ptMtTable->GetMtSelMtByMode(byMtId, MODE_VIDEO2SECOND).IsNull())
			{
				continue;
			}
			if(!m_ptMtTable->GetMtLogicChnnl(byMtId, LOGCHL_SECVIDEO, &tLogicChnl, TRUE))
			{
				continue;
			}
			
			atDstMt[byDstMtNum] = m_ptMtTable->GetMt(byMtId);
			byDstMtNum++;
			
			m_ptMtTable->SetMtVideo2Recv(byMtId, FALSE);
			MtStatusChange(&atDstMt[byDstMtNum], TRUE);

			//close channel
			u8 byOut = 1;
			cServMsg.SetMsgBody((u8 *)&tLogicChnl, sizeof(tLogicChnl));
			cServMsg.CatMsgBody(&byOut, sizeof(byOut));
			SendMsgToMt(byMtId, MCU_MT_CLOSELOGICCHNNL_CMD, cServMsg);

			if (m_ptMtTable->GetMtTransE1(byMtId) && m_ptMtTable->GetMtBRBeLowed(byMtId))
            {
                u16 wRealBR = m_ptMtTable->GetLowedRcvBandWidth(byMtId);
                m_ptMtTable->SetMtReqBitrate(byMtId, wRealBR, LOGCHL_VIDEO);
                ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT2, "[ChangeSecSpeaker]tDstMt.%d, MtReqBitrate = %d, adjust restore\n", byMtId, wRealBR);
            }
            else
            {
                u16 wMtDialBitrate = m_ptMtTable->GetRcvBandWidth(byMtId);
                m_ptMtTable->SetMtReqBitrate(byMtId, wMtDialBitrate, LOGCHL_VIDEO);
                ConfPrint(LOG_LVL_DETAIL, MID_MCU_MT2, "[ChangeSecSpeaker]tDstMt.%d, MtReqBitrate = %d, normally restore\n", byMtId, wMtDialBitrate);
            }
		}

		if (byDstMtNum > 0)
		{
			u16 wSpyStartPort = SPY_CHANNL_NULL;
			CRecvSpy tSpyResource;
			if(m_cSMcuSpyMana.GetRecvSpy(tOldSecVid, tSpyResource))
			{
				wSpyStartPort = tSpyResource.m_tSpyAddr.GetPort();
			}

			StopSwitchToSubMt(byDstMtNum, atDstMt, MODE_VIDEO2SECOND, TRUE, TRUE, TRUE, wSpyStartPort);

			TLogicalChannel tNullLogicChnnl;
			for (u8 byLoop = 0; byLoop < byDstMtNum; ++byLoop)
			{
				m_ptMtTable->SetMtLogicChnnl(atDstMt[byLoop].GetMtId(), LOGCHL_SECVIDEO, &tNullLogicChnnl, TRUE );
			}
		}

		//存在第一个发言人，恢复码率
		TMt tLocalVidBrdSrc = GetLocalVidBrdSrc();

		if (!tLocalVidBrdSrc.IsNull() && TYPE_MT == tLocalVidBrdSrc.GetType())
		{
			if (m_ptMtTable->GetMtLogicChnnl(tLocalVidBrdSrc.GetMtId(), LOGCHL_VIDEO, &tLogicChnl, FALSE))
			{            
				tLogicChnl.SetFlowControl(m_ptMtTable->GetSndBandWidth(tLocalVidBrdSrc.GetMtId()));
				cServMsg.SetMsgBody((u8*)&tLogicChnl, sizeof(tLogicChnl));
				SendMsgToMt(tLocalVidBrdSrc.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cServMsg);
			}
		}

		//调第一路选看源的发送码率
		TMt tOtherMt;
		TMt tOtherMtSec;
		for (byMtId = 1; byMtId <= MAXNUM_CONF_MT; ++byMtId)
		{
			if (!m_tConfAllMtInfo.MtJoinedConf(byMtId))
			{
				continue;
			}
			
			tOtherMt = m_ptMtTable->GetMtSelMtByMode(byMtId, MODE_VIDEO);
			tOtherMtSec = m_ptMtTable->GetMtSelMtByMode(byMtId, MODE_VIDEO2SECOND);

			//如果第二路选看也存在则不用调
			if (tOtherMt.IsNull() || !tOtherMtSec.IsNull())
			{
				continue;
			}

			m_ptMtTable->GetMtLogicChnnl(tOtherMt.GetMtId(), LOGCHL_VIDEO, &tLogicChnl, FALSE);
			tLogicChnl.SetCurrFlowControl(0xFFFF);
			tLogicChnl.SetFlowControl(m_ptMtTable->GetDialBitrate(tOtherMt.GetMtId()));
			cServMsg.SetMsgBody((u8*)&tLogicChnl, sizeof(tLogicChnl));
			SendMsgToMt(tOtherMt.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cServMsg);
		}

		//PRS支持，占用双流的prs
		TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
		if (tConfAttrb.IsResendLosePack())
		{	
			StopBrdPrs(MODE_SECVIDEO);				
		}
	}
	else
	{
		TLogicalChannel tSpeakerChnnl;
		//取选看源主视频能力开目的终端的双流通道
		if (!m_ptMtTable->GetMtLogicChnnl(tNewSpeaker.GetMtId(), LOGCHL_VIDEO, &tSpeakerChnnl, FALSE))
		{
			return;
		}
		tSpeakerChnnl.SetSupportH239(m_tConf.GetCapSupport().IsDStreamSupportH239());

		//建桥
		if (!(GetSecVidBrdSrc() == GetVidBrdSrc()))
		{
			g_cMpManager.SetSwitchBridge(tNewSpeaker, 0, MODE_VIDEO);
		}

		TMt tDstMt;
		TCapSupport tCapSupport;
		for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; ++byMtId)
		{
			//拆旧发言人到新发言人的交换，通道暂时不关
			if (GetSecVidBrdSrc().GetMtId() == byMtId)
			{
				if (!tOldSecVid.IsNull() && m_ptMtTable->GetMtSelMtByMode(byMtId, MODE_VIDEO2SECOND).IsNull()
					&& m_ptMtTable->GetMtLogicChnnl(byMtId, LOGCHL_SECVIDEO, &tLogicChnl, TRUE))
				{
					StopSwitchToSubMt(1, &m_tSecVidBrdSrc, MODE_VIDEO2SECOND);
				}
				continue;
			}

			//开双流逻辑通道
			tDstMt = m_ptMtTable->GetMt(byMtId);

			//终端正在选看，先停选看
			if(!m_ptMtTable->GetMtSelMtByMode(byMtId, MODE_VIDEO2SECOND).IsNull())
			{
				StopSelectSrc(tDstMt, MODE_VIDEO2SECOND, FALSE, FALSE);
			}

			//开终端双流接收通道
			if(!m_ptMtTable->GetMtLogicChnnl(byMtId, LOGCHL_SECVIDEO, &tLogicChnl, TRUE))
			{
				//设置通道是否带有H239标签
				if (m_ptMtTable->GetMtCapSupport(byMtId, &tCapSupport))
				{
					tSpeakerChnnl.SetSupportH239(tCapSupport.IsDStreamSupportH239());
				}

				McuMtOpenDoubleStreamChnnl(tDstMt, tSpeakerChnnl);
				continue;
			}
			
			if (IsNeedAdapt(tNewSpeaker, tDstMt, MODE_VIDEO2SECOND))
			{
				//暂不处理适配，过适配关逻辑通道
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[ChangeSecSpeaker]need adapt,mtId:%d\n", byMtId);
			}
			else
			{
				atDstMt[byDstMtNum] = m_ptMtTable->GetMt(byMtId);
				byDstMtNum++;
			}
		}

		if (byDstMtNum > 0)
		{
			CRecvSpy tVidSpy;
			u16 wSpyPort = SPY_CHANNL_NULL;
			if(m_cSMcuSpyMana.GetRecvSpy(tNewSpeaker, tVidSpy))
			{
				wSpyPort = tVidSpy.m_tSpyAddr.GetPort();
			}
			TSwitchGrp tSwitchGrp;		
			tSwitchGrp.SetSrcChnl(0);
			tSwitchGrp.SetDstMtNum(byDstMtNum);
			tSwitchGrp.SetDstMt(atDstMt);
			StartSwitchToAll(tNewSpeaker, 1, &tSwitchGrp, MODE_VIDEO2SECOND, SWITCH_MODE_BROADCAST, FALSE, FALSE, wSpyPort);
		}

		//调第一路发言人的发送
		TMt tLocalVidBrdSrc = GetLocalVidBrdSrc();
		if (!tLocalVidBrdSrc.IsNull() && TYPE_MT == tLocalVidBrdSrc.GetType())
		{
			CServMsg cFlowServMsg;
			if (m_ptMtTable->GetMtLogicChnnl(tLocalVidBrdSrc.GetMtId(), LOGCHL_VIDEO, &tLogicChnl, FALSE))
			{
				tLogicChnl.SetFlowControl(GetDoubleStreamVideoBitrate(m_ptMtTable->GetSndBandWidth(tLocalVidBrdSrc.GetMtId())));
				cFlowServMsg.SetMsgBody((u8*)&tLogicChnl, sizeof(tLogicChnl));
				SendMsgToMt(tLocalVidBrdSrc.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cFlowServMsg);
			}
		}

		//PRS支持，占用双流的prs
		TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
		if (tConfAttrb.IsResendLosePack())
		{	
			StartBrdPrs(MODE_VIDEO2SECOND);				
		}
	}

	//如果老的双广播终端在发发送第一路视频码率，恢复码率
	if(IsDStreamMtSendingVideo(tOldSecVid))
	{
		CServMsg cFlowServMsg;
		if (m_ptMtTable->GetMtLogicChnnl(tOldSecVid.GetMtId(), LOGCHL_VIDEO, &tLogicChnl, FALSE))
		{            
			tLogicChnl.SetFlowControl(m_ptMtTable->GetSndBandWidth(tOldSecVid.GetMtId()));
			cFlowServMsg.SetMsgBody((u8*)&tLogicChnl, sizeof(tLogicChnl));
			SendMsgToMt(tOldSecVid.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cFlowServMsg);
		}
	}

	//调vmp码率
	if (g_cMcuVcApp.IsBrdstVMP(m_tVmpEqp))
	{
		AdjustVmpBrdBitRate();
    }

	// 刷新第一路适配编码
	if (m_tConf.m_tStatus.IsVidAdapting())
	{
		RefreshBasBrdAdpParam(MODE_VIDEO);
		RefreshBrdBasParam4AllMt(MODE_VIDEO);
		
		if (!m_tConf.m_tStatus.IsNoRecording() && !IsRecNeedAdapt(MODE_VIDEO) && m_tRecPara.IsRecLowStream())
		{
			RefreshBasParamForLowBrUse();
		}
	}

// 	if(!tNewSpeaker.IsNull() && !tNewSpeaker.IsLocal() && !IsLocalAndSMcuSupMultSpy(tNewSpeaker.GetMcuId()))
// 	{
// 		TConfMcInfo *ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(tNewSpeaker.GetMcuId());
// 		if(ptConfMcInfo != NULL)
// 		{
// 			TMt tMt; //自己
// 			tMt.SetMcuIdx(tNewSpeaker.GetMcuIdx());
// 			tMt.SetMtId(0);
// 			TMcMtStatus *ptStatus = ptConfMcInfo->GetMtStatus(tMt);
// 			if(ptStatus != NULL)
// 			{
// 				OnMMcuSetIn(tNewSpeaker, cServMsg.GetSrcSsnId(), SWITCH_MODE_BROADCAST);
// 			}
// 		}
// 	}

	if(!tNewSpeaker.IsNull() && !tNewSpeaker.IsLocal() && IsLocalAndSMcuSupMultSpy(tNewSpeaker.GetMcuId()))
	{
		TSimCapSet tSimCapSet = GetMtSimCapSetByMode( GetFstMcuIdFromMcuIdx(tNewSpeaker.GetMcuId()));	
		SendMMcuSpyNotify(tNewSpeaker, MCS_MCU_SPECSPEAKER_REQ, tSimCapSet);
	}

	//通知所有会控第二发言人
	cServMsg.SetMsgBody((u8 *)&tNewSpeaker, sizeof(tNewSpeaker));
	SendMsgToAllMcs(MCU_MCS_SECSPEAKER_NOTIFY, cServMsg);
	
    //n+1备份更新发言人信息
}

/*====================================================================
    函数名      ：IsChangeVmpParam
    功能        ：是否需要改变画面合成参数

    算法实现    ：
    引用全局变量：
    输入参数说明：

    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/06/15    3.6         libo          创建
    06/04/24    4.0         张宝卿        适应自动合成加入主席和发言人
	11/07/29	4.6			彭国锋		  删除参数
====================================================================*/
BOOL32 CMcuVcInst::IsChangeVmpParam()
{  
    if ( !m_tConfInStatus.IsVmpNotify() )
    {
        ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[IsChangeVmpParam] m_bVmpNotify: %d, No change !\n", m_tConfInStatus.IsVmpNotify() );
        return FALSE;
    }

    return TRUE;
}

/*=============================================================================
函 数 名： GetSatCastChnnlNum
功    能：  获取当前分散会议回传通道数
算法实现： 
全局变量： 
参    数： void
返 回 值： u8  
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/8/22  4.0			许世林                  创建
=============================================================================*/
u8  CMcuVcInst::GetSatCastChnnlNum(u8 bySrcMtId)
{
    u8 byChnnlNum = 0;
    for(u8 byIdx = 1; byIdx <= MAXNUM_CONF_MT; byIdx++)
    {
        //只有组播终端才占回传计数
        if (m_tConfAllMtInfo.MtJoinedConf(byIdx) && 
            bySrcMtId != byIdx && 
            (m_ptMtTable->GetMtSndBitrate(byIdx) > 0 || m_ptMtTable->GetMtSndBitrate(byIdx, LOGCHL_SECVIDEO) > 0) &&
            IsMultiCastMt(byIdx))
        {
            byChnnlNum++;
        }
    }
    return byChnnlNum;
}

/*=============================================================================
  函 数 名： IsOverSatCastChnnlNum
  功    能： 卫星分散会议中是否超过最大回传通道数
  算法实现： 
  全局变量： 
  参    数： TVMPParam tVmpParam
  返 回 值： BOOL32 
=============================================================================*/
/*=============================================================================
  函 数 名： IsOverSatCastChnnlNum
  功    能： 卫星分散会议中是否超过最大回传通道数
  算法实现： 
  全局变量： 
  参    数： TVMPParam tVmpParam
  返 回 值： BOOL32 
=============================================================================*/
BOOL32 CMcuVcInst::IsOverSatCastChnnlNum(TVMPParam_25Mem &tVmpParam)
{

	TVMPParam_25Mem tLastVmpParam = g_cMcuVcApp.GetLastVmpParam(m_tVmpEqp);
	u8 byUseSatNum = 0;
	emSatReplaceType emReplaceType = emVmpBrd;
	if ( !tVmpParam.IsVMPBrdst())
	{
		emReplaceType = emVmpNoBrd;
	}
	for ( u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
	{
		if ( !IsMultiCastMt(byMtId)
			|| !m_tConfAllMtInfo.MtJoinedConf(byMtId))
		{
			continue;
		}

		TMt tMt = m_ptMtTable->GetMt(byMtId);
		// VMP广播的时候，过滤当前发言人 [pengguofeng 2/20/2013]
		//应该用emVmpBrd emVmpNoBrd来区分
		if ( tVmpParam.IsMtInMember(tMt))
		{
			LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[IsOverSatCastChnnlNum]Mt:%d in vmp\n", byMtId);
			byUseSatNum++;
		}
		else
		{
			// 如果原来在VMP中的话，要过滤所对应的VMP某一通道 [pengguofeng 2/20/2013]
			u8 bySkipVmpChnnl = 0xff;
			if ( tLastVmpParam.IsMtInMember(tMt))
			{
				bySkipVmpChnnl = tLastVmpParam.GetChlOfMtInMember(tMt);
			}
			if ( IsMtKeepSatChnnl(tMt, emReplaceType, 0xff, 0xff, bySkipVmpChnnl) )
			{
				LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[IsOverSatCastChnnlNum]Mt:%d must keep\n", byMtId);
				byUseSatNum++;
			}
		}
	}

	return byUseSatNum > m_tConf.GetSatDCastChnlNum();
    /*u8 byIncNum = 0;
    for (u8 byMemIdx = 0; byMemIdx < tVmpParam.GetMaxMemberNum(); byMemIdx++)
    {
		TMt tMtMember = (TMt)(*tVmpParam.GetVmpMember(byMemIdx));
        TMt *ptMt = &tMtMember;

		if (ptMt == NULL)
		{
			continue;
		}
		*ptMt = GetLocalMtFromOtherMcuMt(*ptMt);

        if (m_tConfAllMtInfo.MtJoinedConf(ptMt->GetMtId()) &&
            m_ptMtTable->GetMtSndBitrate(ptMt->GetMtId()) == 0)
        {
            byIncNum++;
        }
    }

    return IsOverSatCastChnnlNum(0, byIncNum);*/
}

/*=============================================================================
  函 数 名： ChangeSatDConfMtRcvAddr
  功    能： 改变分散会议中终端接收地址
  算法实现： 
  全局变量： 
  参    数： BOOL32 bMulti 若为多播则为创会时设定的多播地址，单播地址为0
  返 回 值： TTransportAddr 
=============================================================================*/
void CMcuVcInst::ChangeSatDConfMtRcvAddr(u8 byMtId, u8 byChnnlType, BOOL32 bMulti/*= TRUE*/)
{
    TTransportAddr tMtRcvAddr;   
    //多播
    if (bMulti)
    {
        tMtRcvAddr.SetIpAddr(m_tConf.GetConfAttrb().GetSatDCastIp());
        
        u16 wPort = m_tConf.GetConfAttrb().GetSatDCastPort();
        if (LOGCHL_VIDEO == byChnnlType)
        {
            tMtRcvAddr.SetPort(wPort);
        }        
        else if (LOGCHL_AUDIO == byChnnlType)
        {
            tMtRcvAddr.SetPort(wPort+2);
        }
        else if (LOGCHL_SECVIDEO == byChnnlType)
        {
            tMtRcvAddr.SetPort(wPort+4);
        }
        else
        {
			ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[ChangeSatDConfMtRcvAddr] invalid channel type %d!\n", byChnnlType);
        }
    }
    //单播
    else
    {
        TLogicalChannel tLogicChannel;
        m_ptMtTable->GetMtLogicChnnl(byMtId, byChnnlType, &tLogicChannel, TRUE);
        tMtRcvAddr.SetIpAddr(0);
        tMtRcvAddr.SetPort(tLogicChannel.GetRcvMediaChannel().GetPort());        
    }

    CServMsg cServMsg;
    cServMsg.SetEventId(MCU_MT_SATDCONFCHGADDR_CMD);
    cServMsg.SetMsgBody(&byChnnlType, sizeof(byChnnlType));
    cServMsg.CatMsgBody((u8*)&tMtRcvAddr, sizeof(tMtRcvAddr));
    SendMsgToMt(byMtId, MCU_MT_SATDCONFCHGADDR_CMD, cServMsg);

    ConfPrint(LOG_LVL_DETAIL, MID_MCU_MT2, "[ChangeSatDConfMtRcvAddr] byMtId.%d byChnnlType.%d MtRcvAddr<0x%x, %d>.\n", 
        byMtId, byChnnlType, tMtRcvAddr.GetIpAddr(), tMtRcvAddr.GetPort());

    return;
}

/*
 *	pgf看卫星终端是不是能正常接收广播源/双流源的码流
 */
BOOL32 CMcuVcInst::IsCanSatMtReceiveBrdSrc(const TMt &tMt, u8 byMode /*= MODE_VIDEO*/)
{
	if ( tMt.IsNull() 
		|| !tMt.IsLocal()
		|| !IsMultiCastMt(tMt.GetMtId())
		)
	{
		return FALSE;
	}

	TMt tBrdSrc;
	switch ( byMode )
	{
	case MODE_VIDEO:
// 	case MODE_VIDEO2SECOND:
		{
			tBrdSrc = GetVidBrdSrc();
			if ( tBrdSrc.IsNull() )
			{
				return FALSE;
			}
			if ( tBrdSrc.GetType() == TYPE_MT )
			{
				if ( IsNeedAdapt(tBrdSrc, tMt, MODE_VIDEO))
				{
					return FALSE;
				}
				else
				{
					return TRUE;
				}
			}
			else if ( tBrdSrc.GetType() == TYPE_MCUPERI)
			{
				TVideoStreamCap tDstRcvVidCap = m_ptMtTable->GetDstSCS(tMt.GetMtId()).GetVideoCap();
				TVideoStreamCap tSrcVidCap = m_tConf.GetMainSimCapSet().GetVideoCap();
				if ( tBrdSrc.GetEqpType() == EQP_TYPE_VMP )
				{
				}
				else if ( tBrdSrc.GetEqpType() == EQP_TYPE_RECORDER )
				{
					// 			if ( m_tConf.m_tStatus.IsPlaying() ) //不用管是不是已经暂停
					{
						u8 byVidType;
						u16 wWidth, wHeight;
						byVidType = 0;
						wWidth = wHeight = 0;
						m_tPlayFileMediaInfo.GetVideo(byVidType, wWidth, wHeight);
						u8 byRes = GetResByWH(wWidth, wHeight);
						//设置属性
						tSrcVidCap.SetMediaType(byVidType);
						tSrcVidCap.SetResolution(byRes);
						tSrcVidCap.SetH264ProfileAttrb(m_tPlayFileHpAttrib.GetFirstVideHpAttrib());
					}
				}
				else
				{
					tSrcVidCap.Clear();
				}
// 				LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "+++++++++cap compare: Src: conf DstMt:%d\n", tMt.GetMtId());
// 				tSrcVidCap.Print();
// 				tDstRcvVidCap.Print();
				// 比较条件： [pengguofeng 3/1/2013]
				// 接收通道开+MediaType相等+分辨率相等+源的FPS<=目的FPS+源的Profile <=目的的Profile
				if ( m_ptMtTable->IsLogicChnnlOpen(tMt.GetMtId(), LOGCHL_VIDEO, TRUE)
					&& tDstRcvVidCap.GetMediaType() != MEDIA_TYPE_NULL
					&& tDstRcvVidCap.GetMediaType() == tSrcVidCap.GetMediaType()
					&& tDstRcvVidCap.GetResolution() == tSrcVidCap.GetResolution()
					&& tDstRcvVidCap.GetUserDefFrameRate() >= tSrcVidCap.GetUserDefFrameRate()
					&& tDstRcvVidCap.GetH264ProfileAttrb() >= tSrcVidCap.GetH264ProfileAttrb())
				{
					return TRUE;
				}
				else
				{
					return FALSE;
				}
			}
		}
		break;
	case MODE_AUDIO:
		{
			tBrdSrc = GetAudBrdSrc();
			if ( tBrdSrc.IsNull() )
			{
				return FALSE;
			}

			if ( !IsNeedAdapt(tBrdSrc, tMt, MODE_AUDIO))
			{
				return TRUE;
			}			
		}
		break;
	case MODE_SECVIDEO:
		{
			tBrdSrc = m_tDoubleStreamSrc;
			if ( tBrdSrc.IsNull() )
			{
				return FALSE;
			}

			if ( !IsNeedAdapt(tBrdSrc, tMt, MODE_SECVIDEO))
			{
				return TRUE;
			}
			
		}
		break;
	default:
		break;
	}

	return FALSE;
}

/*=============================================================================
函 数 名： IsMtSendingVidToOthers
功    能： 终端除了视频广播，是否还在向其他实体发送码流, 仅用于分散会议
算法实现： 
全局变量： 
参    数： TMt tMt
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/8/23  4.0			许世林                  创建
=============================================================================*/
BOOL32 CMcuVcInst::IsMtSendingVidToOthers(TMt tMt, BOOL32 bConfPoll/*with audio*/, BOOL32 bTwPoll, u8 bySelDstMtId)
{	
    TMtStatus tStatus;
    TPeriEqpStatus tTWStatus;

    //是否在广播(带音频会议轮询时不判断)
    if (!bConfPoll)
    {
        if (tMt == GetLocalSpeaker())
        {
            return TRUE;
        }
    }      

    //是否在vmp中
	TVMPParam_25Mem tConfVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
    if (tConfVmpParam.GetVMPMode() != CONF_VMPMODE_NONE)
    {
        if (tConfVmpParam.IsMtInMember(tMt))
        {
            return TRUE;
        }
    }

    //是否在tvwall中(电视墙轮询时不判断)
    if (!bTwPoll)
    {
		TMt tMtInTv;
        for(u8 byTvId = TVWALLID_MIN; byTvId <= TVWALLID_MAX; byTvId++)
        {      
            g_cMcuVcApp.GetPeriEqpStatus(byTvId, &tTWStatus);
            if( tTWStatus.m_byOnline )
            {
                for(u8 byLp = 0; byLp < min(tTWStatus.m_tStatus.tTvWall.byChnnlNum,MAXNUM_PERIEQP_CHNNL); byLp++)
                {
                    tMtInTv = (TMt)tTWStatus.m_tStatus.tTvWall.atVideoMt[byLp];
                    if(tMtInTv.GetMtId() == tMt.GetMtId())
                    {
                        return TRUE;
                    }
                }
            }
        }
    }    

    //是否在mtw中
	TVMPParam tVmpTwParam = m_tConf.m_tStatus.GetVmpTwParam();
    if (m_tConf.m_tStatus.GetVmpTwMode() != CONF_VMPTWMODE_NONE)
    {
        if (tVmpTwParam.IsMtInMember(tMt))
        {
            return TRUE;
        }
    }

    //是否在会控监控
    if (IsMtInMcSrc(tMt.GetMtId(), MODE_VIDEO))
    {
        return TRUE;
    }

    //是否在终端录像
	m_ptMtTable->GetMtStatus(tMt.GetMtId(), &tStatus);
	if (tStatus.m_tRecState.IsRecording())
	{
		return TRUE;
	}

    //是否在被选看
    for (u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++)
    {
        if (!m_tConfAllMtInfo.MtJoinedConf(byLoop) || byLoop == bySelDstMtId)//去掉此目的终端，看是否还有其他终端在选看
        {
            continue;
        }      
		
		if (m_ptMtTable->GetMtStatus(byLoop, &tStatus))
        {
            if (tStatus.GetSelectMt(MODE_VIDEO) == tMt)
            {               
                return TRUE;
            }
        }
    }

    //分散会议不支持级联，不判断回传

    return FALSE;
}

/*=============================================================================
函 数 名： IsSatMtOverConfDCastNum
功    能： tNewMt替换时，卫星回传计数是否会超过会议计数
算法实现： tNewMt肯定会占一路，就看除它以外的卫星终端了
全局变量： 
参    数：	TMt tNewMt,必定要占一路回传的终端
			emSatReplaceType emReplaceType,业务类型，与过滤相关，emDefault不过滤任何一个
			u8 bySkipVcId,所要跳过的界面ID
			u8 bySkipVcChnnl,所要跳过的界面通道
			u8 bySkipVmpChnnl,所要跳过的Vmp通道
			u8 &bySkipHduId, 跳过的HduId
			u8 &bySkipHduChnnl,跳过的Hdu通道
			u8 &bySkipMtId,跳过的MT id，主要是本级，对于选看时有用，扩展的话，就用*TMt替代之
返 回 值： BOOL32 TRUE: 超过　FALSE: 不超
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/1/23   4.7			彭国锋                  创建
=============================================================================*/
BOOL32 CMcuVcInst::IsSatMtOverConfDCastNum(const TMt &tNewMt, emSatReplaceType emReplaceType /* = emDefault */,
											const u8 &bySkipVcId/* = 0xff*/, const u8 &bySkipVcChnnl/* = 0xff*/,
											const u8 &bySkipVmpChnnl/* = 0xff*/, const u8 &bySkipHduId /*= 0xff*/,
											const u8 &bySkipHduChnnl/* = 0xff*/, const u8 &bySkipMtId /*= 0*/)
{
	LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "\n--IsSatMtOverConfDCastNum-start-NewMt:%d emType:%d-\n",
		tNewMt.GetMtId(), emReplaceType);
	if ( !IsMultiCastMt(tNewMt.GetMtId())
		//emSpeakerSrc的场景下，上一个发言人还没拆交换，因此他的码率还是非0
		|| IsSatMtSend(tNewMt) && emReplaceType != emSpeakerSrc )
	{
		return FALSE;
	}

	u8 byConfDCastNum = 0;
	//deal other Mt but input mt
	for ( u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT ; byMtId++)
	{
		TMt tMt = m_ptMtTable->GetMt(byMtId);
		if ( !m_tConfAllMtInfo.MtJoinedConf(byMtId)
			|| !IsMultiCastMt(byMtId)
			|| !IsSatMtSend(tMt) )
		{
			continue;
		}

		if ( byMtId == tNewMt.GetMtId() )
		{
			continue;
		}

		BOOL32 bKeep = IsMtKeepSatChnnl(tMt, emReplaceType, bySkipVcId, bySkipVcChnnl,
								bySkipVmpChnnl, bySkipHduId, bySkipHduChnnl, bySkipMtId);
		if ( bKeep == TRUE)
		{
			LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[IsSatMtOverConfDCastNum]Mt:%d will continue sending bitrate\n",
				byMtId);
			byConfDCastNum++;
		}
	}

	byConfDCastNum++;
	LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "-IsSatMtOverConfDCastNum-end: using DCastNum:%d conf:%d---------\n\n",
		byConfDCastNum, m_tConf.GetSatDCastChnlNum());
	return byConfDCastNum > m_tConf.GetSatDCastChnlNum();
}

/*
 *	主要看byOprType决定哪些需要过滤
 *	监控有可能要过滤当前VC的当前通道
 *	VMP有可能要过滤Vmp的通道
 */
BOOL32 CMcuVcInst::IsMtKeepSatChnnl(const TMt &tMt, emSatReplaceType emReplaceType,
									const u8 &bySkipVcId /* = 0xff */, const u8 &bySkipVcChnnl /* = 0xff */,
									const u8 &bySkipVmpChnnl /* = 0xff*/, const u8 &bySkipHduId /*= 0xff*/,
									const u8 &bySkipHduChnnl /* = 0xff*/, const u8 &bySkipMtId /*= 0*/ )
{
	if ( tMt.IsNull()
		|| !tMt.IsLocal()
		|| !IsMultiCastMt(tMt.GetMtId())
		|| !IsSatMtSend(tMt) )
	{
		return FALSE;
	}

	u8 byIdx = 0; //一级循环索引

	//1.peri-VMP
	// 停止的时候不用考虑VMP成员了 [pengguofeng 2/28/2013]
	if ( emReplaceType != emVmpStop )
	{
		TVMPParam tConfVmpParam = m_tConf.m_tStatus.GetVmpParam();
		TVMPMember * ptVmpMem = NULL;
		for ( byIdx = 0; byIdx < tConfVmpParam.GetMaxMemberNum(); byIdx++ )
		{
			ptVmpMem = tConfVmpParam.GetVmpMember(byIdx);
			if ( !ptVmpMem
				|| ptVmpMem->IsNull()
				|| !IsMultiCastMt(ptVmpMem->GetMtId())
				|| byIdx == bySkipVmpChnnl
				// 			|| !IsSatMtSend(tMt)
				)
			{
				continue;
			}
			
			if ( (TMt)(* ptVmpMem) == tMt
				&& ( ptVmpMem->GetMemberType() == VMP_MEMBERTYPE_MCSSPEC ||
					( ptVmpMem->GetMemberType() == VMP_MEMBERTYPE_SPEAKER && emSpeaker != emReplaceType )
					 )
				)
			{
				LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "Mt:%d is in vmp chnnl:%d\n", tMt.GetMtId(), byIdx+1);
				return TRUE;
			}
		}
	}

	//2.0. tvWall
	//2.peri-hdu
	u8 byHduEqpId = 0;
	TPeriEqpStatus tHduStatus;
	for (byHduEqpId = HDUID_MIN; byHduEqpId <= HDUID_MAX; byHduEqpId++)
	{
		if(IsValidHduEqp(g_cMcuVcApp.GetEqp(byHduEqpId)))
		{
			u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byHduEqpId));
			if ( byHduChnNum == 0)
			{
				continue;
			}
			if (g_cMcuVcApp.GetPeriEqpStatus(byHduEqpId, &tHduStatus)
				&& tHduStatus.m_byOnline == 1)
			{
				TMt tHduMem;
				u8 byMemberType;
				u8 byMtConfIdx;
				for ( byIdx = 0; byIdx < MAXNUM_HDU_CHANNEL; byIdx++ )
				{
					byMtConfIdx = tHduStatus.m_tStatus.tHdu.atVideoMt[byIdx].GetConfIdx();
					if ( m_byConfIdx != byMtConfIdx )
					{
						continue;
					}

					if ( byHduEqpId == bySkipHduId
						&& byIdx == bySkipHduChnnl)
					{
						continue;
					}
					tHduMem = (TMt)tHduStatus.m_tStatus.tHdu.atVideoMt[byIdx];
					byMemberType = tHduStatus.m_tStatus.tHdu.atVideoMt[byIdx].byMemberType;
					if ( tHduMem == tMt
						&&
							( byMemberType == TW_MEMBERTYPE_MCSSPEC
							|| byMemberType == TW_MEMBERTYPE_CHAIRMAN
							|| byMemberType == TW_MEMBERTYPE_TWPOLL
							|| byMemberType == TW_MEMBERTYPE_BATCHPOLL
							)
						)
					{
						LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "Mt:%d is in hdu[eqp:%d chnnl:%d]\n",
							tMt.GetMtId(), byHduEqpId, byIdx);
						return TRUE;
					}
				}
			}
		}
	}

	//3.select
	TMtStatus tMtSts;
	//3.1 chair select
	m_ptMtTable->GetMtStatus(m_tConf.GetChairman().GetMtId(), &tMtSts);
	if ( emReplaceType != emStopChairSel )
	{
		if ( tMtSts.GetSelectMt(MODE_VIDEO) == tMt )
		{
			if ( emReplaceType == emPoll
				&& ( m_tConf.m_tStatus.GetPollMode() == CONF_POLLMODE_VIDEO_CHAIRMAN
				|| m_tConf.m_tStatus.GetPollMode() == CONF_POLLMODE_BOTH_CHAIRMAN )
				)
			{
				//主席轮询时不用考虑主席看的MT
			}
			else if ( emReplaceType == emChairSel )
			{
				//主席选看不用考虑当前主席看的MT
			}
			else
			{
				LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "Mt:%d is selected by chairman\n",tMt.GetMtId());
				return TRUE;
			}
		}
	}
	//3.2 speaker select
	tMtSts.Clear();
	m_ptMtTable->GetMtStatus(m_tConf.GetSpeaker().GetMtId(), &tMtSts);
	if ( /*m_tConf.GetSpeaker()*/tMt.GetMtId() != bySkipMtId
		//发言人和主席是同一个终端的情况，不要重复判断
		&& m_tConf.GetSpeaker().GetMtId() != m_tConf.GetChairman().GetMtId()
		&& tMtSts.GetSelectMt(MODE_VIDEO) == tMt )
	{
		if ( emReplaceType == emPoll
			&& m_tConf.m_tStatus.GetPollMode() == CONF_POLLMODE_SPEAKER )
		{
			//轮询发言人不用考虑当前发言人看的MT
		}
		else
		{
			LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "Mt:%d is selected by speaker\n",tMt.GetMtId());
			return TRUE;
		}
	}
	//3.3 common select
	//发言人冲普通终端的选看
	if ( emReplaceType != emSpeaker )
	{
		for ( byIdx = 1; byIdx <= MAXNUM_CONF_MT; byIdx++)
		{
			if ( !m_tConfAllMtInfo.MtJoinedConf(byIdx))
			{
				continue;
			}

			if ( byIdx == bySkipMtId )
			{
				continue;//跳过的无视
			}

			if ( byIdx == m_tConf.GetSpeaker().GetMtId()
				|| byIdx == m_tConf.GetChairman().GetMtId() )
			{
				continue;//主席和发言人的已经特殊处理
			}

			if ( !m_ptMtTable->GetMtStatus(byIdx, &tMtSts) )
			{
				continue;
			}

			if ( tMtSts.GetSelectMt(MODE_VIDEO) == tMt )
			{
				LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "Mt:%d is selected by Mt:%d\n", tMt.GetMtId(), byIdx);
				return TRUE;
			}
		}
	}

	//4.poll
	TPollInfo *ptPollInfo = m_tConf.m_tStatus.GetPollInfo();
	if ( ptPollInfo)
	{
		TMt tPollMt = ptPollInfo->GetMtPollParam().GetTMt();
		if ( tPollMt == tMt )
		{
			if ( emReplaceType == emPoll )
			{
			}
			else
			{
				LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "Mt:%d is in poll\n",tMt.GetMtId());
				return TRUE;
			}
		}
	}
	//5.dualsrc
	if ( m_tDoubleStreamSrc == tMt)
	{
		if ( emReplaceType == emSpeaker
			&& m_tConf.GetConfAttrb().GetDualMode() == CONF_DUALMODE_SPEAKERONLY )
		{
			//只允许发言人发双流时也不用管双流源
		}
		else
		{
			LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "Mt:%d is dual src\n",tMt.GetMtId());
			return TRUE;
		}
	}
	//6.vid brd src
	TMt tVidBrdSrc = GetVidBrdSrc();
	if ( tVidBrdSrc == tMt )
	{
		if ( emReplaceType == emSpeaker
			&& tMt == m_tConf.GetSpeaker() )
		{
		}
		else if ( emReplaceType == emPoll
				/*&& m_tConf.m_tStatus.GetPollMode() == CONF_POLLMODE_SPEAKER*/ )
		{
		}
		else if ( emReplaceType == emVmpBrd ) //Vmp广播就不用考虑当前MT在广播视频了
		{
		}
		else
		{
			LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "Mt:%d is boardcast video\n",tMt.GetMtId());
			return TRUE;
		}
	}

	//7.vc monitor
	TMt tMcVidCurSrc;
	u8 byMcId = 0;
	for ( byMcId = 1; byMcId <= (MAXNUM_MCU_MC + MAXNUM_MCU_VC); byMcId++)
	{
		if ( !g_cMcuVcApp.IsMcConnected(byMcId))
		{
			continue;
		}
		for ( byIdx = 0; byIdx < MAXNUM_MC_CHANNL; byIdx++)
		{
			if ( byMcId == bySkipVcId && bySkipVcChnnl == byIdx )
			{
				continue;
			}

			g_cMcuVcApp.GetMcSrc( byMcId, &tMcVidCurSrc, byIdx, MODE_VIDEO );
			if ( tMcVidCurSrc == tMt)
			{
				LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "Mt:%d is in Vc monitor Vc:%d chnnl:%d\n",
					tMt.GetMtId(), byMcId, byIdx+1);
				return TRUE;
			}
		}
	}

	//8.is recorded?
	if ( !m_ptMtTable->IsMtNoRecording(tMt.GetMtId()) )
	{
		LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "Mt:%d is recorded\n", tMt.GetMtId());
		return TRUE;
	}

	//9.default return value
	return FALSE;
}
/*=============================================================================
函 数 名： IsSatMtCanContinue
功    能： 卫星终端能否继续完成该业务
算法实现： 
全局变量： 
参    数：	byNewSatMtId ,  新业务终端
			emSatReplaceType emServiceType,业务类型，与过滤相关，emDefault不过滤任何一个
			ptEqp      所要跳过的外设或监控等
			byChnId    所要跳过的通道
			bySubChnId 所要跳过的子通道，目前只针对HDU四风格有效
			pTVMPParam 开启画面合成时传入的画面合成参数
			返 回 值： BOOL32 TRUE: 可以继续　FALSE: 不能继续
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/04/10  4.7			田志勇                  创建
=============================================================================*/
BOOL32 CMcuVcInst::IsSatMtCanContinue(u8                byNewSatMtId, 
									  emSatReplaceType  emServiceType,
									  TEqp              *ptEqp,
						   			  u8                byChnId,
									  u8                bySubChnId,
									  TVMPParam_25Mem   *pTVMPParam)
{
	if (!m_tConf.GetConfAttrb().IsSatDCastMode())
	{
		LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[IsSatMtCanContinue]Is not  SatDCastConf,So return TRUE\n");
		return TRUE;
	}
	if ((emServiceType == emDefault && byNewSatMtId == 0) || emServiceType > emStartRecord)
	{
		LogPrint(LOG_LVL_WARNING,MID_MCU_CONF,"[IsSatMtCanContinue]NewSatMtId(%d)  emServiceType(%d)  emStartRecord(%d),Return False!\n",
												byNewSatMtId,emServiceType,emStartRecord);
		return FALSE;
	}
	s16  swSatMtNum = GetCurSatMtNum();
	//用位来记录该终端是否在列表中里面了
	u8  abyIsMtInList[MAXNUM_CONF_MT/8]; 
	memset((u8*)abyIsMtInList,0,sizeof(abyIsMtInList));
	u8  byEqpIdx = 0;                          //当前遍历到的外设ID或者监控ID
	u8  byChnIdx = 0;                          //当前遍历到的相关外设通道索引
	u8  byCurLocalMtId = 0;		               //当前遍历到的某个外设通道终端或选看源或监控终端等(本地化后的MTID)
	u8  byChnMemberType = 0;                   //当前遍历到的通道对应类型
	u8  byMtIdIdx = 0;
	LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[IsSatMtCanContinue]byNewSatMtId:%d,emServiceType:%d,ptEqp:(%d,%d),byChnId:%d,bySubChnId:%d,swSatMtNum:%d\n",
											byNewSatMtId,emServiceType,((ptEqp == NULL || ptEqp->IsNull()) ? 65535 : ptEqp->GetMcuIdx()),
											((ptEqp == NULL || ptEqp->IsNull()) ? 0 : ptEqp->GetMtId()),byChnId,bySubChnId,swSatMtNum);
	if (emServiceType == emStartVmp || emServiceType == emVmpChnChange)//开启/调整画面合成业务处理
	{
		if (pTVMPParam != NULL)
		{
			TVMPParam_25Mem tConfVmpParam;
			if (ptEqp)
			{
				tConfVmpParam = g_cMcuVcApp.GetConfVmpParam(*ptEqp);
			}
			TVMPMember *ptConfVmpMember;
			TVMPMember *ptNewVmpMember;
			if (emServiceType == emStartVmp )
			{
				if (pTVMPParam->IsVMPBrdst() && !GetLocalSpeaker().IsNull() && IsMultiCastMt(GetLocalSpeaker().GetMtId()))
				{
					byCurLocalMtId = GetLocalSpeaker().GetMtId();
					if (pTVMPParam->IsTypeInMember(VMP_MEMBERTYPE_SPEAKER) || pTVMPParam->IsMtInMember(GetLocalSpeaker()))
					{
						if (!IsSatMtSend(m_ptMtTable->GetMt(byCurLocalMtId)))
						{
							swSatMtNum--;//发言人要重新占一路,可用数目就要减去一路
							LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[IsSatMtCanContinue]speaker need joined in vmp ,so swSatMtNum--(%d)\n",swSatMtNum);
						}
					} 
					else
					{
						if (IsSatMtCanContinue(byCurLocalMtId))
						{
							if (IsSatMtSend(m_ptMtTable->GetMt(byCurLocalMtId)))
							{
								swSatMtNum++;//发言人可以释放一路，可用数目就要增加一路
								LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[IsSatMtCanContinue]speaker can release,so swSatMtNum++(%d)\n",swSatMtNum);
							}
						}
					}
				}
			}
			else
			{
				//调整成员时，在旧通道里且不在新通道，并且不在其它外设通道中时，可用数目才增加
				for (byChnIdx = 0; byChnIdx < tConfVmpParam.GetMaxMemberNum(); byChnIdx++)
				{
					ptConfVmpMember = tConfVmpParam.GetVmpMember(byChnIdx);
					ptNewVmpMember = pTVMPParam->GetVmpMember(byChnIdx);
					if (NULL == ptConfVmpMember || NULL == ptNewVmpMember || ptConfVmpMember->IsNull())
					{
						continue;
					}
					// 新旧成员相等时，跳过
					if (*ptNewVmpMember == *ptConfVmpMember)
					{
						continue;
					}
					byCurLocalMtId = GetLocalMtFromOtherMcuMt(*(TMt*)ptConfVmpMember).GetMtId();
					// 跳过非卫星终端
					if (byCurLocalMtId == 0 || !IsMultiCastMt(byCurLocalMtId))
					{
						continue;
					}
					// 新通道成员里有该终端，可用数目不增加
					if (pTVMPParam->IsMtInMember(*ptConfVmpMember))
					{
						continue;
					}
					if (IsSatMtCanContinue(byCurLocalMtId, emDefault, ptEqp))
					{
						swSatMtNum++;//可以释放一路，可用数目就要增加一路
						LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[IsSatMtCanContinue]CurLocalMtId.%d can release,so swSatMtNum++(%d)\n", byCurLocalMtId, swSatMtNum);
					}
				}
			}
			for ( byChnIdx = 0; byChnIdx < pTVMPParam->GetMaxMemberNum(); byChnIdx++ )
			{
				byChnMemberType = pTVMPParam->GetVmpMember(byChnIdx)->GetMemberType();
				switch (byChnMemberType)
				{
					case VMP_MEMBERTYPE_SPEAKER:
						byCurLocalMtId = GetLocalSpeaker().GetMtId();
						break;
					case VMP_MEMBERTYPE_CHAIRMAN:
						byCurLocalMtId = m_tConf.GetChairman().GetMtId();
						break;
					case VMP_MEMBERTYPE_POLL:
						byCurLocalMtId = GetLocalMtFromOtherMcuMt(m_tConf.m_tStatus.GetPollInfo()->GetMtPollParam().GetTMt()).GetMtId();
						break;
					case VMP_MEMBERTYPE_DSTREAM:
						byCurLocalMtId = m_tDoubleStreamSrc.GetMtId();
						break;
					default:
						byCurLocalMtId = GetLocalMtFromOtherMcuMt(*(TMt*)pTVMPParam->GetVmpMember(byChnIdx)).GetMtId();
						break;
				}
				if (byCurLocalMtId == 0 || IsSatMtSend(m_ptMtTable->GetMt(byCurLocalMtId)) || !IsMultiCastMt(byCurLocalMtId))
				{
					continue;
				}
				// 开启时已在发，跳过
				if (emServiceType == emStartVmp)
				{
					if (byCurLocalMtId == GetLocalSpeaker().GetMtId())
					{
						continue;
					}
				}
				else
				{
					// 旧通道成员里有该终端，可用数目不减少
					if (tConfVmpParam.IsMtInMember(*ptNewVmpMember))
					{
						continue;
					}
				}
				if ((abyIsMtInList[(byCurLocalMtId-1) / 8] & ( 1 << ( (byCurLocalMtId-1) % 8 ) ) ) == 0)
				{
					abyIsMtInList[(byCurLocalMtId-1) / 8] |= 1 << ( (byCurLocalMtId-1) % 8 );
					swSatMtNum--;
					if (swSatMtNum < 0)
					{
						LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emServiceType == emStartVmp swSatMtNum(%d),Return False\n",swSatMtNum);
						return FALSE;
					}
				}
			}
			LogPrint(LOG_LVL_DETAIL,MID_MCU_CONF,"[IsSatMtCanContinue]emServiceType == emStartVmp swSatMtNum(%d),Return TRUE\n",swSatMtNum);
			return TRUE;
		}
		else
		{
			LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emServiceType == emStartVmp pTVMPParam == NULL,Return False\n");
			return FALSE;
		}
	}
	TPeriEqpStatus tHduStatus;
	if (byNewSatMtId == 0 || swSatMtNum > 0 || (emServiceType != emDefault && IsSatMtSend(m_ptMtTable->GetMt(byNewSatMtId))) || !IsMultiCastMt(byNewSatMtId))
	{
		LogPrint(LOG_LVL_DETAIL,MID_MCU_CONF,"[IsSatMtCanContinue]byNewSatMtId(%d) IsSatMtSending(%d) swSatMtNum(%d)\n",
												byNewSatMtId,IsSatMtSend(m_ptMtTable->GetMt(byNewSatMtId)),swSatMtNum);
		if (emServiceType == emHduBatch)
		{
			if (ptEqp == NULL)
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]ptEqp == NULL,Return False\n");
				return FALSE;
			}
			byEqpIdx = ptEqp->GetEqpId();
			if (!g_cMcuVcApp.GetPeriEqpStatus(byEqpIdx, &tHduStatus) || tHduStatus.m_byOnline != 1)
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emHduBatch::stop GetPeriEqpStatus(%d) Online(%d) wrong,Return False\n",ptEqp->GetEqpId(),tHduStatus.m_byOnline);
				return FALSE;
			}
			TMt tOldHduChnMt = GetLocalMtFromOtherMcuMt((TMt)tHduStatus.m_tStatus.tHdu.atVideoMt[byChnId]);
			if (!tOldHduChnMt.IsNull() && IsMultiCastMt(tOldHduChnMt.GetMtId()))//将老的可释放终端放到里面，以备后用
			{
				//将老的可释放终端放到THduChnStatus::m_byChnIdx里面，以备后用,该字段未被用，atVideoMt里面用于存新的，故不能使用
				tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].SetChnIdx(tOldHduChnMt.GetMtId());
				g_cMcuVcApp.SetPeriEqpStatus( byEqpIdx, &tHduStatus );
				return TRUE;
			}
			if( swSatMtNum > 0 )
			{
				return TRUE;
			}
			else
			{
				// 等于0时，若要判断的终端不是卫星终端，或是已在发送的卫星终端，则仍可返回TRUE
				if (!IsMultiCastMt(byNewSatMtId) || IsSatMtSend(m_ptMtTable->GetMt(byNewSatMtId)))
				{
					return TRUE;
				}
			}
		}
		else
		{
			// emDefault时会判断是否为可释放资源，需要经过下面的一系列判断才能得出，不在此处直接返回TRUE
			if (emServiceType != emDefault)
			{
				return TRUE;
			}
		}
		
	}

	//终端录像业务没有替换业务，故走不到这里，终端录像是先停掉后开，应该走不到这里，如果走到这里就返回FALSE
	if (emServiceType == emStartRecord)
	{
		LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emServiceType(%d) == emStartRecord(%d)\n",emServiceType , emStartRecord);
		return FALSE;
	}

	//根据不同业务获得待释放终端列表，共十种业务，其中emStartVmp emStartRecord两种业务在之前已经处理过了，只有剩余八种才会继续
	u8  abyTempMtList[MAXNUM_CONF_MT];         //作用：用于保存对应业务的可释放终端
	memset((u8*)abyTempMtList,0,sizeof(abyTempMtList));
	TMtStatus tMtSts;
	TVMPParam_25Mem tVMPParam;
	TVMPMember * ptVmpMem = NULL;
	u8 byWaitReleaseMtNum = 0;       //待释放终端数目
	u8 bySubChnIdx = 0;              //
	TMt tMonitorChnMt;               //用于保存从监控通道中取得的终端
	u8 byMtIdx1     = 1;
	//以下代码为根据不同业务获得相应的可释放终端列表
	switch (emServiceType)
	{
		case emDefault:
			break;
		case emSpeaker:
		case emStartPoll:
			if (emServiceType == emSpeaker && !m_tVmpEqp.IsNull())//画面合成在广播时切换发言人直接返回TRUE
			{
				LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[IsSatMtCanContinue]emSpeaker m_tVmpEqp(%d),return TRUE\n",m_tVmpEqp.GetEqpId());
				return TRUE;
			}
			if ((emServiceType == emSpeaker) || 
				(emServiceType == emStartPoll && 
				(CONF_POLLMODE_VIDEO == m_tConf.m_tStatus.GetPollMode() || CONF_POLLMODE_SPEAKER == m_tConf.m_tStatus.GetPollMode())))
			{
				byCurLocalMtId = GetLocalSpeaker().GetMtId();
				if (byCurLocalMtId != 0 && byNewSatMtId != byCurLocalMtId && 
					IsSatMtSend(m_ptMtTable->GetMt(byCurLocalMtId)) && IsMultiCastMt(byCurLocalMtId))
				{
					abyIsMtInList[(byCurLocalMtId-1) / 8] |= 1 << ( (byCurLocalMtId-1) % 8 );
					abyTempMtList[byWaitReleaseMtNum++] = byCurLocalMtId;
				}
			}
			if (emServiceType == emStartPoll)
			{
				byCurLocalMtId = GetLocalMtFromOtherMcuMt(m_tConf.m_tStatus.GetPollInfo()->GetMtPollParam().GetTMt()).GetMtId();
				if (byCurLocalMtId != 0 && byNewSatMtId != byCurLocalMtId && 
					((abyIsMtInList[(byCurLocalMtId-1) / 8] & ( 1 << ( (byCurLocalMtId-1) % 8 ) ) ) == 0) &&
					IsSatMtSend(m_ptMtTable->GetMt(byCurLocalMtId)) && IsMultiCastMt(byCurLocalMtId))
				{
					abyIsMtInList[(byCurLocalMtId-1) / 8] |= 1 << ( (byCurLocalMtId-1) % 8 );
					abyTempMtList[byWaitReleaseMtNum++] = byCurLocalMtId;
				}
			}
			if (emServiceType == emStartPoll && 
				(CONF_POLLMODE_VIDEO_SPY == m_tConf.m_tStatus.GetPollMode() ||
				 CONF_POLLMODE_SPEAKER_SPY == m_tConf.m_tStatus.GetPollMode() ||
				 CONF_POLLMODE_VIDEO_CHAIRMAN == m_tConf.m_tStatus.GetPollMode() ||
				 CONF_POLLMODE_BOTH_CHAIRMAN == m_tConf.m_tStatus.GetPollMode()))
			{	
			}
			else
			{
				for ( byMtIdx1 = 1 ; byMtIdx1 <=  MAXNUM_CONF_MT; byMtIdx1++)
				{
					if (m_ptMtTable->GetMtStatus(byMtIdx1, &tMtSts) )
					{
						byCurLocalMtId = GetLocalMtFromOtherMcuMt(tMtSts.GetSelectMt(MODE_VIDEO)).GetMtId();
						if (byCurLocalMtId != GetLocalSpeaker().GetMtId() && IsSatMtSend(m_ptMtTable->GetMt(byCurLocalMtId)) && IsMultiCastMt(byCurLocalMtId))
						{
							if ((abyIsMtInList[(byCurLocalMtId-1) / 8] & ( 1 << ( (byCurLocalMtId-1) % 8 ) ) ) == 0)
							{
								abyIsMtInList[(byCurLocalMtId-1) / 8] |= 1 << ( (byCurLocalMtId-1) % 8 );
								abyTempMtList[byWaitReleaseMtNum++] = byCurLocalMtId;
							}
						}
					}
				}
			}
			break;
		case emChairMan:
			byCurLocalMtId = m_tConf.GetChairman().GetMtId();
			if (byCurLocalMtId != byNewSatMtId && IsSatMtSend(m_ptMtTable->GetMt(byNewSatMtId)) && IsMultiCastMt(byCurLocalMtId))
			{
				abyIsMtInList[(byCurLocalMtId-1) / 8] |= 1 << ( (byCurLocalMtId-1) % 8 );
				abyTempMtList[0] = byCurLocalMtId;
				byWaitReleaseMtNum = 1;
			}
			break;
		case emVmpChnChange:
			/*if (ptEqp == NULL || ptEqp->GetEqpType() != EQP_TYPE_VMP)
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emVmpChnChange ptEqp is wrong,Return False\n");
				return FALSE;
			}
			tVMPParam = g_cMcuVcApp.GetLastVmpParam(*ptEqp);
			ptVmpMem = tVMPParam.GetVmpMember(byChnId);
			if ( ptVmpMem == NULL )
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emVmpChnChange ptVmpMem == NULL,Return False\n");
				return FALSE;
			}
			byCurLocalMtId = GetLocalMtFromOtherMcuMt(*(TMt *)ptVmpMem).GetMtId();
			if (byCurLocalMtId == 0)
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emVmpChnChange byCurLocalMtId == 0,Return False\n");
				return FALSE;
			}
			if (IsSatMtSend(m_ptMtTable->GetMt(byCurLocalMtId)) && IsMultiCastMt(byCurLocalMtId))
			{
				abyIsMtInList[(byCurLocalMtId-1) / 8] |= 1 << ( (byCurLocalMtId-1) % 8 );
				abyTempMtList[0] = byCurLocalMtId;
				byWaitReleaseMtNum = 1;
			}*/
			break;
		case emStartOrChangeHdu:
			if (ptEqp == NULL || HDUID_MIN > ptEqp->GetEqpId() || HDUID_MAX < ptEqp->GetEqpId() || byChnId > MAXNUM_HDU_CHANNEL)
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emStartOrChangeHdu ptEqp is wrong,Return False\n");
				return FALSE;
			}
			if (ptEqp != NULL && !g_cMcuVcApp.GetPeriEqpStatus(ptEqp->GetEqpId(), &tHduStatus) || tHduStatus.m_byOnline != 1)
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emStartOrChangeHdu GetPeriEqpStatus(%d) Online(%d) wrong,Return False\n",ptEqp->GetEqpId(),tHduStatus.m_byOnline);
				return FALSE;
			}
			if ( HDUCHN_MODE_ONE == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnId) && byChnId < MAXNUM_HDU_CHANNEL)
			{
				/*if (bySubChnId == 0xFF)
				{
					for ( bySubChnIdx = 0 ; bySubChnIdx < HDU_MODEFOUR_MAX_SUBCHNNUM; bySubChnIdx ++)
					{
						byCurLocalMtId = GetLocalMtFromOtherMcuMt((TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byChnId,bySubChnId)).GetMtId();
						if (IsSatMtSend(m_ptMtTable->GetMt(byCurLocalMtId)) && IsMultiCastMt(byCurLocalMtId) &&
							(abyIsMtInList[(byCurLocalMtId-1) / 8] & ( 1 << ( (byCurLocalMtId-1) % 8 ) ) ) == 0)
						{
							abyIsMtInList[(byCurLocalMtId-1) / 8] |= 1 << ( (byCurLocalMtId-1) % 8 );
							abyTempMtList[byWaitReleaseMtNum++] = byCurLocalMtId;
						}
					}
				}
				else
				{*/
					byCurLocalMtId = GetLocalMtFromOtherMcuMt((TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byChnId)).GetMtId();
					if (IsSatMtSend(m_ptMtTable->GetMt(byCurLocalMtId)) && IsMultiCastMt(byCurLocalMtId))
					{
						abyIsMtInList[(byCurLocalMtId-1) / 8] |= 1 << ( (byCurLocalMtId-1) % 8 );
						abyTempMtList[0] = byCurLocalMtId;
						byWaitReleaseMtNum = 1;
					}
				//}
			}
			else if ( HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnId) && byChnId < MAXNUM_HDU_CHANNEL )
			{
				if (bySubChnId < HDU_MODEFOUR_MAX_SUBCHNNUM)
				{
					byCurLocalMtId = GetLocalMtFromOtherMcuMt((TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byChnId,bySubChnId)).GetMtId();
					if (IsSatMtSend(m_ptMtTable->GetMt(byCurLocalMtId)) && IsMultiCastMt(byCurLocalMtId))
					{
						abyIsMtInList[(byCurLocalMtId-1) / 8] |= 1 << ( (byCurLocalMtId-1) % 8 );
						abyTempMtList[0] = byCurLocalMtId;
						byWaitReleaseMtNum = 1;
					}
				} 
				else
				{
					LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emStartOrChangeHdu bySubChnId(%d) is wrong,Return False\n",bySubChnId);
					return FALSE;
				}
			}
			else
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emStartOrChangeHdu CurHduMode(%d) is wrong,Return False\n",
															tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnId));
				return FALSE;
			}
			break;
		case emHduBatch:
			{
				if (ptEqp == NULL || HDUID_MIN > ptEqp->GetEqpId() || HDUID_MAX < ptEqp->GetEqpId() || byChnId > MAXNUM_HDU_CHANNEL)
				{
					LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emHduBatch ptEqp is wrong,Return False\n");
					return FALSE;
				}
				for ( byChnIdx = 0; byChnIdx < m_tHduBatchPollInfo.GetChnlPollNum(); byChnIdx++ )
				{
					byEqpIdx = m_tHduBatchPollInfo.m_tChnlBatchPollInfo[byChnIdx].GetEqpId();
					byChnIdx = m_tHduBatchPollInfo.m_tChnlBatchPollInfo[byChnIdx].GetChnlIdx();
					if (ptEqp != NULL && !g_cMcuVcApp.GetPeriEqpStatus(ptEqp->GetEqpId(), &tHduStatus) || tHduStatus.m_byOnline != 1)
					{
						LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emHduBatch GetPeriEqpStatus(%d) Online(%d) wrong,Return False\n",
							ptEqp != NULL ? ptEqp->GetEqpId() : 0,tHduStatus.m_byOnline);
						continue;
					}
					if ( HDUCHN_MODE_ONE == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnIdx) )
					{
						if (tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnIdx) == THduChnStatus::eWAITSTART)
						{
							byCurLocalMtId = tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnIdx].GetChnIdx();
						}
						else
						{
							byCurLocalMtId = GetLocalMtFromOtherMcuMt((TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byChnIdx)).GetMtId();
						}
						if (byCurLocalMtId == 0 || !IsMultiCastMt(byCurLocalMtId))
						{
							continue;
						}
						if ((abyIsMtInList[(byCurLocalMtId-1) / 8] & ( 1 << ( (byCurLocalMtId-1) % 8 ) ) ) == 0 &&
							IsSatMtSend(m_ptMtTable->GetMt(byCurLocalMtId)) && IsMultiCastMt(byCurLocalMtId))
						{
							abyIsMtInList[(byCurLocalMtId-1) / 8] |= 1 << ( (byCurLocalMtId-1) % 8 );
							abyTempMtList[byWaitReleaseMtNum++] = byCurLocalMtId;
						}
					}
					else if ( HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnIdx))
					{
						for ( bySubChnIdx = 0 ; bySubChnIdx < HDU_MODEFOUR_MAX_SUBCHNNUM; bySubChnIdx ++)
						{
							if (tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnIdx,bySubChnIdx) == THduChnStatus::eWAITSTART)
							{
								byCurLocalMtId = tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnIdx].GetChnIdx();
							}
							else
							{
								byCurLocalMtId = GetLocalMtFromOtherMcuMt((TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byChnIdx,bySubChnIdx)).GetMtId();
							}
							if (byCurLocalMtId == 0 || !IsMultiCastMt(byCurLocalMtId))
							{
								continue;
							}
							if ((abyIsMtInList[(byCurLocalMtId-1) / 8] & ( 1 << ( (byCurLocalMtId-1) % 8 ) ) ) == 0 &&
								IsSatMtSend(m_ptMtTable->GetMt(byCurLocalMtId)) && IsMultiCastMt(byCurLocalMtId))
							{
								abyIsMtInList[(byCurLocalMtId-1) / 8] |= 1 << ( (byCurLocalMtId-1) % 8 );
								abyTempMtList[byWaitReleaseMtNum++] = byCurLocalMtId;
							}
						}
					}
					else
					{
						LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emHduBatch CurHduMode(%d) is wrong,Return False\n",
							tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnId));
						return FALSE;
					}
				}
			}
			break;
		case emSelect:
			if (ptEqp == NULL || !m_ptMtTable->GetMtStatus(ptEqp->GetMtId(), &tMtSts))
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emSelect ptEqp is wrong,Return False\n");
				break;
			}
			byCurLocalMtId = GetLocalMtFromOtherMcuMt(tMtSts.GetSelectMt(MODE_VIDEO)).GetMtId();
			if (IsSatMtSend(m_ptMtTable->GetMt(byCurLocalMtId)) && IsMultiCastMt(byCurLocalMtId))
			{
				abyIsMtInList[(byCurLocalMtId-1) / 8] |= 1 << ( (byCurLocalMtId-1) % 8 );
				abyTempMtList[0] = byCurLocalMtId;
				byWaitReleaseMtNum = 1;
			}
			break;
		case emStartOrChangeMonitor:
			if (ptEqp == NULL || !g_cMcuVcApp.GetMcSrc( ptEqp->GetEqpId(), &tMonitorChnMt, byChnId, MODE_VIDEO ))
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emStartOrChangeMonitor ptEqp is wrong,Return False\n");
				break;
			}
			byCurLocalMtId = GetLocalMtFromOtherMcuMt(tMonitorChnMt).GetMtId();
			if (IsSatMtSend(m_ptMtTable->GetMt(byCurLocalMtId)) && IsMultiCastMt(byCurLocalMtId))
			{
				abyIsMtInList[(byCurLocalMtId-1) / 8] |= 1 << ( (byCurLocalMtId-1) % 8 );
				abyTempMtList[0] = byCurLocalMtId;
				byWaitReleaseMtNum = 1;
			}
			break;
		case emstartDs:
			byCurLocalMtId = m_tDoubleStreamSrc.GetMtId();
			if (IsSatMtSend(m_ptMtTable->GetMt(byCurLocalMtId)) && IsMultiCastMt(byCurLocalMtId))
			{
				abyIsMtInList[(byCurLocalMtId-1) / 8] |= 1 << ( (byCurLocalMtId-1) % 8 );
				abyTempMtList[0] = byCurLocalMtId;
				byWaitReleaseMtNum = 1;
			}
			break;
		default:
			LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]unknown emServiceType(%d)\n",emServiceType);
			return FALSE;
	}
	
	if (byWaitReleaseMtNum == 0 && emServiceType != emDefault)
	{
		if (emServiceType == emSpeaker || emServiceType == emChairMan)
		{
			//遍历画面合成通道
			for (byEqpIdx = 0; byEqpIdx < MAXNUM_CONF_VMP; byEqpIdx++)
			{
				if (!IsValidVmpId(m_abyVmpEqpId[byEqpIdx]))
				{
					continue;
				}
				tVMPParam = g_cMcuVcApp.GetLastVmpParam(g_cMcuVcApp.GetEqp( m_abyVmpEqpId[byEqpIdx] ));
				for ( byChnIdx = 0; byChnIdx < tVMPParam.GetMaxMemberNum(); byChnIdx++ )
				{
					ptVmpMem = tVMPParam.GetVmpMember(byChnIdx);
					if ( ptVmpMem == NULL )
					{
						continue;
					}
					byChnMemberType = ptVmpMem->GetMemberType();
					if ((emServiceType == emSpeaker && byChnMemberType == VMP_MEMBERTYPE_SPEAKER) ||
						(emServiceType == emChairMan && byChnMemberType == VMP_MEMBERTYPE_CHAIRMAN))
					{
						LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]OperaType(%d) NoReleaseMt VMP(%d,%d) ChnType(%d),return FALSE\n",
							emServiceType,m_abyVmpEqpId[byEqpIdx],byChnIdx,byChnMemberType);
						return FALSE;
					}
				}
			}

			//遍历HDU通道
			for (byEqpIdx = HDUID_MIN; byEqpIdx <= HDUID_MAX; byEqpIdx++)
			{
				if (g_cMcuVcApp.GetPeriEqpStatus(byEqpIdx, &tHduStatus) && tHduStatus.m_byOnline == 1)
				{
					for ( byChnIdx = 0; byChnIdx < MAXNUM_HDU_CHANNEL; byChnIdx++ )
					{
						byChnMemberType = tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnIdx);
						if ( HDUCHN_MODE_ONE == byChnMemberType)
						{
							byChnMemberType = tHduStatus.m_tStatus.tHdu.atVideoMt[byChnIdx].byMemberType;
							if ((emServiceType == emSpeaker  && byChnMemberType == TW_MEMBERTYPE_SPEAKER) ||
								(emServiceType == emChairMan && byChnMemberType == TW_MEMBERTYPE_CHAIRMAN))
							{
								LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]OperaType(%d) NoReleaseMt HDU(%d,%d) ChnType(%d),return FALSE\n",
									emServiceType,byEqpIdx,byChnIdx,byChnMemberType);
								return FALSE;
							}
						}
					}
				}
			}
			if (emServiceType == emSpeaker)
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emSpeaker NoReleaseMtNum,return FALSE\n",emServiceType);
				return FALSE;
			}
			return TRUE;
		}
		LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]1.emServiceType(%d) NoReleaseMtNum,return FALSE\n",emServiceType);
		return FALSE;
	}

	for (byMtIdIdx = 0; byMtIdIdx < byWaitReleaseMtNum ; byMtIdIdx++ )
	{
		LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[IsSatMtCanContinue]abyTempMtList[%d]:%d\n",byMtIdIdx,abyTempMtList[byMtIdIdx]);
	}

	u8 byMtIdx = 0;
	BOOL32 bIsCanNext =  FALSE;          //是否可以直接跳到下个
	if (emServiceType == emDefault)
	{
		abyTempMtList[0] = byNewSatMtId;
		byWaitReleaseMtNum = 1;
	}
	for ( byMtIdIdx = 0 ; byMtIdIdx < byWaitReleaseMtNum ; byMtIdIdx++ )
	{
		bIsCanNext = FALSE;
		//未开画面合成广播时是否在发言
		byCurLocalMtId = GetLocalSpeaker().GetMtId();
		if (m_tVmpEqp.IsNull() && abyTempMtList[byMtIdIdx] == byCurLocalMtId && emServiceType != emDefault && emServiceType != emSpeaker &&
			!(emServiceType == emStartPoll && (CONF_POLLMODE_VIDEO == m_tConf.m_tStatus.GetPollMode() || CONF_POLLMODE_SPEAKER == m_tConf.m_tStatus.GetPollMode())))
		{
			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[IsSatMtCanContinue]Mt(%d) is speaking!\n",byCurLocalMtId);
			continue;
		}
		//是否在发双流
		byCurLocalMtId = m_tDoubleStreamSrc.GetMtId();
		if (abyTempMtList[byMtIdIdx] == byCurLocalMtId && 
			!(emServiceType == emstartDs  || 
			(emServiceType == emSpeaker && m_tConf.GetConfAttrb().GetDualMode() == CONF_DUALMODE_SPEAKERONLY))
			)
		{
			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[IsSatMtCanContinue]Mt(%d) is sending DS!\n",byCurLocalMtId);
			continue;
		}
		
		//是否是录像终端
		byCurLocalMtId = abyTempMtList[byMtIdIdx];
		if (!m_ptMtTable->IsMtNoRecording(byCurLocalMtId))
		{
			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[IsSatMtCanContinue]Mt(%d) is Recording!\n",byCurLocalMtId);
			continue;
		}
		
		//是否当前轮训终端
		byCurLocalMtId = GetLocalMtFromOtherMcuMt(m_tConf.m_tStatus.GetPollInfo()->GetMtPollParam().GetTMt()).GetMtId();
		if (emServiceType != emStartPoll && 
			abyTempMtList[byMtIdIdx] == byCurLocalMtId)
		{
			LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[IsSatMtCanContinue]Mt(%d) is Polling!\n",byCurLocalMtId);
			continue;
		}

		//遍历画面合成通道
		for (byEqpIdx = 0; byEqpIdx < MAXNUM_CONF_VMP; byEqpIdx++)
		{
			if (!IsValidVmpId(m_abyVmpEqpId[byEqpIdx]))
			{
				continue;
			}
			// default时，跳过传入的指定vmp
			if (emDefault == emServiceType && ptEqp != NULL && ptEqp->GetEqpId() == m_abyVmpEqpId[byEqpIdx])
			{
				continue;
			}
			tVMPParam = g_cMcuVcApp.GetLastVmpParam(g_cMcuVcApp.GetEqp( m_abyVmpEqpId[byEqpIdx] ));
			for ( byChnIdx = 0; byChnIdx < tVMPParam.GetMaxMemberNum(); byChnIdx++ )
			{
				ptVmpMem = tVMPParam.GetVmpMember(byChnIdx);
				if (emVmpChnChange == emServiceType && ptEqp != NULL && ptEqp->GetEqpId() == m_abyVmpEqpId[byEqpIdx] && byChnIdx == byChnId)
				{
					continue;
				}
				if ( ptVmpMem == NULL )
				{
					continue;
				}
				byChnMemberType = ptVmpMem->GetMemberType();
				byCurLocalMtId = GetLocalMtFromOtherMcuMt(*(TMt *)ptVmpMem).GetMtId();
				if (byCurLocalMtId == 0)
				{
					continue;
				}
				if (abyTempMtList[byMtIdIdx] == byCurLocalMtId && 
					(byChnMemberType == VMP_MEMBERTYPE_MCSSPEC ||
					 (emServiceType == emSpeaker && byChnMemberType != VMP_MEMBERTYPE_SPEAKER) ||
					 (emServiceType == emChairMan && byChnMemberType != VMP_MEMBERTYPE_CHAIRMAN) ||
					 (emServiceType == emStartPoll && 
						!(byChnMemberType == VMP_MEMBERTYPE_POLL || 
						 (byChnMemberType == VMP_MEMBERTYPE_SPEAKER && CONF_POLLMODE_SPEAKER == m_tConf.m_tStatus.GetPollMode())))))
				{
					LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[IsSatMtCanContinue]OperaType(%d) ReleaseMt(%d) VMP(%d,%d) ChnType(%d)\n",
							emServiceType,byCurLocalMtId,m_abyVmpEqpId[byEqpIdx],byChnIdx,byChnMemberType);
					bIsCanNext = TRUE;
					break;
				}
			}
			if (bIsCanNext) break;
		}
		if (bIsCanNext) continue;

		//遍历HDU通道
		for (byEqpIdx = HDUID_MIN; byEqpIdx <= HDUID_MAX; byEqpIdx++)
		{
			if (g_cMcuVcApp.GetPeriEqpStatus(byEqpIdx, &tHduStatus) && tHduStatus.m_byOnline == 1)
			{
				for ( byChnIdx = 0; byChnIdx < MAXNUM_HDU_CHANNEL; byChnIdx++ )
				{
					if (emHduBatch == emServiceType && m_tHduBatchPollInfo.GetHduSchemeIdx() == tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnIdx].GetSchemeIdx())
					{
						continue;
					}
					byChnMemberType = tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnIdx);
					if ( HDUCHN_MODE_ONE == byChnMemberType)
					{
						if (emStartOrChangeHdu == emServiceType && ptEqp != NULL && ptEqp->GetEqpId() == byEqpIdx && byChnIdx == byChnId)
						{
							continue;
						}
						byChnMemberType = tHduStatus.m_tStatus.tHdu.atVideoMt[byChnIdx].byMemberType;
						byCurLocalMtId = GetLocalMtFromOtherMcuMt((TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byChnIdx)).GetMtId();
						if (byCurLocalMtId == 0)
						{
							continue;
						}
						if (abyTempMtList[byMtIdIdx] == byCurLocalMtId && 
							(byChnMemberType == TW_MEMBERTYPE_MCSSPEC ||
							(emServiceType == emSpeaker && byChnMemberType != TW_MEMBERTYPE_SPEAKER) ||
							(emServiceType == emChairMan && byChnMemberType != TW_MEMBERTYPE_CHAIRMAN) ||
							(emServiceType == emStartPoll && 
								!(byChnMemberType == TW_MEMBERTYPE_POLL || 
								 (byChnMemberType == TW_MEMBERTYPE_SPEAKER && CONF_POLLMODE_SPEAKER == m_tConf.m_tStatus.GetPollMode())))))
						{
							LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[IsSatMtCanContinue]OperaType(%d) ReleaseMt(%d) HDU(%d,%d) ChnType(%d)\n",
									emServiceType,byCurLocalMtId,byEqpIdx,byChnIdx,byChnMemberType);
							bIsCanNext = TRUE;
							break;
						}
					}
					else if ( HDUCHN_MODE_FOUR == byChnMemberType)
					{
						for ( bySubChnIdx = 0 ; bySubChnIdx < HDU_MODEFOUR_MAX_SUBCHNNUM; bySubChnIdx ++)
						{
							if (emServiceType == emStartOrChangeHdu && ptEqp != NULL && ptEqp->GetEqpId() == byEqpIdx && ptEqp != NULL &&
								byChnIdx == byChnId && bySubChnIdx == bySubChnId)
							{
								continue;
							}
							byCurLocalMtId = GetLocalMtFromOtherMcuMt((TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byChnIdx,bySubChnIdx)).GetMtId();
							if (byCurLocalMtId == 0)
							{
								continue;
							}
							if (abyTempMtList[byMtIdIdx] == byCurLocalMtId)
							{
								LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[IsSatMtCanContinue]OperaType(%d) ReleaseMt(%d) HDU(%d,%d,%d) ChnType(%d)\n",
									emServiceType,byCurLocalMtId,byEqpIdx,byChnIdx,bySubChnIdx,byChnMemberType);
								bIsCanNext = TRUE;
								break;
							}
						}
					}
					else
					{
						continue;
					}
					if (bIsCanNext) break;
				}
				if (bIsCanNext) break;
			}
		}
		if (bIsCanNext) continue;

		//对选看进行遍历
		if (emServiceType == emDefault || emServiceType == emSpeaker ||
			(emServiceType == emStartPoll && 
			(CONF_POLLMODE_VIDEO == m_tConf.m_tStatus.GetPollMode() || CONF_POLLMODE_SPEAKER == m_tConf.m_tStatus.GetPollMode())))
		{
			if (!m_tConf.GetChairman().IsNull())
			{
				if (m_ptMtTable->GetMtStatus(m_tConf.GetChairman().GetMtId(), &tMtSts) )
				{
					byCurLocalMtId = GetLocalMtFromOtherMcuMt(tMtSts.GetSelectMt(MODE_VIDEO)).GetMtId();
					if (abyTempMtList[byMtIdIdx] == byCurLocalMtId)
					{
						LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[IsSatMtCanContinue]ChairMan(%d) is seeing ReleaseMt(%d)\n",
																	m_tConf.GetChairman().GetMtId(),byCurLocalMtId);
						continue;
					}
				}
			}
		}
		else
		{
			for ( byMtIdx1 = 1; byMtIdx1 <= MAXNUM_CONF_MT ; byMtIdx1++)
			{
				if ((emServiceType == emSelect && ptEqp != NULL && byMtIdx1 == ptEqp->GetMtId()) ||
					(emServiceType == emStartPoll &&
						(((CONF_POLLMODE_VIDEO_CHAIRMAN == m_tConf.m_tStatus.GetPollMode() || CONF_POLLMODE_BOTH_CHAIRMAN == m_tConf.m_tStatus.GetPollMode()) &&
					      byMtIdx1 == m_tConf.GetChairman().GetMtId()) ||
						 ((CONF_POLLMODE_VIDEO_SPY == m_tConf.m_tStatus.GetPollMode() || CONF_POLLMODE_SPEAKER_SPY == m_tConf.m_tStatus.GetPollMode()) &&
						  byMtIdx1 == m_tCascadeMMCU.GetMtId()))))
				{
					continue;
				}
				if (m_ptMtTable->GetMtStatus(byMtIdx1, &tMtSts) )
				{
					byCurLocalMtId = GetLocalMtFromOtherMcuMt(tMtSts.GetSelectMt(MODE_VIDEO)).GetMtId();
					if (abyTempMtList[byMtIdIdx] == byCurLocalMtId)
					{
						LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[IsSatMtCanContinue]Mt(%d) is seeing ReleaseMt(%d)\n",
																	byMtIdx1,byCurLocalMtId);
						bIsCanNext = TRUE;
						break;
					}
				}
			}
			if (bIsCanNext) continue;
		}

		//监控通道
		for ( byEqpIdx = 1; byEqpIdx <= MAXNUM_MCU_MC ; byEqpIdx++)
		{
			if ( !g_cMcuVcApp.IsMcConnected(byEqpIdx))
			{
				continue;
			}
			for ( byChnIdx = 0; byChnIdx < MAXNUM_MC_CHANNL; byChnIdx++)
			{
				if (emServiceType == emStartOrChangeMonitor && ptEqp != NULL && ptEqp->GetEqpId() == byEqpIdx && byChnIdx == byChnId)
				{
					continue;
				}
				g_cMcuVcApp.GetMcSrc( byEqpIdx, &tMonitorChnMt, byChnIdx, MODE_VIDEO );
				byCurLocalMtId = GetLocalMtFromOtherMcuMt(tMonitorChnMt).GetMtId();
				if (byCurLocalMtId == 0)
				{
					continue;
				}
				if (abyTempMtList[byMtIdIdx] == byCurLocalMtId)
				{	
					LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[IsSatMtCanContinue]OperaType(%d) ReleaseMt(%d) Monitor(%d,%d) ChnType(%d)\n",
																emServiceType,byCurLocalMtId,byEqpIdx,byChnIdx);
					bIsCanNext = TRUE;
					break;
				}
			}
			if (bIsCanNext) break;
		}
		if (bIsCanNext) continue;
		if (emServiceType == emHduBatch)
		{
			//批量轮训通道有可释放终端的可以将通道停掉，下次不必再作为可释放终端了
			for ( byChnIdx = 0; byChnIdx < m_tHduBatchPollInfo.GetChnlPollNum(); byChnIdx++ )
			{
				byEqpIdx = m_tHduBatchPollInfo.m_tChnlBatchPollInfo[byChnIdx].GetEqpId();
				byChnIdx = m_tHduBatchPollInfo.m_tChnlBatchPollInfo[byChnIdx].GetChnlIdx();
				if (ptEqp != NULL && (!g_cMcuVcApp.GetPeriEqpStatus(ptEqp->GetEqpId(), &tHduStatus) || tHduStatus.m_byOnline != 1))
				{
					LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emHduBatch::stop GetPeriEqpStatus(%d) Online(%d) wrong,Return False\n",ptEqp->GetEqpId(),tHduStatus.m_byOnline);
					continue;
				}
				if ( HDUCHN_MODE_ONE == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnIdx) )
				{
					byCurLocalMtId = GetLocalMtFromOtherMcuMt((TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byChnIdx)).GetMtId();
					if (abyTempMtList[byMtIdIdx] == byCurLocalMtId)
					{
						if (tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnIdx) == THduChnStatus::eWAITSTART)
						{
							//不再作为可释放终端清理掉
							tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].SetChnIdx(0);
							g_cMcuVcApp.SetPeriEqpStatus( byEqpIdx, &tHduStatus );
						} 
						else
						{
							ChangeHduSwitch( NULL, byEqpIdx, byChnIdx, 0,TW_MEMBERTYPE_BATCHPOLL, TW_STATE_STOP);
						}
					}
				}
				else if ( HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnIdx))
				{
					for ( bySubChnIdx = 0 ; bySubChnIdx < HDU_MODEFOUR_MAX_SUBCHNNUM; bySubChnIdx ++)
					{
						byCurLocalMtId = GetLocalMtFromOtherMcuMt((TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byChnIdx,bySubChnIdx)).GetMtId();
						if (abyTempMtList[byMtIdIdx] == byCurLocalMtId)
						{
							if (tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnIdx) == THduChnStatus::eWAITSTART)
							{
								//不再作为可释放终端清理掉
								tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnId].SetChnIdx(0);
								g_cMcuVcApp.SetPeriEqpStatus( byEqpIdx, &tHduStatus );
							} 
							else
							{
								ChangeHduSwitch( NULL, byEqpIdx, byChnIdx, bySubChnIdx,
									TW_MEMBERTYPE_BATCHPOLL, TW_STATE_STOP, MODE_VIDEO, FALSE, TRUE, TRUE, HDUCHN_MODE_FOUR);
							}
						}
					}
				}
				else
				{
					LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]emHduBatch::stop CurHduMode(%d) is wrong,Return False\n",
						tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnId));
					return FALSE;
				}
			}
		}
		LogPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[IsSatMtCanContinue]emServiceType(%d) ReleaseMt(%d),return TRUE\n",emServiceType,abyTempMtList[byMtIdIdx] );
		return TRUE;
	}
	LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsSatMtCanContinue]2.emServiceType(%d) NoReleaseMtNum,return FALSE\n",emServiceType);
	return FALSE;
}
/*=============================================================================
函 数 名： IsMtInMcSrc
功    能：  终端是否在会控监控
算法实现： 
全局变量： 
参    数： u8 byMtId
           u8 byMode
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/8/23  4.0			许世林                  创建
=============================================================================*/
BOOL32 CMcuVcInst::IsMtInMcSrc(u8 byMtId, u8 byMode)
{
    TLogicalChannel tLogicalChannel;
    TMt tMt;
    for( u8 byIndex = 1; byIndex <= (MAXNUM_MCU_MC + MAXNUM_MCU_VC); byIndex++ )
	{
		if( g_cMcuVcApp.IsMcConnected( byIndex ) )
		{
			u8 byChannelNum;
			if( g_cMcuVcApp.GetMcLogicChnnl( byIndex, byMode, &byChannelNum, &tLogicalChannel ) )
			{
				while( byChannelNum-- != 0 )
				{
					if( g_cMcuVcApp.GetMcSrc( byIndex, &tMt, byChannelNum, byMode ) )
					{
						if (tMt.GetMtId() == byMtId)
                        {
                            return TRUE;
                        }
					}
				}
			}
		}
	}

    return FALSE;
}

/*====================================================================
函数名      ：GetCanRlsNumInVcsMc
功能        ：获取vcs会议中正在监控终端tMt的总数。多个vcs连同一mcu，每个vcs都有一路监控
算法实现    ：
引用全局变量：
输入参数说明：TMt & tMt, 指定终端
			  u8 byMode, 交换模式
返回值说明  ：无
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
03/06/26    4.6         zhangli           创建
====================================================================*/
u8 CMcuVcInst::GetCanRlsNumInVcsMc(TMt &tMt, u8 byMode)
{
	if (tMt.IsNull())
	{
		return 0;
	}
	
	u8 byNum = 0;
    TMt tMcSrc;
    for(u16 wMcIndex = MAXNUM_MCU_VC+1; wMcIndex <= (MAXNUM_MCU_MC + MAXNUM_MCU_VC); ++wMcIndex)
	{
		//普通监控窗口
		tMcSrc.SetNull();
		if (g_cMcuVcApp.IsMcConnected(wMcIndex)
			&& g_cMcuVcApp.GetMcSrc(wMcIndex, &tMcSrc, VCS_VCMT_MCCHLIDX, byMode)
			&& tMcSrc == tMt)
		{
			byNum++;
		}
		
		//视频源控制 || 摄像机控制监控窗口
		tMcSrc.SetNull();
		if (g_cMcuVcApp.IsMcConnected(wMcIndex)
			&& g_cMcuVcApp.GetMcSrc(wMcIndex, &tMcSrc, VCS_MONITORCTRL_MCCHLIDX, byMode)
			&& tMcSrc == tMt)
		{
			byNum++;
		}
		// 		for(u8 byChidx = 0; byChidx < MAXNUM_MC_CHANNL; ++byChidx)
		// 		{
		// 			tMcSrc.SetNull();
		// 			if (g_cMcuVcApp.IsMcConnected(wMcIndex)
		// 				&& g_cMcuVcApp.GetMcSrc(wMcIndex, &tMcSrc, byChidx, byMode)
		// 				&& tMcSrc == tMt)
		// 			{
		// 				byNum++;
		// 			}
		// 		}
	}
	return byNum;
}

/*====================================================================
    函数名      ：RestoreAllSubMtJoinedConfWatchingSrcMt
    功能        ：1. 与会终端中谁的视(音)频源为tSrc的, 若会议有发言人，
                     则收看(听)发言人，无发言人，停止向其的交换。
                  2. 未收视频源的不要停。
                  3. 在停止了向某与会终端的交换后，检查最后选看终端是否为空，
                     若不为空，则再将选看终端的视频源交换到该与会终端。
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt & tSrc, 指定终端 
				  u8 byMode, 交换模式，缺省为MODE_BOTH
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/26    1.0         JQL           创建
    06/04/14    4.0         张宝卿        停tSrc的交换后，判断恢复选看交换
====================================================================*/
BOOL32 CMcuVcInst::RestoreAllSubMtJoinedConfWatchingSrcMt(TMt tSrc, u8 byMode,BOOL32 bIsStopSel /*=TRUE*/  )
{
	TMt tCurSrc,tSelMt;
	u8  byMtLoop;
	TMtStatus tStat;

	//lukunpeng 2010/06/08 音视频源非local化后，不能对tSrc local化。
// 	if (!tSrc.IsLocal() && !IsLocalAndSMcuSupMultSpy(tSrc.GetMcuId()))
// 	{
// 		tSrc = GetLocalMtFromOtherMcuMt(tSrc);
// 	}

	/*u16 wSrcMcuIdx = INVALID_MCUIDX;
	if( tSrc.IsLocal() &&
		MT_TYPE_SMCU == m_ptMtTable->GetMtType(tSrc.GetMtId())
		)
	{
		wSrcMcuIdx = GetMcuIdxFromMcuId( tSrc.GetMtId() );
	}*/
	
	u8 byVidMtNum = 0;
	u8 byAudMtNum = 0;
	TMt atVidDstMt[MAXNUM_CONF_MT];
	TMt atAudDstMt[MAXNUM_CONF_MT];

	for( byMtLoop = 1; byMtLoop <= MAXNUM_CONF_MT; byMtLoop++ )
	{
		if( m_tConfAllMtInfo.MtJoinedConf( byMtLoop ) )
		{
			if (m_ptMtTable->GetMtType(byMtLoop) == MT_TYPE_VRSREC)
			{
				//跳过vrs新录播实体
				continue;
			}

			m_ptMtTable->GetMtStatus(byMtLoop, &tStat);
			
		    if( byMode == MODE_VIDEO || byMode == MODE_BOTH )
			{				
				m_ptMtTable->GetMtSrc( byMtLoop, &tCurSrc, MODE_VIDEO ); 
				tSelMt = tStat.GetSelectMt(MODE_VIDEO);
				if ( bIsStopSel && (tSelMt == tSrc 
					|| ( tSrc.IsLocal() && m_ptMtTable->GetMtType(tSrc.GetMtId() ) == MT_TYPE_SMCU && 
								IsMtInMcu( tSrc,tSelMt ) 
								) )
					)
				{
					StopSelectSrc(m_ptMtTable->GetMt(byMtLoop), MODE_VIDEO, FALSE, FALSE);
					atVidDstMt[byVidMtNum] = m_ptMtTable->GetMt( byMtLoop );
					byVidMtNum++;
				}
				else
				{
					if( !bIsStopSel && !tSelMt.IsNull() )
					{

					}
					else if( (bIsStopSel || !(tSelMt == tSrc)) && (GetLocalMtFromOtherMcuMt(tCurSrc) == tSrc || tCurSrc == tSrc )
							)
					{
						/*if(tSrc == m_tVmpEqp && m_tConf.m_tStatus.IsVmpSeeByChairman()
							&& m_tConf.GetChairman().GetMtId() == byMtLoop )
						{
							// xliang [4/2/2009] VMP 继续将码流给该MT，所以此处不停交换
						}
						else*/
						{
							//非KEDA厂商看自己，KEDA停交换
							//RestoreRcvMediaBrdSrc( byMtLoop, MODE_VIDEO, FALSE,wSpyStartPort );
							atVidDstMt[byVidMtNum] = m_ptMtTable->GetMt( byMtLoop );
							byVidMtNum++;
						}
						//判断恢复选看
	//                    RestoreMtSelectStatus( byMtLoop, MODE_VIDEO );
					}
				}			    
			}

			if(byMode == MODE_VIDEO2SECOND) 
			{
				tSelMt = m_ptMtTable->GetMtSelMtByMode(byMtLoop, MODE_VIDEO2SECOND);
				if (bIsStopSel && (tSelMt == tSrc
					|| (tSrc.IsLocal() && m_ptMtTable->GetMtType(tSrc.GetMtId()) == MT_TYPE_SMCU && IsMtInMcu(tSrc,tSelMt))))
				{
					StopSelectSrc(m_ptMtTable->GetMt(byMtLoop), MODE_VIDEO2SECOND);
				}
			}

            if( byMode == MODE_AUDIO || byMode == MODE_BOTH ) 
			{
				m_ptMtTable->GetMtSrc( byMtLoop, &tCurSrc, MODE_AUDIO ); 

				tSelMt = tStat.GetSelectMt(MODE_AUDIO);
				if ( bIsStopSel && ( tSelMt == tSrc
					|| ( tSrc.IsLocal() && m_ptMtTable->GetMtType(tSrc.GetMtId() ) == MT_TYPE_SMCU
							&&  IsMtInMcu(tSrc,tSelMt) ) )/*INVALID_MCUIDX != wSrcMcuIdx && 
					tStat.GetSelectMt(MODE_VIDEO).GetMcuIdx() == wSrcMcuIdx */
					)
				{
					StopSelectSrc(m_ptMtTable->GetMt(byMtLoop), MODE_AUDIO, FALSE);
					atAudDstMt[byAudMtNum] = m_ptMtTable->GetMt( byMtLoop );
					byAudMtNum++;
				}
				else
				{
					if( !bIsStopSel && !tSelMt.IsNull() )
					{

					}
					else if( (bIsStopSel || !(tSelMt == tSrc)) && (GetLocalMtFromOtherMcuMt(tCurSrc) == tSrc || tCurSrc == tSrc )/* || ( tSrc.GetMtId() == byMtLoop && tSrc.GetType() == TYPE_MT )*/ 
							)
					{
						//非KEDA厂商看自己，KEDA停交换
						//RestoreRcvMediaBrdSrc( byMtLoop, MODE_AUDIO, FALSE,wSpyStartPort );
						atAudDstMt[byAudMtNum] = m_ptMtTable->GetMt( byMtLoop );
						byAudMtNum++;

						//判断恢复选看
						//RestoreMtSelectStatus( byMtLoop, MODE_AUDIO );
					}

				}
				
			}
		}
	}

	if( byVidMtNum != 0 )
	{
		RestoreRcvMediaBrdSrc( byVidMtNum, atVidDstMt, MODE_VIDEO, FALSE);
	}
	if( byAudMtNum != 0 )
	{
		RestoreRcvMediaBrdSrc( byAudMtNum, atAudDstMt, MODE_AUDIO, FALSE);
	}

	//[2011/11/14/zhangli]这段代码移到RemoveJoinedMt
	//如果tSrc过适配回传到上级，并且tSrc为发言人，取消发言人时回传被取消
// 	//如果当前终端同时回传到上级，回收适配器并停交换
// 	if(IsSupportMultiSpy())
// 	{
// 		TSimCapSet tSrcCap;
// 		CSendSpy *ptSndSpy = NULL;
// 		for (u8 bySpyIdx = 0; bySpyIdx < MAXNUM_CONF_SPY; bySpyIdx++)
// 		{
// 			ptSndSpy = m_cLocalSpyMana.GetSendSpy(bySpyIdx);
// 			if (NULL == ptSndSpy)
// 			{
// 				continue;
// 			}
// 			if (ptSndSpy->GetSpyMt().IsNull() || ptSndSpy->GetSimCapset().IsNull() || !(ptSndSpy->GetSpyMt() == tSrc))
// 			{
// 				continue;
// 			}
// 			tSrcCap = m_ptMtTable->GetSrcSCS(GetLocalMtFromOtherMcuMt(ptSndSpy->GetSpyMt()).GetMtId());
// 			if(ptSndSpy->GetSimCapset() < tSrcCap)
// 			{
// 				StopSpyAdapt(ptSndSpy->GetSpyMt(), ptSndSpy->GetSimCapset(), MODE_VIDEO);
// 			}
// 			if (ptSndSpy->GetSimCapset().GetAudioMediaType() != MEDIA_TYPE_NULL &&
// 				tSrcCap.GetAudioMediaType() != MEDIA_TYPE_NULL && 
// 				ptSndSpy->GetSimCapset().GetAudioMediaType() != tSrcCap.GetAudioMediaType())
// 			{
// 				StopSpyAdapt(ptSndSpy->GetSpyMt(), ptSndSpy->GetSimCapset(), MODE_AUDIO);
// 			}
// 			break;
// 		}
// 	}

	MtStatusChange();

	return TRUE;
}


/*====================================================================
    函数名      ：RestoreRcvMediaBrdSrc
    功能        ：指定恢复接收广播媒体源
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt & tMt, 指定终端
				  u8 byMode, 恢复模式，缺省为MODE_BOTH
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/01/23    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::RestoreRcvMediaBrdSrc( u8 byMtId, u8 byMode, BOOL32 bMsgMtStutas, u16 wSpyStartPort )
{
	TMt tMt = m_ptMtTable->GetMt( byMtId );
	RestoreRcvMediaBrdSrc( 1,&tMt,byMode,bMsgMtStutas,wSpyStartPort );
//	CServMsg cServMsg;
//	u8		 bySrcChnnl;
//	TMt      tMt = m_ptMtTable->GetMt( byMtId );
//
//	cServMsg.SetConfId( m_tConf.GetConfId() );
//
//	u8 byVmpState = TVmpStatus::IDLE;
//
//	// xliang [3/31/2009] 对于新VMP广播，恢复交换走普通交换
//	BOOL32 bHdVmpBrdst = FALSE;
//	TVMPParam_25Mem tConfVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
//	if( tConfVmpParam.GetVMPMode() != CONF_VMPMODE_NONE	//断链保护
//		&& tConfVmpParam.IsVMPBrdst())
//	{
//		//m_tVidBrdSrc = m_tVmpEqp;	// xliang [7/28/2009] 因为时序问题，这里务必赋下值
//		SetVidBrdSrc(m_tVmpEqp);
//		TPeriEqpStatus tPeriEqpStatus; 
//		g_cMcuVcApp.GetPeriEqpStatus( m_tVmpEqp.GetEqpId(), &tPeriEqpStatus );
//		u8 byVmpSubType = tPeriEqpStatus.m_tStatus.tVmp.m_bySubType;
//		if(byVmpSubType != VMP)
//		{
//			bHdVmpBrdst = TRUE;
//		}
//
//		byVmpState = tPeriEqpStatus.m_tStatus.tVmp.m_byUseState;
//	}
//
//	TMt tLocalVidBrdSrc = GetLocalVidBrdSrc();
//	TMt tLocalAudBrdSrc = GetLocalAudBrdSrc();
//
//	BOOL32 bIsBrdSrcNoKedaAndDumb = FALSE;
//	//zjj20120627 非科达终端(外厂商或kdc的mcu)做发言人哑音处理
//	if( !tLocalAudBrdSrc.IsNull() && GetAudBrdSrc().GetType() != TYPE_MCUPERI && MT_MANU_KDC != m_ptMtTable->GetManuId(GetLocalAudBrdSrc().GetMtId())
//		&& m_ptMtTable->IsMtAudioDumb( GetLocalAudBrdSrc().GetMtId() ) )
//	{
//		bIsBrdSrcNoKedaAndDumb = TRUE;
//	}
//
//
//	CRecvSpy tSpyResource;	
//	TMt tSpeaker = m_tConf.GetSpeaker();
//	if( byMode == MODE_VIDEO || byMode == MODE_BOTH )
//	{		
//        // xsl [8/19/2006] 卫星会议接收组播码流
//        //pgf分散会议，非组播终端不接收组播码流
//		if( !tLocalVidBrdSrc.IsNull()
//			&& 
//			( !IsMultiCastMt(tMt.GetMtId())
//			|| IsCanSatMtReceiveBrdSrc(tMt) )
////             ( !m_tConf.GetConfAttrb().IsSatDCastMode() || 
////               m_tConf.GetConfAttrb().IsSatDCastMode() && !IsMultiCastMt(tMt.GetMtId()) )
//          )
//		{
//            //非kdc厂商有广播源且节省带宽时，通知mt停止发送码流
//            if(g_cMcuVcApp.IsSavingBandwidth() && MT_MANU_KDC != m_ptMtTable->GetManuId( tMt.GetMtId())
//				&& tLocalVidBrdSrc.GetMtId() != tMt.GetMtId()  // [11/23/2010 xliang] 该外厂商终端本身就是发言人的情况不应该停止发码流
//				)
//            {
//                NotifyOtherMtSend(byMtId, FALSE);
//            }
//
//
//			if(bHdVmpBrdst)
//			{
//				//zjj20101227 vcs组呼点名双画面会议,主席不看自己就是看调度终端,所以不要恢复看画面合成,
//				//否则当跨断或取消调度终端时会导致主席先看到一个双画面图像再看自己
//				if( VCS_CONF == m_tConf.GetConfSource() &&
//						m_cVCSConfStatus.GetCurVCMode() == VCS_GROUPROLLCALL_MODE &&
//						tMt == m_tConf.GetChairman() )
//				{
//					if( m_cVCSConfStatus.GetChairPollState() != VCS_POLL_START )
//					{
//						StopSwitchToSubMt( 1, &tMt, MODE_VIDEO );
//					}				
//					else
//					{
//						ConfPrint(LOG_LVL_WARNING, MID_MCU_MT, "[RestoreRcvMediaBrdSrc] Fail to Restore,Chariman.%d is now poll.\n",tMt.GetMtId() );
//					}
//				}
//				else if( VCS_CONF == m_tConf.GetConfSource() && tMt == m_tConf.GetChairman() &&
//					m_cVCSConfStatus.GetChairPollState() == VCS_POLL_START )
//				{
//					ConfPrint(LOG_LVL_WARNING, MID_MCU_MT, "[RestoreRcvMediaBrdSrc] Fail to Restore,Chariman.%d is now poll.\n",tMt.GetMtId() );					
//				}
//				else
//				{
//					ConfPrint(LOG_LVL_WARNING, MID_MCU_MT, "[RestoreRcvMediaBrdSrc] Call SwitchNewVmpToSingleMt here!\n");
//					SwitchNewVmpToSingleMt(tMt);
//				}
//			}
//			else
//			{
//				bySrcChnnl = (tLocalVidBrdSrc == m_tPlayEqp) ? m_byPlayChnnl : 0; 
//				// guzh [3/21/2007]
//				//StartSwitchToSubMt( m_tVidBrdSrc, bySrcChnnl, byMtId, MODE_VIDEO, SWITCH_MODE_BROADCAST, bMsgMtStutas );
//				if( SPY_CHANNL_NULL == wSpyStartPort && !m_tConf.GetSpeaker().IsNull() &&
//					!tConfVmpParam.IsVMPBrdst() &&
//					!(tLocalVidBrdSrc == m_tPlayEqp)
//					)
//				{
//									
//					if( m_cSMcuSpyMana.GetRecvSpy( tSpeaker, tSpyResource ) )
//					{
//						wSpyStartPort = tSpyResource.m_tSpyAddr.GetPort();
//					}					
//				}
//				if( VCS_CONF == m_tConf.GetConfSource() && tMt == m_tConf.GetChairman() &&
//					m_cVCSConfStatus.GetChairPollState() == VCS_POLL_START )
//				{
//					ConfPrint( LOG_LVL_DETAIL, MID_MCU_CONF, "[RestoreRcvMediaBrdSrc] Fail to Restore,Chariman.%d is now poll.\n",tMt.GetMtId() );
//					ProcChairPollTimer();
//				}
//				else
//				{
//					if( tConfVmpParam.GetVMPMode() != CONF_VMPMODE_NONE && tConfVmpParam.IsVMPBrdst() )
//					{
//						if(byVmpState != TVmpStatus::WAIT_STOP && byVmpState != TVmpStatus::IDLE)
//						{
//							// 2011-9-13 add by pgf: 某终端只能接收会议辅格式码流，则老VMP的第1通道交换打给它
//							// bHdVmpBrdst == False表示是老的VMP
//							TLogicalChannel tSrcMtChnnl;
//							m_ptMtTable->GetMtLogicChnnl(byMtId, LOGCHL_VIDEO, &tSrcMtChnnl, TRUE);
//							if ( m_tConf.GetSecVideoMediaType() != MEDIA_TYPE_NULL
//								&& m_tConf.GetSecVideoMediaType() == tSrcMtChnnl.GetChannelType())
//							{
//								StartSwitchFromBrd(m_tVmpEqp, 1, 1, &tMt, wSpyStartPort);
//							}
//							else
//							{
//								StartSwitchFromBrd(GetVidBrdSrc(), bySrcChnnl, 1, &tMt, wSpyStartPort);
//							}
//						}
//					}
//					else
//					{
//						StartSwitchFromBrd(GetVidBrdSrc(), bySrcChnnl, 1, &tMt, wSpyStartPort);
//					}
//				}				
//			}
//	    
//		}
//	    else
//		{
//			if( m_ptMtTable->GetManuId( tMt.GetMtId() ) == MT_MANU_KDC )
//			{
//				//zjl 20110510 StopSwitchToSubMt 接口重载替换
//				//StopSwitchToSubMt( byMtId, MODE_VIDEO, SWITCH_MODE_BROADCAST, bMsgMtStutas );
//				StopSwitchToSubMt(1, &tMt, MODE_VIDEO, bMsgMtStutas);
//
//                // xsl [8/19/2006] 卫星会议接收组播码流
//                /*if (m_tConf.GetConfAttrb().IsSatDCastMode())
//                {
//                    ChangeSatDConfMtRcvAddr(byMtId, LOGCHL_VIDEO);
//                }*/
//			}
//			else
//			{
//                //非kdc厂商无发言人时回传自身视频, 节省带宽时，通知mt发送码流
//                if(g_cMcuVcApp.IsSavingBandwidth())
//                {
//                    NotifyOtherMtSend(byMtId, TRUE);
//                }
//				//zjl 20110510 StartSwitchToAll 替换 StartSwitchToSubMt
//				//StartSwitchToSubMt( tMt, 0, tMt.GetMtId(), MODE_VIDEO, SWITCH_MODE_BROADCAST, bMsgMtStutas,TRUE,FALSE, wSpyStartPort );
//				TSwitchGrp tSwitchGrp;
//				tSwitchGrp.SetSrcChnl(0);
//				tSwitchGrp.SetDstMtNum(1);
//				tSwitchGrp.SetDstMt(&tMt);
//				//zyl 20121101 外厂商终端看自己不能用SWITCH_MODE_BROADCAST，因为如果前面选看了别的终端，在CMpManager::StartSwitchToAll里面有
//				//下面的规则，会导致前面的交换不拆:
//				//{*建立广播视频交换时，根据平滑考虑，指定以下规则:当前目的终端上一个源和当前的源都是终端,交换前不拆交换.
//				StartSwitchToAll(tMt, 1, &tSwitchGrp, MODE_VIDEO, SWITCH_MODE_SELECT, bMsgMtStutas, TRUE, wSpyStartPort);
//			}
//		}
//	}
//
//	if( byMode == MODE_AUDIO || byMode == MODE_BOTH )
//	{
//        // xsl [8/19/2006] 卫星会议接收组播码流
//        // guzh [4/23/2007] 直接取音频广播源
//		if( !tLocalAudBrdSrc.IsNull() &&
//			( 
//			!IsMultiCastMt(tMt.GetMtId())
//			|| IsCanSatMtReceiveBrdSrc(tMt, MODE_AUDIO)
//			 )
////             ( !m_tConf.GetConfAttrb().IsSatDCastMode() ||
////               m_tConf.GetConfAttrb().IsSatDCastMode() && !IsMultiCastMt(byMtId) )
//			&& 
//            !bIsBrdSrcNoKedaAndDumb )
//		{
//			if( m_tConf.m_tStatus.IsNoMixing()  )
//			{
//				if( SPY_CHANNL_NULL == wSpyStartPort && !m_tConf.GetSpeaker().IsNull() )
//				{
//					
//					if( m_cSMcuSpyMana.GetRecvSpy( tSpeaker, tSpyResource ) )
//					{
//						wSpyStartPort = tSpyResource.m_tSpyAddr.GetPort();
//					}					
//				}
//				bySrcChnnl = (tSpeaker == m_tPlayEqp) ? m_byPlayChnnl : 0; 
//
//				TPeriEqpStatus tBasStatus;
//				TBasOutInfo	tOutInfo;
//				if (IsNeedAdapt(tLocalVidBrdSrc,  m_ptMtTable->GetMt(byMtId), MODE_VIDEO) &&
//					FindBasChn2BrdForMt(byMtId, MODE_VIDEO, tOutInfo) &&
//					g_cMcuVcApp.GetPeriEqpStatus(tOutInfo.m_tBasEqp.GetEqpId(), &tBasStatus) &&
//					(tBasStatus.m_tStatus.tHdBas.GetEqpType() == TYPE_MPU ||
//						tBasStatus.m_tStatus.tHdBas.GetEqpType() == TYPE_MPU_H)&&
//					!IsNeedAdapt(tLocalAudBrdSrc, m_ptMtTable->GetMt(byMtId), MODE_AUDIO) &&
//					g_cMcuVcApp.IsVASimultaneous())
//
//				{
//					//[nizhijun 2011/01/18] Bug00042900 对于音频广播源时自己时，终端不需要收自己的音频
//					TMt tTempMt = m_ptMtTable->GetMt(byMtId);
//					if ( tTempMt == tLocalAudBrdSrc && 
//						 TYPE_MT == tTempMt.GetMtType() )
//					{
//						StopSwitchToSubMt(1, &tTempMt, MODE_AUDIO, bMsgMtStutas);
//						ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT, "[RestoreRcvMediaBrdSrc] tLocalAudBrdSrc == tSrc(%d-%d)\n",tTempMt.GetMcuId(),tTempMt.GetMtId());
//					}
//					else
//					{
//						StartSwitchAud2MtNeedAdp(GetAudBrdSrc(),tTempMt);
//					}					
//				}
//				else
//				{
//					//zjl 20110510 StartSwitchToAll 替换 StartSwitchToSubMt
//					//StartSwitchToSubMt( tSpeaker, bySrcChnnl, byMtId, MODE_AUDIO, SWITCH_MODE_BROADCAST, bMsgMtStutas, TRUE, FALSE, wSpyStartPort );
//					TSwitchGrp tSwitchGrp;
//					tSwitchGrp.SetSrcChnl(bySrcChnnl);
//					tSwitchGrp.SetDstMtNum(1);
//					TMt tTempMt = m_ptMtTable->GetMt(byMtId);
//					tSwitchGrp.SetDstMt(&tTempMt);
//					StartSwitchToAll(tSpeaker, 1, &tSwitchGrp, MODE_AUDIO, SWITCH_MODE_BROADCAST, bMsgMtStutas, TRUE, wSpyStartPort);
//
//					TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
//					//[2011/08/22/zhangli]恢复到广播PRS的RTCP交换
//					if (tConfAttrb.IsResendLosePack())
//					{
//						u8 byPrsId = 0;
//						u8 byPrsChlId = 0;
//						if (FindPrsChnForSrc(tSpeaker, bySrcChnnl, MODE_AUDIO, byPrsId, byPrsChlId))
//						{
//							AddRemovePrsMember(byMtId, byPrsId, byPrsChlId, MODE_AUDIO);
//						}
//					}
//				}				
//			}
//			else
//			{
//				// miaoqingsong [06/29/2011] 带音频主席轮询选看并且开启混音的状态下，停轮询选看药补建混音器到主席的音频交换
//				//if ( byMtId == m_tConf.GetChairman().GetMtId() )
//				{
//					TMt tMan = m_ptMtTable->GetMt(byMtId);
//					TSwitchGrp tSwitchGrp;
//					if ( m_ptMtTable->IsMtInMixGrp(byMtId) )
//					{
//						tSwitchGrp.SetSrcChnl(GetMixChnPos(tMan));
//					} 
//					else
//					{
//						tSwitchGrp.SetSrcChnl(GetMixerNModeChn());
//					}				
//					tSwitchGrp.SetDstMtNum(1);
//					
//					// [7/20/2011 liuxu] pclint error 50: (Error -- Attempted to take the address of a non-lvalue)
//					//tSwitchGrp.SetDstMt(&m_tConf.GetChairman());
//					tSwitchGrp.SetDstMt(&tMan);
//
//					//g_cMpManager.StartSwitchToAll( m_tMixEqp, 1, &tSwitchGrp, MODE_AUDIO );
//					StartSwitchToAll( m_tMixEqp, 1, &tSwitchGrp, MODE_AUDIO );
//
//					TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
//					if (tConfAttrb.IsResendLosePack())
//					{
//						u8 byPrsId = 0;
//		                u8 byPrsChnId = 0;
//
//						if ( m_ptMtTable->IsMtInMixGrp(byMtId))
//						{
//							AddRemoveMixRtcpMember(1, &tMan, TRUE);
//						}
//						else if (FindPrsChnForBrd(MODE_AUDIO, byPrsId, byPrsChnId))
//						{
//							AddRemovePrsMember(1, &tMan, byPrsId, byPrsChnId, MODE_AUDIO, TRUE);
//						}
//					}
//				}
//			}
//		}
//	    else
//		{			
//
//			if( !m_tCascadeMMCU.IsNull() && byMtId == m_tCascadeMMCU.GetMtId() )
//			{
//				// 如果是上级级联的终端，则不破坏此回传通道交换
//				// StartSwitchToSubMt( tMt, 0, tMt.GetMtId(), MODE_AUDIO, SWITCH_MODE_BROADCAST, bMsgMtStutas );
//			}
//			else
//			{
//				TMt tMtSel;
//				TMtStatus status;
//				m_ptMtTable->GetMtStatus( tMt.GetMtId(),&status );
//				tMtSel = status.GetSelectMt( MODE_AUDIO );
//				if( tLocalAudBrdSrc.IsNull() ||
//					( !tLocalAudBrdSrc.IsNull() && bIsBrdSrcNoKedaAndDumb && m_ptMtTable->GetMtType(GetLocalAudBrdSrc().GetMtId()) == MT_TYPE_SMCU && tMt == GetLocalAudBrdSrc() ) ||
//					tMtSel.IsNull() || ( !tLocalAudBrdSrc.IsNull() && tMtSel == tLocalAudBrdSrc && bIsBrdSrcNoKedaAndDumb ) )
//				{				
//					//zjl 20110510 StopSwitchToSubMt 接口重载替换
//					//StopSwitchToSubMt( byMtId, MODE_AUDIO, SWITCH_MODE_BROADCAST, bMsgMtStutas );
//					StopSwitchToSubMt(1, &tMt, MODE_AUDIO, bMsgMtStutas);
//
//					// xsl [8/19/2006] 卫星会议接收组播码流
//					/*if (m_tConf.GetConfAttrb().IsSatDCastMode())
//					{
//						ChangeSatDConfMtRcvAddr(byMtId, LOGCHL_AUDIO);
//					}*/
//				}
//			}
//		}
//	}
}

/*====================================================================
    函数名      ：RestoreRcvMediaBrdSrc
    功能        ：指定恢复接收广播媒体源
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMtNum 要恢复的终端数量
	              TMt *ptDstMt 终端信息
				  u8 byMode, 恢复模式，缺省为MODE_BOTH
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/01/23    1.0         LI Yi         创建
	20110505    4.6         pengjie       批量终端支持
====================================================================*/
void CMcuVcInst::RestoreRcvMediaBrdSrc( u8 byMtNum, TMt *ptDstMt, u8 byMode, BOOL32 bMsgMtStutas, u16 wSpyStartPort )
{
	CServMsg cServMsg;
	u8		 bySrcChnnl;
	cServMsg.SetConfId( m_tConf.GetConfId() );

	u8 byVmpState = TVmpStatus::IDLE;

	// xliang [3/31/2009] 对于新VMP广播，恢复交换走普通交换
	BOOL32 bHdVmpBrdst = FALSE;
	TVMPParam_25Mem tConfVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
	if( tConfVmpParam.GetVMPMode() != CONF_VMPMODE_NONE	//断链保护
		&& tConfVmpParam.IsVMPBrdst())
	{
		//m_tVidBrdSrc = m_tVmpEqp;	// xliang [7/28/2009] 因为时序问题，这里务必赋下值
		SetVidBrdSrc(m_tVmpEqp);
		TPeriEqpStatus tPeriEqpStatus; 
		g_cMcuVcApp.GetPeriEqpStatus( m_tVmpEqp.GetEqpId(), &tPeriEqpStatus );
		u8 byVmpSubType = tPeriEqpStatus.m_tStatus.tVmp.m_bySubType;
		if(byVmpSubType != VMP)
		{
			bHdVmpBrdst = TRUE;
		}

		byVmpState = tPeriEqpStatus.m_tStatus.tVmp.m_byUseState;
	}

	TMt tLocalVidBrdSrc = GetLocalVidBrdSrc();
	TMt tLocalAudBrdSrc = GetLocalAudBrdSrc();


	CRecvSpy tSpyResource;	
	TMt tSpeaker = m_tConf.GetSpeaker();

	u8 byVidMtNum = 0;
	u8 byVmpDstNum = 0;
	u8 byAudMtNum = 0;
	TMt atVidDstMt[MAXNUM_CONF_MT];
	memset( atVidDstMt, 0, sizeof(atVidDstMt) );
	TMt atAudDstMt[MAXNUM_CONF_MT];
	memset( atAudDstMt, 0, sizeof(atAudDstMt) );
	TMt atVmpDstMt[MAXNUM_CONF_MT];
	memset( atVmpDstMt, 0, sizeof(atVmpDstMt) );

	BOOL32 bIsBrdSrcNoKedaAndDumb = FALSE;
	//zjj20120627 非科达终端(外厂商或kdc的mcu)做发言人哑音处理
	if( !tLocalAudBrdSrc.IsNull() && GetAudBrdSrc().GetType() != TYPE_MCUPERI && MT_MANU_KDC != m_ptMtTable->GetManuId(GetLocalAudBrdSrc().GetMtId())
		&& m_ptMtTable->IsMtAudioDumb( GetLocalAudBrdSrc().GetMtId() ) )
	{
		bIsBrdSrcNoKedaAndDumb = TRUE;
	}
	TMt tMtSel;
	TMtStatus status;
	TMt tMt;

	for( u8 byLoop = 0; byLoop < byMtNum; byLoop++ )
	{
		tMt = ptDstMt[byLoop];

		if( byMode == MODE_VIDEO || byMode == MODE_BOTH )
		{		
			// xsl [8/19/2006] 卫星会议接收组播码流
			if( !tLocalVidBrdSrc.IsNull()
				&&
				( !IsMultiCastMt(tMt.GetMtId())
				||  IsCanSatMtReceiveBrdSrc(tMt)
				)
				/*&& !m_tConf.GetConfAttrb().IsSatDCastMode()*/ )
			{
				//非kdc厂商有广播源且节省带宽时，通知mt停止发送码流
				if(g_cMcuVcApp.IsSavingBandwidth() && MT_MANU_KDC != m_ptMtTable->GetManuId( tMt.GetMtId())
					&& tLocalVidBrdSrc.GetMtId() != tMt.GetMtId()  // [11/23/2010 xliang] 该外厂商终端本身就是发言人的情况不应该停止发码流
					)
				{
					NotifyOtherMtSend(tMt.GetMtId(), FALSE);
				}
				
				if(bHdVmpBrdst)
				{
					//zjj20101227 vcs组呼点名双画面会议,主席不看自己就是看调度终端,所以不要恢复看画面合成,
					//否则当跨断或取消调度终端时会导致主席先看到一个双画面图像再看自己
					if( VCS_CONF == m_tConf.GetConfSource() &&
						m_cVCSConfStatus.GetCurVCMode() == VCS_GROUPROLLCALL_MODE &&
						tMt == m_tConf.GetChairman() )
					{
						if( m_cVCSConfStatus.GetChairPollState() != VCS_POLL_START )
						{
							atVmpDstMt[byVmpDstNum] = tMt;
							byVmpDstNum++;
							//StopSwitchToSubMt( tMt.GetMtId(), MODE_VIDEO );
						}				
						else
						{
							ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[RestoreRcvMediaBrdSrc] Fail to Restore,Chariman.%d is now poll.\n",tMt.GetMtId() );
						}
					}
					else if( VCS_CONF == m_tConf.GetConfSource() && tMt == m_tConf.GetChairman() &&
						m_cVCSConfStatus.GetChairPollState() == VCS_POLL_START )
					{
						ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_CONF,"[RestoreRcvMediaBrdSrc] Fail to Restore,Chariman.%d is now poll.\n",tMt.GetMtId() );						
					}
					else
					{
						if( byVmpState != TVmpStatus::WAIT_STOP && byVmpState != TVmpStatus::IDLE )
						{
							ConfPrint( LOG_LVL_DETAIL, MID_MCU_CONF, "[RestoreRcvMediaBrdSrc] Call SwitchNewVmpToSingleMt here!\n");
							SwitchNewVmpToSingleMt(tMt);
						}
					}
				}
				else
				{
					bySrcChnnl = (tLocalVidBrdSrc == m_tPlayEqp) ? m_byPlayChnnl : 0; 
					// guzh [3/21/2007]
					//StartSwitchToSubMt( m_tVidBrdSrc, bySrcChnnl, byMtId, MODE_VIDEO, SWITCH_MODE_BROADCAST, bMsgMtStutas );
					if( SPY_CHANNL_NULL == wSpyStartPort && !m_tConf.GetSpeaker().IsNull() &&
						!tConfVmpParam.IsVMPBrdst() &&
						!(tLocalVidBrdSrc == m_tPlayEqp)
						)
					{
						
						if( m_cSMcuSpyMana.GetRecvSpy( tSpeaker, tSpyResource ) )
						{
							wSpyStartPort = tSpyResource.m_tSpyAddr.GetPort();
						}					
					}
					if( VCS_CONF == m_tConf.GetConfSource() && tMt == m_tConf.GetChairman() &&
						m_cVCSConfStatus.GetChairPollState() == VCS_POLL_START )
					{
						ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[RestoreRcvMediaBrdSrc] Fail to Restore,Chariman.%d is now poll.\n",tMt.GetMtId() );
						ProcChairPollTimer();
					}
					else
					{
						if( tConfVmpParam.GetVMPMode() != CONF_VMPMODE_NONE && tConfVmpParam.IsVMPBrdst() )
						{
							if( byVmpState != TVmpStatus::WAIT_STOP && byVmpState != TVmpStatus::IDLE )
							{
								StartSwitchFromBrd(GetVidBrdSrc(), bySrcChnnl, 1, &tMt, wSpyStartPort);
							}
						}
						else
						{
							StartSwitchFromBrd(GetVidBrdSrc(), bySrcChnnl, 1, &tMt, wSpyStartPort);
						}
					}				
				}
				
			}
			else
			{
				if( m_ptMtTable->GetManuId( tMt.GetMtId() ) == MT_MANU_KDC )
				{
					atVidDstMt[byVidMtNum] = tMt;
					byVidMtNum++;
					//StopSwitchToSubMt( tMt.GetMtId(), MODE_VIDEO, SWITCH_MODE_BROADCAST, bMsgMtStutas );
					
					// xsl [8/19/2006] 卫星会议接收组播码流
					/*if (m_tConf.GetConfAttrb().IsSatDCastMode())
					{
						ChangeSatDConfMtRcvAddr(tMt.GetMtId(), LOGCHL_VIDEO);
					}*/
				}
				else
				{
					//非kdc厂商无发言人时回传自身视频, 节省带宽时，通知mt发送码流
					if(g_cMcuVcApp.IsSavingBandwidth())
					{
						NotifyOtherMtSend(tMt.GetMtId(), TRUE);
					}
					//zjl 20110510 StartSwitchToAll 替换 StartSwitchToSubMt
					//StartSwitchToSubMt( tMt, 0, tMt.GetMtId(), MODE_VIDEO, SWITCH_MODE_BROADCAST, bMsgMtStutas,TRUE,FALSE, wSpyStartPort );
					TSwitchGrp tSwitchGrp;
					tSwitchGrp.SetSrcChnl(0);
					tSwitchGrp.SetDstMtNum(1);
					tSwitchGrp.SetDstMt(&tMt);
					StartSwitchToAll(tMt, 1, &tSwitchGrp, MODE_VIDEO, SWITCH_MODE_BROADCAST, bMsgMtStutas, TRUE, wSpyStartPort);
				}
			}
		}

		if( byMode == MODE_AUDIO || byMode == MODE_BOTH )
		{
			// xsl [8/19/2006] 卫星会议接收组播码流
			// guzh [4/23/2007] 直接取音频广播源
			if( !tLocalAudBrdSrc.IsNull()
// 				&& !m_tConf.GetConfAttrb().IsSatDCastMode()
				&& ( !IsMultiCastMt(tMt.GetMtId())
					|| IsCanSatMtReceiveBrdSrc(tMt, MODE_AUDIO) )
				&& !bIsBrdSrcNoKedaAndDumb )
			{
				if( m_tConf.m_tStatus.IsNoMixing()  )
				{
					if( SPY_CHANNL_NULL == wSpyStartPort && !m_tConf.GetSpeaker().IsNull() )
					{
						
						if( m_cSMcuSpyMana.GetRecvSpy( tSpeaker, tSpyResource ) )
						{
							wSpyStartPort = tSpyResource.m_tSpyAddr.GetPort();
						}					
					}
					bySrcChnnl = (tSpeaker == m_tPlayEqp) ? m_byPlayChnnl : 0; 
					
					TPeriEqpStatus tBasStatus;
					TBasOutInfo	tOutInfo;
					if (IsNeedAdapt(tLocalVidBrdSrc,  tMt, MODE_VIDEO) &&
						FindBasChn2BrdForMt(tMt.GetMtId(), MODE_VIDEO, tOutInfo) &&
						g_cMcuVcApp.GetPeriEqpStatus(tOutInfo.m_tBasEqp.GetEqpId(), &tBasStatus) &&
						(tBasStatus.m_tStatus.tHdBas.GetEqpType() == TYPE_MPU ||
						tBasStatus.m_tStatus.tHdBas.GetEqpType() == TYPE_MPU_H)&&
						!IsNeedAdapt(tLocalAudBrdSrc, tMt, MODE_AUDIO) &&
						g_cMcuVcApp.IsVASimultaneous())
						
					{
						//[nizhijun 2011/01/18] Bug00042900 对于音频广播源时自己时，终端不需要收自己的音频
						TMt tTempMt = tMt;
						if ( tTempMt == tLocalAudBrdSrc && 
							TYPE_MT == tTempMt.GetMtType() )
						{
							StopSwitchToSubMt(1, &tTempMt, MODE_AUDIO, bMsgMtStutas);
							ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT, "[RestoreRcvMediaBrdSrc] tLocalAudBrdSrc == tSrc(%d-%d)\n",tTempMt.GetMcuId(),tTempMt.GetMtId());
						}
						else
						{
							StartSwitchAud2MtNeedAdp(GetAudBrdSrc(),tTempMt);
						}					
					}
					else
					{
						if ( IsNeedAdapt(tLocalAudBrdSrc, tMt, MODE_AUDIO) )
						{
							//源是终端，且源也是自己时，不需要补建音频交换
							BOOL32 bIsNeedSwitch = TRUE;
							if ( (tLocalAudBrdSrc.GetType() == TYPE_MT) && 
								(tLocalAudBrdSrc.GetMtType() == MT_TYPE_MT) &&
								tLocalAudBrdSrc.GetMtId() == tMt.GetMtId()
								)
							{
								bIsNeedSwitch = FALSE;
							}
						
							if ( bIsNeedSwitch )
							{
								if ( m_tConf.m_tStatus.IsAudAdapting() )
								{
									StartSwitchToSubMtFromAdp(tMt.GetMtId(), MODE_AUDIO);
								}
							}	
							else
							{
								TSwitchGrp tSwitchGrp;
								tSwitchGrp.SetSrcChnl(bySrcChnnl);
								tSwitchGrp.SetDstMtNum(1);
								tSwitchGrp.SetDstMt(&tMt);
								StartSwitchToAll(tSpeaker, 1, &tSwitchGrp, MODE_AUDIO, SWITCH_MODE_BROADCAST, bMsgMtStutas, TRUE, wSpyStartPort);
							}
						}
						else
						{
							//zjl 20110510 StartSwitchToAll 替换 StartSwitchToSubMt
							//StartSwitchToSubMt( tSpeaker, bySrcChnnl, tMt.GetMtId(), MODE_AUDIO, SWITCH_MODE_BROADCAST, bMsgMtStutas, TRUE, FALSE, wSpyStartPort );
							TSwitchGrp tSwitchGrp;
							tSwitchGrp.SetSrcChnl(bySrcChnnl);
							tSwitchGrp.SetDstMtNum(1);
							tSwitchGrp.SetDstMt(&tMt);
							StartSwitchToAll(tSpeaker, 1, &tSwitchGrp, MODE_AUDIO, SWITCH_MODE_BROADCAST, bMsgMtStutas, TRUE, wSpyStartPort);
						}
					}				
				}
				else
				{   
					// miaoqingsong [06/29/2011] 带音频主席轮询选看并且开启混音的状态下，停轮询选看药补建混音器到主席的音频交换
					//if ( tMt == m_tConf.GetChairman() )
					{
						TMt tMan = m_ptMtTable->GetMt(tMt.GetMtId());
						TSwitchGrp tSwitchGrp;
						if ( m_ptMtTable->IsMtInMixGrp(tMt.GetMtId()) )
						{
							tSwitchGrp.SetSrcChnl(GetMixChnPos(tMan));
						} 
						else
						{
							u8 byMixerSubtype = UNKONW_MIXER;
							g_cMcuAgent.GetMixerSubTypeByEqpId(m_tMixEqp.GetEqpId(), byMixerSubtype);
							TLogicalChannel tLogicalChannel;
							TAudioTypeDesc tAudTypeInfo;
							if ( m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_AUDIO, &tLogicalChannel, TRUE) )
							{
								tAudTypeInfo.SetAudioMediaType(tLogicalChannel.GetChannelType());
								tAudTypeInfo.SetAudioTrackNum(tLogicalChannel.GetAudioTrackNum());
							}
							
							u8 byPos = 0;
							if (byMixerSubtype == APU2_MIXER || byMixerSubtype == MIXER_8KI)
							{
								byPos = m_tConfEx.GetPosInConfByAudioCap(tAudTypeInfo);
								if (byPos == 0xFF)
								{
									ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[RestoreRcvMediaBrdSrc] MediaType.%d_TrackNum.%d Is Error!Not in AudioTypeInfo\n", 
								     tAudTypeInfo.GetAudioMediaType(), tAudTypeInfo.GetAudioTrackNum());

									return;
								}
							}
							
							tSwitchGrp.SetSrcChnl(GetMixerNModeChn() + byPos);
						}				
						tSwitchGrp.SetDstMtNum(1);

						// [7/20/2011 liuxu] pclint error 50: (Error -- Attempted to take the address of a non-lvalue)
						/*tSwitchGrp.SetDstMt(&m_tConf.GetChairman());*/
						tSwitchGrp.SetDstMt(&tMan);
						
						//g_cMpManager.StartSwitchToAll( m_tMixEqp, 1, &tSwitchGrp, MODE_AUDIO );
						StartSwitchToAll( m_tMixEqp, 1, &tSwitchGrp, MODE_AUDIO );
						TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
						if (tConfAttrb.IsResendLosePack())
						{
							u8 byPrsId = 0;
							u8 byPrsChnId = 0;
							
							if ( m_ptMtTable->IsMtInMixGrp(tMt.GetMtId()))
							{
								AddRemoveMixRtcpMember(1, &tMan, TRUE);
							}
							else if (FindPrsChnForBrd(MODE_AUDIO, byPrsId, byPrsChnId))
							{
								AddRemovePrsMember(1, &tMan, byPrsId, byPrsChnId, MODE_AUDIO, TRUE);
							}
						}
					}
				}
			}
			else
			{			
				
				if( !m_tCascadeMMCU.IsNull() && tMt.GetMtId() == m_tCascadeMMCU.GetMtId() )
				{
					// 如果是上级级联的终端，则不破坏此回传通道交换
					// StartSwitchToSubMt( tMt, 0, tMt.GetMtId(), MODE_AUDIO, SWITCH_MODE_BROADCAST, bMsgMtStutas );
				}
				else
				{				
					m_ptMtTable->GetMtStatus( tMt.GetMtId(),&status );
					tMtSel = status.GetSelectMt( MODE_AUDIO );
					if( tLocalAudBrdSrc.IsNull() ||
						( !tLocalAudBrdSrc.IsNull() && bIsBrdSrcNoKedaAndDumb && m_ptMtTable->GetMtType(tLocalAudBrdSrc.GetMtId()) == MT_TYPE_SMCU && tMt == tLocalAudBrdSrc ) ||
						tMtSel.IsNull() || ( !tLocalAudBrdSrc.IsNull() && bIsBrdSrcNoKedaAndDumb && tMtSel == tLocalAudBrdSrc ) )
					{					
						atAudDstMt[byAudMtNum] = tMt;
						byAudMtNum++;
						//StopSwitchToSubMt( tMt.GetMtId(), MODE_AUDIO, SWITCH_MODE_BROADCAST, bMsgMtStutas );
						
						// xsl [8/19/2006] 卫星会议接收组播码流
						/*if (m_tConf.GetConfAttrb().IsSatDCastMode())
						{
							ChangeSatDConfMtRcvAddr(tMt.GetMtId(), LOGCHL_AUDIO);
						}*/
					}
				}
			}
		}
	}

	if( byVmpDstNum != 0 )
	{
		StopSwitchToSubMt( byVmpDstNum, atVmpDstMt, MODE_VIDEO );
	}
	if( byVidMtNum != 0 )
	{
		StopSwitchToSubMt( byVidMtNum, atVidDstMt, MODE_VIDEO, bMsgMtStutas );
	}
	if( byAudMtNum != 0 )
	{
		StopSwitchToSubMt( byAudMtNum, atAudDstMt, MODE_AUDIO, bMsgMtStutas );
	}


}

/*====================================================================
    函数名      RestoreRcvSecMediaBrdSrc
    功能        ：恢复看第二路广播，可能是双广播也可能是双流
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2012/08/16  4.7         zhangli        create
====================================================================*/
void CMcuVcInst::RestoreRcvSecMediaBrdSrc(u8 byMtNum, TMt *ptDstMt, u8 byMode, BOOL32 bMsgMtStutas, u16 wSpyStartPort)
{
	if (MODE_VIDEO2SECOND != byMode)
	{
		return;
	}
	CServMsg cServMsg;
	cServMsg.SetConfId(m_tConf.GetConfId());

	u8 bySwitchMode = MODE_VIDEO2SECOND;
	TMt tSecVidBrdSrc = GetSecVidBrdSrc();
	if (tSecVidBrdSrc.IsNull())
	{
		tSecVidBrdSrc = m_tDoubleStreamSrc;
		bySwitchMode = MODE_SECVIDEO;
	}

	CRecvSpy tSpyResource;	

	u8 byVidMtNum = 0;
	TMt atVidDstMt[MAXNUM_CONF_MT];
	memset( atVidDstMt, 0, sizeof(atVidDstMt) );
	
	TMt tMt;

	u8 byLoop = 0;
	for(byLoop = 0; byLoop < byMtNum; byLoop++ )
	{
		//非kdc厂商有广播源且节省带宽时，通知mt停止发送码流
		if(g_cMcuVcApp.IsSavingBandwidth() && MT_MANU_KDC != m_ptMtTable->GetManuId( tMt.GetMtId())
			&& (tSecVidBrdSrc.IsNull() || tSecVidBrdSrc.GetMtId() != tMt.GetMtId()))
		{
			NotifyOtherMtSend(tMt.GetMtId(), FALSE);
		}

		tMt = ptDstMt[byLoop];
		if(!tSecVidBrdSrc.IsNull() && !m_tConf.GetConfAttrb().IsSatDCastMode() )
		{	
			if(SPY_CHANNL_NULL == wSpyStartPort && !tSecVidBrdSrc.IsLocal()
				&& m_cSMcuSpyMana.GetRecvSpy(tSecVidBrdSrc, tSpyResource))
			{
				wSpyStartPort = tSpyResource.m_tSpyAddr.GetPort();
			}
			
			if( VCS_CONF == m_tConf.GetConfSource() && tMt == m_tConf.GetChairman() &&
				m_cVCSConfStatus.GetChairPollState() == VCS_POLL_START )
			{
				ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[RestoreRcvMediaBrdSrc] Fail to Restore,Chariman.%d is now poll.\n",tMt.GetMtId() );
			}
			else
			{
				//过适配考虑
				TSwitchGrp tSwitchGrp;		
				tSwitchGrp.SetSrcChnl(0);
				tSwitchGrp.SetDstMtNum(1);
				tSwitchGrp.SetDstMt(&tMt);
				StartSwitchToAll(tSecVidBrdSrc, 1, &tSwitchGrp, bySwitchMode, SWITCH_MODE_BROADCAST,FALSE, FALSE, wSpyStartPort);
			}
		}
		else
		{
			if(m_ptMtTable->GetManuId(tMt.GetMtId() ) == MT_MANU_KDC)
			{
				atVidDstMt[byVidMtNum] = tMt;
				byVidMtNum++;
			}
		}
	}

	if(byVidMtNum != 0)
	{
		StopSwitchToSubMt(byVidMtNum, atVidDstMt, MODE_VIDEO2SECOND, bMsgMtStutas);

		TLogicalChannel TNullLogicalChannel;
		TLogicalChannel tH239LogicChnnl;
		for (byLoop = 0; byLoop < byVidMtNum; ++byLoop)
		{
			tMt = atVidDstMt[byLoop];
			//关接收终端双流逻辑通道
			if(m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_SECVIDEO, &tH239LogicChnnl, TRUE))
			{
				u8 byOut = 1;
				cServMsg.SetMsgBody((u8 *)&tH239LogicChnnl, sizeof(tH239LogicChnnl));
				cServMsg.CatMsgBody(&byOut, sizeof(byOut));
				SendMsgToMt(tMt.GetMtId(), MCU_MT_CLOSELOGICCHNNL_CMD, cServMsg);
			}
			
			//设置主流码率
			if (m_ptMtTable->GetMtTransE1(tMt.GetMtId()) && m_ptMtTable->GetMtBRBeLowed(tMt.GetMtId()))
			{
				u16 wRealBR = m_ptMtTable->GetLowedRcvBandWidth(tMt.GetMtId());
				m_ptMtTable->SetMtReqBitrate(tMt.GetMtId(), wRealBR, LOGCHL_VIDEO);
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT2, "[RestoreRcvSecMediaBrdSrc]tDstMt.%d, MtReqBitrate = %d, adjust restore\n", tMt.GetMtId(), wRealBR);
			}
			else
			{
				u16 wMtDialBitrate = m_ptMtTable->GetRcvBandWidth(tMt.GetMtId());
				m_ptMtTable->SetMtReqBitrate(tMt.GetMtId(), wMtDialBitrate, LOGCHL_VIDEO);
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_MT2, "[RestoreRcvSecMediaBrdSrc]tDstMt.%d, MtReqBitrate = %d, normally restore\n", tMt.GetMtId(), wMtDialBitrate);
			}

			//置空双流码率
			m_ptMtTable->SetMtLogicChnnl(tMt.GetMtId(), LOGCHL_SECVIDEO, &TNullLogicalChannel, TRUE);
		}
	}
}

/*====================================================================
    函数名      ：ConfStatusChange
    功能        ：改变会议状态
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/01/23    1.0         LI Yi         创建
	04/03/07    3.0         胡昌威        胡昌威
====================================================================*/
void CMcuVcInst::ConfStatusChange( )
{
	CServMsg	cServMsg;

	//notify all meeting consoles
	cServMsg.SetMsgBody( ( u8 * )&( m_tConf.m_tStatus ), sizeof( TConfStatus ) );
	SendMsgToAllMcs( MCU_MCS_CONFSTATUS_NOTIF, cServMsg );	
	
	SendConfInfoToChairMt();
}

/*=============================================================================
  函 数 名： ConfModeChange
  功    能： 会议模式通知
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： void 
=============================================================================*/
void CMcuVcInst::ConfModeChange()
{
    CServMsg	cServMsg;    

	// [pengjie 2010/9/29]
	TConfMode tConfMode = m_tConf.m_tStatus.m_tConfMode;
	if( m_tConf.m_tStatus.IsRecPauseByInternal() )
	{
		tConfMode.SetRecordMode( CONF_RECMODE_REC );
	}

//    cServMsg.SetMsgBody( ( u8 * )&( m_tConf.m_tStatus.m_tConfMode ), sizeof( TConfMode ) );
	cServMsg.SetMsgBody( ( u8 * )&( tConfMode ), sizeof( TConfMode ) );

    SendMsgToAllMcs( MCU_MCS_CONFMODE_NOTIF, cServMsg );	

    SendConfInfoToChairMt();
}

/*=============================================================================
  函 数 名： SendMixModeToMt
  功    能： 发送混音模式给主席终端
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： void 
=============================================================================*/
void CMcuVcInst::NotifyChairmanMixMode(void)
{
    //发会议通知
    if( HasJoinedChairman() )
    {
        CServMsg cServMsg;
		u8 byMixMode = m_tConf.m_tStatus.GetMixerMode();
        cServMsg.SetMsgBody(&byMixMode, sizeof(byMixMode));
        SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_STARTDISCUSS_NOTIF, cServMsg);
    }
}

/*=============================================================================
  函 数 名： SendConfInfoToChair
  功    能： 发送会议信息给主席终端
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： void 
=============================================================================*/
void CMcuVcInst::SendConfInfoToChairMt(void)
{
    //发会议通知
    if( HasJoinedChairman() )
    {
        TMt tMt = m_tConf.GetChairman();

		// 主席终控台特殊处理，4.7.2 ConfInfo里的合成信息已作废，但要兼容终控台
		TConfInfo tConfInfo = m_tConf;
		// 发言人local化
        tConfInfo.SetSpeaker( GetLocalSpeaker() );
		u8 byVmpId = GetTheOnlyVmpIdFromVmpList();
		if (IsValidVmpId(byVmpId))
		{
			TEqp tVmpEqp = g_cMcuVcApp.GetEqp(byVmpId);
			TVMPParam_25Mem tVmpParam_25Mem = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
			TVMPParam tVmpParam;
			//将25成员的合成信息，取前20个复制，会议信息中为20成员合成信息
			memcpy(&tVmpParam, &tVmpParam_25Mem, sizeof(tVmpParam));
			TVMPMember *ptVmpMember = NULL;
			u8 byLoop = 0;
			TMt tTempMt;
			
			for(byLoop = 0; byLoop < tVmpParam.GetMaxMemberNum(); byLoop++)
			{
				ptVmpMember = tVmpParam.GetVmpMember(byLoop);
				if( ptVmpMember == NULL )
				{
					continue;
				}
				if( ptVmpMember->IsNull())
				{
					// 为空
				}
				else
				{
					if( !ptVmpMember->IsLocal() )
					{
						memset( &tTempMt,0,sizeof(tTempMt) );
						tTempMt.SetMcuId( ptVmpMember->GetMcuId() );
						tTempMt.SetMtId( ptVmpMember->GetMtId() );
						tTempMt = GetLocalMtFromOtherMcuMt( tTempMt );
						ptVmpMember->SetMt( tTempMt );
					}
				}
			}
			
			// 20旧成员合成信息，清空之后的成员
			for(; byLoop < MAXNUM_MPUSVMP_MEMBER; byLoop++)
			{
				ptVmpMember = tVmpParam.GetVmpMember(byLoop);
				if( ptVmpMember == NULL )
				{
					continue;
				}
				ptVmpMember->SetMcuId( 0 );
				ptVmpMember->SetMtId( 0 );
			}

			// 将信息更新到临时会议信息中
			tConfInfo.m_tStatus.SetVmpParam(tVmpParam);
		}

        CServMsg	cServMsg;    
        cServMsg.SetMsgBody( ( u8 * )&tConfInfo, sizeof( tConfInfo ) );
        SendMsgToMt( tMt.GetMtId(), MCU_MT_CONF_NOTIF, cServMsg );
    }
}

/*====================================================================
    函数名      ：MtStatusChange
    功能        ：改变终端状态
    算法实现    ：
    引用全局变量：
    输入参数说明：u8     byMtId  : 具体的状态改变终端ID, 0表示所有的终端.
                  BOOL32 bForcely: 是否马上上报。FALSE: 遵循上报最短周期约束，TRUE: 实时上报.
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/05/08    3.0         胡昌威        胡昌威
====================================================================*/
// void CMcuVcInst::MtStatusChange( u8 byMtId, BOOL32 bForcely )
// {
// 	CServMsg	cServMsg;
// 	TMtStatus   tMtStatus;
// 
// 	u32 dwCurTick = OspTickGet();
// 	BOOL32 bHasStat = FALSE;
// 
// 	u8 byLoop;
// 	
//     if ( !bForcely )
//     {
//         if( dwCurTick - m_tRefreshParam.dwMcsLastTick >= m_tRefreshParam.GetMcsRefreshInterval() )
//         {
//             KillTimer( MCUVC_REFRESH_MCS_TIMER );
//             m_tRefreshParam.dwMcsLastTick = dwCurTick;
//             bHasStat = TRUE;
//             
//             cServMsg.SetMsgBody( );
//             if ( 0 == byMtId )
//             {
//                 for( byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
//                 {
//                     if( m_tConfAllMtInfo.MtInConf( byLoop ) && 
//                         m_ptMtTable->GetMtStatus( byLoop, &tMtStatus ) ) 
//                     {
// 						//ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "MtStatusChange MtId: %d, Mix:%d\n", byLoop, tMtStatus.IsInMixing());						
//                         cServMsg.CatMsgBody( (u8*)&tMtStatus, sizeof( TMtStatus ) );
//                     }
//                 }                
//             }
//             else if ( byMtId <= MAXNUM_CONF_MT )
//             {
//                 if( m_tConfAllMtInfo.MtInConf( byMtId ) && 
//                     m_ptMtTable->GetMtStatus( byMtId, &tMtStatus ) ) 
//                 {
// 					//ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "MtStatusChange MtId: %d, Mix:%d\n", byMtId, tMtStatus.IsInMixing());
// 
//                     cServMsg.CatMsgBody( (u8*)&tMtStatus, sizeof( TMtStatus ) );
//                 }
//             }
//             else
//             {
//                 ConfLog( FALSE, "[MtStatusChange] unexpected MtId.%d\n", byMtId );
//             }
//             
//             
//             if ( 0 != cServMsg.GetMsgBodyLen() )
//             {
//                 SendMsgToAllMcs( MCU_MCS_MTSTATUS_NOTIF, cServMsg );
//             }
//         }
//         else
//         {
//             SetTimer( MCUVC_REFRESH_MCS_TIMER, m_tRefreshParam.dwMcsRefreshInterval*1000, byMtId );
//         }
//     }
//     else
//     {
//         cServMsg.SetMsgBody( );
//         if ( 0 == byMtId )
//         {
//             for( byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
//             {
//                 if( m_tConfAllMtInfo.MtInConf( byLoop ) && 
//                     m_ptMtTable->GetMtStatus( byLoop, &tMtStatus ) ) 
//                 {
// 					//ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "MtStatusChange MtId: %d, Mix:%d\n", byLoop, tMtStatus.IsInMixing());
//                     cServMsg.CatMsgBody( (u8*)&tMtStatus, sizeof( TMtStatus ) );
//                 }
//             }                
//         }
//         else if ( byMtId <= MAXNUM_CONF_MT )
//         {
//             if( m_tConfAllMtInfo.MtInConf( byMtId ) && 
//                 m_ptMtTable->GetMtStatus( byMtId, &tMtStatus ) ) 
//             {
// 				//ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "MtStatusChange MtId: %d, Mix:%d\n", byMtId, tMtStatus.IsInMixing());
// 
//                 cServMsg.CatMsgBody( (u8*)&tMtStatus, sizeof( TMtStatus ) );
//             }
//         }
//         else
//         {
//             ConfLog( FALSE, "[MtStatusChange] unexpected MtId.%d\n", byMtId );
//         }
//         
//         
//         if ( 0 != cServMsg.GetMsgBodyLen() )
//         {
//             SendMsgToAllMcs( MCU_MCS_MTSTATUS_NOTIF, cServMsg );
//         }        
//     }
// 
//     return;
// }

/*====================================================================
    函数名        MtStatusChange
    功能        ：多回传改变上下级终端状态
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt* ptMt 需要发送的TMT,BOOL32 bForcely是否强制发送

    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	10/07/14    4.6         陆昆朋        创建
	20110111    4.6         pengjie       接口逻辑调整
	20110928    4.6			liuxu		  定时发送添加了缓冲发送的功能
	                                      基本策略为:
										  1. 定时发送启动一次定时器, 后续要定时发送的终端先进入缓冲池
										  2. 定时器未到缓冲区已满, 则马上发送缓冲去,并清空缓冲区
										  3. 定时器到再次发送缓冲区内容, 并停定时器
====================================================================*/
void CMcuVcInst::MtStatusChange(const TMt* ptMt, BOOL32 bForcely )
{
	if ( g_cMcuVcApp.GetMcuMcsMtStatusBufFlag() != 0	// 配置启动了缓冲发送
		&& (!bForcely									// 非马上发送		
		|| m_byAllMtToAllMcsTimerFlag)				// 如果需要发送MtInfo or Mt List, 先加入缓冲			
		)
	{
		// 如果缓冲区满了, 先把缓冲区内容发送出去并清空
		if (m_cMtStatusSendBuf.IsFull())
		{
			SendMtStatusInBuf();
		}

		// [9/27/2011 liuxu] 缓冲发送的终端, 先进缓冲池
		TMt tTempMt;
		tTempMt.SetNull();
		// Null Mt有特殊含义, 表示本地终端状态全部上报
		tTempMt = ptMt ? *ptMt : tTempMt;

		if( !m_cMtStatusSendBuf.Add( tTempMt ) )
		{
			LogPrint(LOG_LVL_WARNING, MID_MCU_CONF, "Add to MtStatusSendBuf failed\n");		
			return;
		}


		// 定时器还未启动, 则启动定时器, 否则不需要再启动了
		if ( 0 == m_tRefreshParam.dwMcsLastTick )
		{
			//liuxu, 干嘛要支持用户自定义?徒增难使用程度
			SetTimer(MCUVC_REFRESH_MCS_TIMER, m_tRefreshParam.dwMcsRefreshInterval);
			m_tRefreshParam.dwMcsLastTick = OspTickGet();			// 定时器标记为已启动
		}

		return;
	}
	// 2、直接发送
	else
	{
		CServMsg cServMsg;
		cServMsg.SetMsgBody();
		// 2.1 发送给本级所有终端
		if( ptMt == NULL )
		{
			TMtStatus tMtStatus;
			for(u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
			{
				if( m_tConfAllMtInfo.MtInConf( byLoop ) && 
					m_ptMtTable->GetMtStatus( byLoop, &tMtStatus ) ) 
				{
					cServMsg.CatMsgBody( (u8*)&tMtStatus, sizeof( TMtStatus ) );
					UpdateUploadMtMixingToMcs(m_ptMtTable->GetMt(byLoop),cServMsg);
				}
			} 
		}
		// 2.2 发送给具体某个终端 本地或下级
		else
		{
			if( ptMt->IsLocal() )
			{
				TMtStatus tMtStatus;
				if( m_tConfAllMtInfo.MtInConf( ptMt->GetMtId() ) && 
					m_ptMtTable->GetMtStatus( ptMt->GetMtId(), &tMtStatus ) ) 
				{
					cServMsg.CatMsgBody( (u8*)&tMtStatus, sizeof( TMtStatus ) );
					UpdateUploadMtMixingToMcs(m_ptMtTable->GetMt(ptMt->GetMtId()),cServMsg);
				}
			}
			else
			{
				TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(ptMt->GetMcuId());
				if (ptMcInfo == NULL)
				{
					return;
				}

				TMcMtStatus *ptMcMtStatus = ptMcInfo->GetMtStatus(*ptMt);
				if (ptMcMtStatus == NULL)
				{
					return;
				}
				
				TMtStatus tMtStatus = ptMcMtStatus->GetMtStatus();
				if (IsNeedCheapMcsMtMixing(*ptMt))
				{
					tMtStatus.SetInMixing(TRUE);
				}
				cServMsg.CatMsgBody( (u8*)&tMtStatus, sizeof( TMtStatus ) );
			}
		}

		if ( 0 != cServMsg.GetMsgBodyLen() )
		{
			SendMsgToAllMcs( MCU_MCS_MTSTATUS_NOTIF, cServMsg );
		}
	}

	return;
}

/*====================================================================
    函数名      : SendMtStatusInBuf
    功能        : 将处在缓冲池中的终端的状态发送给mcs
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    11/09/27    4.6         liuxu           创建
====================================================================*/
void CMcuVcInst::SendMtStatusInBuf( const BOOL32 bClearBuf /* = true */ )
{
	ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MCS, "Start Buf Send mtstatus to mcs\n");
	if (m_cMtStatusSendBuf.GetUsedNum())
	{
		TMt tMt;
		TMtStatus tMtStatus;
		CServMsg cServMsg;
		cServMsg.SetMsgBody();
		
		const u32 dwMaxBufNum = m_cMtStatusSendBuf.GetCapacity();
		
		u32 deSendNum = 0;						// 统计
		for ( u32 dwLoop = 0; dwLoop < dwMaxBufNum; dwLoop++ )
		{
			if(!m_cMtStatusSendBuf.Get(dwLoop, tMt))
				continue;
				
			// 有时候mcu会定时刷新所有本地终端的状态, 是通过在缓冲区插入一个空Tmt标记的
			// 同一个本地终端有空能被刷新多次, 不影响性能和功能
			if (tMt.IsNull()) 
			{
				SendAllLocalMtStatus();
				continue;
			}

			if(tMt.IsLocal())
			{
				if( m_tConfAllMtInfo.MtInConf( tMt.GetMtId() ) && 
					m_ptMtTable->GetMtStatus( tMt.GetMtId(), &tMtStatus ) ) 
				{
					deSendNum++;
					cServMsg.CatMsgBody( (u8*)&tMtStatus, sizeof( TMtStatus ) );
				}
			}else
			{
				TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tMt.GetMcuId());
				if (ptMcInfo == NULL)
				{
					continue;
				}
				
				TMcMtStatus *ptMcMtStatus = ptMcInfo->GetMtStatus(tMt);
				if (ptMcMtStatus == NULL)
				{
					continue;
				}
				
				tMtStatus = ptMcMtStatus->GetMtStatus();
				if (IsNeedCheapMcsMtMixing(tMt))
				{
					tMtStatus.SetInMixing(TRUE);
				}
				cServMsg.CatMsgBody( (u8*)&tMtStatus, sizeof( TMtStatus ) );
				deSendNum++;
			}
		}

		if ( 0 != cServMsg.GetMsgBodyLen() )
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MCS, "Buf send %d other mt status to mcs\n", deSendNum);
			SendMsgToAllMcs( MCU_MCS_MTSTATUS_NOTIF, cServMsg );
		}
	}

	if (bClearBuf)
	{
		m_cMtStatusSendBuf.ClearAll();
	}
}

/*====================================================================
    函数名      : MtSecSelSrcChange
    功能        : 通知界面终端的双选看源改变
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt，需要通知的终端，如果为NULL，则通知会议中所有终端的双选看源
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2012/09/23  4.7         zhangli        create
====================================================================*/
void CMcuVcInst::MtSecSelSrcChange(const TMt &tMt)
{
	CServMsg cServMsg;
	cServMsg.SetMsgBody();
	u8 bySrcMtId = 0;
	
	if(tMt.IsNull())
	{
		TMt tSrcMt;
		for(u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; ++byMtId)
		{
			if (!m_tConfAllMtInfo.MtJoinedConf(byMtId))
			{
				continue;
			}
			
			tSrcMt = m_ptMtTable->GetMtSelMtByMode(byMtId, MODE_VIDEO2SECOND);
			cServMsg.CatMsgBody((u8*)&byMtId, sizeof(u8));
			cServMsg.CatMsgBody((u8*)&tSrcMt, sizeof(TMt));
		} 
	}
	else
	{
		if (tMt.IsLocal())
		{
			return;
		}
		
		u8 byMtId = tMt.GetMtId();
		if (!m_tConfAllMtInfo.MtJoinedConf(byMtId))
		{
			return;
		}
		
		TMt tSrcMt = m_ptMtTable->GetMtSelMtByMode(byMtId, MODE_VIDEO2SECOND);
		cServMsg.CatMsgBody((u8*)&byMtId, sizeof(u8));
		cServMsg.CatMsgBody((u8*)&tSrcMt, sizeof(TMt));
	}
	
	if ( 0 != cServMsg.GetMsgBodyLen() )
	{
		SendMsgToAllMcs( MCU_MCS_MTSECSEL_NOTIFY, cServMsg );
	}
}

/*====================================================================
    函数名      : SendAllLocalMtStatus
    功能        : 将所有本地与会终端的状态
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    11/09/27    4.6         liuxu           创建
====================================================================*/
void CMcuVcInst::SendAllLocalMtStatus( const u16 wEvent/* = MCU_MCS_MTSTATUS_NOTIF*/ )
{
	TMtStatus tMtStatus;
	CServMsg cServMsg;
	cServMsg.SetMsgBody();
	
	if ( MCU_MCS_ALLMTSTATUS_NOTIF == wEvent )
	{
		TMt tMcu;
		tMcu.SetNull();
		tMcu.SetMcu( LOCAL_MCUID );
		tMcu.SetMcuIdx( LOCAL_MCUIDX );
		cServMsg.SetMsgBody( (u8*)&tMcu, sizeof( tMcu ) );
	}
	
	u8 bySendNum = 0;
	for(u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
	{
		if( m_tConfAllMtInfo.MtInConf( byLoop ) && 
			m_ptMtTable->GetMtStatus( byLoop, &tMtStatus ) ) 
		{
			bySendNum++;
			cServMsg.CatMsgBody( (u8*)&tMtStatus, sizeof( TMtStatus ) );
		}
	} 
	
	if ( 0 != cServMsg.GetMsgBodyLen() )
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_MCS, "Buf send %d local mt status to mcs\n", bySendNum);
		SendMsgToAllMcs( wEvent, cServMsg );
	}
}

/*====================================================================
    函数名      : ProcTimerRefreshMmcuMcs
    功能        处理刷新会控时钟
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/11/04    3.5         胡昌威           创建
	11/09/28	4.6			liuxu		  定时发送之前存在只能发送一个终端的状态(最后一个请求的)的问题
										  现在调整为缓冲发送, 缓冲发送机制详见MtStatusChange的修改记录
====================================================================*/
void CMcuVcInst::ProcTimerRefreshMcs( void )
{
// 	CServMsg	cServMsg;
// 	cServMsg.SetMsgBody();
//     u32 dwMcuMtIdInfo = *(u32*)pcMsg->content;

	switch( CurState() )
	{
	case STATE_ONGOING:
		// [9/28/2011 liuxu] m_tRefreshParam.dwMcsLastTick为0, 表示定时器未启动, 或者启动已经响应了
		m_tRefreshParam.dwMcsLastTick = 0 /*OspTickGet()*/;
		
		if (m_byAllMtToAllMcsTimerFlag)
		{
			CServMsg	cServMsg;
			SendAllMtInfoToAllMcs( MCU_MCS_CONFALLMTINFO_NOTIF, cServMsg, TRUE );
		}
		
		// [9/27/2011 liuxu] 将缓冲区内容发送给界面
		SendMtStatusInBuf();

// 
//         if ( 0 == dwMcuMtIdInfo )
//         {
// 			TMtStatus   tMtStatus;
//             for( u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
//             {
//                 if( m_tConfAllMtInfo.MtInConf( byLoop ) && 
//                     m_ptMtTable->GetMtStatus( byLoop, &tMtStatus ) ) 
//                 {
//                     cServMsg.CatMsgBody( (u8*)&tMtStatus, sizeof( TMtStatus ) );
//                 }
//             }            
//         }
// 		else
// 		{  
// 			u16 wMcuId = (u16)(dwMcuMtIdInfo >> 16);
// 			u8 byMtId = (u8)dwMcuMtIdInfo;
// 			TMt tMt;
// 			tMt.SetMcuId(wMcuId);
// 			tMt.SetMtId(byMtId);
// 			if( tMt.IsLocal() )
// 			{
// 				TMtStatus   tMtStatus;
// 				if( m_tConfAllMtInfo.MtInConf( byMtId ) && 
// 					m_ptMtTable->GetMtStatus( byMtId, &tMtStatus ) ) 
// 				{
// 					cServMsg.CatMsgBody( (u8*)&tMtStatus, sizeof( TMtStatus ) );
// 				}
// 			}
// 			else
// 			{
// 				//TConfMcInfo *ptMcInfo = GetMcInfo(tMt.GetMcuId());
// 				TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tMt.GetMcuId());
// 				if (ptMcInfo == NULL)
// 				{
// 					return;
// 				}
// 				
// 				TMcMtStatus *ptMcMtStatus = ptMcInfo->GetMtStatus(tMt);
// 				if (ptMcMtStatus == NULL)
// 				{
// 					return;
// 				}
// 				
// 				TMtStatus tMtStatus = ptMcMtStatus->GetMtStatus();
// 				cServMsg.CatMsgBody( (u8*)&tMtStatus, sizeof( TMtStatus ) );
// 			}
// 		}
// 
// 		SendMsgToAllMcs( MCU_MCS_MTSTATUS_NOTIF, cServMsg );
		break;
	default:
		ConfPrint( LOG_LVL_WARNING, MID_MCU_CONF, "CMcuVcInst: Wrong message TIMER_REFRESH_MCS received in state %u!\n", CurState() );
		break;
	}
}

/*====================================================================
    函数名      : SendMcuMediaSrcNotify
    功能        : 发送MCU数据源通知
    算法实现    ：
    引用全局变量：
    输入参数说明：BOOL32 bFource = FALSE TRUE-不论是否变化,强制通知
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/11/04    3.5         胡昌威           创建
	10/12/31    4.6          liuxu           修改
====================================================================*/
void CMcuVcInst::SendMcuMediaSrcNotify(BOOL32 bFource)
{
	CServMsg cServMsg;

	// 保护性处理
	if (NULL == m_ptConfOtherMcTable)
	{
		return;
	}

	TConfMcInfo * ptMcInfo = NULL;
	u16 wMcuIdx = 0;
	u8 byFstMcuId = 0;
	u8 abyMcuId[ MAX_CASCADEDEPTH - 1 ] = {0};
	TMt tMt;
	TMcu tMcu;
	for (u16 wLoop = 0; wLoop < TConfOtherMcTable::GetMaxMcuNum(); wLoop++)
	{		
		ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(wLoop);
		if (NULL == ptMcInfo)
		{
			continue;
		}

		wMcuIdx = ptMcInfo->GetMcuIdx();
		if (!IsValidSubMcuId(wMcuIdx))
		{
			continue;
		}

		memset( &abyMcuId[0],0,sizeof(abyMcuId) );					// 清0
		if( !m_tConfAllMcuInfo.GetMcuIdByIdx(wMcuIdx, &abyMcuId[0]) )
		{
			continue;
		}
		
		tMt = GetMcuMediaSrc(wMcuIdx);
		if( !IsValidMtId(tMt.GetMtId()) )
		{
			continue;
		}

		byFstMcuId = abyMcuId[0];
		//不进行强制通知，没有变化，则不再重复通知
		if (ptMcInfo->m_tSrcMt.GetMcuIdx() == tMt.GetMcuIdx() && 
			ptMcInfo->m_tSrcMt.GetMtId() == tMt.GetMtId() && 
			FALSE == bFource)
		{
			continue;
		}

		//如果查询的是上级mcu并且媒体源为空，则设置媒体源即是该mcu
		if ((tMt.IsNull() || 0 == tMt.GetMtId()) && 
			!m_tCascadeMMCU.IsNull() && 
			byFstMcuId == m_tCascadeMMCU.GetMtId())
		{
			tMt.SetMcuIdx(wMcuIdx);
			tMt.SetMtId(byFstMcuId);
		}

		ConfPrint(LOG_LVL_DETAIL, MID_MCU_MMCU, "[ProcTimerMcuSrcCheck] McuId.%d - MtMcuIdx.%d MtId.%d MtType.%d MtConfIdx.%d\n", 
				byFstMcuId, tMt.GetMcuIdx(), tMt.GetMtId(), tMt.GetMtType(), tMt.GetConfIdx());

		
        // guzh [4/8/2007] 设置新的媒体源
		ptMcInfo->m_tSrcMt = tMt;
		
		tMcu.SetNull();
		tMcu.SetMcuIdx(wMcuIdx);
		cServMsg.SetEventId(MCU_MCS_MCUMEDIASRC_NOTIF);
		cServMsg.SetMsgBody((u8 *)&tMcu, sizeof(tMcu));
		cServMsg.CatMsgBody((u8 *)&tMt, sizeof(tMt));
		SendMsgToAllMcs(MCU_MCS_MCUMEDIASRC_NOTIF, cServMsg);
	}

	return;
}

/*====================================================================
    函数名      : ProcTimerMcuSrcCheck
    功能        ：mcu源检查时钟
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/11/04    3.5         胡昌威           创建
====================================================================*/
void CMcuVcInst::ProcTimerMcuSrcCheck(const CMessage * pcMsg)
{
	STATECHECK;

	SendMcuMediaSrcNotify(FALSE);

	// [10/17/2011 liuxu]老版本如R2发过来的Setoutnotify带的终端是不正确的，mediasrcnotify触发时机需要该timer保证
	SetTimer(MCUVC_MCUSRC_CHECK_TIMER, TIMESPACE_MCUSRC_CHECK);

	return;	
}

/*====================================================================
    函数名      ProcTimerChangeVmpParam
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	05/06/14    3.6         LIBO          创建
    06/04/25    4.0         张宝卿        适应自动合成主席和发言人的加入
====================================================================*/
void CMcuVcInst::ProcTimerChangeVmpParam(const CMessage * pcMsg)
{
    u32 dwVmpMemberType = *(u32 *)pcMsg->content;

    if (m_tConfInStatus.IsVmpNotify())
    {
        if (MCUVC_CHANGE_VMPPARAM_TIMER == pcMsg->event)//此Timer未使用，作废
        {
            TVMPParam_25Mem tVMPParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
            //ChangeVmpParam(&tVMPParam);

			// xliang [1/6/2009] 区分新老VMP设VMP param
			//AdjustVmpParam(&tVMPParam);
        }
        else
        {
            TMt tMt;
            tMt.SetNull();
            if (VMP_MEMBERTYPE_SPEAKER == dwVmpMemberType)
            {
				// [pengjie 2010/3/31] 事实证明这里不合理...
//                tMt = GetLocalSpeaker(); //FIXME:取Local的是否合理
				tMt = m_tConf.GetSpeaker();
                ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "\n[ProcTimerChangeVmpChanParam] - VMP_MEMBERTYPE_SPEAKER - mtid:%d\n\n", tMt.GetMtId());
            }
            else if (VMP_MEMBERTYPE_CHAIRMAN == dwVmpMemberType)
            {
                tMt = m_tConf.GetChairman();
                ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "\n[ProcTimerChangeVmpChanParam] - VMP_MEMBERTYPE_CHAIRMAN - mtid:%d\n\n", tMt.GetMtId());
            }

            if (tMt.IsNull())
            {                
                return;
            }

            ChangeVmpChannelParam(&tMt, (u8)dwVmpMemberType);     		
        }
    }
    else
    {
        SetTimer(pcMsg->event, TIMESPACE_CHANGEVMPPARAM, dwVmpMemberType);
    }
}

/*====================================================================
    函数名      ：MtOnlineChange
    功能        ：终端在线状态变化
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/08/12    3.0         胡昌威        创建
====================================================================*/
void CMcuVcInst::MtOnlineChange( TMt tMt, BOOL32 bOnline, u8 byReason )
{
	u8 byOnline = bOnline;
	CServMsg	cServMsg;
    cServMsg.SetMsgBody( (u8*)&tMt, sizeof( TMt ) );
	cServMsg.CatMsgBody( (u8*)&byOnline, sizeof( u8 ) );
	cServMsg.CatMsgBody( (u8*)&byReason, sizeof( u8 ) );
	SendMsgToAllMcs( MCU_MCS_MTONLINECHANGE_NOTIF, cServMsg );
	TMt tNull;

	// 对于VCS会议，还需要通告当前VCS会议的特殊状态信息
	if (VCS_CONF == m_tConf.GetConfSource())
	{
		TMt tCurVCMT  = m_cVCSConfStatus.GetCurVCMT();
		TMt tReqVCMT  = m_cVCSConfStatus.GetReqVCMT();
		TMt tChairMan = m_tConf.GetChairman();
		TMtAlias tChairManAlias = m_tConf.GetChairAlias();
		TMt tBackChairMan = m_cVCSConfStatus.GetVcsBackupChairMan();

		if (byOnline)
		{
			// 根据调度席当前的静哑音状态设置对应终端状态
			//本机地址掉线后，chairman会设为null，但是此时再上线，可以通过chairmanalias来判断是不是主席上线
			if ( tChairMan.IsNull() )
			{
				u8 byMtId = m_ptMtTable->GetMtIdByAlias(&tChairManAlias);
				if( byMtId > 0 )
				{
					tChairMan = m_ptMtTable->GetMt(byMtId) ;
				}
			}
			if( (tChairMan == tMt) ||
				( tBackChairMan == tMt && !m_tConfAllMtInfo.MtJoinedConf( tChairMan ) )
				)
			{
				ChangeChairman( &tMt );
				VCSMTMute(tMt, m_cVCSConfStatus.IsLocMute(), VCS_AUDPROC_MUTE);
				VCSMTMute(tMt, m_cVCSConfStatus.IsLocSilence(), VCS_AUDPROC_SILENCE);
				if( tBackChairMan == tMt )
				{
					m_cVCSConfStatus.SetVcsBackupChairMan( tChairMan );
				}
				//zhouyiliang 20100907 主席备份主席都掉线再上线时，组呼模式下应该restore原逻辑
				if ( ISGROUPMODE( m_cVCSConfStatus.GetCurVCMode()) ) 
				{
					m_ptMtTable->SetMtInMixing( tMt.GetMtId(),TRUE,TRUE );
					//RestoreVCConf( m_cVCSConfStatus.GetCurVCMode() );
					switch( m_cVCSConfStatus.GetCurVCMode() )
					{
					case VCS_GROUPCHAIRMAN_MODE:
						ChangeSpeaker( &tMt );
						break;
					case VCS_GROUPSPEAK_MODE:
						if( m_cVCSConfStatus.GetCurVCMT().IsNull() )
						{
							ChangeSpeaker( &tMt );
						}
						
						
						break;
					case VCS_GROUPROLLCALL_MODE:
					case VCS_GROUPVMP_MODE:
						/* 2011-12-23 mod by pgf: 此时不用调，后向通道有可能没开，导致参数设进去了，但是交换没建立
						TVMPParam tVmpParam = m_tConf.m_tStatus.GetVmpParam();
						TVMPMember tVMPMember;
						for(u8 byIdx = tVmpParam.GetMaxMemberNum();byIdx > 0;--byIdx )
						{
							tVMPMember = *tVmpParam.GetVmpMember(byIdx-1);
							tVmpParam.SetVmpMember( byIdx,tVMPMember );
						}
						tVMPMember.SetMemberTMt(tMt);
						tVmpParam.SetVmpMember(0,tVMPMember);
						//if( m_cVCSConfStatus.GetCurVCMode() == VCS_GROUPROLLCALL_MODE )
						{
							tVmpParam.SetVMPStyle(GetVmpDynStyle(tVmpParam.GetMaxMemberNum()+1));
						}
						if( !m_cVCSConfStatus.GetCurVCMT().IsNull() )
						{
							tNull = m_cVCSConfStatus.GetCurVCMT();
							m_cVCSConfStatus.SetReqVCMT( tNull );
						}
						AdjustVmpParam( &tVmpParam );
						tNull.SetNull();
						m_cVCSConfStatus.SetReqVCMT( tNull );
						*/											
						break;
					default:
						break;
					}

					
					
				}
				//通知所有会控
				cServMsg.SetMsgBody( ( u8 * )&m_tConf, sizeof( m_tConf ) );
				if(m_tConf.HasConfExInfo())
				{
					u8 abyConfInfExBuf[CONFINFO_EX_BUFFER_LENGTH] = {0};
					u16 wPackDataLen = 0;
					PackConfInfoEx(m_tConfEx,abyConfInfExBuf,wPackDataLen);
					cServMsg.CatMsgBody(abyConfInfExBuf, wPackDataLen);
				}
				SendMsgToAllMcs( MCU_MCS_CONFINFO_NOTIF, cServMsg );
			}
			/*if ( tChairMan == tMt )
			{
				ChangeChairman( &tChairMan );
				VCSMTMute(tMt, m_cVCSConfStatus.IsLocMute(), VCS_AUDPROC_MUTE);
				VCSMTMute(tMt, m_cVCSConfStatus.IsLocSilence(), VCS_AUDPROC_SILENCE);
				//zhouyiliang 20100907 主席备份主席都掉线再上线时，组呼模式下应该restore原逻辑
				if ( ISGROUPMODE( m_cVCSConfStatus.GetCurVCMode()) ) 
				{
					RestoreVCConf( m_cVCSConfStatus.GetCurVCMode() );
				}
				//通知所有会控
				cServMsg.SetMsgBody( ( u8 * )&m_tConf, sizeof( m_tConf ) );
				SendMsgToAllMcs( MCU_MCS_CONFINFO_NOTIF, cServMsg );
			}
			else if ( tBackChairMan == tMt && !m_tConfAllMtInfo.MtJoinedConf( tChairMan ) )
			{
				ChangeChairman( &tBackChairMan );
				VCSMTMute(tMt, m_cVCSConfStatus.IsLocMute(), VCS_AUDPROC_MUTE);
				VCSMTMute(tMt, m_cVCSConfStatus.IsLocSilence(), VCS_AUDPROC_SILENCE);
				m_cVCSConfStatus.SetVcsBackupChairMan( tChairMan );
				//zhouyiliang 20100907 主席备份主席都掉线再上线时，组呼模式下应该restore原逻辑
				if ( ISGROUPMODE( m_cVCSConfStatus.GetCurVCMode()) ) 
				{
					RestoreVCConf( m_cVCSConfStatus.GetCurVCMode() );
				}
				//通知所有会控
				cServMsg.SetMsgBody( ( u8 * )&m_tConf, sizeof( m_tConf ) );
				SendMsgToAllMcs( MCU_MCS_CONFINFO_NOTIF, cServMsg );
			}*/
			else 
			{
				TMt tLocalMt = tMt; 
				if (!tMt.IsLocal())
				{
					tLocalMt = m_ptMtTable->GetMt(GetFstMcuIdFromMcuIdx(tMt.GetMcuId()));
				}
				if( ( !(tMt == m_tConf.GetChairman() ) 
					&& !(m_tCascadeMMCU == tLocalMt) // [12/31/2010 xliang] 如果是上级mcu的终端，则不要再触发远端静哑音动作
					)
					|| MT_TYPE_SMCU == m_ptMtTable->GetMtType(tLocalMt.GetMtId()) )
					// 				if ( !(tMt == m_tConf.GetChairman() ) ||//CONF_CALLMODE_NONE == VCSGetCallMode(tMt) || 
					// 					MT_TYPE_SMCU == m_ptMtTable->GetMtType(tMt.GetMtId()))
				{
					//VCSMTMute(tMt, m_cVCSConfStatus.IsRemMute(), VCS_AUDPROC_MUTE);
					
					//VCSMTMute(tMt, m_cVCSConfStatus.IsRemSilence(), VCS_AUDPROC_SILENCE);

// 					if( MT_TYPE_SMCU == m_ptMtTable->GetMtType(tLocalMt.GetMtId()) )
// 					{
// 						//ConfPrint(LOG_LVL_DETAIL, MID_MCU_VCS, "[ProcVcsMcuMuteReq] pass the msg to mt.%d(smcu)!\n", byMTId );
// 						CServMsg cMsgMute;
// 						u8 byMode = m_cVCSConfStatus.GetCurVCMode();
// 						u8  byMuteOpenFlag =      m_cVCSConfStatus.IsRemMute() ? 1 : 0;   //是否开启
// 						u8  byOprObj       =      VCS_OPR_REMOTE;	//操作本地/远端
// 						u8  byAudProcType  =      VCS_AUDPROC_MUTE; //处理静音/哑音
// 			
// 						cMsgMute.SetMsgBody(&byMode, sizeof(byMode));
// 						cMsgMute.CatMsgBody(&byMuteOpenFlag, sizeof(byMuteOpenFlag));
// 						cMsgMute.CatMsgBody(&byOprObj, sizeof(byOprObj));
// 						cMsgMute.CatMsgBody(&byAudProcType, sizeof(byAudProcType));
// 
// 						SendMsgToMt(tLocalMt.GetMtId(), VCS_MCU_MUTE_REQ, cMsgMute);
// 
// 
// 						byMuteOpenFlag = m_cVCSConfStatus.IsRemSilence();
// 						byMuteOpenFlag = VCS_AUDPROC_SILENCE;
// 						CServMsg cMsgSilence;
// 						cMsgSilence.SetMsgBody(&byMode, sizeof(byMode));
// 						cMsgSilence.CatMsgBody(&byMuteOpenFlag, sizeof(byMuteOpenFlag));
// 						cMsgSilence.CatMsgBody(&byOprObj, sizeof(byOprObj));
// 						cMsgSilence.CatMsgBody(&byAudProcType, sizeof(byAudProcType));
// 
// 						SendMsgToMt(tLocalMt.GetMtId(), VCS_MCU_MUTE_REQ, cMsgSilence);
// 					}
				}
			}

			//zjj20100330
			TMtStatus tMtStatus;
			if( tMt.IsLocal() &&
				 m_ptMtTable->GetMtStatus( tMt.GetMtId(),&tMtStatus ) 
				 )
			{	
				tMtStatus.SetMtDisconnectReason( MTLEFT_REASON_NONE );
				m_ptMtTable->SetMtStatus( tMt.GetMtId(),&tMtStatus );
				if( ISGROUPMODE(  m_cVCSConfStatus.GetCurVCMode() ) ||
					CONF_CREATE_MT == m_byCreateBy)
				{
					m_ptMtTable->SetCallMode( tMt.GetMtId(),CONF_CALLMODE_TIMER );
				}
			}

			if( tMt.IsLocal() )
			{
				NotiyfMtConfSpeakMode( tMt.GetMtId(),m_cVCSConfStatus.GetConfSpeakMode() );
			}
		}

		
		tNull.SetNull();
		if (tReqVCMT == tMt && byOnline && !tMt.IsLocal())
		{
			// 对于下级终端上线通告，认为已完成调度，而对于本级终端需要等到终端请求打开通道才认为调度完成
			KillTimer(MCUVC_VCMTOVERTIMER_TIMER);
			ChgCurVCMT(tMt);
		}

	//	u16 wMcuIdx = INVALID_MCUIDX;
		//if (GetLocalMtFromOtherMcuMt(tCurVCMT) == GetLocalMtFromOtherMcuMt(tMt) && !byOnline)
		if( !byOnline && ( tCurVCMT == tMt ||
				( !tCurVCMT.IsNull() && IsMtInMcu( tMt,tCurVCMT)
				/*m_ptMtTable->GetMtType( tMt.GetMtId() ) == MT_TYPE_SMCU && 
				INVALID_MCUIDX != (wMcuIdx = GetMcuIdxFromMcuId( tMt.GetMtId() )) &&				
				tCurVCMT.GetMcuIdx() == wMcuIdx*/ ) 
			)
			)
		{
			// 对于当前调度的终端，在线－－>不在线
			m_cVCSConfStatus.SetCurVCMT(tNull);
//			ChangeConfRestoreMixParam();
			// 如果对于组呼发言人及组呼电视墙模式,自动更改本地终端作发言人
			u8 byMode = m_cVCSConfStatus.GetCurVCMode();
			if ( (VCS_GROUPSPEAK_MODE == byMode &&
				(CONF_SPEAKMODE_ANSWERINSTANTLY != m_tConf.GetConfSpeakMode() ||
				m_tApplySpeakQue.IsQueueNull()))
				|| VCS_GROUPTW_MODE == byMode 
				|| VCS_GROUPCHAIRMAN_MODE == byMode
				)
			{
				TMt tTempChairMan = m_tConf.GetChairman();
				ChangeSpeaker(&tTempChairMan);
			}
		}

	    VCSConfStatusNotif();
	}

}

/*====================================================================
    函数名      ：SendReplyBack
    功能        ：将应答发给正确对象
    算法实现    ：根据消息头中的源MCU、MT和会话号决定方向
    引用全局变量：
    输入参数说明：CServMsg & cCmdReply, 应答消息
				  u16 wEvent, 应答消息号
    返回值说明  ：TRUE/FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/08/09    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::SendReplyBack( CServMsg &cReplyMsg, u16 wEvent )
{
	if( IsMtCmdFromThisMcu( cReplyMsg ) )	   // 是连接本MCU的终端发的命令应答
	{
		 SendMsgToMt( cReplyMsg.GetSrcMtId(), wEvent, cReplyMsg ) ;
	}
	else if( IsMcCmdFromThisMcu( cReplyMsg ) ) // 是连接本MCU的会议控制台发的命令应答
	{
		 SendMsgToMcs( cReplyMsg.GetSrcSsnId(), wEvent, cReplyMsg );
	}

	return;
}

/*====================================================================
    函数名      ：IsMtCmdFromThisMcu
    功能        ：判断是否是本MCU终端发出命令的返回应答
    算法实现    ：
    引用全局变量：
    输入参数说明：const CServMsg & cCmdReply, 应答消息
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/08/08    1.0         LI Yi         创建
====================================================================*/
BOOL32 CMcuVcInst::IsMtCmdFromThisMcu(const CServMsg &cCmdReply) const
{
	if( cCmdReply.GetSrcMtId() !=0 )
		return( TRUE );
	else
		return( FALSE );
}

/*====================================================================
    函数名      ：IsMcCmdFromThisMcu
    功能        ：判断是否是本MCU会议控制台发出命令的返回应答
    算法实现    ：
    引用全局变量：
    输入参数说明：const CServMsg & cCmdReply, 应答消息
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/08/05    1.0         LI Yi         创建
====================================================================*/
BOOL32 CMcuVcInst::IsMcCmdFromThisMcu( const CServMsg & cCmdReply ) const
{
	if( cCmdReply.GetSrcMtId() == 0 && cCmdReply.GetSrcSsnId() != 0 )
		return( TRUE );
	else
		return( FALSE );
}

/*====================================================================
    函数名      ：ClearVcInst
    功能        ：清空实例 数据（m_ptMtTable、m_ptSwitchTable、m_ptConfOtherMcTable除外）
    算法实现    ：
    引用全局变量：
    输入参数说明：无
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/11/08    3.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::ClearVcInst(void)
{
    m_tConf.Reset();
	m_tConfEx.Clear();

    memset(&m_tConfPollParam, 0, sizeof(m_tConfPollParam));
	//[03/04/2010] zjl modify 
    //memset(&m_tTvWallPollParam, 0, sizeof(m_tTvWallPollParam));
	//memset( &m_tHduPollParam, 0x0, sizeof(m_tHduPollParam) );  // add by jlb
	memset(&m_tTWMutiPollParam, 0, sizeof(m_tTWMutiPollParam));
    memset(&m_tConfEqpModule, 0, sizeof(m_tConfEqpModule));
    memset(&m_tConfProtectInfo, 0, sizeof(m_tConfProtectInfo));

    memset(&m_tVmpEqp, 0, sizeof(m_tVmpEqp));
	memset(&m_tRecPara, 0, sizeof(m_tRecPara));
	//memset(&m_tLastVmpEqp, 0, sizeof(m_tLastVmpEqp));
	
    memset(&m_tMixEqp, 0, sizeof(m_tMixEqp));
//     memset(&m_tAudBasEqp, 0, sizeof(m_tAudBasEqp));         //modify bas 2
//     memset(&m_tVidBasEqp, 0, sizeof(m_tVidBasEqp));         //modify bas 2
//     memset(&m_tBrBasEqp, 0, sizeof(m_tBrBasEqp));           //modify bas 2
//     memset(&m_tCasdAudBasEqp, 0, sizeof(m_tCasdAudBasEqp)); //modify bas 2
//     memset(&m_tCasdVidBasEqp, 0, sizeof(m_tCasdVidBasEqp)); //modify bas 2
    memset(&m_tRecEqp, 0, sizeof(m_tRecEqp));
    memset(&m_tPlayEqp, 0, sizeof(m_tPlayEqp));
//    memset(&m_tPrsEqp, 0, sizeof(m_tPrsEqp));
//    memset(m_abyCasChnCheckTimes, 0, sizeof(m_abyCasChnCheckTimes));
    memset(&m_tRefreshParam, 0, sizeof(m_tRefreshParam));
    memset(m_abyMixMtId, 0, sizeof(m_abyMixMtId));
	memset(m_atMixMt,0,sizeof(m_atMixMt));

	//memset(m_abyMtCountPoint, 0, sizeof(m_abyMtCountPoint));
    SetVidBrdSrcNull();
    //m_tAudBrdSrc.SetNull();
	SetAudBrdSrcNull();
    m_tLastSpeaker.SetNull();
    m_tVacLastSpeaker.SetNull();
    m_tCascadeMMCU.SetNull();
    m_tConfAllMtInfo.m_tMMCU.SetNull();
    m_tLastSpyMt.SetNull();    
    memset(&m_tChargeSsnId, 0, sizeof(m_tChargeSsnId));
	//memset(&m_tLastVmpParam, 0, sizeof(m_tLastVmpParam));
	memset(&m_tLastVmpTwParam, 0, sizeof(m_tLastVmpTwParam));
    memset(&m_byLastMixMode, 0, sizeof(m_byLastMixMode));
    m_tHduBatchPollInfo.SetNull();
    m_tHduPollSchemeInfo.SetNull();
	m_cVCSConfStatus.VCCDefaultStatus();
    
	m_tDoubleStreamSrc.SetNull();
    m_tH239TokenOwnerInfo.Clear();

    m_tConfInStatus.Reset();

    m_byMixGrpId        = 0;
    m_byRecChnnl        = EQP_CHANNO_INVALID;
    m_byPlayChnnl       = EQP_CHANNO_INVALID;
//     m_byAudBasChnnl     = EQP_CHANNO_INVALID; //modify bas 2
//     m_byVidBasChnnl     = EQP_CHANNO_INVALID; //modify bas 2
//     m_byBrBasChnnl      = EQP_CHANNO_INVALID; //modify bas 2
//     m_byCasdAudBasChnnl = EQP_CHANNO_INVALID;
//     m_byCasdVidBasChnnl = EQP_CHANNO_INVALID;
    m_wVidBasBitrate    = 0;
    m_wBasBitrate       = 0;
	//memset(m_awVMPBrdBitrate, 0, sizeof(m_awVMPBrdBitrate));
//    m_byRegGKDriId      = 0;
//     m_byPrsChnnl        = EQP_CHANNO_INVALID;
//     m_byPrsChnnl2       = EQP_CHANNO_INVALID;
//     m_byPrsChnnlAud     = EQP_CHANNO_INVALID;
//     m_byPrsChnnlAudBas  = EQP_CHANNO_INVALID;
//     m_byPrsChnnlVidBas  = EQP_CHANNO_INVALID;
//     m_byPrsChnnlBrBas   = EQP_CHANNO_INVALID;

// 	m_byPrsChnnlVmpOut1 = EQP_CHANNO_INVALID;
// 	m_byPrsChnnlVmpOut2	= EQP_CHANNO_INVALID;
// 	m_byPrsChnnlVmpOut3	= EQP_CHANNO_INVALID;
// 	m_byPrsChnnlVmpOut4	= EQP_CHANNO_INVALID;
// 	m_byPrsChnnlDsVidBas		= EQP_CHANNO_INVALID;

#ifdef _MINIMCU_
    m_byIsDoubleMediaConf = 0;
#endif

	// 增加对 向外设发送请求关键帧命令的保护, zgc, 2008-04-21
	m_dwVmpLastVCUTick = 0;				
	/*m_dwVmpTwLastVCUTick = 0;		
	m_dwVidBasChnnlLastVCUTick = 0;	
	m_dwAudBasChnnlLastVCUTick = 0;
	m_dwBrBasChnnlLastVCUTick = 0;
	m_dwCasdAudBasChnnlLastVCUTick = 0;
	m_dwCasdVidBasChnnlLastVCUTick = 0;*/

	m_wRestoreTimes      = 1;
    m_byConfIdx          = 0;
	m_byDcsIdx			 = 0;
    
    m_byCreateBy         = 0;
	m_byNewTokenReqMtid    = 0;
	m_byMtIdNotInvite    = 0;// xliang [12/26/2008] 
	// 会议发言人码流源的设定渠道, zgc, 2008-04-14
	m_bySpeakerAudSrcSpecType = SPEAKER_SRC_NOTSEL;
	m_bySpeakerVidSrcSpecType = SPEAKER_SRC_NOTSEL;

    //m_cMtRcvGrp.Clear();


	
	// xliang [12/18/2008] 清空vmp channel信息
	//m_tVmpChnnlInfo.clear();
	//memset(m_abyMtVmpChnnl, 0, sizeof(m_abyMtVmpChnnl));
	memset(m_abyMtNeglectedByVmp, 0, sizeof(m_abyMtNeglectedByVmp));

	memset(m_abyVmpEqpId, 0, sizeof(m_abyVmpEqpId));
	m_tModuleVmpEqp.SetNull();

	m_tLastVmpChnnlMemInfo.Init();
	//memset(m_atVMPTmpMember,0,sizeof(m_atVMPTmpMember));
	//m_bNewMemberSeize = 0;

	//m_tVMPOutParam.Initialize();
	//m_tVmpAdaptChnSeizeOpr.Clear(); 

	//m_tVmpCasMemInfo.Init();
	m_byVmpOperating = 0;
	
	m_bMMcuSpeakerValid  = FALSE; 
	m_byOtherConfMtId = 0;
	//zjj20091102
	m_cCfgInfoRileExtraDataMgr.Clear();
	
	//zjj20100224 多回传增加
	m_cLocalSpyMana.Clear();

	//lukunpeng 2010/07/19 多回传整理
	CMultiSpyMgr *pcMultiSpyMgr = g_cMcuVcApp.GetCMultiSpyMgr();
	m_cSMcuSpyMana.Clear(pcMultiSpyMgr);

	m_tApplySpeakQue.ClearQueue();

	m_cSmsControl.Init();

	m_cMtStatusSendBuf.ClearAll();
	
	m_byAllMtToAllMcsTimerFlag = 0;
	m_cMcuMtListSendBuf.ClearAll();
	
	m_byMtStatusToMMcuTimerFlag = 0;
	m_cLocalMtStatusToMMcuBuf.ClearAll();
	m_cSMcuMtStatusToMMcuBuf.ClearAll();

	m_dwBrdFastUpdateTick = 0;
	m_tSecVidBrdSrc.SetNull();

	SetRealSndSpyBandWidth(0);
	
	KillTimer(MCUVC_SENDALLMT_ALLMCS_TIMER);
    KillTimer(MCUVC_SEND_SMCUMTSTATUS_TIMER);

    KillTimer(MCUVC_SCHEDULED_CHECK_TIMER);
    KillTimer(MCUVC_ONGOING_CHECK_TIMER);
    KillTimer(MCUVC_INVITE_UNJOINEDMT_TIMER);
    KillTimer(MCUVC_MCUSRC_CHECK_TIMER);
	KillTimer(MCUVC_RECREATE_DATACONF_TIMER);
    KillTimer(MCUVC_CONFSTARTREC_TIMER);
	//  [12/26/2009 pengjie]
	KillTimer(MCUVC_UPDATA_AUTOREC_TIMER);
	// [pengjie 2010/2/26]
	KillTimer(MCUVC_NOTIFYMCUH239TOKEN_TIMER);

	// [pengjie 2010/9/29]
	KillTimer(MCUVC_CHECK_CONFBRDSRC_TIMER);
    
	/*MCU_SAFE_DELETE(m_ptMtTable);*/
	DeleteMcuBasMgr();
    MCU_SAFE_DELETE(m_ptSwitchTable);
    MCU_SAFE_DELETE(m_ptConfOtherMcTable);
	m_byConfFlag = 0;
    return;
}

/*====================================================================
    函数名      ：ConfPrint
    功能        ：业务打印
    算法实现    ：
    引用全局变量：
    输入参数说明：无
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/11/08    3.0         胡昌威         创建
    11/06/23    4.6         liuxu          修改
====================================================================*/
void CMcuVcInst::ConfPrint( const u8 byLevel, const u16 wModule, const s8* pszFormat, ...)
{
	s8 achPrintBuf[1024];
	
    //s32 nBufLen;
    va_list argptr;
	s32 nLen = sprintf( achPrintBuf, "Conf%d:", m_byConfIdx );
    va_start( argptr, pszFormat );    
	vsnprintf(achPrintBuf + nLen, 1024 - nLen - 1, pszFormat, argptr );
    //vsprintf( achPrintBuf + nLen, pszFormat, argptr );   
    LogPrint( byLevel, wModule, achPrintBuf );
    va_end(argptr); 
}

/*====================================================================
    函数名      ：GetPollParam
    功能        ：得到下一个符合被轮询条件的终端
    算法实现    ：
    引用全局变量：
    输入参数说明：[IN/OUT] u8 &byPollPos 当前/下一个轮询的终端
                  [IN/OUT] TPollInfo& tPollInfo  轮询的信息
    返回值说明  ：TMtPollParam *，如果找不到下一个，则返回 NULL
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/08/21    1.0         胡昌威         创建
	07/03/29	4.0			周广程			修改：增加判断是否是轮询的BOOL32参数
    07/04/04    4.0         顾振华         重写
====================================================================*/
TMtPollParam *CMcuVcInst::GetNextMtPolled(u8 &byPollPos, TPollInfo& tPollInfo)
{
    // guzh [4/5/2007] 首先检查用户是否指定了轮询位置
    if ( m_tConfPollParam.IsSpecPos() )
    {
        byPollPos = m_tConfPollParam.GetSpecPos();
        m_tConfPollParam.ClearSpecPos();
        if ( byPollPos == POLLING_POS_START )
        {
            // 从头开始轮询
            byPollPos = 0;
        }
    }
    else
    {
        byPollPos ++;
    }   

    u8 wFindMtNum = 0;
    BOOL32 bJoined = FALSE;
    BOOL32 bSendVideo = FALSE;
    BOOL32 bSendAudio = FALSE;
	BOOL32 bVideoLose = FALSE;
	
	// [7/1/2010 xliang] 级联回传过滤：（目前包括发言人，合成）
	BOOL32 bCasSpyFiltered		 = FALSE;
    BOOL32 bCasMcuSpeaker		 = FALSE;
	BOOL32 bCasVmpMemberFiltered = FALSE;

	// [miaoqingsong_20111025] 单回传存在全局发言人进行主席轮询时，将与发言人同MCU的预轮询终端过滤掉
	BOOL32 bCasChairpollFiltered = FALSE;

    TMtPollParam tCurMtParam, *ptMtPollParam = NULL;
	TMt tLastPolledMt = tPollInfo.GetMtPollParam().GetTMt();
    do 
    {
        // 新一轮的轮询开始
        if (byPollPos >= m_tConfPollParam.GetPolledMtNum())
        {
            // 根据轮询次数决定下面的方向
            u32 dwPollNum = tPollInfo.GetPollNum();
            if (1 != dwPollNum)
            {
                // rewind to top
                byPollPos = 0;
                if (0 != dwPollNum)
                {
                    tPollInfo.SetPollNum(dwPollNum - 1);
                }            
            }
            else
            {
                // polling to end, all over
                tPollInfo.SetPollNum(0);
                return NULL;
            }
        }
        
		ptMtPollParam = m_tConfPollParam.GetPollMtByIdx(byPollPos);
        if ( NULL != ptMtPollParam)
        {
			tCurMtParam = *ptMtPollParam;
        }
		else
		{
            break;
		}
		if ( m_tConf.GetConfAttrb().IsSatDCastMode()
			&& IsMultiCastMt(tCurMtParam.GetMtId()))
		{
			// 重新判断 [pengguofeng 1/25/2013]
			u8 byMtId = 0;
			if ( !tLastPolledMt.IsNull() )//m_tConf.m_tStatus.GetConfMode().GetPollMode() == CONF_POLLMODE_SPEAKER )
			{
				byMtId = tLastPolledMt.GetMtId();//轮询发言人模式下，需要过滤上一个发言人，主要是为了过滤它的选看
			}
			//if ( IsSatMtOverConfDCastNum(tCurMtParam, emPoll, 0xff, 0xff, 0xff, 0xff, 0xff, byMtId) )
			if (!IsSatMtCanContinue(GetLocalMtFromOtherMcuMt(tCurMtParam).GetMtId(),emStartPoll))
			{
				byPollPos++; //找下一个
				wFindMtNum++;
				continue;
			}
		}

        if (tCurMtParam.IsLocal())
        {
            TMtStatus tMtStatus;
            m_ptMtTable->GetMtStatus(tCurMtParam.GetMtId(), &tMtStatus);
            bJoined = m_tConfAllMtInfo.MtJoinedConf( tCurMtParam.GetMtId() );
            bSendVideo = tMtStatus.IsSendVideo();
            // 顾振华@2006.4.14 增加音频的逻辑
            bSendAudio = tMtStatus.IsSendAudio();
            
            // guzh [7/27/2006] 本级肯定不是下级MCU发言人，一定要赋值
            bCasMcuSpeaker = FALSE;

			bCasVmpMemberFiltered = FALSE;
			bCasChairpollFiltered = FALSE;

            // zbq [03/09/2007] 跳过当前没有视频的终端
            bVideoLose = tMtStatus.IsVideoLose() || ( MT_MANU_CHAORAN == m_ptMtTable->GetManuId(tCurMtParam.GetMtId()) );
			
        }
        else
        {
			//增加判断下级mcu是否支持多回传
			//BOOL32 bSupMultSpy = m_ptConfOtherMcTable->GetIsMcuSupMultSpy(tCurMtParam.GetMcuId());

            TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tCurMtParam.GetMcuId());
			
            if (NULL != ptMcInfo)
            {
				TMtExt *ptMtExt       = ptMcInfo->GetMtExt( tCurMtParam );
                TMcMtStatus *pMcMtStatus = ptMcInfo->GetMtStatus((TMt &)tCurMtParam);
                if (NULL != pMcMtStatus)
                {
                    bJoined = m_tConfAllMtInfo.MtJoinedConf(tCurMtParam.GetMcuId(), tCurMtParam.GetMtId());

					//zbq[06/30/2008] 级联终端状态本字段非实时上报，仅依赖于list请求时下级MCU的终端状态. 可能由于下级终端打开逻辑通道的响应慢而导致误判.
                    //bSendVideo = pMcMtStatus->IsSendVideo();
                    //bSendAudio = pMcMtStatus->IsSendAudio();
					bSendVideo = TRUE;
                    bSendAudio = TRUE;
					bCasVmpMemberFiltered = FALSE;
					bCasChairpollFiltered = FALSE;
					
					// [7/1/2010 xliang]  如果上级有其他指定操作使下级某终端在回传，对于单回传而言做过滤.
					// 例如：
					// 1,不带音频的轮询，上级已有下级某终端做全局发言人，则跳过轮询到的下级成员
					// 2,VMP中有指定的下级成员，则需跳过所有轮询到的下级成员
					// 2011-11-3 add by pgf
					// 3.已经有单回传MCU的成员或自身在VMP中，则过滤在此MCU下的任一轮询终端
								
					if( !IsLocalAndSMcuSupMultSpy(tCurMtParam.GetMcuId()) )
					{
						bCasMcuSpeaker = ( (m_tConf.m_tStatus.GetPollMode() == CONF_POLLMODE_VIDEO) &&
							GetFstMcuIdFromMcuIdx(m_tConf.GetSpeaker().GetMcuIdx()) == GetFstMcuIdFromMcuIdx(tCurMtParam.GetMcuIdx())
							);

						TVMPParam_25Mem tVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
						if( tVmpParam.GetVMPMode() != CONF_VMPMODE_NONE)
						{
							if( tVmpParam.IsTypeInMember(VMP_MEMBERTYPE_POLL)
								/*&& tVmpParam.HasUnLocalMemberInVmp(VMP_MEMBERTYPE_POLL)*/)
							{
								for (u8 byChnnl = 0; byChnnl < MAXNUM_VMP_MEMBER/*tVmpParam.GetVMPMemberNum()*/; byChnnl++)
								{
									// compare VmpMember with tCurPollMt
									TVMPMember *ptVmpMember = tVmpParam.GetVmpMember(byChnnl);
									
									// pass Null Member or MEMBERTYPE_POLL
									if ( ptVmpMember == NULL || ptVmpMember->IsNull()
										|| ptVmpMember->GetMemberType() == VMP_MEMBERTYPE_POLL)
									{
										continue;
									}
									
									// pass speaker with MEMBERTYPE_SPEAKER
									if (( m_tConf.m_tStatus.GetPollInfo()->GetMediaMode() == MODE_BOTH
										|| m_tConf.m_tStatus.GetPollInfo()->GetMediaMode() == MODE_BOTH_BOTH)
										&& ptVmpMember->GetMemberType() == VMP_MEMBERTYPE_SPEAKER)
									{
										continue;
									}
									
									/*lint -save -e740*/
									// 比较他们在本级的表示即可
									TMt tVmpMemberMt = (TMt)(*ptVmpMember);
									if ( GetLocalMtFromOtherMcuMt(tCurMtParam.GetTMt()) == GetLocalMtFromOtherMcuMt(tVmpMemberMt))
									{
										ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "VmpMember<%d %d>(chnnl:%d) and PollMt<%d %d> are in same mcu\n",
											ptVmpMember->GetMcuIdx(), ptVmpMember->GetMtId(), byChnnl,
											tCurMtParam.GetMcuIdx(), tCurMtParam.GetMtId());
										bCasVmpMemberFiltered = TRUE;
										break;
									}
									/*lint -restore*/
									
								}
							}
						}

						// [miaoqingsong_20111025] 级联单回传会议有下级终端做发言人的前提下开始主席轮询将与发言人同级的预轮询终端过滤掉；
						//                否则就会造成轮询终端进上传通道将发言人冲掉，不符合发言人优先级大于选看的策略。         
						TMt tMtSpeaker = m_tConf.GetSpeaker();
						TMt tTopSMcu = m_ptMtTable->GetMt(GetFstMcuIdFromMcuIdx(tMtSpeaker.GetMcuIdx()));

						if ( (m_tConf.m_tStatus.GetPollMode() == CONF_POLLMODE_VIDEO_CHAIRMAN || 
							  m_tConf.m_tStatus.GetPollMode() == CONF_POLLMODE_BOTH_CHAIRMAN ) && 
							 (!tMtSpeaker.IsNull() && !tMtSpeaker.IsLocal())
							)
						{
							if ( tMtSpeaker.GetMcuIdx() == tCurMtParam.GetMcuIdx() )
							{
								bCasChairpollFiltered = TRUE;
							}
							else if ( IsMtInMcu(tTopSMcu, tCurMtParam.GetTMt()) )
							{
								bCasChairpollFiltered = TRUE;
							}
						}
					}
					else //如果下级mcu支持多回传则不必考虑上级是否有回传源
					{
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_MCS, "multiSpy support, no need to casfilter!\n");
						bCasMcuSpeaker = FALSE;
						bCasVmpMemberFiltered = FALSE;
						bCasChairpollFiltered = FALSE;
					}

                    // zbq [03/09/2007] 跳过当前没有视频的下级MCU终端
                    bVideoLose = pMcMtStatus->IsVideoLose() || ( NULL != ptMtExt && MT_MANU_CHAORAN == ptMtExt->GetManuId());
                }
            }
        }
		
		bCasSpyFiltered	= ( bCasMcuSpeaker || bCasVmpMemberFiltered || bCasChairpollFiltered );

		ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_MCS, "[GetNextMtPolled] SpeakerFilter:(%d), VmpFilter:(%d), ChairPollFilter:(%d)!\n", 
			bCasMcuSpeaker, bCasVmpMemberFiltered, bCasChairpollFiltered );
		
		// [11/24/2009 xliang] The following line is just for test when using simulate MT(with no video) in environment.
		//bVideoLose = FALSE;

        if ( bJoined &&  
             !bCasSpyFiltered &&
             !bVideoLose &&
             ( bSendVideo || 
               ( bSendAudio && m_tConf.m_tStatus.GetPollMode() == CONF_POLLMODE_SPEAKER ) )
            )
        {
            break;
        }
        else
        {
            ConfPrint( LOG_LVL_DETAIL, MID_MCU_MCS, "[GetNextMtPolled] MT(%d,%d) skipped for Joined.%d, SendVideo.%d, VideoLose:%d SpeakerFilter.%d, VmpFilter.%d, ChairPollFilter.%d!\n", 
                tCurMtParam.GetMcuId(), 
                tCurMtParam.GetMtId(),
                bJoined, 
                bSendVideo, 
				bVideoLose,
                bCasMcuSpeaker,
				bCasVmpMemberFiltered, 
				bCasChairpollFiltered );
        }

        byPollPos++;
        wFindMtNum++;

    // 直到找满一圈
    }while (wFindMtNum<m_tConfPollParam.GetPolledMtNum());

    if (wFindMtNum == m_tConfPollParam.GetPolledMtNum())
    {
        return NULL;
    }
     
    // 保证当前轮询信息的正确性
    tPollInfo.SetMtPollParam( tCurMtParam );
    TMtPollParam *ptNextMt = m_tConfPollParam.GetPollMtByIdx(byPollPos);    
    return ptNextMt;
}

/*=============================================================================
  函 数 名： GetMtTWPollParam
  功    能： 得到TW轮询参数
  算法实现： 
  全局变量： 
  参    数： u8 &byPollPos
  返 回 值： TMtPollParam 
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  09/03/10    4.6         江乐斌         创建
=============================================================================*/
TMtPollParam *CMcuVcInst::GetMtTWPollParam(u8 &byPollPos, u8 byEqpId, u8 byChnId)
{
	u8 wFindMtNum = 0; 
    
    BOOL32 bJoined = FALSE;
    BOOL32 bSendVideo = FALSE;
    BOOL32 bMcuSpeaker = FALSE;
	TMtPollParam tCurMtParam, *ptMtPollParam;
    BOOL32 bVideoLose = FALSE;
	//获取当前指定外设通道的轮询信息
	TTvWallPollParam tTWPollParam;
	if(!m_tTWMutiPollParam.GetTWPollParam(byEqpId, byChnId, tTWPollParam))
	{
		ConfPrint( LOG_LVL_WARNING, MID_MCU_CONF, "[TMtPollParam][GetMtTWPollParam] Cannot get Single TW<EqpId:%d, ChnId:%d> PollParam!\n",
					   byEqpId, byChnId);
		return NULL;
	}
    
	u8   byPolledMtNum = tTWPollParam.GetPolledMtNum();//轮询终端个数
    u32  byPollNum     = tTWPollParam.GetPollNum();	 //单通道轮询次数
	do 
    {
		// xliang [7/27/2009] 对删Mt即退出轮询队列这一策略而言，
		//					  轮询到最末一个，此时删第1个Mt，会导致byPollPos > 轮询的Mt数
		//if (byPollPos == m_tHduPollParam.GetPolledMtNum())
		if (!(byPollPos < byPolledMtNum))
		{        
			u32 dwPollNum = byPollNum;	//轮询次数
			if (1 != dwPollNum)
			{
				if (0 != dwPollNum)
				{
					tTWPollParam.SetPollNum(dwPollNum - 1);
					m_tTWMutiPollParam.SetTWPollParam(byEqpId, byChnId, tTWPollParam);
				}
				byPollPos = 0;
			}
			else
			{
				tTWPollParam.SetPollNum(0);
				m_tTWMutiPollParam.SetTWPollParam(byEqpId, byChnId, tTWPollParam);
				return NULL;
			}
		}
		
        ptMtPollParam = tTWPollParam.GetPollMtByIdx(byPollPos);
        if ( NULL != ptMtPollParam)
        {
			tCurMtParam = *ptMtPollParam;
        }
		else
		{
            break;
		}
		
        if (tCurMtParam.IsLocal())
        {
            TMtStatus tMtStatus;
            m_ptMtTable->GetMtStatus(tCurMtParam.GetMtId(), &tMtStatus);
            bJoined = m_tConfAllMtInfo.MtJoinedConf( tCurMtParam.GetMtId() );
            bSendVideo = tMtStatus.IsSendVideo();
			
            // guzh [7/27/2006] 本级不需要考虑这个问题，一定要赋值
            bMcuSpeaker = FALSE;
            //tzy 2010/06/01  支持无视频源跳过
            bVideoLose = tMtStatus.IsVideoLose() || MT_MANU_CHAORAN == m_ptMtTable->GetManuId(tCurMtParam.GetMtId());

			// 卫星会议需要考虑轮到卫星终端会不会导致多占带宽 [pengguofeng 1/30/2013]
			if ( m_tConf.GetConfAttrb().IsSatDCastMode()
				&& IsMultiCastMt(tCurMtParam.GetMtId()))
			{
				//if ( IsSatMtOverConfDCastNum(tCurMtParam, emHdu, 0xff, 0xff, 0xff, byEqpId, byChnId))
				TEqp tHduEqp = g_cMcuVcApp.GetEqp(byEqpId);
				if (!IsSatMtCanContinue(GetLocalMtFromOtherMcuMt(tCurMtParam).GetMtId(),emStartOrChangeHdu,&tHduEqp,byChnId))
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[GetMtTWPollParam]skip Sat Mt:%d Index:%d\n",
						tCurMtParam.GetMtId(), byPollPos);
					byPollPos++;
					wFindMtNum++;
					continue;
				}
			}
        }
        else
        {
			bMcuSpeaker = FALSE;
			TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tCurMtParam.GetMcuId());
            if (NULL != ptMcInfo)
            {
				TMcMtStatus *pMcMtStatus = ptMcInfo->GetMtStatus((TMt &)tCurMtParam);
				TMtExt *ptMtExt = ptMcInfo->GetMtExt( tCurMtParam );
				
				// [11/29/2010 xliang] add filter here
				if (NULL == pMcMtStatus)
				{
					//maintain default value
					ConfPrint( LOG_LVL_DETAIL, MID_MCU_CONF,"[GetMtTWPollParam] pMcMtStatus is NULL, maintain the default value and do nothing.\n");
				}
				else
				{
					//如果本级或下级mcu不支持多回传则走原来单回传逻辑
					if( !IsLocalAndSMcuSupMultSpy(tCurMtParam.GetMcuId()) )
					{

						bJoined = m_tConfAllMtInfo.MtJoinedConf(tCurMtParam.GetMcuId(), tCurMtParam.GetMtId());
						
						//zbq[2008/08/08] 级联终端状态本字段非实时上报，仅依赖于list请求时下级MCU的终端状态. 可能由于下级终端打开逻辑通道的响应慢而导致误判.
						//bSendVideo = pMcMtStatus->IsSendVideo();
						bSendVideo = TRUE;
						
						// [pengjie 2010/9/30] 没有发言人时出现误判两个Idx都等于0，故先要判断是否有发言人，有才做比较
						if( !m_tConf.GetSpeaker().IsNull() )
						{
							bMcuSpeaker = ( !(m_tConf.GetSpeaker() == tCurMtParam) &&
											GetFstMcuIdFromMcuIdx(m_tConf.GetSpeaker().GetMcuIdx()) == GetFstMcuIdFromMcuIdx(tCurMtParam.GetMcuIdx()));
						}
							
						// [10/28/2011 liuxu] vcs会议不能冲掉调度终端
						if ( m_tConf.GetConfSource() == VCS_CONF )
						{
							const TMt tVcsCurVcMt = m_cVCSConfStatus.GetCurVCMT();
							if ( !tVcsCurVcMt.IsNull() )
							{
								TMt* ptCurTvwMt = (TMt*)&tCurMtParam ;
								if ( ptCurTvwMt 
									&& !(tVcsCurVcMt == *ptCurTvwMt )
									&& GetFstMcuIdFromMcuIdx(tVcsCurVcMt.GetMcuIdx()) == GetFstMcuIdFromMcuIdx(tCurMtParam.GetMcuIdx()) )
								{
									bMcuSpeaker = TRUE;
								}
							}
						}

						// [2013/07/05 chenbing] HDU不在此处进行SetIn，统一放到changhduswitch中setin
 						if( bJoined && bSendVideo && !bMcuSpeaker 
							&& (byEqpId >= TVWALLID_MIN && byEqpId <= TVWALLID_MAX)
						  )
 						{
 							OnMMcuSetIn((TMt&)tCurMtParam, 0, SWITCH_MODE_SELECT);
 						}

					}
					else //如果下级mcu支持多回传，在调用本接口后changhduswitch/changtvswitch中presetin
					{
						bJoined = m_tConfAllMtInfo.MtJoinedConf(tCurMtParam.GetMcuId(), tCurMtParam.GetMtId());
						bSendVideo = TRUE;
						bMcuSpeaker = FALSE;//多回传无需考虑下级终端是否是上级发言人
					}             
					//tzy 2010/06/01  支持无视频源跳过
					bVideoLose = pMcMtStatus->IsVideoLose() || ( NULL != ptMtExt && MT_MANU_CHAORAN == ptMtExt->GetManuId() );
				}
				
            }
        }
        
        if (bJoined && bSendVideo && !bMcuSpeaker && !bVideoLose )
        {
            break;
        }
        else
        {
            ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[GetMtTWPollParam] MT(%d,%d) skipped for Joined.%d, SendVideo.%d, Speaker.%d\n", 
                tCurMtParam.GetMcuId(), 
                tCurMtParam.GetMtId(),
                bJoined, 
                bSendVideo, 
                bMcuSpeaker);
        }
        
        byPollPos++;
		
        wFindMtNum++;
        
    }while (wFindMtNum < byPolledMtNum);

	if (wFindMtNum == byPolledMtNum)
    {
        return NULL;
    }
    
    return tTWPollParam.GetPollMtByIdx(byPollPos);
}



/*====================================================================
    函数名      ：VACChange
    功能        ：语音激励控制改变
    算法实现    ：
    引用全局变量：
    输入参数说明：TDiscussParam tDiscussParam 当前成员
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/08/21    1.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::VACChange(const TMixParam &tMixParam, u8 byExciteChn)
{
    TMt tMt;
    TMt tOldSpeaker;

    ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[VACChange] m_tConf.m_tStatus.GetMixerMode = %d,tMixParam.GetMode()==%d\n",
           m_tConf.m_tStatus.GetMixerMode(),tMixParam.GetMode());

    if (byExciteChn == 0)
    {
        ConfPrint(LOG_LVL_WARNING, MID_MCU_MIXER,  "[VACChange] voice active member num is: %d\n", byExciteChn);
        return;
    }

	ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[VACChange] voice active member num is: %d\n", byExciteChn );

    tMt = m_ptMtTable->GetMt(byExciteChn);
    tOldSpeaker = GetLocalSpeaker();

    //控制发言人切换
    if (m_tConf.m_tStatus.IsVACing() && !(tMt == tOldSpeaker))
    {
        //已有时间切换间隔
        ChangeSpeaker(&tMt);
		NotifyAllSMcuMediaInfo(0,MODE_BOTH);
        m_tVacLastSpeaker = tMt;
        
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[VACChange] Vac speaker change and new speaker is: Mt%d\n", tMt.GetMtId());
    }
    
    return;
}

/*=============================================================================
  函 数 名： DaemonProcUnitTestMsg
  功    能： 单元测试消息处理, 包括
			 (1) 主控热备份
  算法实现： 
  全局变量： 
  参    数： CMessage *pcMsg
  返 回 值： void 
  -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2006/2/15    4.0			张宝卿                  创建
=============================================================================*/
/*
void CMcuVcInst::DaemonProcUnitTestMsg( void )
{
   
	switch( pcMsg->event )
	{
	case EV_TEST_TEMPLATEINFO_GET_REQ:
		ProcUnitTestGetTmpInfoReq(pcMsg);
		break;
	case EV_TEST_CONFINFO_GET_REQ:
		ProcUnitTestGetConfInfoReq(pcMsg);
		break;
	case EV_TEST_CONFMTLIST_GET_REQ:
		ProcUnitTestGetMtListInfoReq(pcMsg);
		break;
	case EV_TEST_ADDRBOOK_GET_REQ:
		ProcUnitTestGetAddrbookReq(pcMsg);
		break;
	case EV_TEST_MCUCONFIG_GET_REQ:
		ProcUnitTestGetMcuCfgReq(pcMsg);
		break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "unexpected message %d<%s> received in DaemonProcUnitTestMsg !\n", pcMsg->event, OspEventDesc(pcMsg->event) );
		break;
	}
    
}
*/

/*=============================================================================
  函 数 名： ProcUnitTestGetTmpInfoReq
  功    能： 模拟会控请求模板信息
  算法实现： 
  全局变量： 
  参    数： CMessage *pcMsg
  返 回 值： void 
  -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2006/2/15    4.0			张宝卿                  创建
=============================================================================*/
/*
void CMcuVcInst::ProcUnitTestGetTmpInfoReq( CMessage *pcMsg )
{

	if ( g_bpUnitMsg )
	{
		ConfPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[UnitTest]message %d<%s> received !\n", pcMsg->event, OspEventDesc(pcMsg->event) );
	}
	CConfId cConfId;
	u8		byConfIdx;

	//上报本板信息
	CServMsg cServMsg( pcMsg->content, pcMsg->length );
	cConfId = cServMsg.GetConfId();
	byConfIdx = g_cMcuVcApp.GetConfIdx( cConfId );

	// 1. 会议信息 TConfInfo
	if( byConfIdx != 0 )
	{
		TTemplateInfo tOldTemInfo;
		TConfInfo tConfInfo;
		if(!g_cMcuVcApp.GetTemplate(byConfIdx, tOldTemInfo))
		{
			ConfLog(FALSE, "[ProcUnitTestGetTmpInfoReq] get template confIdx<%d> failed\n", byConfIdx);
			cServMsg.SetEventId( pcMsg->event + 2 );
			OspPost( MAKEIID(AID_MCU_MCSSN, cServMsg.GetSrcSsnId()), cServMsg.GetEventId(), cServMsg.GetServMsg(), cServMsg.GetServMsgLen() );
			return;
        }
		g_cMcuVcApp.TemInfo2Msg( tOldTemInfo, cServMsg );
	}
	cServMsg.SetEventId( pcMsg->event + 1 );
	OspPost( MAKEIID(AID_MCU_MCSSN, cServMsg.GetSrcSsnId()), cServMsg.GetEventId(), cServMsg.GetServMsg(), cServMsg.GetServMsgLen() );

	return;
}*/

/*=============================================================================
  函 数 名： ProcUnitTestGetConfInfoReq
  功    能： 模拟会控请求会议信息
  算法实现： 
  全局变量： 
  参    数： CMessage *pcMsg
  返 回 值： void 
  -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2006/2/15    4.0			张宝卿                  创建
=============================================================================*/
/*
void CMcuVcInst::ProcUnitTestGetConfInfoReq( CMessage *pcMsg )
{
    
	if ( g_bpUnitMsg )
	{
		ConfPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[UnitTest]message %d<%s> received !\n", pcMsg->event, OspEventDesc(pcMsg->event) );
	}
	CConfId cConfId;
	u8		byConfIdx;
	
	//上报本板信息
	CServMsg cServMsg( pcMsg->content, pcMsg->length );
	cConfId = cServMsg.GetConfId();
	byConfIdx = g_cMcuVcApp.GetConfIdx( cConfId );
	CMcuVcInst *pInst = g_cMcuVcApp.GetConfInstHandle( byConfIdx );
	if ( NULL == pInst ) 
	{
		ConfPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[UnitTest]get mcuvc inst handle failed !\n" );
		return;
	}
	
	// 1. 会议信息 TConfInfo
	if( byConfIdx != 0 )
	{
		TConfInfo tConfInfo;
		tConfInfo = pInst->m_tConf;
		
		cServMsg.SetEventId( pcMsg->event + 1 );
		cServMsg.SetMsgBody( (u8*)&tConfInfo, sizeof(TConfInfo) );
		OspPost( MAKEIID(AID_MCU_MCSSN, cServMsg.GetSrcSsnId()), cServMsg.GetEventId(), cServMsg.GetServMsg(), cServMsg.GetServMsgLen() );
	}
	
	return;
}*/

/*=============================================================================
  函 数 名： ProcUnitTestGetMtListInfoReq
  功    能： 模拟会控请求终端列表信息
  算法实现： 
  全局变量： 
  参    数： CMessage *pcMsg
  返 回 值： void 
  -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2006/2/15    4.0			张宝卿                  创建
=============================================================================*/
/*
#define MSUNITTEST_BUFLEN		(u16)(1024 * 20)
void CMcuVcInst::ProcUnitTestGetMtListInfoReq( CMessage *pcMsg )
{
    
	if ( g_bpUnitMsg )
	{
		ConfPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[UnitTest]message %d<%s> received !\n", pcMsg->event, OspEventDesc(pcMsg->event) );
	}
	CConfId cConfId;
	u8		byConfIdx;
	
	//上报本板信息
	CServMsg cServMsg( pcMsg->content, pcMsg->length );
	cConfId = cServMsg.GetConfId();
	byConfIdx = g_cMcuVcApp.GetConfIdx( cConfId );

	// 1. 会议终端表 TConfMtTable
	TConfMtTable tConfMtTable;

	u8	byPktNum = sizeof(TConfMtTable) / MSUNITTEST_BUFLEN + 1;

	cServMsg.SetTotalPktNum( byPktNum );	//需要发送的总包数

	u8 *pMtTable = (u8*)&tConfMtTable;

	if ( g_cMcuVcApp.GetConfMtTable(byConfIdx, &tConfMtTable) )
	{		
		for( s32 nIndex = 0; nIndex < byPktNum; nIndex ++ )
		{
			cServMsg.SetCurPktIdx( nIndex );
			if ( nIndex < byPktNum - 1 )
			{
				cServMsg.SetMsgBody( pMtTable + nIndex * MSUNITTEST_BUFLEN, sizeof(u8) * MSUNITTEST_BUFLEN );
			}
			else
			{
				cServMsg.SetMsgBody( pMtTable + nIndex * MSUNITTEST_BUFLEN, 
										sizeof(tConfMtTable) - sizeof(u8) * MSUNITTEST_BUFLEN * nIndex );
			}
			cServMsg.SetEventId( pcMsg->event + 1 );
			OspPost( MAKEIID(AID_MCU_MCSSN, cServMsg.GetSrcSsnId()), cServMsg.GetEventId(), cServMsg.GetServMsg(), cServMsg.GetServMsgLen() );
			OspDelay(100);
		}
	}
	else
	{
		ConfLog(FALSE, "ProcUnitTestGetMtListInfoReq] get mt table failed !\n");
		return;
	}
    
}
*/

/*==============================================================================
函数名    :  DaemonProcHDIFullNtf
功能      :  处理因HDI接入能力满而导致MT呼叫MCU失败通知消息
算法实现  :  上报MCS
参数说明  :  CMessage *pcMsg
返回值说明:  void
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2008-10-24					薛亮
==============================================================================*/
void CMcuVcInst::DaemonProcHDIFullNtf ( const CMessage *pcMsg )
{
	CServMsg cServMsg( pcMsg->content, pcMsg->length );
	u8 byHdiId = 0;
	byHdiId = cServMsg.GetSrcDriId();
	
	NotifyMcsAlarmInfo( 0, ERR_MCU_MTCALLFAIL_FULL);
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_MCS, "[DaemonProcHDIFullNtf]Send HDI FULL NOTIFY to All Mcs:HDI.%u is full\n",byHdiId);
}
/*=============================================================================
  函 数 名： ProcUnitTestGetMcuCfgReq
  功    能： 模拟会控请求MCU配置信息
  算法实现： 
  全局变量： 
  参    数： CMessage *pcMsg
  返 回 值： void 
  -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2006/2/15    4.0			张宝卿                  创建
=============================================================================*/
/*
void CMcuVcInst::ProcUnitTestGetMcuCfgReq( CMessage *pcMsg )
{
    
	if ( g_bpUnitMsg )
	{
		ConfPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[UnitTest]message %d<%s> received !\n", pcMsg->event, OspEventDesc(pcMsg->event) );
	}
	
	u8 abyCfgBuf[MSUNITTEST_BUFLEN];
	u32 dwBufOut = 0;
	g_cMcuVcApp.GetCfgFileData( (u8*)&abyCfgBuf, sizeof(u8) * MSUNITTEST_BUFLEN, dwBufOut, TRUE );
	
	CServMsg cServMsg( pcMsg->content, pcMsg->length );

	cServMsg.SetEventId( pcMsg->event + 1 );
	cServMsg.SetMsgBody( abyCfgBuf, sizeof(u8) * dwBufOut );
	
	// 上报本板配置信息
	OspPost( MAKEIID(AID_MCU_MCSSN, cServMsg.GetSrcSsnId()), cServMsg.GetEventId(), cServMsg.GetServMsg(), cServMsg.GetServMsgLen() );
    
}*/

/*=============================================================================
  函 数 名： ProcUnitTestGetAddrbookReq
  功    能： 模拟会控请求地址薄信息(这里还有完成地址薄上报，只是回了个消息)
  算法实现： 
  全局变量： 
  参    数： CMessage *pcMsg
  返 回 值： void 
  -----------------------------------------------------------------------------
  修改记录：
  日  期		版本		修改人		走读人    修改内容
  2006/2/15    4.0			张宝卿                  创建
=============================================================================*/
/*
void CMcuVcInst::ProcUnitTestGetAddrbookReq( CMessage *pcMsg )
{
    
	if ( g_bpUnitMsg )
	{
		ConfPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[UnitTest]message %d<%s> received !\n", pcMsg->event, OspEventDesc(pcMsg->event) );
	}
	//上报本板地址薄信息
    
}
*/

/*====================================================================
    函数名      : IsMtNeedAdapt
    功能        : 终端是否需适配
    算法实现    :
    引用全局变量:
    输入参数说明: u8 byMtId 终端Id
				  u8 byAdaptType 适配类型
    返回值说明  :
----------------------------------------------------------------------
    修改记录    :
    日  期      版本        修改人        修改内容
    04/02/14    3.0         胡昌威         创建
====================================================================*/
//modify bas 2
// BOOL32 CMcuVcInst::IsMtNeedAdapt(u8 byAdaptType, u8 byMtId, TMt *ptSrcMt)
// {
//     TSimCapSet tBrdSrcSCS;
//     TSimCapSet tMtDstSCS;
//     
//     //保护一下
//     if (!m_tConf.GetConfAttrb().IsUseAdapter())
//     {
//         return FALSE;
//     }
// 
//     TMt tSrcMt;
// 
//     switch(byAdaptType)
//     {
//     case ADAPT_TYPE_AUD:
//     case ADAPT_TYPE_CASDAUD:
// 	case ADAPT_TYPE_MULTISPYCASDAUD:
//         if (NULL == ptSrcMt ||
//             (NULL != ptSrcMt && ptSrcMt->IsNull()))
//         {
//             //是否需要媒体类型适配
//             if (TYPE_MT == GetLocalAudBrdSrc().GetType())
//             {
//                 tSrcMt = GetLocalAudBrdSrc();
//             }
//         }
//         else
//         {
//             tSrcMt = *ptSrcMt;
//         }
// 
//         tMtDstSCS  = m_ptMtTable->GetDstSCS(byMtId);
//         //支持rec放像适配
//         if ( TYPE_MCUPERI == tSrcMt.GetType() && EQP_TYPE_RECORDER == tSrcMt.GetEqpType() )
//         {
//             tBrdSrcSCS.SetAudioMediaType( m_tPlayEqpAttrib.GetAudioType() );
//         }
//         else
//         {
//             tBrdSrcSCS = m_ptMtTable->GetSrcSCS(tSrcMt.GetMtId());     
//         }  
//         
//         if (tBrdSrcSCS.GetAudioMediaType() != tMtDstSCS.GetAudioMediaType())
//         {
//             return TRUE;
//         }
//         break;
// 
//     case ADAPT_TYPE_VID:
//     case ADAPT_TYPE_CASDVID:
// 	case ADAPT_TYPE_MULTISPYCASDVID:
//         {
//             if (NULL == ptSrcMt ||
//                 (NULL != ptSrcMt && ptSrcMt->IsNull()))
//             {
//                 //是否需要媒体类型适配
//                 if (TYPE_MT == GetLocalVidBrdSrc().GetType())
//                 {
//                     tSrcMt = GetLocalVidBrdSrc();
//                 }
//             }
//             else
//             {
//                 tSrcMt = *ptSrcMt;
//             }
// 
//             tMtDstSCS  = m_ptMtTable->GetDstSCS(byMtId);
//             
//             if ( TYPE_MCUPERI == tSrcMt.GetType() && EQP_TYPE_RECORDER == tSrcMt.GetEqpType() )
//             {
//                 tBrdSrcSCS.SetVideoMediaType(m_tPlayEqpAttrib.GetVideoType());
//                 tBrdSrcSCS.SetVideoResolution(tMtDstSCS.GetVideoResolution());
//             }
//             else
//             {
//                 tBrdSrcSCS = m_ptMtTable->GetSrcSCS(tSrcMt.GetMtId());
//             }
//                                
//             if(MEDIA_TYPE_NULL != tBrdSrcSCS.GetVideoMediaType())
//             {
//                 // zbq [08/20/2007] 适配器不支持H264的D1分辨率
//                 u8 bySrcType = tBrdSrcSCS.GetVideoMediaType();
//                 u8 byDstType = tMtDstSCS.GetVideoMediaType();
//                 u8 bySrcFormat = tBrdSrcSCS.GetVideoResolution();
//                 u8 byDstFormat = tMtDstSCS.GetVideoResolution();
// 
//                 if ( bySrcType   != byDstType ||
//                      bySrcFormat != byDstFormat )
//                 {
//                     if ( (MEDIA_TYPE_H264 == bySrcType &&
//                           VIDEO_FORMAT_4CIF == bySrcFormat)
//                         ||
//                          (MEDIA_TYPE_H264 == byDstType &&
//                           VIDEO_FORMAT_4CIF == byDstFormat)
// 						//||
// 						//  ( MEDIA_TYPE_H264 == bySrcType && bySrcType == byDstType
// 						//  && bySrcFormat < byDstFormat )	
// 						  )
//                     {
// 						ConfLog(FALSE, "[IsMtNeedAdapt] no need adapter! bySrcType: %u, bySrcFormat: %u, byDstType: %u, byDstFormat: %u\n",
// 							bySrcType, bySrcFormat, byDstType, byDstFormat);
//                     }
//                     else
//                     {
//                         return TRUE;
//                     }
//                 }
//                 /*
//                 if ( (tBrdSrcSCS.GetVideoMediaType() != tMtDstSCS.GetVideoMediaType() )
//                     || (tBrdSrcSCS.GetVideoResolution() != tMtDstSCS.GetVideoResolution() &&
//                         tMtDstSCS.GetVideoResolution() != VIDEO_FORMAT_AUTO &&
//                         MEDIA_TYPE_H264 != tMtDstSCS.GetVideoMediaType()) )//  [4/24/2006] 264格式没有分辨率
//                 {
//                     return TRUE;
//                 }
//                 */
//             }          
//         }
//         break;
// 
//     case ADAPT_TYPE_BR:
// 		{
// 			// 顾振华 [6/2/2006] 如果不是双速会议,永远不认为需要做码率适配
// 			if (m_tConf.GetSecBitRate() == 0)
// 			{
// 				return FALSE;
// 			}
//         
//             if (NULL == ptSrcMt ||
//                 (NULL != ptSrcMt && ptSrcMt->IsNull()))
// 			{
// 				//是否需要媒体类型适配
// // 				if (TYPE_MT == m_tVidBrdSrc.GetType())
// // 				{
// 					tSrcMt = GetLocalVidBrdSrc();
// // 				}
// 			}
//             else
//             {
//                 tSrcMt = *ptSrcMt;
//             }
//             
//             // xsl [8/25/2006] 源与目的相同，不进行适配，与判断是否启动会议码率适配的逻辑统一
//             if (tSrcMt.GetMtId() == byMtId)
//             {
//                 return FALSE;
//             }
// 
//             // zbq [08/26/2007] 源端的码率应该取当前的发送码率
// 			// u16 wSrcBitrate = m_ptMtTable->GetDialBitrate(tSrcMt.GetMtId());
//             u16 wSrcBitrate = m_ptMtTable->GetMtSndBitrate(tSrcMt.GetMtId());
// 
//             // zbq [08/20/2007] 码率适配启用同样要校验视频格式和分辨率
//             tMtDstSCS  = m_ptMtTable->GetDstSCS(byMtId);
// 
// 			// 录像机发送码率强制取会议第一码率
// 			if ( TYPE_MCUPERI == tSrcMt.GetType() && EQP_TYPE_RECORDER == tSrcMt.GetEqpType() )
// 			{
// 				wSrcBitrate = m_tConf.GetBitRate();
// 
//                 // zbq [08/20/2007] 码率适配启用同样要校验视频格式和分辨率
//                 tBrdSrcSCS.SetVideoMediaType(m_tPlayEqpAttrib.GetVideoType());
//                 tBrdSrcSCS.SetVideoResolution(tMtDstSCS.GetVideoResolution());
// 			}
//             else
//             {
//                 // zbq [08/20/2007] 码率适配启用同样要校验视频格式和分辨率
//                 tBrdSrcSCS = m_ptMtTable->GetSrcSCS(tSrcMt.GetMtId());
//             }
// 
// 			//是否需要码率适配
// 			//判决 若发送源的发送码率 高于 接收端的接收码率 则需要码率适配   
// 			if (m_ptMtTable->GetMtReqBitrate(byMtId) > 0 && 
// 				(m_ptMtTable->GetMtReqBitrate(byMtId)*(g_cMcuVcApp.GetBitrateScale()+100)/100) < wSrcBitrate)
// 			{
//                 // zbq [08/20/2007] 适配器不支持H264的D1分辨率
//                 u8 bySrcType = tBrdSrcSCS.GetVideoMediaType();
//                 u8 byDstType = tMtDstSCS.GetVideoMediaType();
//                 u8 bySrcFormat = tBrdSrcSCS.GetVideoResolution();
//                 u8 byDstFormat = tMtDstSCS.GetVideoResolution();
//                 
//                 if ( (MEDIA_TYPE_H264 == bySrcType &&
//                       VIDEO_FORMAT_4CIF == bySrcFormat)
//                     ||
//                      (MEDIA_TYPE_H264 == byDstType &&
//                       VIDEO_FORMAT_4CIF == byDstFormat))
//                 {
//                 }
//                 else
//                 {
//                     return TRUE;
//                 }
// 			}
// 		}
//         break;
// 
//     default:
//         break;
//     }
// 
//     return FALSE;
// }


/*=============================================================================
函 数 名： IsMtSrcBas
功    能： 终端源是否来自bas
算法实现： 
全局变量： 
参    数： u8 byMtId
u8 byMode
返 回 值： BOOL32 
=============================================================================*/
/*
BOOL32 CMcuVcInst::IsMtSrcBas(u8 byMtId, u8 byMode, u8 &byAdpType)
{
    byAdpType = ADAPT_TYPE_NONE;

    TMt tMt = m_ptMtTable->GetMt(byMtId);
    if(tMt.GetType() != TYPE_MT)
    {
        return FALSE;
    }
    
    TMt tMtSrc;
    if(!m_ptMtTable->GetMtSrc(byMtId, &tMtSrc, byMode))
    {
        return FALSE;
    }
    
    if(MODE_VIDEO == byMode)
    {
        // guzh [7/10/2007] 格式适配优先
        if(m_tConf.m_tStatus.IsVidAdapting() && IsMtNeedAdapt(ADAPT_TYPE_VID, byMtId, &tMtSrc))
        {
            byAdpType = ADAPT_TYPE_VID;
            return TRUE;
        }
//         else if(m_tConf.m_tStatus.IsCasdVidAdapting() && IsMtNeedAdapt(ADAPT_TYPE_CASDVID, byMtId, &tMtSrc))
//         {
//             byAdpType = ADAPT_TYPE_CASDVID;
//             return TRUE;
//         }
//         else if(m_tConf.m_tStatus.IsBrAdapting() && IsMtNeedAdapt(ADAPT_TYPE_BR, byMtId, &tMtSrc))
//         {
//             byAdpType = ADAPT_TYPE_BR;
//             return TRUE;
//         }
        else if (m_tConf.m_tStatus.IsHdVidAdapting() &&
			     m_cMtRcvGrp.IsMtNeedAdp(byMtId))
        {
			return TRUE;
        }
		else
        {
            return FALSE;
        }
    }   
    else if(MODE_AUDIO == byMode)
    {
        if(m_tConf.m_tStatus.IsAudAdapting() && IsMtNeedAdapt(ADAPT_TYPE_AUD, byMtId, &tMtSrc))
        {
            byAdpType = ADAPT_TYPE_AUD;
            return TRUE;
        }
//         else if(m_tConf.m_tStatus.IsCasdAudAdapting() && IsMtNeedAdapt(ADAPT_TYPE_CASDAUD, byMtId, &tMtSrc))
//         {
//             byAdpType = ADAPT_TYPE_CASDAUD;
//             return TRUE;
//         }
        else
        {
            return FALSE;
        }
    }    
    
    return FALSE;
}
*/

/*=============================================================================
函 数 名： IsIsMtSrcVmp2
功    能： 终端源是否vmp第二路码流
算法实现： 
全局变量： 
参    数： u8 byMtId
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/3/9  4.0			许世林                  创建
=============================================================================*/
BOOL32 CMcuVcInst::IsMtSrcVmp2(u8 byMtId) 
{
    if (0 == m_tConf.GetSecBitRate() || 
        MEDIA_TYPE_NULL != m_tConf.GetSecVideoMediaType() ||       
        !(GetLocalVidBrdSrc() == m_tVmpEqp) ||
        m_ptMtTable->GetMtReqBitrate(byMtId) == m_tConf.GetBitRate())
    {
        return FALSE;
    }

    return TRUE;
}

/*=============================================================================
    函 数 名： StartAdapt
    功    能： 开启适配
    算法实现： 
    全局变量： 
    参    数： u8  byAdaptType     适配类型
               u16 wBitRate        适配码率
               TSimCapSet *pDstSCS 适配后的码流能力集
               TSimCapSet *pSrcSCS 适配前的原始的码流能力集
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/03/08  3.6			万春雷                  创建
    2007/01/30  4.0         顾振华                 8000B能力限制
=============================================================================*/
//modify bas 2
// BOOL32 CMcuVcInst::StartAdapt(u8 byAdaptType, 
// 								  u16 wBitRate, 
// 								  TSimCapSet *pDstSCS, 
// 								  TSimCapSet *pSrcSCS,
// 								  TEqp *ptBas,
// 								  u8 *pbyBasChl
// 								  )
// {
// 	u16 wWidth;
//     u16 wHight;
// 	TSimCapSet tSrcSCS;
// 	TAdaptParam tAdaptParam;
//     memset(&tAdaptParam, 0, sizeof(tAdaptParam));
//     
//     if (ADAPT_TYPE_AUD == byAdaptType)
//     {
//         if (!g_cMcuVcApp.IsPeriEqpConnected(m_tAudBasEqp.GetEqpId()))
//         {
//             return FALSE;
//         }
//     }
// 
//     if (ADAPT_TYPE_VID == byAdaptType)
//     {
//         if (!g_cMcuVcApp.IsPeriEqpConnected(m_tVidBasEqp.GetEqpId()))
//         {
//             return FALSE;
//         }
//     }
// 
//     if (ADAPT_TYPE_BR == byAdaptType)
//     {
//         if (!g_cMcuVcApp.IsPeriEqpConnected(m_tBrBasEqp.GetEqpId()))
//         {
//             return FALSE;
//         }
//     }
// 
//     if (ADAPT_TYPE_CASDAUD == byAdaptType)
//     {
//         if (!g_cMcuVcApp.IsPeriEqpConnected(m_tCasdAudBasEqp.GetEqpId()))
//         {
//             return FALSE;
//         }
//     }
// 
//     if (ADAPT_TYPE_CASDVID == byAdaptType)
//     {
//         if (!g_cMcuVcApp.IsPeriEqpConnected(m_tCasdVidBasEqp.GetEqpId()))
//         {
//             return FALSE;
//         }
//     }
// 
// 	if( ADAPT_TYPE_MULTISPYCASDVID == byAdaptType ||
// 		ADAPT_TYPE_MULTISPYCASDAUD == byAdaptType
// 		)
// 	{
// 		if( NULL == ptBas ||
// 			!g_cMcuVcApp.IsPeriEqpConnected( ptBas->GetEqpId() ) )
// 		{
// 			return FALSE;
// 		}
// 	}	
// 
//     // guzh [1/30/2007] 8000B能力限制
//     u16 wError = 0;
//     if ( !CMcuPfmLmt::IsBasOprSupported( m_tConf, GetMixMtNumInGrp(), wError ) )
//     {
//         NotifyMcsAlarmInfo(0, wError);
//         return FALSE;
//     }
// 
// 	if (NULL == pDstSCS || pDstSCS->IsNull())
// 	{
//         if (ADAPT_TYPE_AUD == byAdaptType)
//         {
// 		    tAdaptParam.SetVidType(MEDIA_TYPE_NULL);
// 		    tAdaptParam.SetAudType(m_tConf.GetMainAudioMediaType());
//         }
//         else
//         {
//             tAdaptParam.SetVidType(m_tConf.GetMainVideoMediaType());
//             u8 byResolution = m_tConf.GetMainVideoFormat();
//             m_tConf.GetVideoScale(m_tConf.GetMainVideoMediaType(), 
//                                 wWidth, wHight, &byResolution);
//             tAdaptParam.SetResolution(wWidth, wHight);
// 		    tAdaptParam.SetAudType(MEDIA_TYPE_NULL);
//         }
// 	}
// 	else
// 	{
// 		tAdaptParam.SetVidType(pDstSCS->GetVideoMediaType());	
// 		tAdaptParam.SetAudType(pDstSCS->GetAudioMediaType());
//         u8 byResolution = pDstSCS->GetVideoResolution();
//         m_tConf.GetVideoScale(pDstSCS->GetVideoMediaType(), wWidth, wHight, &byResolution);
//         tAdaptParam.SetResolution(wWidth, wHight);
// 	}
// 
// 	if (NULL == pSrcSCS || pSrcSCS->IsNull())
// 	{
// 		if (NULL == pDstSCS || pDstSCS->IsNull())
// 		{
// 			tSrcSCS.SetVideoMediaType(tAdaptParam.GetVidType());
// 			tSrcSCS.SetAudioMediaType(tAdaptParam.GetAudType());
// 		}
// 		else
// 		{
// 			tSrcSCS = *pDstSCS;
// 		}
// 	}
// 	else
// 	{
// 		tSrcSCS = *pSrcSCS;
// 	}
// 
//     if (ADAPT_TYPE_AUD != byAdaptType && ADAPT_TYPE_CASDAUD != byAdaptType)
//     {
//         if (0 != m_tConf.GetSecBitRate())//双速会议
//         {
//             // 若存在低速录制或者广播，直接调整为第二速（即此双速会议的最低限速）
//             if ((m_tConf.GetConfAttrb().IsMulticastMode() && 
//                  m_tConf.GetConfAttrb().IsMulcastLowStream()) || 
//                  m_tRecPara.IsRecLowStream())
//             {
//                 wBitRate = m_tConf.GetSecBitRate();
//             }
//             // 否则降至所需的最低速率（此速率高于或等于第二速）
//             else
//             {
//                 wBitRate = (wBitRate > m_tConf.GetSecBitRate()) ? wBitRate : m_tConf.GetSecBitRate();
//             }
//         }
// 
//         if (0 == wBitRate)
//         {
//             tAdaptParam.SetBitRate(m_tConf.GetBitRate());
//         }
//         else
//         {
//             if (wBitRate != m_tConf.GetBitRate())
//             {
//                 tAdaptParam.SetBitRate(wBitRate);
//             }
//             else
//             {
//                 tAdaptParam.SetBitRate(wBitRate);
//             }
//         }
//         m_tConf.GetVideoScale(tAdaptParam.GetVidType(), wWidth, wHight);
//         tAdaptParam.SetResolution(wWidth, wHight);
// 
//         if (ADAPT_TYPE_VID == byAdaptType)
//         {
//             m_wVidBasBitrate = wBitRate;            
//         }
//         else if (ADAPT_TYPE_BR == byAdaptType)
//         {
//             m_wBasBitrate = wBitRate;
//         }
//         ConfLog(FALSE, "Request start adapt(type.%d) and bitrate is:%u\n", byAdaptType, wBitRate);
//     }
//     else
//     {
//         tAdaptParam.SetBitRate(GetAudioBitrate(tAdaptParam.GetAudType()));
//     }
// 
// 	return StartBasAdapt(&tAdaptParam, byAdaptType, &tSrcSCS,ptBas,pbyBasChl);
// }

/*=============================================================================
    函 数 名： ChangeAdapt
    功    能： 改变适配(目前没有对级联适配支持)
    算法实现： 
    全局变量： 
    参    数： u16 wBitRate        适配码率
               TSimCapSet *pDstSCS 适配后的码流能力集
               TSimCapSet *pSrcSCS 适配前的原始的码流能力集
    返 回 值： void 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/3/9    3.5			万春雷                  创建
=============================================================================*/
//modify bas 2
// BOOL32 CMcuVcInst::ChangeAdapt(u8 byAdaptType, u16 wBitRate, TSimCapSet *pDstSCS, TSimCapSet *pSrcSCS)
// {
//     u16 wWidth;
//     u16 wHight;
// 	TSimCapSet tSrcSCS;
// 	TAdaptParam tAdaptParam;
//     memset(&tAdaptParam, 0, sizeof(tAdaptParam));
// 
//     if (ADAPT_TYPE_AUD == byAdaptType)
//     {
//         if (!g_cMcuVcApp.IsPeriEqpConnected(m_tAudBasEqp.GetEqpId()))
//         {
//             return FALSE;
//         }
//     }
// 
//     if (ADAPT_TYPE_VID == byAdaptType)
//     {
//         if (!g_cMcuVcApp.IsPeriEqpConnected(m_tVidBasEqp.GetEqpId()))
//         {
//             return FALSE;
//         }
//     }
// 
//     if (ADAPT_TYPE_BR == byAdaptType)
//     {
//         if (!g_cMcuVcApp.IsPeriEqpConnected(m_tBrBasEqp.GetEqpId()))
//         {
//             return FALSE;
//         }
//     }
// 
// 	if (NULL == pDstSCS || pDstSCS->IsNull())
// 	{
//         if (ADAPT_TYPE_AUD == byAdaptType)
//         {
// 		    tAdaptParam.SetVidType(MEDIA_TYPE_NULL);
// 		    tAdaptParam.SetAudType(m_tConf.GetMainAudioMediaType());
//         }
//         else
//         {
//             tAdaptParam.SetVidType(m_tConf.GetMainVideoMediaType());
// 		    tAdaptParam.SetAudType(MEDIA_TYPE_NULL);
//             m_tConf.GetVideoScale(byAdaptType, wWidth, wHight);
//             tAdaptParam.SetResolution(wWidth, wHight);
//         }
// 	}
// 	else
// 	{
// 		tAdaptParam.SetVidType(pDstSCS->GetVideoMediaType());	
// 		tAdaptParam.SetAudType(pDstSCS->GetAudioMediaType());
//         u8 byResolution = pDstSCS->GetVideoResolution();
//         m_tConf.GetVideoScale(byAdaptType, wWidth, wHight, &byResolution);
//         tAdaptParam.SetResolution(wWidth, wHight);
// 	}
// 
//     if (ADAPT_TYPE_AUD != byAdaptType && ADAPT_TYPE_CASDAUD != byAdaptType)
//     {
// //        if (0 != m_tConf.GetSecBitRate()) //双速会议
// //        {
// //            if ((m_tConf.GetConfAttrb().IsMulticastMode() && 
// //                m_tConf.GetConfAttrb().IsMulcastLowStream()) || 
// //                m_byRecLowStream)
// //            {
// //                wBitRate = m_tConf.GetSecBitRate();
// //            }
// //            else
// //            {
// //                wBitRate = (wBitRate > m_tConf.GetSecBitRate()) ? wBitRate : m_tConf.GetSecBitRate();
// //            }
// //        }
// 
//         if (0 == wBitRate)
//         {
//             tAdaptParam.SetBitRate(m_tConf.GetBitRate());
//         }
//         else
//         {
//             if (wBitRate != m_tConf.GetBitRate())
//             {
//                 tAdaptParam.SetBitRate(wBitRate);
//             }
//             else
//             {
//                 tAdaptParam.SetBitRate(wBitRate);
//             }
//         }
//         m_tConf.GetVideoScale(tAdaptParam.GetVidType(), wWidth, wHight);
//         tAdaptParam.SetResolution(wWidth, wHight);
// 
//         if (ADAPT_TYPE_VID == byAdaptType)
//         {
//             m_wVidBasBitrate = wBitRate;
//         }
//         else if (ADAPT_TYPE_BR == byAdaptType)
//         {
//             m_wBasBitrate = wBitRate;
//         }
// 
//         ConfLog(TRUE, "Change adapt(type.%d) param and bitrate is:%u\n", byAdaptType, wBitRate);
//     }
//     else
//     {
//         tAdaptParam.SetBitRate(GetAudioBitrate(tAdaptParam.GetAudType()));
//     }
// 
// 	return ChangeBasAdaptParam(&tAdaptParam, byAdaptType, pSrcSCS);	
// 
// }

/*====================================================================
    函数名      ：SendTrapMsg
    功能        ：发 Trap 消息
    算法实现    ：
    引用全局变量：
    输入参数说明：无
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/04/29    3.0         胡昌威          创建
====================================================================*/
void CMcuVcInst::SendTrapMsg( u16 wEvent, u8 * const pbyMsg, u16 wLen )
{
    post( MAKEIID( AID_MCU_AGENT, 1 ), wEvent, pbyMsg, wLen );

	return;
}

/*====================================================================
    函数名      ：ShowMtStat
    功能        ：打印会议终端状态
    算法实现    ：
    引用全局变量：
    输入参数说明：无
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/03/11    3.0         胡昌威          创建
====================================================================*/
void CMcuVcInst::ShowMtStat( void )
{
	if( !m_tConf.m_tStatus.IsOngoing() )
	{
		return;
	}

	//打印本地终端状态
	TCapSupport tCapSupport;
	u8 byLoop = 1;
	u16 wLoop = 1;
	StaticLog("\n本地终端状态: McuId-%d\n", LOCAL_MCUID );
	if (m_ptMtTable != NULL)
	{
		TMtStatus   tMtStatus;
		for( byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
		{
			if( m_tConfAllMtInfo.MtJoinedConf( byLoop ) )
			{
				m_ptMtTable->GetMtStatus( byLoop, &tMtStatus );
				m_ptMtTable->GetMtCapSupport( byLoop, &tCapSupport );
				tMtStatus.Print();
				tCapSupport.Print();
				
				StaticLog( "\nDialBitrate:%d\n",m_ptMtTable->GetDialBitrate(byLoop) );
				//双选看源
				StaticLog("\nSec Sel Video MT: mcu%d,mtid%d\n", m_ptMtTable->GetMtSelMtByMode(byLoop, MODE_VIDEO2SECOND).GetMcuId(), 
					m_ptMtTable->GetMtSelMtByMode(byLoop, MODE_VIDEO2SECOND).GetMtId());

				StaticLog("\n是否自动加入混音: %d\n", m_ptMtTable->IsMtAutoInSpec(byLoop));
			}
		}
	}

	u16 wMcuIdx = 0,wMMcuIdx = 0;
	if (m_ptConfOtherMcTable != NULL)
	{
		//u8 byFstMcuId = 0;
		u8 abyMcuId[ MAX_CASCADEDEPTH - 1];
		memset( &abyMcuId[0],0,sizeof(abyMcuId) );

		TConfMcInfo *ptMcInfo = NULL;
		//打印其它Mc上终端状态
		for( u16 wLoop1 = 0; wLoop1 < TConfOtherMcTable::GetMaxMcuNum(); wLoop1++ )
		{
			ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(wLoop1);
			if (NULL == ptMcInfo)
			{
				continue;
			}

			wMcuIdx = m_ptConfOtherMcTable->GetMcInfo(wLoop1)->GetMcuIdx();
			if (!IsValidSubMcuId(wMcuIdx))
			{
				continue;
			}

			m_tConfAllMcuInfo.GetMcuIdByIdx( wMcuIdx,&abyMcuId[0] );
			if( m_tConfAllMcuInfo.IsSMcuByMcuIdx(wMcuIdx) )
			{
				StaticLog("\n其它终端状态: McuId-%d\n", abyMcuId[0] );
			}
			else
			{
				StaticLog("\n其它非直属终端状态: McuId-%d SMcuId-%d\n", abyMcuId[0],abyMcuId[1] );
			}
			TConfMcInfo *ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo( wMcuIdx );
			if(ptConfMcInfo == NULL)
			{
				break;
			}
			
			ptConfMcInfo->m_atMtStatus[0].PrintTitle();
			for( u8 byIdx = 1; byIdx <= MAXNUM_CONF_MT; byIdx++ )
			{	
				if ( !ptConfMcInfo->m_atMtStatus[byIdx-1].IsNull() )
				{
					//StaticLog("Postion Index: %d\t", byIdx-1 );
					ptConfMcInfo->m_atMtStatus[byIdx-1].Print();
				}		
			}
		}
	}

	//zjj20100327	
	if( m_tConf.GetConfSource() == VCS_CONF )
	{
		StaticLog("\n本地终端状态(VCS会议终端呼叫模式): McuId-%d\n", LOCAL_MCUID );
		TMtStatus tMtStatus;
		for( byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
		{
			if( m_ptMtTable && m_tConfAllMtInfo.MtInConf( byLoop ) )
			{
				m_ptMtTable->GetMtStatus( byLoop,&tMtStatus );
				StaticLog("MT%d CallMode:%d DisconnectReason:%d\n", 
					byLoop, m_ptMtTable->GetCallMode( byLoop ),
					tMtStatus.GetMtDisconnectReason()					
					);
			}			
		}

		
		TConfMcInfo *ptMcInfo = NULL;
		TConfMtInfo *ptConfMtInfo = NULL;
		u8 abyMcuId[ MAX_CASCADEDEPTH - 1 ];
		memset( &abyMcuId[0],0,sizeof(abyMcuId) );

		wMMcuIdx = GetMcuIdxFromMcuId( m_tCascadeMMCU.GetMtId() );
		const u16 wMaxMcuNum = m_tConfAllMtInfo.GetMaxMcuNum();
		for( wLoop = 0; wLoop < wMaxMcuNum; wLoop++ )
		{
			ptConfMtInfo = m_tConfAllMtInfo.GetMtInfoPtr(wLoop);
			if (NULL == ptConfMtInfo)
			{
				continue;
			}

			wMcuIdx = ptConfMtInfo->GetMcuIdx();
			if (!IsValidMcuId(wMcuIdx))
			{
				continue;
			}

			if( wMcuIdx == wMMcuIdx )
			{
				continue;
			}

			m_tConfAllMcuInfo.GetMcuIdByIdx( wMcuIdx,&abyMcuId[0] );
			if( m_tConfAllMcuInfo.IsSMcuByMcuIdx(wMcuIdx) )
			{
				StaticLog("其它终端: McuId-%d\n", abyMcuId[0] );
			}
			else
			{
				StaticLog("其它非直属终端: McuId-%d SMcuId-%d\n", abyMcuId[0],abyMcuId[1] );
			}
			
			ptMcInfo = m_ptConfOtherMcTable->GetMcInfo( wMcuIdx );
			if( NULL == ptMcInfo )
			{
				continue;
			}

			u8 byMtId = 1;
			while( byMtId < MAXNUM_CONF_MT )
			{
				if( ptConfMtInfo->MtInConf( byMtId ) &&
					!ptConfMtInfo->MtJoinedConf(byMtId) )
				{
					StaticLog(
						"MT%d DisconnectReason:%d\n",
						byMtId,
						ptMcInfo->m_atMtStatus[byMtId].GetMtDisconnectReason()
						);					
				}				
				++byMtId;
			}
		}
	}

	return;
}

/*====================================================================
    函数名      ：ProcMpMessage
    功能        ：处理Mp的消息
    算法实现    ：
    引用全局变量：
    输入参数说明：CMessage * const pcMsg, 传入的消息
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/03/10    3.0         胡昌威          创建
====================================================================*/
void CMcuVcInst::ProcMpMessage( CMessage * const pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TSwitchChannel *ptSwitchChannel;
	//CMcuVcInst *pMcuVcInst = NULL;
    u8 byMpId = cServMsg.GetSrcDriId();
	
	if( CurState() != STATE_ONGOING )
	{
		return;
	}
	
	// 打印 [pengguofeng 5/24/2012]
	TSwitchChannel *ptChnnel111 = (TSwitchChannel*)cServMsg.GetMsgBody();
	LogPrint(LOG_LVL_DETAIL, MID_MCU_MPMGR, "[ProcMpMessage]recv %d(%s),and param is\n",
		pcMsg->event, ::OspEventDesc(pcMsg->event) );

	LogPrint(LOG_LVL_DETAIL, MID_MCU_MPMGR, "SrcMt;%d dwSrcIp:%s dwRcvIP:%s dwRcvBindIp:%s\n",
		ptChnnel111->GetSrcMt().GetMtId(), StrOfIP(ptChnnel111->GetSrcIp()),
		StrOfIP(ptChnnel111->GetRcvIP()), StrOfIP(ptChnnel111->GetRcvBindIP()));

	LogPrint(LOG_LVL_DETAIL, MID_MCU_MPMGR, "disIp:%s dwSndBindIp;%s dstIp:%s RcvPort:%d DstPort:%d\n",
		StrOfIP(ptChnnel111->GetDisIp()), StrOfIP(ptChnnel111->GetSndBindIP()),
		StrOfIP(ptChnnel111->GetDstIP()), (ptChnnel111->GetRcvPort()), ptChnnel111->GetDstPort());

	switch( pcMsg->event )
	{
	case MP_MCU_REG_REQ://Mp注册
        {
            // xsl [9/12/2006] 通知mp板是否归一重整
            TMp tMp = *(TMp*)cServMsg.GetMsgBody();
			TConfAttrb tConfAttrb = m_tConf.GetConfAttrb(); 
            u8 m_byUniformMode = tConfAttrb.IsAdjustUniformPack();
			cServMsg.SetMsgBody((u8 *)&m_byUniformMode, sizeof(u8));
            cServMsg.SetConfIdx(m_byConfIdx);
			g_cMpSsnApp.SendMsgToMpSsn(tMp.GetMpId(), MCU_MP_CONFUNIFORMMODE_NOTIFY, cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
        
            // xsl [9/15/2006]调整桥交换
            AdjustSwitchBridge(tMp.GetMpId(), TRUE);
			
			//如果当前有发言人或终端放像，应发消息给上线转发板建到内部跳变端口的交换[4/12/2012 chendaiwei]
			TMt tVidSrc = GetVidBrdSrc();
			
			if(!tVidSrc.IsNull() && 
				( (tVidSrc.GetType() == TYPE_MT || tVidSrc.GetType() == TYPE_MCU) || 
				 (tVidSrc.GetMtType() == EQP_TYPE_RECORDER && tVidSrc.GetType() == TYPE_MCUPERI ) ))
			{
				//建立交换桥
				u8 bySrcChnnl = 0;
				u16 wSpyStartPort = SPY_CHANNL_NULL;

				if(tVidSrc == m_tPlayEqp)
				{
					bySrcChnnl = m_byPlayChnnl;
				}
				else
				{					
					CRecvSpy tSpyResource; 
					if( m_cSMcuSpyMana.GetRecvSpy( tVidSrc, tSpyResource ) )
					{
						wSpyStartPort = tSpyResource.m_tSpyAddr.GetPort();
					}
				}

				LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_MPMGR, "[ProcMpMessage]recv MP_MCU_REG_REQ, Send MCU_MP_ADDBRDSRCSWITCH_REQ to MP.%d\n",tMp.GetMpId());
				TMt tLocalSrc = GetLocalMtFromOtherMcuMt(tVidSrc);
				g_cMpManager.StartSwitchToBrd(tLocalSrc, bySrcChnnl, FALSE, wSpyStartPort,tMp.GetMpId());
			}
			
			//zbq 20091220 处理 断线恢复 标识
            for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
            {
                //含不在线终端
                if (!m_tConfAllMtInfo.MtInConf(byMtId))
                {
                    continue;
                }
                if (NULL == m_ptMtTable)
                {
                    continue;
                }
                if (m_ptMtTable->GetDisconnectDRI(byMtId) == tMp.GetMpId())
                {
                    m_ptMtTable->SetDisconnectDRI(byMtId, 0);
                }
            }
        }
		break;

	case MP_MCU_ADDSWITCH_ACK://成功增加交换
		{
			TSwitchChannel *ptChnnel = (TSwitchChannel*)cServMsg.GetMsgBody();
            u8 byChnlNum = cServMsg.GetMsgBodyLen() / sizeof(TSwitchChannel);
			for( u8 byLoop = 0; byLoop < byChnlNum; byLoop++ )
			{
				m_ptSwitchTable->AddSwitchTable( cServMsg.GetSrcDriId(), &ptChnnel[byLoop] );	  
				StartMtSendbyNeed( &ptChnnel[byLoop] );
				NotifyRecStartPlaybyNeed( &ptChnnel[byLoop] );
			}
		}
		// 	    ptSwitchChannel = (TSwitchChannel*)cServMsg.GetMsgBody();
		// 	    m_ptSwitchTable->AddSwitchTable( cServMsg.GetSrcDriId(), ptSwitchChannel );	  
		// 	    StartMtSendbyNeed( ptSwitchChannel );
		// 		NotifyRecStartPlaybyNeed( ptSwitchChannel );
		break;

	case MP_MCU_REMOVESWITCH_ACK://成功移除交换
		{
			TSwitchChannel *ptChnnel = (TSwitchChannel*)cServMsg.GetMsgBody();
			u8 byChnlNum = cServMsg.GetMsgBodyLen() / sizeof(TSwitchChannel);
			ConfPrint( LOG_LVL_DETAIL, MID_MCU_MPMGR, "ProcMpMessage MP_MCU_REMOVESWITCH_ACK remove Num = %d Such As: \n", byChnlNum );
			for( u8 byLoop = 0; byLoop < byChnlNum; byLoop++ )
			{
				m_ptSwitchTable->RemoveSwitchTable( cServMsg.GetSrcDriId(), &ptChnnel[byLoop] );
				ConfPrint( LOG_LVL_DETAIL, MID_MCU_MPMGR, "Num.%d, dstIp<%s@%d>\n", byLoop + 1, StrOfIP( ptChnnel[byLoop].GetDstIP() ), \
					ptChnnel[byLoop].GetDstPort() );
				if ( ptChnnel[byLoop].GetRcvPort() != 0 )
				{
					StopMtSendbyNeed( &ptChnnel[byLoop] );
				}
			}
		}
		// 	    ptSwitchChannel = (TSwitchChannel*)cServMsg.GetMsgBody();
		//         MpManagerLog( "[ProcMpMessage] MP_MCU_REMOVESWITCH_ACK : dst<%s@%d>\n", 
		//                        StrOfIP( ptSwitchChannel->GetDstIP() ), ptSwitchChannel->GetDstPort() );
		// 	    m_ptSwitchTable->RemoveSwitchTable( cServMsg.GetSrcDriId(), ptSwitchChannel );
		//         // zgc, 2008-05-27, 非广播交换目的才需要检查是否要停广播
		//         if ( ptSwitchChannel->GetRcvPort() != 0 )
		//         {
		//             StopMtSendbyNeed( ptSwitchChannel );
		//         }
		break;
	case MP_MCU_ADDMULTITOONESWITCH_ACK:		//MP接受MCU的增加多点到一点交换请求
		{
			ptSwitchChannel = (TSwitchChannel*)cServMsg.GetMsgBody();
			u8 bySwitchNum = cServMsg.GetMsgBodyLen() / sizeof(TSwitchChannel);
			for (u8 bySwitchIdx = 0; bySwitchIdx < bySwitchNum; bySwitchIdx++)
			{
				m_ptSwitchTable->ProcMultiToOneSwitch( &ptSwitchChannel[bySwitchIdx], 1 );
			}
		}
		break;
	case MP_MCU_REMOVEMULTITOONESWITCH_ACK:		//MP接受MCU的移除多点到一点交换请求	   
		{
			ptSwitchChannel = (TSwitchChannel*)cServMsg.GetMsgBody();
			u8 bySwitchNum = cServMsg.GetMsgBodyLen() / sizeof(TSwitchChannel);
			for (u8 bySwitchIdx = 0; bySwitchIdx < bySwitchNum; bySwitchIdx++)
			{
				m_ptSwitchTable->ProcMultiToOneSwitch(  &ptSwitchChannel[bySwitchIdx], 2 );
			}	
		}
		break;
	case MP_MCU_STOPMULTITOONESWITCH_ACK:       //MP接受MCU的停止多点到一点交换请求 
	    ptSwitchChannel = (TSwitchChannel*)cServMsg.GetMsgBody();
	    m_ptSwitchTable->ProcMultiToOneSwitch( ptSwitchChannel, 3 );
		break;
		
	case MP_MCU_GETSWITCHSTATUS_ACK:
	case MP_MCU_ADDRECVONLYSWITCH_ACK:
	case MP_MCU_REMOVERECVONLYSWITCH_ACK:
	case MP_MCU_SETRECVSWITCHSSRC_ACK:
		break;	

	case MP_MCU_ADDSWITCH_NACK:
	case MP_MCU_ADDMULTITOONESWITCH_NACK:
		{
            // guzh [1/11/2007] 添加交换失败
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MPMGR, "Fail to Add switch. Mp.%d is full\n", cServMsg.GetSrcDriId());
		}
		break;
	case MP_MCU_REMOVESWITCH_NACK:
		{
            ConfPrint(LOG_LVL_ERROR, MID_MCU_MPMGR, "Fail to Remove switch at Mp.%d\n", cServMsg.GetSrcDriId());
		}
		break;
	case MP_MCU_GETSWITCHSTATUS_NACK:	
	case MP_MCU_REMOVEMULTITOONESWITCH_NACK:
	case MP_MCU_STOPMULTITOONESWITCH_NACK:
	case MP_MCU_ADDRECVONLYSWITCH_NACK:
	case MP_MCU_REMOVERECVONLYSWITCH_NACK:
	case MP_MCU_SETRECVSWITCHSSRC_NACK:	
		break;	
        
        // guzh [3/26/2007]成功增加广播交换
    case MP_MCU_ADDBRDSRCSWITCH_ACK:
        ptSwitchChannel = (TSwitchChannel*)cServMsg.GetMsgBody();       
        m_ptSwitchTable->ProcBrdSwitch( 1, ptSwitchChannel, 1, byMpId );       
        StartMtSendbyNeed( ptSwitchChannel );   
        break;
    case MP_MCU_ADDBRDDSTSWITCH_ACK:
        {
        /*
        TSwitchChannel atChnnels[MAXNUM_CONF_MT];            
        u8 byChnlNum = cServMsg.GetMsgBodyLen() / (sizeof(TSwitchChannel)+3*sizeof(u8));
        u8 *byPtr = cServMsg.GetMsgBody();
        for ( u8 byLoop = 0; byLoop < byChnlNum; byLoop++ )
        {
        atChnnels[byLoop] = *(TSwitchChannel*)byPtr;
        byPtr += (sizeof(TSwitchChannel)+3*sizeof(u8));
        }
            */
            TSwitchChannel *ptChnnel = (TSwitchChannel*)cServMsg.GetMsgBody();
            u8 byChnlNum = cServMsg.GetMsgBodyLen() / sizeof(TSwitchChannel);
            
            ConfPrint(LOG_LVL_DETAIL, MID_MCU_MPMGR, "[ProcMpMessage] Mp Added broadcast destination MT n=%d!\n", byChnlNum);
            m_ptSwitchTable->ProcBrdSwitch( byChnlNum, ptChnnel, 11, byMpId );        
            break;
        }
        // 成功移除广播源
    case MP_MCU_REMOVEBRDSRCSWITCH_ACK:
        ptSwitchChannel = (TSwitchChannel*)cServMsg.GetMsgBody();
        m_ptSwitchTable->ProcBrdSwitch( 1, ptSwitchChannel, 2, byMpId );
        // guzh [4/3/2007] 如果是终端,这里还不移交换.等 MP_MCU_BRDSRCSWITCHCHANGE_NTF
        break;
        
    case MP_MCU_BRDSRCSWITCHCHANGE_NTF:    // 广播源完成移除通知
        ProcVidBrdSrcChanged(pcMsg);
        break;
        
    case MP_MCU_ADDBRDSRCSWITCH_NACK:
    case MP_MCU_REMOVEBRDSRCSWITCH_NACK:
    case MP_MCU_ADDBRDDSTSWITCH_NACK:
        ConfPrint( LOG_LVL_ERROR, MID_MCU_MPMGR, "MP switch failed. %d(%s)!\n", 
            pcMsg->event, ::OspEventDesc( pcMsg->event ) );
        break;
        
    default:
        ConfPrint( LOG_LVL_ERROR, MID_MCU_MPMGR, "Wrong message %u(%s) received in DaemonEntry!\n", 
            pcMsg->event, ::OspEventDesc( pcMsg->event ) );
        break;	
    }
    
    return;
}


/*====================================================================
函数名      ：ProcVidBrdSrcChanged
功能        ：处理MP通知视频广播源已变化的通知
算法实现    ：1. 停止 Mt-->Mp 的码流交换
2. 停止桥交换(可能包括第二路)
3. etc...
引用全局变量：
输入参数说明：CMessage * const pcMsg, 传入的消息
返回值说明  ：无
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
07/03/27    4.0         顾振华          创建
====================================================================*/
void CMcuVcInst::ProcVidBrdSrcChanged( CMessage * const pcMsg )
{    
    CServMsg cServMsg( pcMsg->content, pcMsg->length );
    TMt tOldVidSrc = *(TMt*)cServMsg.GetMsgBody();
	//将recvport传过来
	u16 wRecvPort = ntohs(*(u16*)(cServMsg.GetMsgBody()+sizeof(TMt)));
    u8 bySrcDriId = cServMsg.GetSrcDriId();
    
	ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MPMGR, "[ProcVidBrdSrcChanged] bySrcDriId.%d, tOldVidSrc<McuId.%d, MtId.%d>\n",
												bySrcDriId, tOldVidSrc.GetMcuId(), tOldVidSrc.GetMtId());
    if (tOldVidSrc.IsNull())
        return;
    
	// xliang [2/6/2009] 判断之前是否是新VMP广播
	BOOL32 bNewVmpBrd = FALSE;
	if( tOldVidSrc == m_tVmpEqp )
	{
		TPeriEqpStatus tPeriEqpStatus; 
		g_cMcuVcApp.GetPeriEqpStatus( m_tVmpEqp.GetEqpId(), &tPeriEqpStatus );
		u8 byVmpSubType = tPeriEqpStatus.m_tStatus.tVmp.m_bySubType;
		if(byVmpSubType != VMP)
		{
			bNewVmpBrd = TRUE;
		}
	}
    TSwitchChannel tSwitchChannel;
    u32 dwMtSwitchIp;
    u16 wMtSwitchPort;
    u32 dwMtSrcIp;    
    g_cMpManager.GetSwitchInfo(tOldVidSrc,dwMtSwitchIp, wMtSwitchPort, dwMtSrcIp );
    // 只处理来自接入源的MP消息
    if ( bySrcDriId != g_cMcuVcApp.FindMp( dwMtSwitchIp ) )
    {
        return;
    }
	//下级多回传终端发言，且下级终端的时候老的发言人是30000之类的端口不是61000之类的端口
    if ( wRecvPort !=0 &&  wRecvPort != wMtSwitchPort )
    {
		wMtSwitchPort = wRecvPort;
    }
    TLogicalChannel tLogicalChannel;
    
    //启用适配并且开启了双流, 恢复老的第一路发送源的发送码率,没有适配器则根据FlowControl调整
    if ( !m_tDoubleStreamSrc.IsNull() &&
        TYPE_MT == tOldVidSrc.GetType() )
    {        
        if (m_ptMtTable->GetMtLogicChnnl(tOldVidSrc.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE))
        {
            tLogicalChannel.SetFlowControl(m_ptMtTable->GetSndBandWidth( tOldVidSrc.GetMtId()));
            cServMsg.SetMsgBody((u8*)&tLogicalChannel, sizeof(tLogicalChannel));
            SendMsgToMt(tOldVidSrc.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cServMsg);
        }
    } 
    
    u8 bySrcChnnl = 0;

	// [12/29/2010 liuxu]需要判断m_tCascadeMMCU是否为空，否则这里会导致GetMcInfo刷屏
	TConfMcInfo *ptConfMcInfo = NULL;
	if (!m_tCascadeMMCU.IsNull())
	{
		 ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(GetMcuIdxFromMcuId(m_tCascadeMMCU.GetMtId()));
	}
	// zbq [08/23/2007] 查看该终端是否在回传通道里，是则不能停其桥交换，否则会导致回传通道无码流
	if ( !m_tCascadeMMCU.IsNull() &&
		ptConfMcInfo != NULL &&
		!GetLocalVidBrdSrc().IsNull() &&
		ptConfMcInfo->m_tSpyMt == GetLocalVidBrdSrc() )
	{
	}
	else
	{
		// 老广播源是终端且有普通交换存在，则不拆桥, zgc, 2008-05-23
		if ( tOldVidSrc.GetType() == TYPE_MCUPERI ||
			!m_ptSwitchTable->IsValidCommonSwitchSrcIp(dwMtSrcIp, wMtSwitchPort, MODE_VIDEO) )
		{
			if(bNewVmpBrd) // xliang [2/6/2009] 是新VMP，则要拆3路交换桥(在进该函数之前就拆掉)
			{
				// 				bySrcChnnl = 0;
				// 				g_cMpManager.RemoveSwitchBridge(tOldVidSrc, bySrcChnnl, MODE_VIDEO);
				// 				g_cMpManager.RemoveSwitchBridge(tOldVidSrc, bySrcChnnl+1, MODE_VIDEO);
				// 				g_cMpManager.RemoveSwitchBridge(tOldVidSrc, bySrcChnnl+2, MODE_VIDEO);
				// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "New VMP : RemoveSwitchBridge!\n");
			}
			else
			{
				if (!(tOldVidSrc == GetLocalVidBrdSrc()) && !(tOldVidSrc == GetSecVidBrdSrc()))
				{
					// 拆除交换桥
					bySrcChnnl = (tOldVidSrc == m_tPlayEqp) ? m_byPlayChnnl : 0;
					u16 wSpyStartPort = SPY_CHANNL_NULL;
					//实际老发言人是级联多回传终端（tOldVidSrc是下级mcu），要传多回传端口
					if ( wMtSwitchPort >= CASCADE_SPY_STARTPORT && wMtSwitchPort < CASCADE_BRD_STARTPORT )
					{
						wSpyStartPort = wMtSwitchPort;
					}
					g_cMpManager.RemoveSwitchBridge(tOldVidSrc, bySrcChnnl, MODE_VIDEO,FALSE,wSpyStartPort);
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MPMGR, "[ProcVidBrdSrcChanged] RemoveSwitchBridge!\n");
				}
			}
		}
	}
	

    
    //  xsl [3/10/2006] 双速或双格式会议广播源为vmp时，拆除第二路交换桥
	// xliang [2/18/2009] mpu-vmp不在这里拆
    if (tOldVidSrc == m_tVmpEqp 
		&& !bNewVmpBrd 
		&& ((0 != m_tConf.GetSecBitRate() || MEDIA_TYPE_NULL != m_tConf.GetSecVideoMediaType())))
    {
        // VMP不可能有普通交换，这里不进行判断，zgc, 2008-05-23
        g_cMpManager.RemoveSwitchBridge(tOldVidSrc, bySrcChnnl+1, MODE_VIDEO);           
    }	

    
    // 停止交换源发送                  
    tSwitchChannel.SetSrcMt( tOldVidSrc );        
    tSwitchChannel.SetSrcIp(dwMtSrcIp);
    tSwitchChannel.SetRcvIP(dwMtSwitchIp);
    tSwitchChannel.SetRcvPort(wMtSwitchPort);
    
    ConfPrint(LOG_LVL_DETAIL, MID_MCU_MPMGR, "[ProcVidBrdSrcChanged]Recvied MT(%d,%d) %s switch removed notify.\n",
        tOldVidSrc.GetMcuId(), tOldVidSrc.GetMtId(), StrOfIP(dwMtSrcIp));
    
    m_ptSwitchTable->ProcBrdSwitch( 1, &tSwitchChannel, 2, bySrcDriId );
	if (TYPE_MT == tOldVidSrc.GetType())
    {    
        StopMtSendbyNeed(&tSwitchChannel);
    }    
}

/*====================================================================
    函数名      ：DaemonProcMtadpDiscAndRegMsg
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：CMessage * const pcMsg, 传入的消息
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
====================================================================*/
void CMcuVcInst::DaemonProcMtadpDiscAndRegMsg(const CMessage * pcMsg)
{
	g_cMpManager.ProcMtAdpToMcuMessage(pcMsg);

	NotifyMcsCriMacAddrInfo();

// 	//处理 断线恢复 标识
// 	CServMsg cServMsg( pcMsg->content ,pcMsg->length );	
// 	TMtAdpReg tMtAdpReg =  *( TMtAdpReg* )cServMsg.GetMsgBody();
// 	for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
// 	{
// 		//含不在线终端
// 		if (!m_tConfAllMtInfo.MtInConf(byMtId))
// 		{
// 			continue;
// 		}
// 		if (NULL == m_ptMtTable)
// 		{
// 			continue;
// 		}
// 		if (m_ptMtTable->GetDisconnectDRI(byMtId) == tMtAdpReg.GetDriId())
// 		{
// 			m_ptMtTable->SetDisconnectDRI(byMtId, 0);
// 		}
// 	}
	
}
/*====================================================================
    函数名      ：DaemonProcMpFluxNotify
    功能        ：MP能力限制相关消息处理
    算法实现    ：
    引用全局变量：
    输入参数说明：CMessage * const pcMsg, 传入的消息
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    07/02/11    4.0         张宝卿          创建
====================================================================*/
void CMcuVcInst::DaemonProcMpFluxNotify( const CMessage * pcMsg )
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);
    switch( pcMsg->event )
    {
    case MP_MCU_FLUXSTATUS_NOTIFY:
        {
            //u16 wMpBand = *(u16*)cServMsg.GetMsgBody();
            g_cMcuVcApp.m_atMpData[cServMsg.GetSrcDriId()-1].m_wNetBandReal = ntohs(*(u16*)cServMsg.GetMsgBody());
            if ( ntohs(*(u16*)cServMsg.GetMsgBody()) > g_cMcuVcApp.m_atMpData[cServMsg.GetSrcDriId()-1].m_wNetBandAllowed )
            {
                u32 dwMpIp = g_cMcuVcApp.m_atMpData[cServMsg.GetSrcDriId()-1].m_tMp.GetIpAddr();
                dwMpIp = htonl(dwMpIp);
                cServMsg.SetMsgBody( (u8*)&dwMpIp, sizeof(u32) );
                SendMsgToAllMcs( MCU_MCS_MPFLUXOVERRUN_NOTIFY, cServMsg );
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MPMGR, "[DaemonProcMpFluxNotify] send MCU_MCS_MPFLUXOVERRUN_NOTIFY to mcs, Mp.%d's Band = %d !\n", 
                     cServMsg.GetSrcDriId(), ntohs(*(u16*)cServMsg.GetMsgBody()) );
				showmp();
                break;                        
            }
           
            break;
        }
    default:
        ConfPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[DaemonProcMpFluxNotify] unexpected msg.%d<%s> recieved !\n",
                                 pcMsg->event, OspEventDesc(pcMsg->event) );
        break;
    }
}

/*====================================================================
    函数名      ：DaemonProcGetDsInfoAck
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2011/07/07	4.6			薛亮			create
====================================================================*/
void CMcuVcInst::DaemonProcGetDsInfoAck(const CMessage * pcMsg )
{
	if (pcMsg == NULL)
	{
		return;
	}

	CServMsg cServMsg(pcMsg->content, pcMsg->length);
	
	u8 byMpId = cServMsg.GetSrcDriId();
	TTransportAddr tRcvAddr = *(TTransportAddr *)cServMsg.GetMsgBody();
	TTransportAddr tDstAddr = *(TTransportAddr *)( cServMsg.GetMsgBody() + sizeof(TTransportAddr));
	u32 dwRcvIp  = tRcvAddr.GetIpAddr(); 
	u16 wRcvPort = tRcvAddr.GetPort();
	u32 dwDstIp  = tDstAddr.GetIpAddr();
	u16 wDstPort = tDstAddr.GetPort();
	s8 achBuf[255] = { 0 };
	u16 wLen = 0;
	wLen += sprintf(achBuf, "\n[mp%2u]%s:%d <<<<-- xxx packets/sec \n", byMpId, StrOfIP(dwRcvIp),wRcvPort  );
	wLen += sprintf(achBuf + wLen, "                           -->>>> ");
	u8 byDstMpId = g_cMcuVcApp.FindMp( dwDstIp );
	if (byDstMpId > 0)
	{
		wLen += sprintf(achBuf + wLen, "[mp%u]%s:%d XXX packets/sec\n", byDstMpId, StrOfIP(dwDstIp), wDstPort);
	}
	else
	{
		wLen += sprintf(achBuf + wLen, "[dst]%s:%d XXX packets/sec\n", StrOfIP(dwDstIp), wDstPort);
	}

	ConfPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "%s\n", achBuf);

}

/*====================================================================
    函数名      ：ProcMpDissconnected
    功能        ：处理Mp的断链
    算法实现    ：
    引用全局变量：
    输入参数说明：CMessage * const pcMsg, 传入的消息
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/06/08    3.0         胡昌威          创建
====================================================================*/
void CMcuVcInst::ProcMpDissconnected( CMessage * const pcMsg )
{	
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TMp tMp;
	TMt tMt;
	u8 byLoop;

 	switch( CurState() )
	{
	case STATE_ONGOING:
		{
			//通知所属转发板的终端掉线
			tMp = *(TMp*)cServMsg.GetMsgBody();	 

			//20110819 zjl bas广播平滑交换重建
			u8 byNum = 0;
			TMt tBasSrc;
			u8 bySrcChn = 0;
			CBasChn *apcBasChn[MAXNUM_PERIEQP]={NULL};
			u8  abyMediaMode[3] = {MODE_VIDEO, MODE_AUDIO, MODE_SECVIDEO};
			for (u8 byModeIdx = 0; byModeIdx < sizeof(abyMediaMode)/sizeof(u8); byModeIdx++)
			{
				byNum = 0;
				bySrcChn = 0;
				tBasSrc.SetNull();
				memset(apcBasChn, 0, sizeof(apcBasChn));
				
				if (MODE_VIDEO == abyMediaMode[byModeIdx])
				{
					if (!m_tConf.m_tStatus.IsVidAdapting())
					{
						continue;
					}
					else
					{
						bySrcChn = m_tPlayEqp == GetLocalVidBrdSrc() ? m_byPlayChnnl : 0;
						tBasSrc = GetVidBrdSrc();
					}
				}
				else if (MODE_AUDIO == abyMediaMode[byModeIdx])
				{
					if (!m_tConf.m_tStatus.IsAudAdapting())
					{
						continue;
					}
					else
					{
						bySrcChn = 0;
						tBasSrc = GetAudBrdSrc();
					}
				}
				else if (MODE_SECVIDEO == abyMediaMode[byModeIdx])
				{
					if (!m_tConf.m_tStatus.IsDSAdapting())
					{
						continue;
					}
					else
					{	
						bySrcChn = m_tPlayEqp == m_tDoubleStreamSrc ? m_byPlayChnnl : 0;
						tBasSrc = m_tDoubleStreamSrc;
					}
				}
				else
				{
					ConfPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[ProcMpDissconnected] Unexpected MediaMode.%d!\n", abyMediaMode[byModeIdx]);
					continue;
				}
				
				if(GetBasBrdChnGrp(byNum, apcBasChn, abyMediaMode[byModeIdx]))
				{					
					for (u8 byChnIdx = 0; byChnIdx < byNum; byChnIdx ++)
					{
						if ( NULL == apcBasChn[byChnIdx] )
						{
							continue;
						}
						
						if ( tBasSrc.IsNull() )
						{
							continue;
						}

						StartSwitchToPeriEqp(tBasSrc, bySrcChn, 
							apcBasChn[byChnIdx]->GetBas().GetEqpId(), 
							apcBasChn[byChnIdx]->GetChnId(),
							abyMediaMode[byModeIdx],
							SWITCH_MODE_BROADCAST, 
							TRUE);
					}
				}
			}

			//[2011/08/30/zhangli]
			u8 atOnlineMt[MAXNUM_CONF_MT] = {0};
			u8 byOnlineNum = 0;
			for( byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
			{
				if( m_tConfAllMtInfo.MtInConf( byLoop ) )
				{
					if( tMp.GetMpId() == m_ptMtTable->GetMpId( byLoop ) )
					{
						//zbq 20091220 不作 重复断链处理
						if(m_ptMtTable->GetDisconnectDRI(byLoop) == tMp.GetMpId())
						{
							ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "Mp %d disconnected while mt.%d ignored to remove due to duplicate!\n",
								tMp.GetMpId(), byLoop);
							continue;
						}
						else
						{
							tMt = m_ptMtTable->GetMt( byLoop );
							m_ptMtTable->SetDisconnectDRI(byLoop, tMp.GetMpId());

							//zjj20110223 若上级转发板掉线认为上级掉线,结束下级会议,上级会自动再次呼叫
							//对应Bug00047550
							if ( VCS_CONF == m_tConf.GetConfSource() && 
								MT_TYPE_MMCU == tMt.GetMtType() &&
								CONF_CREATE_MT == m_byCreateBy )
							{
								ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_VCS,  "[ProcMpDissconnected] MMcu(%d)'s Mp.%d is disconnect,release conf!\n",
									tMt.GetMtId(),tMp.GetMpId() );
								
								RestoreVCConf(VCS_SINGLE_MODE);
								m_byCreateBy = CONF_CREATE_MCS;
								cServMsg.SetConfId( m_tConf.GetConfId() );
								cServMsg.SetConfIdx( m_byConfIdx );
								cServMsg.SetEventId(MCUVC_VCSSN_MMCURLSCTRL_CMD);
								CMcsSsn::SendMsgToMcsSsn( CInstance::DAEMON, MCUVC_VCSSN_MMCURLSCTRL_CMD,
									cServMsg.GetServMsg(), cServMsg.GetServMsgLen() );								
								return;
							}

							//zbq 20091220 进一步关照一下，防止mp/mtadp交叉 同板卡 误判
							if ( tMp.GetMpId() == m_ptMtTable->GetDriId(byLoop) )
							{
								m_ptMtTable->SetDriId(byLoop, 0);
							}
							
							// [pengjie 2011/8/29] 如果是级联上级mcu所挂的转发板掉线，直接挂上级mcu
							if( !m_tCascadeMMCU.IsNull() && m_tCascadeMMCU == tMt )
							{
								ConfPrint( LOG_LVL_ERROR, MID_MCU_CALL, "Mp%d disconnected and Mmcu On this Mp, droped it!\n", 
									tMp.GetMpId() );
								RemoveJoinedMt( tMt, TRUE, MTLEFT_REASON_EXCEPT );
								continue;
							}
							
							RemoveJoinedMt( tMt, TRUE, MTLEFT_REASON_EXCEPT );
							
							//mp掉线导致的终端异常退会，立即恢复呼叫
							CServMsg cMsg;
							cMsg.SetConfId( m_tConf.GetConfId() );
							cMsg.SetNoSrc();
							cMsg.SetMsgBody( NULL, 0 );
							
							InviteUnjoinedMt(cMsg, &tMt);
						}

	// 					tMt = m_ptMtTable->GetMt( byLoop );
	// 
	//                     //zbq [12/26/2009] 特殊处理：删除视频广播源的广播交换；除此，其他可自动被替代。
	//                     if (tMt == GetLocalVidBrdSrc() &&
	//                         tMt.GetMtType() == MT_TYPE_MT)
	//                     {
	//                         TSwitchChannel tSrcSWChn;
	//                         tSrcSWChn.SetSrcMt(tMt);
	// 
	//                         u32 dwMpIp;
	//                         u32 dwSrcIp;
	//                         u16 wMpRecvPort;
	//                         if ( ! g_cMpManager.GetSwitchInfo(tMt, dwMpIp, wMpRecvPort, dwSrcIp) )
	//                         {
	//                             break;
	//                         }
	// 
	//                         tSrcSWChn.SetSrcIp(dwSrcIp);
	//                         tSrcSWChn.SetRcvPort(wMpRecvPort + 0/*只有MODE_VIDEO有广播中转*/);
	// 
	//                         m_ptSwitchTable->ProcBrdSwitch(1, &tSrcSWChn, 2, tMp.GetMpId(), TRUE);
	//                     }
	// 					RemoveJoinedMt( tMt, TRUE, MTLEFT_REASON_EXCEPT );
					}
					else
					{
						if (m_ptMtTable->GetDisconnectDRI(byLoop) != tMp.GetMpId())
						{
							atOnlineMt[byNum] = byLoop;
							byOnlineNum++;
						}
					}
				}
			}
        
			// xsl [9/15/2006]调整桥交换
			AdjustSwitchBridge(tMp.GetMpId(), FALSE);
			
			ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_CONF, "Mp %d disconnected, some mt droped!\n", tMp.GetMpId() );
			
			// xsl [11/14/2006] 清除此mp交换记录
			m_ptSwitchTable->ClearSwitchTable(tMp.GetMpId());
			//[2011/08/30/zhangli]
			m_ptSwitchTable->ClearRtcpSwitchTable(tMp.GetMpId(), tMp.GetIpAddr());

			// zbq [02/14/2007] 清除此mp对应的data信息
			g_cMcuVcApp.m_atMpData[tMp.GetMpId()-1].SetNull();

			//[2011/08/30/zhangli]如果外设在掉链的转发板上，需要重建外设到源的RTCP交换，这里判断不出外设是否在掉链转发板上，所以都建一次
			if (!m_tMixEqp.IsNull())
			{
				for (byLoop = 0; byLoop < byOnlineNum; ++byLoop)
				{
					if (m_ptMtTable->IsMtInMixGrp(atOnlineMt[byLoop]))
					{
						tMt = m_ptMtTable->GetMt(atOnlineMt[byLoop]);
						u8 byMixChl = GetMixChnPos(tMt);
						//StartSwitchToPeriEqp(tMt, 0, m_tMixEqp.GetEqpId(), byMixChl, MODE_AUDIO);
						BuildRtcpSwitchForSrcToDst(m_tMixEqp, tMt, MODE_AUDIO, byMixChl);
					}
				}
			}

			if (!m_tVmpEqp.IsNull())
			{
				TVMPParam_25Mem  tVMPParam   = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
				u8 byMemberNum = tVMPParam.GetMaxMemberNum();
				for (u8 byVmpIndx = 0; byVmpIndx < byMemberNum; ++byVmpIndx)
				{
					TVMPMember tVMPMember = *(tVMPParam.GetVmpMember(byVmpIndx));
					
					if (tVMPMember.IsNull())
					{
						continue;
					}

					for (byLoop = 0; byLoop < byOnlineNum; ++byLoop)
					{
						if (atOnlineMt[byLoop] == tVMPMember.GetMtId())
						{
							tMt = m_ptMtTable->GetMt(atOnlineMt[byLoop]);
							BuildRtcpSwitchForSrcToDst(m_tMixEqp, tMt, MODE_AUDIO, byVmpIndx);
						}
					}
				}
			}
			break;
		}
	default:
		ConfPrint( LOG_LVL_WARNING, MID_MCU_CONF, "Wrong message %u(%s) received in state %u!\n", 
			   pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}

	return;
}

/*====================================================================
    函数名      ：ProcMtAdpDissconnected
    功能        ：处理MtAdp的断链
    算法实现    ：
    引用全局变量：
    输入参数说明：CMessage * const pcMsg, 传入的消息
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/06/08    3.0         胡昌威          创建
====================================================================*/
void CMcuVcInst::ProcMtAdpDissconnected( CMessage * const pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TMtAdpReg tMtAdpReg;
	TMt tMt;
	u8 byLoop;

	//清掉相关终端
 	switch( CurState() )
	{
	case STATE_ONGOING:
		//通知所属适配板的终端掉线
		tMtAdpReg =  *( TMtAdpReg* )cServMsg.GetMsgBody();
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MT, "MtAdp.%d disconnect\n", tMtAdpReg.GetDriId());
		for( byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
		{
			if( m_tConfAllMtInfo.MtInConf( byLoop ) )
			{
				tMt = m_ptMtTable->GetMt( byLoop );
				if( tMtAdpReg.GetDriId() == tMt.GetDriId() )
				{
					//zbq 20091220 不作 重复断链处理
                    if(m_ptMtTable->GetDisconnectDRI(byLoop) == tMtAdpReg.GetDriId())
                    {
                        ConfPrint(LOG_LVL_DETAIL, MID_MCU_MT, "Mtadp %d disconnected while mt.%d ignored to remove due to duplicate!\n",
							tMtAdpReg.GetDriId(), byLoop);
                        continue;
                    }
                    else
                    {
						//zjj20110223 若上级接入板掉线认为上级掉线,结束下级会议,上级会自动再次呼叫
						//对应Bug00047550
						if ( (VCS_CONF == m_tConf.GetConfSource() && 
							 MT_TYPE_MMCU == tMt.GetMtType() &&
							 CONF_CREATE_MT == m_byCreateBy ) 
							 ||
							 ( MCS_CONF == m_tConf.GetConfSource() &&
							 ( MT_TYPE_MMCU == tMt.GetMtType() ||
							 m_ptMtTable->IsNotInvited(tMt.GetMtId()) )
							 )
							)
						{
							ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT,  "MtAdpDissconnected:MMcu(%d)'s Dri.%d disconnect,rls conf\n",
										tMt.GetMtId(),tMtAdpReg.GetDriId() );

// 							RestoreVCConf(VCS_SINGLE_MODE);
//  							m_byCreateBy = CONF_CREATE_MCS;
// 							cServMsg.SetConfId( m_tConf.GetConfId() );
// 							cServMsg.SetConfIdx( m_byConfIdx );
// 							cServMsg.SetEventId(MCUVC_VCSSN_MMCURLSCTRL_CMD);
// 							CMcsSsn::SendMsgToMcsSsn( CInstance::DAEMON, MCUVC_VCSSN_MMCURLSCTRL_CMD,
// 													  cServMsg.GetServMsg(), cServMsg.GetServMsgLen() );
							RemoveMt( tMt,FALSE );
							continue;
						}
						
                        m_ptMtTable->SetDisconnectDRI(byLoop, tMtAdpReg.GetDriId());
						
						RemoveJoinedMt( tMt, FALSE, MTLEFT_REASON_EXCEPT );
						
                        //zbq 20091220 进一步关照一下，防止mp/mtadp交叉 同板卡 误判
                        if (tMtAdpReg.GetDriId() == m_ptMtTable->GetMpId(byLoop) )
                        {
                            m_ptMtTable->SetMpId(byLoop, 0);
                        }
						
                        //mtadp掉线导致的终端异常退会，立即恢复呼叫
                        CServMsg cMsg;
                        cMsg.SetConfId( m_tConf.GetConfId() );
                        cMsg.SetNoSrc();
                        cMsg.SetMsgBody( NULL, 0 );
						
                        InviteUnjoinedMt(cMsg, &tMt);
                    }
					//RemoveJoinedMt( tMt, FALSE, MTLEFT_REASON_EXCEPT );                    
				}
			}
		}

		ConfPrint( LOG_LVL_WARNING, MID_MCU_MT, "Mtadp %d disconnected, some mt droped!\n", tMtAdpReg.GetDriId() );
		
		break;

	default:
		ConfPrint( LOG_LVL_ERROR, MID_MCU_MT, "Wrong message %u(%s) received in state %u!\n", 
			   pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}  

	return;
}

/*====================================================================
    函数名      : GetVmpStylebyMtNum
    功能        : 这是一个更为基础的接口，单纯判断有几个合成成员，出什么最接近的风格
    算法实现    : 
    引用全局变量: 无
    输入参数说明: byMtNum 终端数量
    返回值说明  : 无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    20100330     4.6        pengjie	      create
====================================================================*/
u8 CMcuVcInst::GetVmpStylebyMtNum( u8 byMtNum )
{
    u8 byVmpStyle;
    switch(byMtNum)
	{
	case 0:
	case 1:
		byVmpStyle = VMP_STYLE_ONE;
		break;
	case 2:
		if( VCS_CONF == m_tConf.GetConfSource() &&
			m_cVCSConfStatus.GetCurVCMode() == VCS_GROUPROLLCALL_MODE )
		{
			byVmpStyle = VMP_STYLE_HTWO;	
		}
		else
		{
			byVmpStyle = VMP_STYLE_VTWO;	
		}				
		break;
	case 3:
		byVmpStyle = VMP_STYLE_THREE;
		break;
	case 4:
		byVmpStyle = VMP_STYLE_FOUR;
		break;
	case 5:
	case 6:
		byVmpStyle = VMP_STYLE_SIX;
		break;
	case 7:
		byVmpStyle = VMP_STYLE_SEVEN;
		break;
	case 8:
		byVmpStyle = VMP_STYLE_EIGHT;
		break;
	case 9:
		byVmpStyle = VMP_STYLE_NINE;
		break;
	case 10:
		byVmpStyle = VMP_STYLE_TEN;
		break;
	case 11:
	case 12:
	case 13:
		byVmpStyle = VMP_STYLE_THIRTEEN;
		break;
#if defined(_8KH_) || defined(_8KI_)
	case 14:
	case 15:
		byVmpStyle = VMP_STYLE_FIFTEEN;
		break;
	case 16:
		byVmpStyle = VMP_STYLE_SIXTEEN;
		break;
#else
	case 14:
	case 15:
	case 16:
		byVmpStyle = VMP_STYLE_SIXTEEN;
		break;
#endif
	case 17:
	case 18:
	case 19:
	case 20:
		byVmpStyle = VMP_STYLE_TWENTY;
		break;
	case 21:
	case 22:
	case 23:
	case 24:
	case 25:
		byVmpStyle = VMP_STYLE_TWENTYFIVE;
		break;
	default:
		byVmpStyle = VMP_STYLE_NONE;
		break;
	}
	return byVmpStyle;
}
/*====================================================================
    函数名      : GetVmpDynStyle
    功能        : 得到动态分屏的画面合成方式
    算法实现    : 
    引用全局变量: 无
    输入参数说明: byMtNum 终端数量
    返回值说明  : 无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/03/31    3.0         胡昌威        创建
    05/04/13    3.6         libo          根据需求书调整动态分屏的逻辑
    07/01/30    4.0         顾振华        8000B能力限制
	09/04/21    4.6			薛亮		  根据新VMP进行调整
====================================================================*/
u8 CMcuVcInst::GetVmpDynStyle(u8 byVmpId, u8 byMtNum )
{
#ifdef _MINIMCU_
   
    // guzh [1/30/2007] 能力限制
    u16 wError = 0;
    // guzh [8/1/2007] 根据传入的终端数计算，而非当前所有在线终端
    u8 byVmpCapStyle = CMcuPfmLmt::GetMaxDynVmpStyle(m_tConf, byMtNum, GetMixMtNumInGrp(), wError);

    return byVmpCapStyle;
    
#else   // 8000
	if (!IsValidVmpId(byVmpId))
	{
        return VMP_STYLE_NONE;
	}

    TPeriEqpStatus tPeriEqpStatus;
    g_cMcuVcApp.GetPeriEqpStatus(byVmpId , &tPeriEqpStatus);
    u8 byEqpMaxChl = tPeriEqpStatus.m_tStatus.tVmp.m_byChlNum;
	u8 byVmpSubType = tPeriEqpStatus.m_tStatus.tVmp.m_bySubType;// xliang [2/13/2009] 
	//ConfPrint(LOG_LVL_DETAIL, MID_MCU_MCS, "[GetVmpDynStyle]byEqpMaxChl: %d\n", byEqpMaxChl);

    if ( byEqpMaxChl == 0 || !ISTRUE(tPeriEqpStatus.m_byOnline) )
    {
        return VMP_STYLE_NONE;
    }

    // 获取最大能力的风格
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
	u8 byVmpCapChlNum = MAXNUM_SDVMP_MEMBER; // [12/21/2009 xliang] 8KE写死16
#else
    u8 byVmpCapChlNum = CMcuPfmLmt::GetMaxCapVMPByConfInfo(m_tConf);
    if (byVmpCapChlNum == 0)
    {
        return VMP_STYLE_NONE;
    } 
#endif
	// xliang [2/12/2009] 区分VMP,MPU,MPU2,vpu,8ke,8kh
	if (MPU2_VMP_BASIC == byVmpSubType ||
		MPU2_VMP_ENHACED == byVmpSubType)
	{
		if ( byMtNum > MAXNUM_MPU2VMP_MEMBER ) 
		{
			byMtNum = MAXNUM_MPU2VMP_MEMBER;
		}
	}
	else if (MPU_SVMP == byVmpSubType)
	{
		if ( byMtNum > MAXNUM_MPUSVMP_MEMBER ) 
		{
			byMtNum = MAXNUM_MPUSVMP_MEMBER;
		}
	}
	else
	{
		if ( byMtNum > MAXNUM_SDVMP_MEMBER) 
		{
			byMtNum = MAXNUM_SDVMP_MEMBER;
		}
	}

    u8 byVmpStyle;
	byVmpStyle = GetVmpStylebyMtNum(byMtNum);
    u8 byCurChlNum = GetVmpChlNumByStyle( byVmpStyle );	 //当前风格所需要的通道数
    
    if (byCurChlNum > byVmpCapChlNum || byCurChlNum > byEqpMaxChl)
    {
        byVmpStyle = GetVmpDynStyle(byVmpId, byMtNum - 1);
    }    

#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if ( byVmpStyle == VMP_STYLE_NONE )
	{
		return VMP_STYLE_NONE;
	}
    
	// 此时外设已指定，不需要再根据当前所有外设去找能力最强的外设风格，传入指定外设即可
	// 计算 最大可能满足需要的 VMP支持的 合成风格, zgc, 2008-03-03	
	/*TPeriEqpStatus atEqpStatus[MAXNUM_PERIEQP];
	memset( atEqpStatus, 0, sizeof(atEqpStatus) );
	u8 byIdx = 0;
	u8 byPeriIdLoop = VMPID_MIN;
    u8 byPeriIdMax = VMPID_MAX;
	
	while( byPeriIdLoop <= byPeriIdMax && byIdx < MAXNUM_PERIEQP )
	{
		if( g_cMcuVcApp.IsPeriEqpValid( byPeriIdLoop ) )
		{
			g_cMcuVcApp.GetPeriEqpStatus( byPeriIdLoop, atEqpStatus+byIdx );
			byIdx++;
		}
		byPeriIdLoop++;
	}*/
    u8 byValidVmpNum = 1;//byIdx;

	u8 abyStyleArray[32];
    u8 bySize = 32;
	u8 byTempSize = bySize;
	CMcuPfmLmt::GetSupportedVmpStyles( m_tConf, m_byConfIdx, &tPeriEqpStatus, byValidVmpNum, abyStyleArray, bySize );

	if ( bySize <= byTempSize && bySize > 0 )
	{
		u8 byLop = 0;
		for ( byLop = 0; byLop < bySize; byLop++ )
		{
			// 根据MT数算出的风格可以被VMP支持，则直接返回
			if ( abyStyleArray[byLop] == byVmpStyle )
			{
				return byVmpStyle;
			}
		}

		// 不被支持，则返回支持的最大风格
		return abyStyleArray[bySize-1];
	}
	else
	{
		return VMP_STYLE_NONE;
	}
#endif
/*lint -save -e527*/
    return byVmpStyle;
/*lint -restore*/
#endif   
}

/*=============================================================================
函 数 名： IsVMPSupportVmpStyle
功    能： 指定的画面合成器是否支持某画面合成风格
算法实现： 
全局变量： 
参    数： u8 byStyle
           u8 byEqpId: 判断的vmpId
           u16 &wError 返回的错误码
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/3/31  4.0			许世林                  创建
2006/5/09  4.0          顾振华                  增加设备参数
=============================================================================*/
BOOL32 CMcuVcInst::IsVMPSupportVmpStyle(u8 byStyle, u8 byEqpId, u16 &wError)
{
#ifndef _MINIMCU_
	// 8000A 8000E 8000H 8000I统一严格判断风格支持
	if (!IsValidVmpId(byEqpId))
	{
        ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_VMP, "[IsVMPSupportVmpStyle] Eqp.%d: Is not valid vmpid. return false!\n", byEqpId);
		return FALSE;
	}
    TPeriEqpStatus tPeriEqpStatus;  
    g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tPeriEqpStatus);

	// 判当前会议是否支持此vmp
	BOOL32 bVmpSupportConf = TRUE;
	u8 byVmpSubType = tPeriEqpStatus.m_tStatus.tVmp.m_bySubType;
	u8 byConfMediaType = m_tConf.GetMainVideoMediaType();
	u8 byConfVidFormat = m_tConf.GetMainVideoFormat();
	if( MEDIA_TYPE_H264 == byConfMediaType && (VIDEO_FORMAT_HD720 == byConfVidFormat || VIDEO_FORMAT_HD1080 == byConfVidFormat) )
	{
		// 高清会议，不能使用VPU（VMP）来进行画面合成
		if(byVmpSubType == VMP)
		{
			bVmpSupportConf = FALSE;
		}
		// 主格式勾选HP时,不能使用MPU
		if (emHpAttrb == m_tConf.GetProfileAttrb() && byVmpSubType == MPU_SVMP)
		{
			bVmpSupportConf = FALSE;
		}
	}
	// 对于会议主格式是mp2,h261,不能用mpu
	if( (MEDIA_TYPE_H262 == byConfMediaType || MEDIA_TYPE_H261 == byConfMediaType)
		&& byVmpSubType == MPU_SVMP)
	{
		bVmpSupportConf = FALSE;
	}
	// 4M以上会议不能占用mpu2的B*2合成器
	if (m_tConf.GetBitRate() > 4096 &&
		byVmpSubType == MPU2_VMP_BASIC &&
		BRD_TYPE_MPU2ECARD == g_cMcuAgent.GetMPU2TypeByVmpEqpId(byEqpId))
	{
		bVmpSupportConf = FALSE;
	}

	if (!bVmpSupportConf)
	{
		wError = ERR_MCU_VMPNOSUPPORT;
		return FALSE;
	}

	u8 abyStyleArray[32];
    u8 bySize = 32;
	u8 byTempSize = bySize;
	CMcuPfmLmt::GetSupportedVmpStyles(m_tConf, m_byConfIdx, &tPeriEqpStatus, 1, abyStyleArray, bySize );
	
	if ( bySize <= byTempSize && bySize > 0 )
	{
		u8 byLop = 0;
		for ( byLop = 0; byLop < bySize; byLop++ )
		{
			// 根据MT数算出的风格可以被VMP支持，则直接返回
			if ( abyStyleArray[byLop] == byStyle )
			{
				return TRUE;
			}
		}
	}

	wError = ERR_INVALID_VMPSTYLE;
	return FALSE;
	
#else
	// guzh [1/30/2007] 对于8000B的性能保护
    if ( !CMcuPfmLmt::IsVmpOprSupported( m_tConf, byStyle, m_tConfAllMtInfo.GetLocalJoinedMtNum(), GetMixMtNumInGrp(), wError )  )
    {
        ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_VMP, "[IsVMPSupportVmpStyle] Eqp.%d: IsVmpOprSupported return false. Error=%d !\n", 
                        byEqpId, wError );
        return FALSE;
    }
    return TRUE;
#endif
}

/*=============================================================================
函 数 名： IsMCUSupportVmpStyle
功    能： 整个MCU是否支持某画面合成风格
算法实现： 
全局变量： 
参    数： u8 byStyle
           u8 byEqpId: 支持该风格的VMPID
           u8 byEqpType
           u16 &wError 返回的错误码
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/12/27  4.0         张宝卿                创建
2010/03/01	4.6			薛亮				  增加8000E支持
=============================================================================*/
BOOL32 CMcuVcInst::IsMCUSupportVmpStyle( u8 byStyle, u8 &byEqpId, u8 byEqpType, u16 &wError )
{
#ifdef	_MINIMCU_
    // guzh [7/25/2007] FIXME：8000B只需要找空闲的VMP即可，暂时这么做
    u8 byIdleVMPNum = 0;
    u8 abyIdleVMPId[MAXNUM_PERIEQP];
    memset( &abyIdleVMPId, 0, sizeof(abyIdleVMPId) );
    g_cMcuVcApp.GetIdleVMP( abyIdleVMPId, byIdleVMPNum, sizeof(abyIdleVMPId) );    
    if ( byIdleVMPNum > 0 )
    {
        byEqpId = abyIdleVMPId[0];
    }
    else
    {
        ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_VMP, "[IsMCUSupportVmpStyle] no idle vmp found!\n" );
        return FALSE;        
    }
    
    // guzh [1/30/2007] 对于8000B的性能保护
    if ( !CMcuPfmLmt::IsVmpOprSupported( m_tConf, byStyle, m_tConfAllMtInfo.GetLocalJoinedMtNum(), GetMixMtNumInGrp(), wError )  )
    {
        ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_VMP, "[IsMCUSupportVmpStyle] Eqp.%d: IsVmpOprSupported return false. Error=%d !\n", 
			byEqpId, wError );
        return FALSE;
    }
	
    return TRUE;

#elif defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
	//注：模板启 AUTO VMP的情况，VMPMode 已置为Auto，但HasVmpModule不会置位
	if( CONF_VMPMODE_CTRL == g_cMcuVcApp.GetVMPMode(m_tVmpEqp) 
		&& !m_tConf.GetConfAttrb().IsHasVmpModule()		//模板配定制VMP，VMP mode 已经提前置成非NONE
		)
	{
		//画面合成已经开启，直接返回TRUE
		byEqpId = m_tVmpEqp.GetEqpId();
		return TRUE;
	}
	byEqpId = 0;
    u8 byIdleVmpNum = 0;
    u8 abyEqpId[MAXNUM_PERIEQP];
    memset( &abyEqpId, 0, sizeof(abyEqpId) );
	
    if ( EQP_TYPE_VMP == byEqpType )
    {
        if ( g_cMcuVcApp.GetIdleVMP(abyEqpId, byIdleVmpNum, sizeof(abyEqpId)) )
        {
            for( u8 byIndex = 0; byIndex < byIdleVmpNum; byIndex ++ )
            {
                if ( IsVMPSupportVmpStyle(byStyle, abyEqpId[byIndex], wError) )
                {
                    byEqpId = abyEqpId[byIndex];
                    return TRUE;
                }
            }
        }
    }
	
    wError = ERR_MCU_NOIDLEVMP;
    return FALSE;
#else	//8000A 
	byEqpId = 0;
	
	TPeriEqpStatus atEqpStatus[MAXNUM_PERIEQP];
	memset( atEqpStatus, 0, sizeof(atEqpStatus) );
	u8 byIdx = 0;
	u8 byPeriIdLoop;
    u8 byPeriIdMax;
	
	if( EQP_TYPE_VMP == byEqpType )
	{
		byPeriIdLoop = VMPID_MIN;
        byPeriIdMax = VMPID_MAX;
    }
    else
    {
        byPeriIdLoop = VMPTWID_MIN;
        byPeriIdMax = VMPTWID_MAX;
    }
	
	BOOL32 bSkipBx2 = FALSE;
	TPeriEqpStatus tTmpEqpStatus;
	while( byPeriIdLoop <= byPeriIdMax && byIdx < MAXNUM_PERIEQP )
	{
		if( g_cMcuVcApp.IsPeriEqpValid( byPeriIdLoop ) )
		{
			g_cMcuVcApp.GetPeriEqpStatus( byPeriIdLoop, &tTmpEqpStatus );
			//会议码率大于4M时，不支持抢占Vmp(Basic*2)的合成器
			if (m_tConf.GetBitRate() > 4096 &&
				tTmpEqpStatus.m_tStatus.tVmp.m_bySubType == MPU2_VMP_BASIC &&
				BRD_TYPE_MPU2ECARD == g_cMcuAgent.GetMPU2TypeByVmpEqpId(byPeriIdLoop))
			{
				byPeriIdLoop++;
				bSkipBx2 = TRUE;
				continue;
			}
			atEqpStatus[byIdx] = tTmpEqpStatus;
			byIdx++;
		}
		byPeriIdLoop++;
	}
    u8 byValidVmpNum = byIdx;
	
	if ( !CMcuPfmLmt::IsVmpStyleSupport( m_tConf, m_byConfIdx, 
		atEqpStatus, byValidVmpNum, byStyle, 
		byEqpId ))
    {
		if (bSkipBx2)
		{
			ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_VMP, "[IsMCUSupportVmpStyle] Conf.BitRate:%d. Can't use Vmp(Basic*2).\n", m_tConf.GetBitRate());
		}
		wError = ERR_MCU_ALLIDLEVMP_NO_SUPPORT;
		return FALSE;
    }
	
	// 再次判找到的合成器是否支持传入风格，可能传入的风格不存在或不在该外设的能力列表内
	if (!IsVMPSupportVmpStyle(byStyle, byEqpId, wError))
	{
		return FALSE;
	}

	return TRUE;
#endif
}



/*====================================================================
    函数名      : HasJoinedSpeaker
    功能        : 判断发言者是否与会
    算法实现    : 
    引用全局变量: 无
    输入参数说明: 无
    返回值说明  : 无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/03/31    3.0         胡昌威       创建
====================================================================*/
BOOL32 CMcuVcInst::HasJoinedSpeaker( void )
{
	if( !m_tConf.HasSpeaker() )
		return  FALSE;
    
	TMt	tSpeaker;
	tSpeaker = GetLocalSpeaker();
	if( tSpeaker.GetType() == TYPE_MT )
		return m_tConfAllMtInfo.MtJoinedConf( tSpeaker.GetMtId() );
	else if( tSpeaker.GetType() == TYPE_MCUPERI )
		return TRUE;
	else
		return FALSE;
}

/*====================================================================
    函数名      : HasJoinedChairman
    功能        : 判断主席是否与会
    算法实现    : 
    引用全局变量: 无
    输入参数说明: 无
    返回值说明  : 无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/03/31    3.0         胡昌威       创建
====================================================================*/
BOOL32 CMcuVcInst::HasJoinedChairman( void )
{	
	if( !m_tConf.HasChairman() )
	{
		return  FALSE;
	}
    TMt		tChairman = m_tConf.GetChairman();
    return m_tConfAllMtInfo.MtJoinedConf( tChairman.GetMtId() );
}

/*====================================================================
    函数名      : IsKedaMt
    功能        : 判断终端是否是科达厂商
    算法实现    : 
    引用全局变量: 无
    输入参数说明: const TMt &tMt 要判断的终端
				  BOOL32 bIsNeedLocal 是否将tMt本地化再判断，如果tMt是下级终端，要判断下级mcu是否为科达厂商，需要填TRUE
    返回值说明  : 无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/01/18    4.6         薛亮          创建
	2011/10/21	4.6			zhangli		  修改
====================================================================*/
BOOL32 CMcuVcInst::IsKedaMt(const TMt &tMt, BOOL32 bIsNeedLocal)
{
	if(tMt.IsNull())
	{
		return FALSE;
	}

	if (TYPE_MT != tMt.GetType())
	{
		return FALSE;
	}

	TMt tCurrMt = tMt;
	if (bIsNeedLocal)
	{
		tCurrMt = GetLocalMtFromOtherMcuMt(tMt);
	}

	u8 byManuID = 0;
	TMt tTmpMt = tMt;
	if(tCurrMt.IsLocal())
	{
		byManuID = m_ptMtTable->GetManuId(tCurrMt.GetMtId());
	}
	else
	{
// 		//u8 bySecMcuId = 0;
// 		u8 abyMcuId[MAX_CASCADEDEPTH-1];
// 		memset( &abyMcuId[0],0,sizeof(abyMcuId) );
// 		m_tConfAllMcuInfo.GetMcuIdByIdx( tMt.GetMcuIdx(),&abyMcuId[0] );
// 		byMtId = abyMcuId[0];
		TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tCurrMt.GetMcuIdx());
		if (NULL != ptMcInfo)
		{
			TMtExt *ptMtExt = ptMcInfo->GetMtExt(tTmpMt);
			if ( NULL != ptMtExt )
			{
				byManuID = ptMtExt->GetManuId(); 
			}
		}
	}

	if (MT_MANU_KDC == byManuID || MT_MANU_KDCMCU == byManuID)
	{
		return TRUE;
	}

	ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsKedaMt] mt(%d,%d) is not keda mt or mcu!\n", tMt.GetMcuId(), tMt.GetMtId());
	return FALSE;
}

/*====================================================================
    函数名      : IsNoneKedaMtCanInMpu
    功能        : 判断非科达厂商终端是否能进画面合成
    算法实现    : 8000G，8000A认为发送通道为非H264或者264格式cif分辨率的非keda终端
					不调整分辨率进画面合成也没问题
    引用全局变量: 无
    输入参数说明: 无
    返回值说明  : BOOL32： TRUE表明该非keda终端发送通道为非H264或264格式cif分辨率
	                       FALSE 是keda终端或者发送通道为H264，非cif
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    11/03/09    4.6         周翼亮          创建
====================================================================*/
BOOL32 CMcuVcInst::IsNoneKedaMtCanInMpu(const TMt &tMt )
{
	if( tMt.IsNull() )
	{
		return FALSE;
	}
	if ( IsKedaMt(tMt, TRUE) ) 
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsNoneKedaMtCanInMpu]tMt(%d,%d) is keda mt,return FALSE\n",tMt.GetMcuId(),tMt.GetMtId());
		return FALSE;
	}
	u8 byMediaType = MEDIA_TYPE_NULL;
	u8 byRes = VIDEO_FORMAT_INVALID;
	TLogicalChannel tRevLogicChn ;
	if ( tMt.IsLocal() )//本级非keda终端，直接看其后项通道的格式和分辨率
	{
		if (m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(),LOGCHL_VIDEO,&tRevLogicChn,FALSE)) 
		{
			byMediaType = tRevLogicChn.GetChannelType();
			byRes = tRevLogicChn.GetVideoFormat();
		}
	
	}
	else if ( IsLocalAndSMcuSupMultSpy( tMt.GetMcuId()) )//如果支持多回传
	{
		CRecvSpy cRecvSpyInfo;
		//1 已经回传的终端，CRecvSpy已经存有该终端的能力
		if ( m_cSMcuSpyMana.GetRecvSpy(tMt, cRecvSpyInfo) ) 
		{
			byMediaType = cRecvSpyInfo.GetSimCapset().GetVideoMediaType();
			byRes = cRecvSpyInfo.GetSimCapset().GetVideoResolution();			
		}
		//2 还没开始回传的终端，取级联通道能力比较
		else if ( m_ptMtTable->GetMtLogicChnnl(GetFstMcuIdFromMcuIdx( tMt.GetMcuIdx() ) ,LOGCHL_VIDEO,&tRevLogicChn,FALSE)
				)
		{
			byMediaType = tRevLogicChn.GetChannelType();
			byRes = tRevLogicChn.GetVideoFormat();
		}
	}
	else //单回传下级mt,取级联通道的能力比较
	{
		if ( m_ptMtTable->GetMtLogicChnnl(GetFstMcuIdFromMcuIdx( tMt.GetMcuIdx() ) ,LOGCHL_VIDEO,&tRevLogicChn,FALSE)
			)
		{
			byMediaType = tRevLogicChn.GetChannelType();
			byRes = tRevLogicChn.GetVideoFormat();
		}
	}
	if (byMediaType == MEDIA_TYPE_NULL || VIDEO_FORMAT_INVALID == byRes )//没取到该终端的后向通道能力
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[IsNoneKedaMtCanInMpu]tMt(%d,%d) Recive VideoCap mediatype=MEDIA_TYPE_NULL or videoformat= VIDEO_FORMAT_INVALID,return FALSE\n",tMt.GetMcuId(),tMt.GetMtId());
		return FALSE;
	}
	if ( MEDIA_TYPE_H264 != byMediaType || 
		(MEDIA_TYPE_H264 == byMediaType && VIDEO_FORMAT_CIF == byRes)
		)
	{
		return TRUE;
	}

	return FALSE;
}

/*==============================================================================
函数名    :  IsMtInTvWall
功能      :  判断终端是否在电视墙中
算法实现  :  
参数说明  :  
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2010-02-4					薛亮							create
==============================================================================*/
BOOL32 CMcuVcInst::IsMtInTvWall(const TMt &tMt)
{
	BOOL32 bRet = FALSE;
	u8 byChnnlIdx = 0;
	TPeriEqpStatus tTWStatus;
	TMt tMtTemp;
	for(u8 byTvWallId = TVWALLID_MIN; byTvWallId < TVWALLID_MAX; byTvWallId ++)
	{
		byChnnlIdx = 0;
		if (g_cMcuVcApp.IsPeriEqpConnected(byTvWallId))
		{
			g_cMcuVcApp.GetPeriEqpStatus(byTvWallId, &tTWStatus);
			for(; byChnnlIdx < MAXNUM_PERIEQP_CHNNL; byChnnlIdx ++)
			{
				tMtTemp = tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnnlIdx];
				if ( tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnnlIdx] == tMt
					|| (IsMcu(tMtTemp) && IsSmcuViewMtInMcu(tMt, tMtTemp))
				   )
				{
					bRet = TRUE;		
				}
			}
			
		}
	}


	return bRet;
}

/*==============================================================================
函数名    :  GetVmpSubType
功能      :  获取VMP子类型
算法实现  :  
参数说明  :  
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2010-01-19					薛亮							create
==============================================================================*/
u8	CMcuVcInst::GetVmpSubType( u8 byEqpId )
{
	u8 byVmpSubType = ~0;
	if( byEqpId < VMPID_MIN || byEqpId > VMPID_MAX )
	{
		return byVmpSubType;
	}
	TPeriEqpStatus tPeriEqpStatus; 
	g_cMcuVcApp.GetPeriEqpStatus( byEqpId, &tPeriEqpStatus );
	byVmpSubType = tPeriEqpStatus.m_tStatus.tVmp.m_bySubType;

	return byVmpSubType;
}

/*==============================================================================
函数名    :  IsSelectedbyOtherMt
功能      :  Mt是否被选看
算法实现  :  
参数说明  :  
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2009-3-18					薛亮							create
2010-01-18					薛亮							修改参数
==============================================================================*/
BOOL32 CMcuVcInst::IsSelectedbyOtherMt(const TMt &tSrcMt, u8 byMode)
{
	// [1/19/2010 xliang] 说明:目前该函数可以判断某下级终端是否被本级选看，
	// 但下级终端被下级另一个终端选看，此函数不提供判断。FIXME：该判断需通过另外途径获取
	BOOL32 bSelected = FALSE;
	//TMtStatus tMtStatus;
	TMt tSelectedMt;
	for(u8 byLoop =1; byLoop<= MAXNUM_CONF_MT; byLoop++) 
	{
		if(m_tConfAllMtInfo.MtJoinedConf( byLoop ))
		{
			//m_ptMtTable->GetMtStatus( byLoop, &tMtStatus);
			//tSelectedMt = tMtStatus.GetVideoMt(); //虽然语义对，但是最初置选看源，用的是SetSelectMt，所以用下句
			//tSelectedMt = tMtStatus.GetSelectMt( byMode ); //获取选看源
			tSelectedMt = m_ptMtTable->GetMtSelMtByMode(byLoop, byMode); //获取选看源
			if( !tSelectedMt.IsNull() && ( tSelectedMt == tSrcMt ) )
			{
				bSelected = TRUE;
				break;
			}
		}
	}
	return bSelected;

}

/*==============================================================================
函数名    :  IsSelectedbyOtherMtInMultiCas
功能      :  Mt在多级级联下是否被选看,支持mcu及其上传通道终端被选看
算法实现  :  
参数说明  :  
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2012-1-11				yanghuaizhi							create
==============================================================================*/
BOOL32 CMcuVcInst::IsSelectedbyOtherMtInMultiCas( const TMt &tMt, u8 byMode/* = MODE_VIDEO*/)
{
	BOOL32 bSelected = FALSE;
	if (IsSelectedbyOtherMt(tMt, byMode))
	{
		bSelected = TRUE;
	}

	//是mcu或下级终端时,需考虑上传通道
	if (IsMcu(tMt) || !tMt.IsLocal())
	{
		TMt tRealTmt = tMt;
		if (IsMcu(tRealTmt))
		{
			//找到此MCU最底层上传终端
			tRealTmt = GetSMcuViewMt(tRealTmt, TRUE);
		}
		if (!tRealTmt.IsNull())
		{
			if (IsSelectedbyOtherMt(tRealTmt, byMode))
			{
				bSelected = TRUE;
			}
			TMt tTmpMt = tRealTmt;
			TMt tMcu;
			//有上级mcu
			while (!tTmpMt.IsNull() && !tTmpMt.IsLocal()
				&& (TYPE_MT == tTmpMt.GetType() || TYPE_MCU == tTmpMt.GetType()))
			{
				//判断终端是否是上级mcu的上传通道终端
				tMcu = GetDirectMcuFromMt(tTmpMt);
				if (tRealTmt == GetSMcuViewMt(tMcu, TRUE))
				{
					// 判断mcu是否被选看,若被选看,表示其上传通道终端被选看
					if (IsSelectedbyOtherMt(tMcu, byMode))
					{
						bSelected = TRUE;
					}
				}
				tTmpMt = tMcu;
			}
		}
	}

	return bSelected;
}

/*=============================================================================
函 数 名： GetMixMtNumInGrp
功    能： 得到混音通道内终端个数
算法实现： 
全局变量： 
参    数： void
返 回 值： u8 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/8/4    4.0			许世林                  创建
=============================================================================*/
u8 CMcuVcInst::GetMixMtNumInGrp( void )
{
    u8 byMixMemberNum = 0;
    if ( mcuNoMix == m_tConf.m_tStatus.GetMixerMode() )
    {
        return 0;
    }

    for( u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
    {
        if( m_tConfAllMtInfo.MtJoinedConf( byLoop ) && m_ptMtTable->IsMtInMixGrp( byLoop )  )            
        {
            byMixMemberNum++;
        }
    }

	return byMixMemberNum;
}

/*=============================================================================
函 数 名： GetMaxMixNum
功    能： 获取会议支持的最大混音个数
算法实现： 
全局变量： 
参    数： u8 byMixerId 混音器EQPID
返 回 值： u8  
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/8/19  4.0			许世林                  创建
2010/3/31  4.0			田志勇                 添加参数
2012/2/15  4.7			田志勇                 重新整理
=============================================================================*/
u8  CMcuVcInst::GetMaxMixNum(u8 byMixerId)
{
	u8 byMixMemChnNum = 0;
	TPeriEqpStatus tEqpStatus ;
	if (!g_cMcuVcApp.GetPeriEqpStatus(byMixerId, &tEqpStatus))
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_MIXER, "[GetPeriEqpStatus] GetPeriEqpStatus.%d failed!\n", byMixerId);
		byMixMemChnNum = 0;
	}
	u8 byMixerSubtype = UNKONW_MIXER;
	g_cMcuAgent.GetMixerSubTypeByEqpId(byMixerId,byMixerSubtype);
	switch (byMixerSubtype)
	{
	case APU_MIXER:
		byMixMemChnNum = MAXNUM_APU_MIXING_MEMBER;
		break;
	case EAPU_MIXER:
	case APU2_MIXER:
	case MIXER_8KH:
	case MIXER_8KI:
		{
			byMixMemChnNum = tEqpStatus.m_tStatus.tMixer.m_atGrpStatus[0].m_byMixGrpChnNum;
		}
		break; 
	case MIXER_8KG:
		byMixMemChnNum = MAXNUM_MIXER_CHNNL;
		break;
	default:
		byMixMemChnNum = 0;
		break;
	}
	if (m_tConf.GetConfAttrb().IsSatDCastMode())
	{
		byMixMemChnNum = min(byMixMemChnNum,MAXNUM_MIXERCHNNL_SATDCONF);
	}
	return byMixMemChnNum;
}

/*=============================================================================
    函 数 名： NtfMcsMcuCurListAllConf
    功    能： 通知会控当前MCU的会议信息
    算法实现： 
    全局变量： 
    参    数： CServMsg &cServMsg
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2006/01/05  4.0			万春雷                  创建
    2006/06/22  4.0         顾振华                  支持用户组
    2010/12/31  4.6         liuxu                   修改
=============================================================================*/
BOOL32 CMcuVcInst::NtfMcsMcuCurListAllConf( CServMsg &cServMsg )
{
	TConfInfo  *ptConfInfo = NULL;
	TConfMtTable  tConfMtTable;
	TConfAllMtInfo tConfAllMtInfo;
    
    cServMsg.SetNullConfId();

	for (u8 byConfIdx = MIN_CONFIDX; byConfIdx <= MAX_CONFIDX; byConfIdx++)
	{
		TConfMapData tMapData = g_cMcuVcApp.GetConfMapData(byConfIdx);
		if (tMapData.IsTemUsed())
		{
			TTemplateInfo tTemConf;
			if (g_cMcuVcApp.GetTemplate(byConfIdx, tTemConf))
			{
				g_cMcuVcApp.TemInfo2Msg(tTemConf, cServMsg);
				SendOneMsgToMcs(cServMsg, MCU_MCS_TEMSCHCONFINFO_NOTIF);

                CConfId cConfId = tTemConf.m_tConfInfo.GetConfId();
				NotifyVCSPackInfo(cConfId, cServMsg.GetSrcSsnId());
			}
		}

		if (tMapData.IsValidConf())
		{
			CMcuVcInst *pcMcuVcInst = g_cMcuVcApp.GetConfInstHandle( byConfIdx );
			if (NULL == pcMcuVcInst)
			{
				continue;
			}

			//依次发送每个会议的通知            
			if (NULL != g_cMcuVcApp.GetConfInstHandle(byConfIdx))
			{
				ptConfInfo = &g_cMcuVcApp.GetConfInstHandle(byConfIdx)->m_tConf;

				//获取信息成功，通知会议控制台
				cServMsg.SetConfId( ptConfInfo->GetConfId() );
				cServMsg.SetConfIdx( byConfIdx );                

				if (ptConfInfo->m_tStatus.IsScheduled())
				{
					g_cMcuVcApp.ConfInfoMsgPack(pcMcuVcInst, cServMsg);

					cServMsg.SetConfIdx(byConfIdx);  
					cServMsg.SetConfId(ptConfInfo->GetConfId());

					SendOneMsgToMcs(cServMsg, MCU_MCS_TEMSCHCONFINFO_NOTIF);
				}
				else
				{
					TConfInfoEx tConfInfoEx = g_cMcuVcApp.GetConfInstHandle(byConfIdx)->m_tConfEx;

					cServMsg.SetMsgBody((u8 *)ptConfInfo, sizeof(TConfInfo));
					if(ptConfInfo->HasConfExInfo())
					{
						u8 abyConfInfExBuf[CONFINFO_EX_BUFFER_LENGTH] = {0};
						u16 wPackDataLen = 0;
						PackConfInfoEx(tConfInfoEx,abyConfInfExBuf,wPackDataLen);
						cServMsg.CatMsgBody(abyConfInfExBuf, wPackDataLen);
					}	
					SendOneMsgToMcs(cServMsg, MCU_MCS_CONFINFO_NOTIF);

					//若为VCS会议，则需同时发出vcs特殊状态
					if (VCS_CONF == ptConfInfo->GetConfSource())
					{
						cServMsg.SetMsgBody((u8* )&pcMcuVcInst->m_cVCSConfStatus, sizeof(CBasicVCCStatus));
						SendOneMsgToMcs(cServMsg, MCU_VCS_CONFSTATUS_NOTIF);
					}

					//发给会控终端信息表
					if (g_cMcuVcApp.GetConfAllMtInfo(byConfIdx, &tConfAllMtInfo))
					{
						cServMsg.SetConfId(ptConfInfo->GetConfId());
						cServMsg.SetConfIdx(byConfIdx);
						//cServMsg.SetMsgBody((u8 *)&tConfAllMcuInfo, sizeof(TConfAllMcuInfo));
						//cServMsg.SetMsgBody((u8 *)&tConfAllMtInfo, sizeof(TConfAllMtInfo));
						//SendOneMsgToMcs(cServMsg, MCU_MCS_CONFALLMTINFO_NOTIF);
						//SendAllMtInfoToAllMcs( MCU_MCS_CONFALLMTINFO_NOTIF,cServMsg );
						
						// [11/22/2011 liuxu] 立即发送, 以后考虑缓冲发送, 但是下面的mtlist必须同步缓冲发送
						pcMcuVcInst->SendAllMtInfoToAllMcs( MCU_MCS_CONFALLMTINFO_NOTIF,cServMsg, TRUE );
						pcMcuVcInst->SendConfExtInfoToMcs();
                        pcMcuVcInst->NotifyMcsApplyList();
					}

					//发给会控终端表
					if (!g_cMcuVcApp.GetConfMtTable(byConfIdx, &tConfMtTable))
					{
						continue;
					}
					//本Mcu
					TMcu tMcu;
					cServMsg.SetConfId(ptConfInfo->GetConfId());
					cServMsg.SetConfIdx(byConfIdx);
					tMcu.SetMcu(LOCAL_MCUID);
					tMcu.SetMcuIdx( LOCAL_MCUIDX );
					tMcu.SetEqpId(tConfMtTable.m_byMaxNumInUse);
					cServMsg.SetMsgBody((u8 *)&tMcu, sizeof(tMcu));
					cServMsg.CatMsgBody((u8 *)tConfMtTable.m_atMtExt, 
					                     tConfMtTable.m_byMaxNumInUse * sizeof(TMtExt));
					
					for( u8 byIdx = 0; byIdx < tConfMtTable.m_byMaxNumInUse; byIdx++ )
					{
						ConfPrint(LOG_LVL_WARNING,MID_MCU_MCS,"MtId:%d,IP:%s\n",byIdx+1,StrOfIP(tConfMtTable.m_atMtExt[byIdx].GetIPAddr()));
					}

					for ( u8 byMtId = 1; byMtId <= tConfMtTable.m_byMaxNumInUse; byMtId ++ )
					{
						TMtAlias tMtAlias;
						if(!tConfMtTable.GetMtAlias( byMtId, mtAliasTypeH320Alias, &tMtAlias ))
						{
							if(!tConfMtTable.GetMtAlias( byMtId, mtAliasTypeH320ID, &tMtAlias ))
							{
								if(!tConfMtTable.GetMtAlias( byMtId, mtAliasTypeH323ID, &tMtAlias ))
								{
									if(!tConfMtTable.GetMtAlias( byMtId, mtAliasTypeE164, &tMtAlias ))
									{
										if( !tConfMtTable.GetMtAlias( byMtId, mtAliasTypeTransportAddress, &tMtAlias ) )
										{
											tConfMtTable.GetDialAlias( byMtId, &tMtAlias );
										}
									}
								}
							}		
						}
						
						cServMsg.CatMsgBody( (u8*)tMtAlias.m_achAlias, VALIDLEN_ALIAS + MAXLEN_CONFNAME );
					}

					// [11/22/2011 liuxu] 立即发送, 以后考虑缓冲发送
					SendOneMsgToMcs(cServMsg, MCU_MCS_MTLIST_NOTIF); // 发本级，不用向mtadp发消息 [pengguofeng 7/2/2013]

					//zjj20100125mcs发送所有上级和下级的别名
					TMt tMt;
					for( u8 byLoop1 = 1; byLoop1 <= MAXNUM_CONF_MT; byLoop1++ )
					{
						tMt = pcMcuVcInst->m_ptMtTable->GetMt( byLoop1 );
						if( !tMt.IsNull() &&
							( MT_TYPE_MMCU == pcMcuVcInst->m_ptMtTable->GetMtType(byLoop1) ||
								MT_TYPE_SMCU == pcMcuVcInst->m_ptMtTable->GetMtType(byLoop1)
								)
							)
						{
							pcMcuVcInst->SendMtAliasToMcs( tMt );
						}
						
					}

					//其它Mcu
					// 下级MCU，向mtadp查询所有 [pengguofeng 7/2/2013]
					LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_MCS, "[NtfMcsMcuCurListAllConf]conf.%d SendMtListToMcs 65535 vc curstate:%d\n", byConfIdx, pcMcuVcInst->CurState());
					pcMcuVcInst->SendMtListToMcs(INVALID_MCUIDX);
					/*
					u16 wMcuIdx = 0,wMMcuIdx = 0;
					TConfMtInfo *ptConfMtInfo = NULL;
					for (u16 wLoop = 0; wLoop < tConfAllMtInfo.GetMaxMcuNum(); wLoop++)
					{
						if (tConfAllMtInfo.GetMtInfo(wLoop).IsNull())
						{
							continue;
						}

						ptConfMtInfo = tConfAllMtInfo.GetMtInfoPtr(wLoop);
						if (NULL == ptConfMtInfo)
						{
							continue;
						}

						wMcuIdx = ptConfMtInfo->GetMcuIdx();
						if (!IsValidMcuId(wMcuIdx))
						{
							continue;
						}

						TConfMcInfo *ptInfo = pcMcuVcInst->m_ptConfOtherMcTable->GetMcInfo(wMcuIdx);
						if (NULL == ptInfo)
						{
							continue;
						}

						tMcu.SetNull();
						tMcu.SetMcuIdx(wMcuIdx);

						wMMcuIdx = 0;
						if( !tConfAllMtInfo.m_tMMCU.IsNull() ) 
						{
							wMMcuIdx = pcMcuVcInst->GetMcuIdxFromMcuId( tConfAllMtInfo.m_tMMCU.GetMtId() );
						}

                        // guzh [5/18/2007] 这里不在实例中，要访问上级MCU，采用tConfAllMtInfo.m_tMMCU
                        if ( !g_cMcuVcApp.IsShowMMcuMtList() 
							&& !tConfAllMtInfo.m_tMMCU.IsNull() 
							&& wMcuIdx == wMMcuIdx )
                        {
							ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MMCU, "[NtfMcsMcuCurListAllConf] ignore mmcu's Mtlist!\n");
                            // guzh [4/30/2007] 上级MCU列表过滤
                            continue;
                        }
                        
						cServMsg.SetMsgBody((u8*)&tMcu, sizeof(tMcu));
						for (s32 nLoop = 0; nLoop < MAXNUM_CONF_MT; nLoop++)
						{
							if (ptInfo->m_atMtStatus[nLoop].IsNull() || 
								0 == ptInfo->m_atMtStatus[nLoop].GetMtId()) //自己
							{
								continue;
							}

							cServMsg.CatMsgBody((u8 *)&(ptInfo->m_atMtExt[nLoop]), sizeof(TMtExt));
						}
						
						// [11/22/2011 liuxu] 立即发送, 以后考虑缓冲发送
						SendOneMsgToMcs(cServMsg, MCU_MCS_MTLIST_NOTIF);
					}
					*/
				}
			}
		}
	}
	
	//回应答
	SendOneMsgToMcs(cServMsg, MCU_MCS_LISTALLCONF_ACK);

//当前消息处理在daemon实例，发言申请列表无效
//	NotifyMcsApplyList();

	return TRUE;
}

/*=============================================================================
    函 数 名： SendOneMsgToMcs
    功    能： 发送一条消息给会控 所有MCS或指定会控
    算法实现： 
    全局变量： 
    参    数： CServMsg &cServMsg, 
	           u16 wEvent
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2006/01/05  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcInst::SendOneMsgToMcs( CServMsg &cServMsg, u16 wEvent )
{
	if (IsMcCmdFromThisMcu(cServMsg))
	{
		SendReplyBack(cServMsg, wEvent);
		
	}
	else
	{
		SendMsgToAllMcs(wEvent, cServMsg);
	}
	return TRUE;
}


/*=============================================================================
    函 数 名： GetInstState
    功    能： 主备数据倒换时 获取 实例状态机 状态
				先把confidx,confid也备过去，防止会议数据备一半的时候主板重启
    算法实现： 
    全局变量： 
    参    数： [OUT]  u8 &byState //STATE_IDLE STATE_SCHEDULED STATE_ONGOING
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcInst::GetInstStateAndConfIdIdx(u8 &byState ,CConfId& cCondId,u8& byConfIdx)
{
	byState = (u8)CurState();
	byConfIdx = m_byConfIdx;
	cCondId = m_tConf.GetConfId();
	//zyl 20121116 可能前面是备板，切为主板后马上备份数据，而自己的会议还没收到前面主板发过来的数据
	if ( IsWaitMsConfData() )
	{
		StaticLog("Error:current WaitMsConfData,this instance state shouldnot send to slave mcu,confidx:%d\n",byConfIdx);
		byState = STATE_IDLE;
		byConfIdx = 0;
		cCondId.SetNull();
	}
	return TRUE;
}

/*=============================================================================
    函 数 名： SetInstStateAndConfIdx
    功    能： 主备数据倒换时 恢复 实例状态机 状态
	           同时同步公用区数据
			   先把confidx和confId也备过去，防止会议数据备一半的时候主板重启
    算法实现： 
    全局变量： 
    参    数： [OUT]  u8 byState //STATE_IDLE STATE_SCHEDULED STATE_ONGOING
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcInst::SetInstStateAndConfIdIdx(const u8& byState ,const CConfId & cConfId, const u8& byConfIdx)
{
    //  xsl [3/3/2006] STATE_WAITFOR 为中间状态，不同步
	if (byState > STATE_ONGOING || STATE_WAITFOR == byState)
	{
		return FALSE;
	}

	if (STATE_IDLE == byState)
	{
		//若原有实例状态机不为STATE_IDLE，则释放会议
		if (STATE_IDLE != CurState())
		{
			//在外面已统一清除
			//g_cMcuVcApp.RemoveConf( m_byConfIdx, FALSE );

			DeleteAlias();
			
			//清空会议实例
			ClearVcInst();
		}
	}
	else
	{
		//若原有实例状态机为 STATE_IDLE 或 STATE_WAITFOR，则保存会议
        //说明：STATE_IDLE    为固有状态
        //      STATE_WAITFOR 为等待mp上线时即时会议下附带强置的状态
		if (STATE_IDLE == CurState() || STATE_WAITFOR == CurState())
		{
			//分配内存
			if (NULL == m_ptMtTable)
			{
				m_ptMtTable = new TConfMtTable;
				if (NULL == m_ptMtTable)
				{
					return FALSE;
				}
			}
//             if (NULL == m_pcBasMgr)
//             {
//                 m_pcBasMgr = new CBasMgr;
//                 if ( NULL == m_pcBasMgr )
//                 {
//                     MCU_SAFE_DELETE(m_ptMtTable)
//                     return FALSE;
//                 }
//             }
			BOOL32 bNewBasMgrSuc = NewMcuBasMgr();
			if (!bNewBasMgrSuc)
			{
				MCU_SAFE_DELETE(m_ptMtTable)
				return FALSE;
			}
// 			if (NULL == m_pcMcuBasMgr)
//             {
//                 m_pcMcuBasMgr = new CMcuBasMgr;
//                 if ( NULL == m_pcMcuBasMgr )
//                 {
//                     MCU_SAFE_DELETE(m_ptMtTable)
// 					return FALSE;
//                 }
//             }
			if (STATE_ONGOING == byState)
			{
				if (NULL == m_ptSwitchTable)
				{
					m_ptSwitchTable = new TConfSwitchTable;
					if (NULL == m_ptSwitchTable)
					{
                        //MCU_SAFE_DELETE(m_pcBasMgr)
						DeleteMcuBasMgr();
						MCU_SAFE_DELETE(m_ptMtTable)
						return FALSE;
					}
				}
				if (NULL == m_ptConfOtherMcTable)
				{
					m_ptConfOtherMcTable = new TConfOtherMcTable;
					if (NULL == m_ptConfOtherMcTable)
					{
						MCU_SAFE_DELETE(m_ptMtTable)
                        //MCU_SAFE_DELETE(m_pcBasMgr)
						DeleteMcuBasMgr();
						MCU_SAFE_DELETE(m_ptSwitchTable)
						return FALSE;
					}
					m_ptConfOtherMcTable->Init();
				}
			}
		}

		if ( byConfIdx >= MIN_CONFIDX && byConfIdx <= MAX_CONFIDX )
		{
			m_byConfIdx = byConfIdx;
		}
		if (!cConfId.IsNull())
		{
			m_tConf.SetConfId(cConfId);
		}
		g_cMcuVcApp.AddConf( this, FALSE );
		//主备如果主板发过来的instance状态非idle，则为ongoing何schedule(wait_for前面返回了)
		//起等待会议数据timer,9s,超时的话则把会议结束
		SetTimer(MCUVC_WAITMSCONFDATA_TIMER,9000);
		SetWaitMsConfData( TRUE );
	}
	NEXTSTATE( byState );

	return TRUE;
}

/*=============================================================================
    函 数 名： HangupInstTimer
    功    能： 主备数据倒换时 暂停 轮循、预约会议等会议定时器（非STATE_IDLE实例）
    算法实现： 
    全局变量： 
    参    数： void
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcInst::HangupInstTimer( void )
{
	if (STATE_IDLE == CurState())
	{
		return FALSE;
	}
	return TRUE;
}

/*=============================================================================
    函 数 名： ResumeInstTimer
    功    能： 主备数据倒换时 恢复 轮循、预约会议等会议定时器 （非STATE_IDLE实例）
    算法实现： 
    全局变量： 
    参    数： void
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcInst::ResumeInstTimer( void )
{
	if (STATE_IDLE == CurState())
	{
		return FALSE;
	}
	return TRUE;
}

/*=============================================================================
    函 数 名： GetConfMtTableData
    功    能： 主备数据倒换时 获取 会议终端表 信息
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
               [OUT]     u32 &dwOutBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcInst::GetConfMtTableData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen )
{
	if (STATE_IDLE == CurState() || NULL == m_ptMtTable)
	{
		return FALSE;
	}
	if (NULL == pbyBuf || dwInBufLen < sizeof(TConfMtTable))
	{
		return FALSE;
	}
	//可对终端列表进行pack处理，
	memcpy(pbyBuf, (s8*)m_ptMtTable, sizeof(TConfMtTable));
	dwOutBufLen = sizeof(TConfMtTable);

	return TRUE;
}

/*=============================================================================
    函 数 名： SetTConfMtTableData
    功    能： 主备数据倒换时 恢复 会议终端表 信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcInst::SetConfMtTableData( u8 *pbyBuf, u32 dwInBufLen )
{
	if (STATE_IDLE == CurState() || NULL == m_ptMtTable)
	{
		return FALSE;
	}
	//允许大于---	
	if (NULL == pbyBuf || dwInBufLen < sizeof(TConfMtTable)) //!= sizeof(TConfMtTable))
	{
		return FALSE;
	}
	//可对终端列表进行pack处理，
	memcpy((s8*)m_ptMtTable, pbyBuf, sizeof(TConfMtTable));

	return TRUE;
}

/*=============================================================================
    函 数 名： GetConfSwitchTableData
    功    能： 主备数据倒换时 获取 会议交换表 信息
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
               [OUT]     u32 &dwOutBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcInst::GetConfSwitchTableData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen )
{
	if (STATE_IDLE == CurState() || NULL == m_ptSwitchTable)
	{
		return FALSE;
	}
	if (NULL == pbyBuf || dwInBufLen < sizeof(TConfSwitchTable))
	{
		return FALSE;
	}
	//可对列表进行pack处理，
	memcpy(pbyBuf, (s8*)m_ptSwitchTable, sizeof(TConfSwitchTable));
	dwOutBufLen = sizeof(TConfSwitchTable);

	return TRUE;
}

/*=============================================================================
    函 数 名： SetConfSwitchTableData
    功    能： 主备数据倒换时 恢复 会议交换表 信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcInst::SetConfSwitchTableData( u8 *pbyBuf, u32 dwInBufLen )
{
	if (STATE_IDLE == CurState() || NULL == m_ptSwitchTable)
	{
		return FALSE;
	}
	if (NULL == pbyBuf || dwInBufLen < sizeof(TConfSwitchTable))
	{
		return FALSE;
	}

	/*20111130 zjl 非8000B下，0槽的MPC广播交换保存在交换表的索引 32-1 = 31 上
							  1槽的MPC广播交换保存在交换表的索引 16-1 = 15 上
							  主备倒换数据时，这块信息各自独立，不能修改
	*/
#ifndef _MINIMCU_
	TSwitchTable tBrd16Table = *(m_ptSwitchTable->GetSwitchTable(MCU_BOARD_MPC));
	TSwitchTable tBrd32Table = *(m_ptSwitchTable->GetSwitchTable(MCU_BOARD_MPCD));
#endif
	//可对列表进行pack处理，
	memcpy((s8*)m_ptSwitchTable, pbyBuf, sizeof(TConfSwitchTable));
	
#ifndef _MINIMCU_
	m_ptSwitchTable->SetSwitchTable(MCU_BOARD_MPC,  &tBrd16Table);
	m_ptSwitchTable->SetSwitchTable(MCU_BOARD_MPCD, &tBrd32Table);
#endif
	return TRUE;
}

/*=============================================================================
    函 数 名： GetConfOtherMcTableData
    功    能： 主备数据倒换时 获取 其它Mc终端列表 信息
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
               [OUT]     u32 &dwOutBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcInst::GetConfOtherMcTableData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen )
{
	if (STATE_IDLE == CurState() || NULL == m_ptConfOtherMcTable)
	{
		return FALSE;
	}
	if (NULL == pbyBuf)
	{
		return FALSE;
	}
	u16  wOtherMcuNum = 0;
	
	TConfMcInfo *ptConfMcInfo = NULL;
	for (u16 wValidMcuLoop = 0; wValidMcuLoop < TConfOtherMcTable::GetMaxMcuNum(); wValidMcuLoop++)
	{
		ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(wValidMcuLoop);
		if (NULL == ptConfMcInfo)
		{
			continue;
		}

		if (IsValidSubMcuId(ptConfMcInfo->GetMcuIdx()))
		{
			wOtherMcuNum += 1;
		}
	}

	//20101022_tzy 数据长度检查，检验当前级联列表信息长度是否超出最大传送长度
	if (dwInBufLen <  (sizeof(TMSVcOtherMcuState) + wOtherMcuNum * sizeof(TConfMcInfo)))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[GetConfOtherMcTableData]InBufLen(%d) less than reallen(%d)\n", 
			      dwInBufLen, (sizeof(TMSVcOtherMcuState) + wOtherMcuNum*sizeof(TConfMcInfo)));
		return FALSE;
	}	

	wOtherMcuNum = 0;
	TMSVcOtherMcuState *ptOtherMcuState = (TMSVcOtherMcuState*)pbyBuf;
	u8 *pbyMcuDataBuf = pbyBuf+sizeof(TMSVcOtherMcuState);
	memset(pbyBuf, 0, sizeof(TMSVcOtherMcuState));
	
	for (u16 wLoop = 0; wLoop < TConfOtherMcTable::GetMaxMcuNum(); wLoop++)
	{
		ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(wLoop);
		if (NULL == ptConfMcInfo)
		{
			continue;
		}

		if ( !IsValidSubMcuId(ptConfMcInfo->GetMcuIdx()))
		{
			ptOtherMcuState->m_abyOnline[wLoop] = 0;
		}
		else
		{
			//可对终端列表进行pack处理，
			ptOtherMcuState->m_abyOnline[wLoop] = 1;
			//TConfMcInfo *ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(wLoop);
			if (ptConfMcInfo)
			{
				memcpy(pbyMcuDataBuf, (u8*)ptConfMcInfo, sizeof(TConfMcInfo));
				pbyMcuDataBuf += sizeof(TConfMcInfo);
				wOtherMcuNum += 1;
			}
		}
	}
	
	dwOutBufLen = sizeof(TMSVcOtherMcuState) + wOtherMcuNum*sizeof(TConfMcInfo);

	return TRUE;
}

/*=============================================================================
    函 数 名： SetConfOtherMcTableData
    功    能： 主备数据倒换时 恢复 其它Mc终端列表 信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcInst::SetConfOtherMcTableData( u8 *pbyBuf, u32 dwInBufLen )
{
	if (STATE_IDLE == CurState() || NULL == m_ptConfOtherMcTable)
	{
		return FALSE;
	}
	if (NULL == pbyBuf || dwInBufLen < sizeof(TMSVcOtherMcuState))
	{
		return FALSE;
	}

	TMSVcOtherMcuState *ptOtherMcuState = (TMSVcOtherMcuState*)pbyBuf;

	// liuxu, 增加pbyMcuDataBuf的计数处理, 保证pbyBuf不越界
	u32 dwUsedBuf = sizeof(TMSVcOtherMcuState);
	u8 *pbyMcuDataBuf = pbyBuf + dwUsedBuf;

	// TConfMcInfo的大小
	const u16 wMcInfoSize = sizeof(TConfMcInfo);

	//可对终端列表进行pack处理，
	for (u16 wLoop = 0; wLoop < TConfOtherMcTable::GetMaxMcuNum(); wLoop++)
	{
		if (1 == ptOtherMcuState->m_abyOnline[wLoop])
		{
			if ((dwInBufLen - dwUsedBuf) < wMcInfoSize)
			{
				// liuxu, 是否需要返回FALSE?
				break;
			}

			// 设置MCinfo
			m_ptConfOtherMcTable->SetMcInfo(wLoop, *((TConfMcInfo *)pbyMcuDataBuf));
			
			// 增加计数
			dwUsedBuf += wMcInfoSize;
			pbyMcuDataBuf = pbyBuf + dwUsedBuf;
		}
		else
		{
			if (NULL != m_ptConfOtherMcTable->GetMcInfo(wLoop))
			{
				m_ptConfOtherMcTable->GetMcInfo(wLoop)->SetNull();
			}
		}
	}
	
	return TRUE;
}

/*=============================================================================
    函 数 名： GetInstOtherData
    功    能： 主备数据倒换时 获取 除上述动态分配的列表信息外的其他需同步 信息
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
			   [OUT]     u32 &dwOutBufLen
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcInst::GetInstOtherData( u8 *pbyBuf, u32 dwInBufLen, u32 &dwOutBufLen )
{
	if (STATE_IDLE == CurState())
	{
		return FALSE;
	}
	
	dwOutBufLen  = 0;
	u32 dwOutLen = OprInstOtherData(pbyBuf, dwInBufLen, TRUE);
	if (0 == dwOutLen)
	{
		return FALSE;
	}

	dwOutBufLen = dwOutLen;
	return TRUE;
}

/*=============================================================================
    函 数 名： SetInstOtherData
    功    能： 主备数据倒换时 恢复 除上述动态分配的列表信息外的其他需同步 信息
    算法实现： 
    全局变量： 
    参    数： [IN]  u8 *pbyBuf
               [IN]  u32 dwInBufLen
               [IN]  BOOL32 bResumeTimer
    返 回 值： BOOL32 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
BOOL32 CMcuVcInst::SetInstOtherData( u8 *pbyBuf, u32 dwInBufLen, BOOL32 bResumeTimer )
{
	if (STATE_IDLE == CurState())
	{
		StaticLog("[SetInstOtherData]Error State:%d\n",CurState());
		return FALSE;
	}

	if (0 == OprInstOtherData(pbyBuf, dwInBufLen, FALSE))
	{
		StaticLog("[SetInstOtherData]Error OprInstOtherData return 0\n");
		return FALSE;
	}
	//zyl 20121116 清掉等待会议数据timer和状态
	KillTimer(MCUVC_WAITMSCONFDATA_TIMER);
	SetWaitMsConfData( FALSE );

	//是否恢复会议实例涉及的定时器，只在第一次主备倒换时恢复
	if (bResumeTimer)
	{
		//即时会议 或者 预约会议
		if (STATE_ONGOING == CurState())
		{
			//恢复 即时会议自动结束时钟
			if (0 != m_tConf.GetDuration())
			{
				KillTimer(MCUVC_ONGOING_CHECK_TIMER);
				SetTimer(MCUVC_ONGOING_CHECK_TIMER, TIMESPACE_ONGOING_CHECK);
			}

			//恢复 自动呼叫终端时钟
			KillTimer(MCUVC_INVITE_UNJOINEDMT_TIMER);
			SetTimer(MCUVC_INVITE_UNJOINEDMT_TIMER, 1000*m_tConf.m_tStatus.GetCallInterval());
			
			//恢复 MCU视频源变更检测时钟
			KillTimer(MCUVC_MCUSRC_CHECK_TIMER);
			SetTimer(MCUVC_MCUSRC_CHECK_TIMER, TIMESPACE_MCUSRC_CHECK);
			
// 			//恢复 VMP主席更随变更检测时钟
// 			if (0)
// 			{
// 				KillTimer(MCUVC_CHANGE_VMPCHAN_CHAIRMAN_TIMER);
// 				SetTimer(MCUVC_CHANGE_VMPCHAN_CHAIRMAN_TIMER, TIMESPACE_CHANGEVMPPARAM, VMP_MEMBERTYPE_CHAIRMAN);
// 			}
			
// 			//恢复 VMP发言人更随变更检测时钟
// 			if (0)
// 			{
// 				KillTimer(MCUVC_CHANGE_VMPCHAN_SPEAKER_TIMER);
// 				SetTimer(MCUVC_CHANGE_VMPCHAN_SPEAKER_TIMER, TIMESPACE_CHANGEVMPPARAM, VMP_MEMBERTYPE_SPEAKER);
// 			}

			if (POLL_STATE_NORMAL == m_tConf.m_tStatus.GetPollState())
			{
				KillTimer(MCUVC_POLLING_CHANGE_TIMER);
				SetTimer(MCUVC_POLLING_CHANGE_TIMER, 1000*1);
			}

            //电视墙多通道轮询定时器恢复
			for (u8 byIdx = 0; byIdx < MAXNUM_TVWALL_CHNNL; byIdx++)
			{
				if (POLL_STATE_NORMAL == m_tTWMutiPollParam.m_tTWPollParam[byIdx].GetPollState())
				{
					KillTimer(MCUVC_TWPOLLING_CHANGE_TIMER + byIdx);
                    SetTimer( MCUVC_TWPOLLING_CHANGE_TIMER + byIdx, 1000*1, byIdx);
				}	
			}

			//电视墙批量轮询定时器恢复
			if (POLL_STATE_NORMAL == m_tHduBatchPollInfo.GetStatus())
			{
				KillTimer(MCUVC_HDUBATCHPOLLI_CHANGE_TIMER);
				SetTimer(MCUVC_HDUBATCHPOLLI_CHANGE_TIMER, 1000);
			}
			// fxh
			if (VCS_POLL_START == m_cVCSConfStatus.GetChairPollState())
			{
				KillTimer(MCUVC_VCS_CHAIRPOLL_TIMER);
				SetTimer(MCUVC_VCS_CHAIRPOLL_TIMER, 1000*m_cVCSConfStatus.GetPollIntval());
			}

            // guzh [4/17/2007] 
            // 自动录像的定时器采用绝对定时
		}
		else
		{
			//恢复 预约会议检测时钟
			time_t nTimeNow = time(NULL);
			long lTimerInterval = TIMESPACE_SCHEDULED_CHECK;
			if ( m_tConf.IsCircleScheduleConf() )
			{
				time_t nNextStartTime;
				m_tConfEx.GetNextStartTime().GetTime(nNextStartTime);
				if ( (nTimeNow + 60) > nNextStartTime )
				{
					lTimerInterval = ( nNextStartTime - nTimeNow )*1000;
				}
			
			}
			else
			{
				if ( (nTimeNow + 60) > m_tConf.GetStartTime())
				{
					lTimerInterval = ( m_tConf.GetStartTime() - nTimeNow )*1000;
				
				}
			}
			SetTimer( MCUVC_SCHEDULED_CHECK_TIMER, lTimerInterval );
		}
	}

	return TRUE;
}

/*=============================================================================
    函 数 名： OprInstOtherData
    功    能： 主备数据倒换时 同步 除上述动态分配的列表信息外的其他需同步 数据
	           由于同步的主从MCU应用环境一致，同步的数据结构暂不考虑紧凑压栈问题：Pack Ingore
    算法实现： 
    全局变量： 
    参    数： [IN/OUT]  u8 *pbyBuf
               [IN]      u32 dwInBufLen
               [IN]      BOOL32 bGet TRUE －获取 FALSE - 恢复 
    返 回 值： u32  同步的数据总长度
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
u32 CMcuVcInst::OprInstOtherData( u8 *pbyBuf, u32 dwInBufLen, BOOL32 bGet )
{
	u32 dwOtherDataLen = GetInstOtherDataLen();
	//允许大于---
	if (NULL == pbyBuf || dwInBufLen < dwOtherDataLen)
	{
		StaticLog("[OprInstOtherData] dwInBufLen:%d,dwOtherDataLen:%d\n",dwInBufLen,dwOtherDataLen);
		return 0;
	}

	if (bGet)
	{
		memcpy(pbyBuf, &m_swCurSatMtNum, sizeof(m_swCurSatMtNum));	
		pbyBuf += sizeof(m_swCurSatMtNum);

		memcpy(pbyBuf, &m_tConf, sizeof(m_tConf));
		pbyBuf += sizeof(m_tConf);

		//zhouyiliang 20120109 v4r7的主备修改,增加能力集勾选备份
		memcpy(pbyBuf, &m_tConfEx, sizeof(m_tConfEx));
		pbyBuf += sizeof(m_tConfEx);

		memcpy(pbyBuf, &m_tConfAllMtInfo, sizeof(m_tConfAllMtInfo));
		pbyBuf += sizeof(m_tConfAllMtInfo);

		memcpy(pbyBuf, &m_tConfProtectInfo, sizeof(m_tConfProtectInfo));
		pbyBuf += sizeof(m_tConfProtectInfo);

		memcpy(pbyBuf, &m_tConfPollParam, sizeof(m_tConfPollParam));
		pbyBuf += sizeof(m_tConfPollParam);

		memcpy(pbyBuf, &m_tTWMutiPollParam, sizeof(m_tTWMutiPollParam));
		pbyBuf += sizeof(m_tTWMutiPollParam);

		memcpy(pbyBuf, &m_tConfEqpModule, sizeof(m_tConfEqpModule));
		pbyBuf += sizeof(m_tConfEqpModule);

		TMt tSrc = GetVidBrdSrc();
		memcpy(pbyBuf, &tSrc, sizeof(tSrc));
		pbyBuf += sizeof(tSrc);

		tSrc = GetAudBrdSrc();
		memcpy(pbyBuf, &tSrc, sizeof(tSrc));
		pbyBuf += sizeof(tSrc);

		memcpy(pbyBuf, &m_tDoubleStreamSrc, sizeof(m_tDoubleStreamSrc));
		pbyBuf += sizeof(m_tDoubleStreamSrc);

		memcpy(pbyBuf, &m_tH239TokenOwnerInfo, sizeof(m_tH239TokenOwnerInfo));
		pbyBuf += sizeof(m_tH239TokenOwnerInfo);
		
		memcpy(pbyBuf, &m_tVmpEqp, sizeof(m_tVmpEqp));
		pbyBuf += sizeof(m_tVmpEqp);

		memcpy(pbyBuf, &m_tVmpTwEqp, sizeof(m_tVmpTwEqp));
		pbyBuf += sizeof(m_tVmpTwEqp);

		memcpy(pbyBuf, &m_tMixEqp, sizeof(m_tMixEqp));
		pbyBuf += sizeof(m_tMixEqp);

		memcpy(pbyBuf, &m_tRecEqp, sizeof(m_tRecEqp));
		pbyBuf += sizeof(m_tRecEqp);

		memcpy(pbyBuf, &m_tPlayEqp, sizeof(m_tPlayEqp));
		pbyBuf += sizeof(m_tPlayEqp);

		memcpy(pbyBuf, &m_tPlayEqpAttrib, sizeof(m_tPlayEqpAttrib));
		pbyBuf += sizeof(m_tPlayEqpAttrib);

		memcpy(pbyBuf, &m_tPlayFileMediaInfo, sizeof(m_tPlayFileMediaInfo));
		pbyBuf += sizeof(m_tPlayFileMediaInfo);

		memcpy(pbyBuf, &m_tRecPara, sizeof(m_tRecPara));
		pbyBuf += sizeof(m_tRecPara);

		memcpy(pbyBuf, &m_tPlayFileHpAttrib, sizeof(m_tPlayFileHpAttrib));
		pbyBuf += sizeof(m_tPlayFileHpAttrib);
		
		memcpy(pbyBuf, &m_byMixGrpId, sizeof(m_byMixGrpId));
		pbyBuf += sizeof(m_byMixGrpId);

		memcpy(pbyBuf, &m_byRecChnnl, sizeof(m_byRecChnnl));
		pbyBuf += sizeof(m_byRecChnnl);

		memcpy(pbyBuf, &m_byPlayChnnl, sizeof(m_byPlayChnnl));
		pbyBuf += sizeof(m_byPlayChnnl);

		memcpy(pbyBuf, &m_wVidBasBitrate, sizeof(m_wVidBasBitrate));
		pbyBuf += sizeof(m_wVidBasBitrate);

		memcpy(pbyBuf, &m_wBasBitrate, sizeof(m_wBasBitrate));
		pbyBuf += sizeof(m_wBasBitrate);

		//memcpy(pbyBuf, m_awVMPBrdBitrate, sizeof(m_awVMPBrdBitrate));	// xliang [8/5/2009] 
		//pbyBuf += sizeof(m_awVMPBrdBitrate);
        // guzh [8/28/2007] 其实MINIMCU 没有主备倒换，为防止以后遗忘
#ifdef _MINIMCU_
        memcpy(pbyBuf, &m_byIsDoubleMediaConf, sizeof(m_byIsDoubleMediaConf));
        pbyBuf += sizeof(m_byIsDoubleMediaConf);
#endif

		memcpy(pbyBuf, &m_tRefreshParam, sizeof(m_tRefreshParam));
		pbyBuf += sizeof(m_tRefreshParam);

		memcpy(pbyBuf, &m_tVacLastSpeaker, sizeof(m_tVacLastSpeaker));
		pbyBuf += sizeof(m_tVacLastSpeaker);

		memcpy(pbyBuf, &m_tLastSpeaker, sizeof(m_tLastSpeaker));
		pbyBuf += sizeof(m_tLastSpeaker);      
        
		memcpy(pbyBuf, &m_tConfInStatus, sizeof(m_tConfInStatus));
		pbyBuf += sizeof(m_tConfInStatus);

		memcpy(pbyBuf, &m_tCascadeMMCU, sizeof(m_tCascadeMMCU));
		pbyBuf += sizeof(m_tCascadeMMCU);

		memcpy(pbyBuf, &m_dwSpeakerViewId, sizeof(m_dwSpeakerViewId));
		pbyBuf += sizeof(m_dwSpeakerViewId);

		memcpy(pbyBuf, &m_dwVmpViewId, sizeof(m_dwVmpViewId));
		pbyBuf += sizeof(m_dwVmpViewId);

		memcpy(pbyBuf, &m_dwSpeakerVideoId, sizeof(m_dwSpeakerVideoId));
		pbyBuf += sizeof(m_dwSpeakerVideoId);

		memcpy(pbyBuf, &m_dwVmpVideoId, sizeof(m_dwVmpVideoId));
		pbyBuf += sizeof(m_dwVmpVideoId);

		memcpy(pbyBuf, &m_dwSpeakerAudioId, sizeof(m_dwSpeakerAudioId));
		pbyBuf += sizeof(m_dwSpeakerAudioId);

		memcpy(pbyBuf, &m_dwMixerAudioId, sizeof(m_dwMixerAudioId));
		pbyBuf += sizeof(m_dwMixerAudioId);

		memcpy(pbyBuf, m_abySerHdr, sizeof(m_abySerHdr));
		pbyBuf += sizeof(m_abySerHdr);

		memcpy(pbyBuf, &m_byConfIdx, sizeof(m_byConfIdx));
		pbyBuf += sizeof(m_byConfIdx);	

        memcpy(pbyBuf, &m_byDcsIdx, sizeof(m_byDcsIdx));
        pbyBuf += sizeof(m_byDcsIdx);

        memcpy(pbyBuf, &m_tLastSpyMt, sizeof(m_tLastSpyMt));
        pbyBuf += sizeof(m_tLastSpyMt);

		//memcpy(pbyBuf, &m_tLastVmpParam, sizeof(m_tLastVmpParam));
		//pbyBuf += sizeof(m_tLastVmpParam);

		memcpy(pbyBuf, &m_tLastVmpTwParam, sizeof(m_tLastVmpTwParam));
		pbyBuf += sizeof(m_tLastVmpTwParam);

        memcpy(pbyBuf, &m_tChargeSsnId, sizeof(m_tChargeSsnId));
        pbyBuf += sizeof(m_tChargeSsnId);

        memcpy(pbyBuf, m_abyMixMtId, sizeof(m_abyMixMtId));        // zbq [03/19/2007]
        pbyBuf += sizeof(m_abyMixMtId);

        memcpy(pbyBuf, &m_byCreateBy, sizeof(m_byCreateBy));
        pbyBuf += sizeof(m_byCreateBy);

        memcpy(pbyBuf, &m_tPollSwitchParam, sizeof(m_tPollSwitchParam));    // guzh [7/21/2007] 
        pbyBuf += sizeof(m_tPollSwitchParam);

        memcpy(pbyBuf, &m_tRollCaller, sizeof(m_tRollCaller));
        pbyBuf += sizeof(m_tRollCaller);

        memcpy(pbyBuf, &m_tRollCallee, sizeof(m_tRollCallee));
        pbyBuf += sizeof(m_tRollCallee);

        memcpy(pbyBuf, &m_byLastMixMode, sizeof(m_byLastMixMode));
        pbyBuf += sizeof(m_byLastMixMode);

		memcpy(pbyBuf, &m_bySpeakerVidSrcSpecType, sizeof(m_bySpeakerVidSrcSpecType));	//zgc, 2008-04-16
		pbyBuf += sizeof(m_bySpeakerVidSrcSpecType);

		memcpy(pbyBuf, &m_bySpeakerAudSrcSpecType, sizeof(m_bySpeakerAudSrcSpecType));
		pbyBuf += sizeof(m_bySpeakerAudSrcSpecType);
    
		pbyBuf += GetBasMgrBuf(pbyBuf);  

		memcpy(pbyBuf,&m_byNewTokenReqMtid,sizeof(m_byNewTokenReqMtid));  // xliang [12/19/2008] 双流抢发所需
		pbyBuf += sizeof(m_byNewTokenReqMtid);

		memcpy(pbyBuf,&m_byMtIdNotInvite,sizeof(m_byMtIdNotInvite)); // xliang [12/26/2008] 
		pbyBuf += sizeof(m_byMtIdNotInvite);

		memcpy(pbyBuf, &m_tHduBatchPollInfo, sizeof(m_tHduBatchPollInfo) );    // add by jlb
		pbyBuf += sizeof(m_tHduBatchPollInfo);

		memcpy(pbyBuf, &m_tHduPollSchemeInfo, sizeof(m_tHduPollSchemeInfo) );
		pbyBuf += sizeof(m_tHduPollSchemeInfo);

		// xliang [5/12/2009] VMP related
		//memcpy(pbyBuf, &m_tVMPOutParam, sizeof(m_tVMPOutParam) );	//zhouyiliang 20120109 v4r7增加vmp的前适配备份
		//pbyBuf += sizeof(m_tVMPOutParam);

		//memcpy(pbyBuf, &m_tVmpAdaptChnSeizeOpr, sizeof(m_tVmpAdaptChnSeizeOpr) );	//zhouyiliang 20120109 v4r7增加vmp的前适配抢占的后续操作备份
		//pbyBuf += sizeof(m_tVmpAdaptChnSeizeOpr);
		
		//memcpy(pbyBuf, &m_tVmpChnnlInfo,sizeof(m_tVmpChnnlInfo)); 
		//pbyBuf += sizeof(m_tVmpChnnlInfo);

		//memcpy(pbyBuf, m_atVMPTmpMember, sizeof(m_atVMPTmpMember));
		//pbyBuf += sizeof(m_atVMPTmpMember);

		//memcpy(pbyBuf, &m_bNewMemberSeize, sizeof(m_bNewMemberSeize));
		//pbyBuf += sizeof(m_bNewMemberSeize);
		
		memcpy(pbyBuf, m_abyVmpEqpId, sizeof(m_abyVmpEqpId));
		pbyBuf += sizeof(m_abyVmpEqpId);
		
		memcpy(pbyBuf, &m_tModuleVmpEqp, sizeof(m_tModuleVmpEqp));
		pbyBuf += sizeof(m_tModuleVmpEqp);
		
		memcpy(pbyBuf, &m_tLastVmpChnnlMemInfo, sizeof(m_tLastVmpChnnlMemInfo));
		pbyBuf += sizeof(m_tLastVmpChnnlMemInfo);

		memcpy(pbyBuf, &m_tVmpBatchPollInfo, sizeof(m_tVmpBatchPollInfo));
		pbyBuf += sizeof(m_tVmpBatchPollInfo);

		memcpy(pbyBuf, &m_tVmpPollParam, sizeof(m_tVmpPollParam));
		pbyBuf += sizeof(m_tVmpPollParam);

		memcpy(pbyBuf, &m_byVmpOperating, sizeof(m_byVmpOperating));
		pbyBuf += sizeof(m_byVmpOperating);

		// VCS会议状态信息同步
		memcpy(pbyBuf, &m_cVCSConfStatus, sizeof(m_cVCSConfStatus));
		pbyBuf += sizeof(m_cVCSConfStatus);	

		memcpy(pbyBuf, &m_tOrginMtList, sizeof(m_tOrginMtList));
		pbyBuf += sizeof(m_tOrginMtList);

		memcpy(pbyBuf, &m_bMMcuSpeakerValid, sizeof(m_bMMcuSpeakerValid));
		pbyBuf += sizeof(m_bMMcuSpeakerValid);

		memcpy(pbyBuf, &m_tApplySpeakQue, sizeof(m_tApplySpeakQue));
		pbyBuf += sizeof(m_tApplySpeakQue);

		memcpy(pbyBuf, &m_tConfAllMcuInfo, sizeof(m_tConfAllMcuInfo));	//20100809 add by zjj
		pbyBuf += sizeof(m_tConfAllMcuInfo);

		memcpy(pbyBuf, &m_cLocalSpyMana, sizeof(m_cLocalSpyMana));	//20110107 add by zhouyiliang
		pbyBuf += sizeof(m_cLocalSpyMana);

		memcpy(pbyBuf, &m_cSMcuSpyMana, sizeof(m_cSMcuSpyMana));	
		pbyBuf += sizeof(m_cSMcuSpyMana);

		memcpy(pbyBuf, m_atMixMt, sizeof(m_atMixMt));	
		pbyBuf += sizeof(m_atMixMt);

		memcpy(pbyBuf, &m_cRecAdaptMgr, sizeof(CRecAdaptMgr));	
		pbyBuf += sizeof(CRecAdaptMgr);

		memcpy(pbyBuf, &m_byOtherConfMtId, sizeof(m_byOtherConfMtId));	
		pbyBuf += sizeof(m_byOtherConfMtId);

		memcpy(pbyBuf, &m_cSmsControl, sizeof(m_cSmsControl));	
		pbyBuf += sizeof(m_cSmsControl);

		memcpy(pbyBuf, &m_dwBrdFastUpdateTick, sizeof(m_dwBrdFastUpdateTick));	
		pbyBuf += sizeof(m_dwBrdFastUpdateTick);

		memcpy(pbyBuf, &m_byFastNeglectNum, sizeof(m_byFastNeglectNum));	
		pbyBuf += sizeof(m_byFastNeglectNum);

		memcpy(pbyBuf, &m_dwRealSndSpyBandWidth, sizeof(m_dwRealSndSpyBandWidth));	//zjj20120518 add by zjj
		pbyBuf += sizeof(m_dwRealSndSpyBandWidth);

		pbyBuf += GetPrsMgrBuf(pbyBuf);

		memcpy(pbyBuf, &m_tSecVidBrdSrc, sizeof(m_tSecVidBrdSrc));
		pbyBuf += sizeof(m_tSecVidBrdSrc);

		pbyBuf += m_cCfgInfoRileExtraDataMgr.GetMSData(pbyBuf);

		
	}
	else
	{
		memcpy(&m_swCurSatMtNum, pbyBuf, sizeof(m_swCurSatMtNum));
		pbyBuf += sizeof(m_swCurSatMtNum);
		
		memcpy(&m_tConf, pbyBuf, sizeof(m_tConf));
		pbyBuf += sizeof(m_tConf);

		//zhouyiliang 20120109 v4r7的主备修改,增加能力集勾选备份
		memcpy(&m_tConfEx, pbyBuf, sizeof(m_tConfEx));
		pbyBuf += sizeof(m_tConfEx);
		
		memcpy(&m_tConfAllMtInfo, pbyBuf, sizeof(m_tConfAllMtInfo));
		pbyBuf += sizeof(m_tConfAllMtInfo);

		//会控锁定信息不强制同步, 因为同一个mcs在主从mpc上的Ssnid可能不一样
		TConfProtectInfo *ptConfProtectInfo = (TConfProtectInfo *)pbyBuf;
		m_tConfProtectInfo.SetLockByMcu(ptConfProtectInfo->GetLockedMcuId());
		//memcpy(&m_tConfProtectInfo, pbyBuf, sizeof(m_tConfProtectInfo));
		//如果是会控锁定会议，根据主板会控状态中的SSRC搜索本地同ID的会控，如果存在，
		//用本地会控ID重添LockMcs，zgc, 2008-03-25
		if ( CONF_LOCKMODE_LOCK == m_tConf.m_tStatus.GetProtectMode() )
		{
			TMSVcMCState tMSVcMCState;
			g_cMSSsnApp.GetMSVcMCState( tMSVcMCState );

			if ( tMSVcMCState.m_abyOnline[ptConfProtectInfo->GetLockedMcSsnId()-1] != 1 )
			{
				// 对应Id的MCS没有连接到主MPC, 则取消会议锁定
				ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_MSMGR, "[OprInstOtherData][ERROR] Lock conf.%s mcs.%d isn't connecting active mcu, it's impossible!\n ",
							m_tConf.GetConfName(), ptConfProtectInfo->GetLockedMcSsnId() );
				m_tConf.m_tStatus.SetProtectMode( CONF_LOCKMODE_NONE );
			}
			else
			{
				u32 dwSSRC = tMSVcMCState.m_tMcsRegInfo[ptConfProtectInfo->GetLockedMcSsnId()-1].GetMcsSSRC();
				u8 byIdx = 0;
				for ( byIdx = 0; byIdx < MAXNUM_MCU_MC; byIdx++ )
				{
					if ( !g_cMcuVcApp.IsMcConnected( byIdx+1 ) )
					{
						continue;
					}
					TMcsRegInfo tMcsRegInfo;
					g_cMcuVcApp.GetMcsRegInfo( byIdx+1, &tMcsRegInfo );
					if ( dwSSRC == tMcsRegInfo.GetMcsSSRC() )
					{
						//设置lockmcs为本地会控ID
						m_tConfProtectInfo.SetLockByMcs( byIdx+1 );
						break;
					}
				}
				//没有找到同SSRC的MCS连接备MCU，则取消会议锁定
				if ( byIdx == MAXNUM_MCU_MC ) 
				{
					ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_MSMGR, "[OprInstOtherData][ERROR] Can't find mcs<SSRC.%d> connecting standby mcu, it's impossible!\n ",
							dwSSRC );
					m_tConf.m_tStatus.SetProtectMode( CONF_LOCKMODE_NONE );
				}
			}			
		}
		pbyBuf += sizeof(m_tConfProtectInfo);
		
		memcpy(&m_tConfPollParam, pbyBuf, sizeof(m_tConfPollParam));
		pbyBuf += sizeof(m_tConfPollParam);

		memcpy(&m_tTWMutiPollParam, pbyBuf, sizeof(m_tTWMutiPollParam));
		pbyBuf += sizeof(m_tTWMutiPollParam);

		memcpy(&m_tConfEqpModule, pbyBuf, sizeof(m_tConfEqpModule));
		pbyBuf += sizeof(m_tConfEqpModule);

		SetVidBrdSrc(*(TMt *)pbyBuf);
		pbyBuf += sizeof(TMt);

		SetAudBrdSrc(*(TMt *)pbyBuf);
		pbyBuf += sizeof(TMt);

		memcpy(&m_tDoubleStreamSrc, pbyBuf, sizeof(m_tDoubleStreamSrc));
		pbyBuf += sizeof(m_tDoubleStreamSrc);

		memcpy(&m_tH239TokenOwnerInfo, pbyBuf, sizeof(m_tH239TokenOwnerInfo));
		pbyBuf += sizeof(m_tH239TokenOwnerInfo);
		
		memcpy(&m_tVmpEqp, pbyBuf, sizeof(m_tVmpEqp));
		pbyBuf += sizeof(m_tVmpEqp);

		memcpy(&m_tVmpTwEqp, pbyBuf, sizeof(m_tVmpTwEqp));
		pbyBuf += sizeof(m_tVmpTwEqp);

		memcpy(&m_tMixEqp, pbyBuf, sizeof(m_tMixEqp));
		pbyBuf += sizeof(m_tMixEqp);

		memcpy(&m_tRecEqp, pbyBuf, sizeof(m_tRecEqp));
		pbyBuf += sizeof(m_tRecEqp);

		memcpy(&m_tPlayEqp, pbyBuf, sizeof(m_tPlayEqp));
		pbyBuf += sizeof(m_tPlayEqp);

		memcpy(&m_tPlayEqpAttrib, pbyBuf, sizeof(m_tPlayEqpAttrib));
		pbyBuf += sizeof(m_tPlayEqpAttrib);

		memcpy(&m_tPlayFileMediaInfo, pbyBuf, sizeof(m_tPlayFileMediaInfo));
		pbyBuf += sizeof(m_tPlayFileMediaInfo);

		memcpy(&m_tRecPara, pbyBuf, sizeof(m_tRecPara));
		pbyBuf += sizeof(m_tRecPara);

		memcpy(&m_tPlayFileHpAttrib, pbyBuf, sizeof(m_tPlayFileHpAttrib));
		pbyBuf += sizeof(m_tPlayFileHpAttrib);
		
		memcpy(&m_byMixGrpId, pbyBuf, sizeof(m_byMixGrpId));
		pbyBuf += sizeof(m_byMixGrpId);

		memcpy(&m_byRecChnnl, pbyBuf, sizeof(m_byRecChnnl));
		pbyBuf += sizeof(m_byRecChnnl);

		memcpy(&m_byPlayChnnl, pbyBuf, sizeof(m_byPlayChnnl));
		pbyBuf += sizeof(m_byPlayChnnl);

		memcpy(&m_wVidBasBitrate, pbyBuf, sizeof(m_wVidBasBitrate));
		pbyBuf += sizeof(m_wVidBasBitrate);

		memcpy(&m_wBasBitrate, pbyBuf, sizeof(m_wBasBitrate));
		pbyBuf += sizeof(m_wBasBitrate);

		//memcpy(m_awVMPBrdBitrate, pbyBuf, sizeof(m_awVMPBrdBitrate));
		//pbyBuf += sizeof(m_awVMPBrdBitrate);

#ifdef _MINIMCU_
        memcpy(&m_byIsDoubleMediaConf, pbyBuf, sizeof(m_byIsDoubleMediaConf));
        pbyBuf += sizeof(m_byIsDoubleMediaConf);
#endif

        memcpy(&m_tRefreshParam, pbyBuf, sizeof(m_tRefreshParam));
		pbyBuf += sizeof(m_tRefreshParam);

		memcpy(&m_tVacLastSpeaker, pbyBuf, sizeof(m_tVacLastSpeaker));
		pbyBuf += sizeof(m_tVacLastSpeaker);

		memcpy(&m_tLastSpeaker, pbyBuf, sizeof(m_tLastSpeaker));
		pbyBuf += sizeof(m_tLastSpeaker);       

		memcpy(&m_tConfInStatus, pbyBuf, sizeof(m_tConfInStatus));
		pbyBuf += sizeof(m_tConfInStatus);

		memcpy(&m_tCascadeMMCU, pbyBuf, sizeof(m_tCascadeMMCU));
		pbyBuf += sizeof(m_tCascadeMMCU);


		memcpy(&m_dwSpeakerViewId, pbyBuf, sizeof(m_dwSpeakerViewId));
		pbyBuf += sizeof(m_dwSpeakerViewId);

		memcpy(&m_dwVmpViewId, pbyBuf, sizeof(m_dwVmpViewId));
		pbyBuf += sizeof(m_dwVmpViewId);

		memcpy(&m_dwSpeakerVideoId, pbyBuf, sizeof(m_dwSpeakerVideoId));
		pbyBuf += sizeof(m_dwSpeakerVideoId);

		memcpy(&m_dwVmpVideoId, pbyBuf, sizeof(m_dwVmpVideoId));
		pbyBuf += sizeof(m_dwVmpVideoId);

		memcpy(&m_dwSpeakerAudioId, pbyBuf, sizeof(m_dwSpeakerAudioId));
		pbyBuf += sizeof(m_dwSpeakerAudioId);

		memcpy(&m_dwMixerAudioId, pbyBuf, sizeof(m_dwMixerAudioId));
		pbyBuf += sizeof(m_dwMixerAudioId);

		memcpy(m_abySerHdr, pbyBuf, sizeof(m_abySerHdr));
		pbyBuf += sizeof(m_abySerHdr);

		memcpy(&m_byConfIdx, pbyBuf, sizeof(m_byConfIdx));
		pbyBuf += sizeof(m_byConfIdx);

        memcpy(&m_byDcsIdx, pbyBuf, sizeof(m_byDcsIdx));
        pbyBuf += sizeof(m_byDcsIdx);
                
        memcpy(&m_tLastSpyMt, pbyBuf, sizeof(m_tLastSpyMt));
        pbyBuf += sizeof(m_tLastSpyMt);

		//memcpy(&m_tLastVmpParam, pbyBuf, sizeof(m_tLastVmpParam));
		//pbyBuf += sizeof(m_tLastVmpParam);

		memcpy(&m_tLastVmpTwParam, pbyBuf, sizeof(m_tLastVmpTwParam));
		pbyBuf += sizeof(m_tLastVmpTwParam);

        memcpy(&m_tChargeSsnId, pbyBuf, sizeof(m_tChargeSsnId));
        pbyBuf += sizeof(m_tChargeSsnId);

        memcpy(m_abyMixMtId, pbyBuf, sizeof(m_abyMixMtId));
        pbyBuf += sizeof(m_abyMixMtId);

        memcpy(&m_byCreateBy, pbyBuf, sizeof(m_byCreateBy));
        pbyBuf += sizeof(m_byCreateBy);
        
        memcpy(&m_tPollSwitchParam, pbyBuf, sizeof(m_tPollSwitchParam));    // guzh [7/21/2007] 
        pbyBuf += sizeof(m_tPollSwitchParam);

        memcpy(&m_tRollCaller, pbyBuf, sizeof(m_tRollCaller));
        pbyBuf += sizeof(m_tRollCaller);

        memcpy(&m_tRollCallee, pbyBuf, sizeof(m_tRollCallee));
        pbyBuf += sizeof(m_tRollCallee);

        memcpy(&m_byLastMixMode, pbyBuf, sizeof(m_byLastMixMode));
        pbyBuf += sizeof(m_byLastMixMode);

		memcpy(&m_bySpeakerVidSrcSpecType, pbyBuf, sizeof(m_bySpeakerVidSrcSpecType));	//zgc, 2008-04-16
		pbyBuf += sizeof(m_bySpeakerVidSrcSpecType);

		memcpy(&m_bySpeakerAudSrcSpecType, pbyBuf, sizeof(m_bySpeakerAudSrcSpecType));
		pbyBuf += sizeof(m_bySpeakerAudSrcSpecType);

		pbyBuf += SetBasMgrBuf(pbyBuf);

		memcpy(&m_byNewTokenReqMtid, pbyBuf,sizeof(m_byNewTokenReqMtid));	// xliang [12/19/2008] 双流抢发所需
		pbyBuf += sizeof(m_byNewTokenReqMtid);

		memcpy(&m_byMtIdNotInvite,pbyBuf,sizeof(m_byMtIdNotInvite)); // xliang [12/26/2008] 
		pbyBuf += sizeof(m_byMtIdNotInvite);

		memcpy(&m_tHduBatchPollInfo, pbyBuf, sizeof(m_tHduBatchPollInfo) );    // add by jlb
		pbyBuf += sizeof(m_tHduBatchPollInfo);

		memcpy(&m_tHduPollSchemeInfo, pbyBuf, sizeof(m_tHduPollSchemeInfo) );
		pbyBuf += sizeof(m_tHduPollSchemeInfo);
		
		//vmp related
		//memcpy( &m_tVMPOutParam, pbyBuf,sizeof(m_tVMPOutParam)); //zhouyiliang 20120109 v4r7增加vmp的前适配备份
		//pbyBuf += sizeof(m_tVMPOutParam);

		//memcpy( &m_tVmpAdaptChnSeizeOpr, pbyBuf,sizeof(m_tVmpAdaptChnSeizeOpr)); //zhouyiliang 20120109 v4r7增加vmp的前适配抢占的后续操作备份
		//pbyBuf += sizeof(m_tVmpAdaptChnSeizeOpr);


		//memcpy( &m_tVmpChnnlInfo, pbyBuf,sizeof(m_tVmpChnnlInfo)); 
		//pbyBuf += sizeof(m_tVmpChnnlInfo);

		//memcpy(m_atVMPTmpMember, pbyBuf, sizeof(m_atVMPTmpMember));
		//pbyBuf += sizeof(m_atVMPTmpMember);

		//memcpy(&m_bNewMemberSeize, pbyBuf, sizeof(m_bNewMemberSeize));
		//pbyBuf += sizeof(m_bNewMemberSeize);
		
		memcpy(m_abyVmpEqpId, pbyBuf, sizeof(m_abyVmpEqpId));
		pbyBuf += sizeof(m_abyVmpEqpId);
		
		memcpy(&m_tModuleVmpEqp, pbyBuf, sizeof(m_tModuleVmpEqp));
		pbyBuf += sizeof(m_tModuleVmpEqp);

		memcpy(&m_tLastVmpChnnlMemInfo, pbyBuf, sizeof(m_tLastVmpChnnlMemInfo));
		pbyBuf += sizeof(m_tLastVmpChnnlMemInfo);

		memcpy(&m_tVmpBatchPollInfo, pbyBuf, sizeof(m_tVmpBatchPollInfo));
		pbyBuf += sizeof(m_tVmpBatchPollInfo);

		memcpy(&m_tVmpPollParam, pbyBuf, sizeof(m_tVmpPollParam));
		pbyBuf += sizeof(m_tVmpPollParam);

		memcpy(&m_byVmpOperating, pbyBuf, sizeof(m_byVmpOperating));
		pbyBuf += sizeof(m_byVmpOperating);

		memcpy(&m_cVCSConfStatus, pbyBuf, sizeof(m_cVCSConfStatus));
		pbyBuf += sizeof(m_cVCSConfStatus);

		memcpy(&m_tOrginMtList, pbyBuf, sizeof(m_tOrginMtList));
		pbyBuf += sizeof(m_tOrginMtList);

		memcpy(&m_bMMcuSpeakerValid, pbyBuf, sizeof(m_bMMcuSpeakerValid));
		pbyBuf += sizeof(m_bMMcuSpeakerValid);

		memcpy(&m_tApplySpeakQue, pbyBuf, sizeof(m_tApplySpeakQue));
		pbyBuf += sizeof(m_tApplySpeakQue);

		memcpy(&m_tConfAllMcuInfo, pbyBuf, sizeof(m_tConfAllMcuInfo));	//20100809 add by zjj
		pbyBuf += sizeof(m_tConfAllMcuInfo);

		memcpy(&m_cLocalSpyMana, pbyBuf, sizeof(m_cLocalSpyMana));	//20110107 add by zhouyiliang
		pbyBuf += sizeof(m_cLocalSpyMana);

		memcpy(&m_cSMcuSpyMana, pbyBuf, sizeof(m_cSMcuSpyMana));	
		pbyBuf += sizeof(m_cSMcuSpyMana);

		memcpy(m_atMixMt, pbyBuf, sizeof(m_atMixMt));	
		pbyBuf += sizeof(m_atMixMt);

		memcpy(&m_cRecAdaptMgr, pbyBuf, sizeof(m_cRecAdaptMgr));	
		pbyBuf += sizeof(m_cRecAdaptMgr);

		memcpy(&m_byOtherConfMtId, pbyBuf, sizeof(m_byOtherConfMtId));	
		pbyBuf += sizeof(m_byOtherConfMtId);

		memcpy(&m_cSmsControl, pbyBuf, sizeof(m_cSmsControl));	
		pbyBuf += sizeof(m_cSmsControl);

		memcpy(&m_dwBrdFastUpdateTick, pbyBuf, sizeof(m_dwBrdFastUpdateTick));	
		pbyBuf += sizeof(m_dwBrdFastUpdateTick);

		memcpy(&m_byFastNeglectNum, pbyBuf, sizeof(m_byFastNeglectNum));	
		pbyBuf += sizeof(m_byFastNeglectNum);

		memcpy(&m_dwRealSndSpyBandWidth, pbyBuf, sizeof(m_dwRealSndSpyBandWidth));
		pbyBuf += sizeof(m_dwRealSndSpyBandWidth);

		pbyBuf += SetPrsMgrBuf(pbyBuf);

		memcpy(&m_tSecVidBrdSrc, pbyBuf, sizeof(m_tSecVidBrdSrc));
		pbyBuf += sizeof(m_tSecVidBrdSrc);

		pbyBuf += m_cCfgInfoRileExtraDataMgr.SetMSData(pbyBuf);


	}

	return dwOtherDataLen;
}

/*=============================================================================
    函 数 名： GetInstOtherDataLen
    功    能： 主备数据倒换时 获取 除上述动态分配的列表信息外的其他需同步 数据总长度
	           由于同步的主从MCU应用环境一致，同步的数据结构暂不考虑紧凑压栈问题：Pack Ingore
    算法实现： 
    全局变量： 
    参    数： void
    返 回 值： u32  数据总长度
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/11/18  4.0			万春雷                  创建
=============================================================================*/
u32 CMcuVcInst::GetInstOtherDataLen( void )
{
	u32 dwOtherDataLen = 0;

	dwOtherDataLen += sizeof(m_tConf);
	dwOtherDataLen += sizeof(m_tConfEx); //zhouyiliang 20120110 add m_tConfEx
	dwOtherDataLen += sizeof(m_tConfAllMtInfo);
	dwOtherDataLen += sizeof(m_tConfProtectInfo);
	dwOtherDataLen += sizeof(m_tConfPollParam);
	dwOtherDataLen += sizeof(m_tTWMutiPollParam);
	dwOtherDataLen += sizeof(m_tConfEqpModule);
	dwOtherDataLen += sizeof(TMt); //m_tVidBrdSrc
	dwOtherDataLen += sizeof(TMt); //m_tAudBrdSrc
	dwOtherDataLen += sizeof(m_tDoubleStreamSrc);
	dwOtherDataLen += sizeof(m_tH239TokenOwnerInfo);
	//10

	dwOtherDataLen += sizeof(m_tVmpEqp);
	dwOtherDataLen += sizeof(m_tVmpTwEqp);
	dwOtherDataLen += sizeof(m_tMixEqp);
	dwOtherDataLen += sizeof(m_tRecEqp);
	dwOtherDataLen += sizeof(m_tPlayEqp);
	dwOtherDataLen += sizeof(m_tPlayEqpAttrib);
	dwOtherDataLen += sizeof(m_tPlayFileMediaInfo);
	dwOtherDataLen += sizeof(m_tRecPara);
	dwOtherDataLen += sizeof(m_tPlayFileHpAttrib);
	dwOtherDataLen += sizeof(m_byMixGrpId);
	//20

	dwOtherDataLen += sizeof(m_byRecChnnl);
	dwOtherDataLen += sizeof(m_byPlayChnnl);

	
	dwOtherDataLen += sizeof(m_wVidBasBitrate);
	dwOtherDataLen += sizeof(m_wBasBitrate);
	//dwOtherDataLen += sizeof(m_awVMPBrdBitrate);
#ifdef _MINIMCU_
    dwOtherDataLen += sizeof(m_byIsDoubleMediaConf);
#endif
    dwOtherDataLen += sizeof(m_tRefreshParam);
	dwOtherDataLen += sizeof(m_tVacLastSpeaker);
	dwOtherDataLen += sizeof(m_tLastSpeaker);
	dwOtherDataLen += sizeof(m_tConfInStatus);
	dwOtherDataLen += sizeof(m_tCascadeMMCU);
	dwOtherDataLen += sizeof(m_dwSpeakerViewId);
	//30
	
	dwOtherDataLen += sizeof(m_dwVmpViewId);
	dwOtherDataLen += sizeof(m_dwSpeakerVideoId);
	dwOtherDataLen += sizeof(m_dwVmpVideoId);
	dwOtherDataLen += sizeof(m_dwSpeakerAudioId);
	dwOtherDataLen += sizeof(m_dwMixerAudioId);
	dwOtherDataLen += sizeof(m_abySerHdr);  
	dwOtherDataLen += sizeof(m_byConfIdx);
    dwOtherDataLen += sizeof(m_byDcsIdx);
    dwOtherDataLen += sizeof(m_tLastSpyMt);
	//dwOtherDataLen += sizeof(m_tLastVmpParam);
	//40
	
	dwOtherDataLen += sizeof(m_tLastVmpTwParam);
    dwOtherDataLen += sizeof(m_tChargeSsnId);
    dwOtherDataLen += sizeof(m_abyMixMtId);
    dwOtherDataLen += sizeof(m_byCreateBy);
    dwOtherDataLen += sizeof(m_tPollSwitchParam);       // guzh [7/21/2007] 
    dwOtherDataLen += sizeof(m_tRollCaller);
    dwOtherDataLen += sizeof(m_tRollCallee);
    dwOtherDataLen += sizeof(m_byLastMixMode);
	dwOtherDataLen += sizeof(m_bySpeakerVidSrcSpecType);	// zgc, 2008-04-17
	dwOtherDataLen += sizeof(m_bySpeakerAudSrcSpecType);
	//50
	
    dwOtherDataLen += sizeof(CMcuBasMgr);
	dwOtherDataLen += sizeof(m_byNewTokenReqMtid);		// xliang [12/19/2008] 双流抢发所需	
	dwOtherDataLen += sizeof(m_byMtIdNotInvite);		// xliang [12/26/2008]
	dwOtherDataLen += sizeof(m_tHduBatchPollInfo);        // add by jlb
	dwOtherDataLen += sizeof(m_tHduPollSchemeInfo);       // add by jlb
	//dwOtherDataLen += sizeof(m_tVMPOutParam);            //zhouyiliang 20120110 add 
	//dwOtherDataLen += sizeof(m_tVmpAdaptChnSeizeOpr);    //zhouyiliang 20120110 add 
	//dwOtherDataLen += sizeof(m_tVmpChnnlInfo);
	//dwOtherDataLen += sizeof(m_atVMPTmpMember);
	//dwOtherDataLen += sizeof(m_bNewMemberSeize);
	dwOtherDataLen += sizeof(m_abyVmpEqpId);
	dwOtherDataLen += sizeof(m_tModuleVmpEqp);
	dwOtherDataLen += sizeof(m_tLastVmpChnnlMemInfo);
	//60
	
	dwOtherDataLen += sizeof(m_tVmpBatchPollInfo);
	dwOtherDataLen += sizeof(m_tVmpPollParam);
	dwOtherDataLen += sizeof(m_byVmpOperating);
	dwOtherDataLen += sizeof(m_cVCSConfStatus);
	dwOtherDataLen += sizeof(m_tOrginMtList);
	dwOtherDataLen += sizeof(m_bMMcuSpeakerValid);
	dwOtherDataLen += sizeof(m_tApplySpeakQue);
	dwOtherDataLen += sizeof(m_tConfAllMcuInfo);
	dwOtherDataLen += sizeof(m_cLocalSpyMana);//zhouyiliang 20110107 会议多回传信息
	dwOtherDataLen += sizeof(m_cSMcuSpyMana);
	dwOtherDataLen += sizeof(m_atMixMt);

	dwOtherDataLen += sizeof(m_cRecAdaptMgr);
	dwOtherDataLen += sizeof(m_byOtherConfMtId);
	dwOtherDataLen += sizeof(m_cSmsControl);

	//70

	dwOtherDataLen += sizeof(m_dwBrdFastUpdateTick);
	dwOtherDataLen += sizeof(m_byFastNeglectNum);
	dwOtherDataLen += sizeof(m_dwRealSndSpyBandWidth);
	dwOtherDataLen += sizeof(TPrsInfoManage);
	dwOtherDataLen += sizeof(m_tSecVidBrdSrc);

	//预案总数(u8) + 是否初始化预案(u8) + 预案长度(u16) + 预案buf(预案长度)
	dwOtherDataLen += m_cCfgInfoRileExtraDataMgr.GetMSDataLen();


	return dwOtherDataLen;
}

/*=============================================================================
  函 数 名： ProcWaitEqpToCreateConf
  功    能： 等待外设上线创会
  算法实现： 
  全局变量： 
  参    数： CMessage * const pcMsg
  返 回 值： void 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2006/02/25  4.0			刘辉云                  创建
=============================================================================*/
void CMcuVcInst::ProcWaitEqpToCreateConf(CMessage * const pcMsg)
{
    if ( STATE_WAITFOR != CurState() )
    {
        return;
    }
	TConfStore tConfStoreBuf;
	TPackConfStore *ptPackConfStore = (TPackConfStore *)&tConfStoreBuf;		
	u16 wAliasBufLen = 0;
	u8* pbyAliasBuf  = NULL; // 终端别名数组打包缓冲
	u8* pbyModuleBuf = NULL; // 电视墙//画面合成模板缓冲
	
	u8 byConfIdx = (u8)(*(u32*)pcMsg->content);
	// 提取后的 tConfStore 为 TPackConfStore 结构，即已进行Pack处理的会议数据
	BOOL32 bRet = g_cMcuVcApp.HasConfStore( byConfIdx-MIN_CONFIDX );
    BOOL32 bRet1  =  ::GetConfFromFile(byConfIdx-MIN_CONFIDX, ptPackConfStore);
	if (bRet && bRet1)
	{
		wAliasBufLen = htons(ptPackConfStore->m_wAliasBufLen);
		pbyAliasBuf  = (u8 *)(ptPackConfStore+1);
		pbyModuleBuf = pbyAliasBuf+ptPackConfStore->m_wAliasBufLen;

        // guzh [4/11/2007] 标记从文件创会
        ptPackConfStore->m_tConfInfo.m_tStatus.SetTakeFromFile(TRUE);
		
		CServMsg cServMsg;
		cServMsg.SetConfIdx( (u8)byConfIdx ); // confidx
		cServMsg.SetMsgBody((u8*)&ptPackConfStore->m_tConfInfo, sizeof(TConfInfo));
		cServMsg.CatMsgBody((u8*)&wAliasBufLen, 2 );
		cServMsg.CatMsgBody(pbyAliasBuf, ntohs(wAliasBufLen) );

		// 电视墙模板
		TConfAttrb tConfAttrb = ptPackConfStore->m_tConfInfo.GetConfAttrb();
		if (tConfAttrb.IsHasTvWallModule())
		{
			cServMsg.CatMsgBody(pbyModuleBuf, sizeof(TMultiTvWallModule));
			pbyModuleBuf += sizeof(TMultiTvWallModule);
		}
		// 画面合成模板 
		if (tConfAttrb.IsHasVmpModule())
		{
			cServMsg.CatMsgBody(pbyModuleBuf, sizeof(TVmpModule));
			pbyModuleBuf += sizeof(TVmpModule);
		}
		
		//VCS信息[12/27/2011 chendaiwei]
		u8 * pbyVCSInfoBuf = pbyModuleBuf;
		if (VCS_CONF == ptPackConfStore->m_tConfInfo.GetConfSource())
		{	
			u8 byIsSupportHDTW = *pbyVCSInfoBuf++;
			if (byIsSupportHDTW)
			{
				pbyVCSInfoBuf += sizeof(THDTvWall);
			}
			
			u8 byHduNum = *pbyVCSInfoBuf++;
			if (byHduNum)
			{
				pbyVCSInfoBuf += byHduNum * sizeof(THduModChnlInfo);
			}
			
			u8 bySMCUExist = *pbyVCSInfoBuf++;
			if (bySMCUExist)
			{
				wAliasBufLen = htons(*(u16*)pbyVCSInfoBuf);
				pbyVCSInfoBuf += sizeof(u16);
				wAliasBufLen = ntohs(wAliasBufLen);
				pbyVCSInfoBuf += wAliasBufLen;					
			}
			
			// 会议模板中不包含分组信息
			pbyVCSInfoBuf++;
// 			u8 byMTPackExist = *pbyVCSInfoBuf++;
// 			byMTPackExist = FALSE;
			//zhouyiliang 20100820 增加备份终端
			pbyVCSInfoBuf += sizeof(TMtAlias);
			
			// [4/20/2011 xliang] VCAutoMode
			pbyVCSInfoBuf ++;
		}
		
		u16 wConInfoExLength = ntohs(*(u16*)pbyVCSInfoBuf);
		cServMsg.CatMsgBody((u8*)pbyVCSInfoBuf,wConInfoExLength + sizeof(u16));

        ::OspPost(MAKEIID( AID_MCU_VC, GetInsID() ), MCU_CREATECONF_FROMFILE, 
                    cServMsg.GetServMsg(), cServMsg.GetServMsgLen());

	}
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_MCS, "[Conf%d] Wait for eqp to create conference: %s\n", 
            GetInsID(), tConfStoreBuf.m_tConfInfo.GetConfName() );

	return;
}

/*=============================================================================
  函 数 名： DaemonProcMcuRegGKFailedNtf
  功    能： Mcu 重新注册GK 通知
  算法实现： 
  全局变量： 
  参    数： const CApp* pApp
  返 回 值： void 
=============================================================================*/
void CMcuVcInst::DaemonProcMcuReRegisterGKNtf( void )
{
    m_tConfInStatus.SetRegGkNackNtf(TRUE);
    return;
}

/*=============================================================================
  函 数 名： DaemonProcPowerOn
  功    能： 实例初始化
  算法实现： 
  全局变量： 
  参    数： const CApp* pApp
  返 回 值： void 
=============================================================================*/
void CMcuVcInst::DaemonProcPowerOn( void )
{
	if (!g_cMcuVcApp.CreateTemplate())
	{
		ConfPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[ProcReoPowerOn] allocate memory failed for conf template!!!\n");
		return;
	}
    
	TConfStore tConfStoreBuf;
	TPackConfStore *ptPackConfStore = (TPackConfStore *)&tConfStoreBuf;
	u8 byConfStoreNum = 0;

    // guzh [4/10/2007] 要从老的MakeTimee恢复,保证CConfId的历史唯一性
    u32 dwOldConfIdMakeTimes = 0;
    u32 dwTmp;
    CConfId cConfId;
	for (u8 byLoop = 0; byLoop < (MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE); byLoop++)
	{
		//提取后的 tConfStore 为 TPackConfStore 结构，即已进行Pack处理的会议数据
        if (::GetConfFromFile(byLoop, ptPackConfStore))
		{
			byConfStoreNum++;
			g_cMcuVcApp.SetConfStore(byLoop, TRUE);	
            
            cConfId = ptPackConfStore->m_tConfInfo.GetConfId();
            dwTmp = g_cMcuVcApp.GetMakeTimesFromConfId(cConfId);
            if (dwTmp > dwOldConfIdMakeTimes) 
            {
                dwOldConfIdMakeTimes = dwTmp;
            }
		}
	}
    g_cMcuVcApp.SetConfIdMakeTimes(dwOldConfIdMakeTimes);

    // xsl [11/28/2006] N+1 备份模式不进行会议恢复
    if (g_cNPlusApp.GetLocalNPlusState() == MCU_NPLUS_SLAVE_IDLE ||
        g_cNPlusApp.GetLocalNPlusState() == MCU_NPLUS_SLAVE_SWITCH)
    {        
        return;
    }
    
	//若有需自动恢复的会议Idx列表（包括模板），则启动MP检测定时器
	if( byConfStoreNum > 0 )
	{
        // guzh [4/13/2007] 设置标记表示是MCU启动第一次恢复
		SetTimer(MCUVC_WAIT_MPREG_TIMER, TIMESPACE_WAIT_MPREG, TRUE);
	}
    // [3/18/2013 liaokang] 发送power_on消息给Nplus业务,启动NPlus业务
    //                      防止无模板时,Nplus线程无法启动
    else 
    {        
        PowerOnNPlusApp();
    }
	return;
}

/*=============================================================================
函 数 名： GetNPlusConfData
功    能： 从会议信息获取N+1备份信息
算法实现： 
全局变量： 
参    数： TNPlusConfData &tConfData
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/11/30  4.0			许世林                  创建
=============================================================================*/
void CMcuVcInst::ProcNPlusConfDataUpdate(const CMessage * pcMsg)
{
    if ( CurState() != STATE_ONGOING )
    {
        return;
    }

    // N+1备份，不支持预约会议的备份倒换 [12/20/2006-zbq]
    if ( m_tConf.m_tStatus.IsScheduled() )
    {
        ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_NPLUS, "[ProcNPlusConfDataUpdate] conf.%s will not be backup as a scheduled conf !\n",
                         m_tConf.GetConfName() );
        return;
    }
    
    TNPlusConfData tConfData;
	TNPlusVmpParam tNplusVmpParam[MAXNUM_PERIEQP];
	u8 byVmpNum = 0;
	
    GetNPlusDataFromConf( tConfData,&tNplusVmpParam[0],byVmpNum);

    //[5/8/2013 liaokang] 转码
    if (MCU_NPLUS_SLAVE_IDLE == g_cNPlusApp.GetLocalNPlusState() )
    {
        u8 byInsId = GETINS(pcMsg->srcid);
        if (0 == byInsId || byInsId > MAXNUM_NPLUS_MCU)
        {
            return;
        }
        
        CApp *pcApp = &g_cNPlusApp;
        CNPlusInst *pcInst = NULL;
        pcInst = (CNPlusInst *)pcApp->GetInstance(byInsId);
        if (NULL == pcInst)
        {
            return;
        }
#ifdef _UTF8
        if( emenCoding_GBK == pcInst->GetMcuEncodingForm() )
        {
            TransEncodingOfNPlusConfData(tConfData,TRANSENCODING_UTF8_GBK); 
        }    
#endif 
    }

	TNPlusConfExData tconfExData;
	u16 wPackDataLen = GetNPlusDataExFromConf(tconfExData);

    CServMsg cServMsg;
    cServMsg.SetEventId(MCU_NPLUS_CONFDATAUPDATE_REQ);
    cServMsg.SetConfId(m_tConf.GetConfId());
    cServMsg.SetMsgBody((u8*)&tConfData, sizeof(tConfData));
	cServMsg.CatMsgBody(tconfExData.m_byConInfoExBuf,wPackDataLen);
	cServMsg.CatMsgBody((u8*)&tconfExData.m_atSmcuCallInfo[0],sizeof(tconfExData.m_atSmcuCallInfo));

	cServMsg.CatMsgBody((u8*)&byVmpNum,sizeof(byVmpNum));
	for( u8 byIdx = 0; byIdx < byVmpNum; byIdx ++ )
	{
		cServMsg.CatMsgBody((u8*)&tNplusVmpParam[byIdx].m_tVmpBaiscParam,sizeof(tNplusVmpParam[byIdx].m_tVmpBaiscParam));
		u8 byChnNum = tNplusVmpParam[byIdx].m_tVmpBaiscParam.GetMaxMemberNum();
		cServMsg.CatMsgBody((u8*)&byChnNum,sizeof(u8));
		cServMsg.CatMsgBody((u8*)&tNplusVmpParam[byIdx].m_tVmpMemer.m_tVmpChnnlInfo[0],byChnNum*sizeof(TNPlusVmpChnlMember));
	}

	ConfPrint(LOG_LVL_DETAIL, MID_MCU_NPLUS, "[ProcNPlusConfDataUpdate] conf:%s VmpNum:%d\n", m_tConf.GetConfName(),byVmpNum);

	//1.先结束会议，取消该会议E164号的注册。以避免回滚到主，主RRQ失败[11/8/2012 chendaiwei]
	//若为回滚模式，即源实例不是daemon，结束备份会议
    if (GETINS(pcMsg->srcid) != CInstance::DAEMON)
    {
        ConfPrint(LOG_LVL_DETAIL, MID_MCU_NPLUS, "[ProcNPlusConfDataUpdate] conf:%s rollback and release\n", m_tConf.GetConfName());
        ReleaseConf(FALSE);        
        NEXTSTATE( STATE_IDLE );
    }

	//2.后发回滚消息[11/8/2012 chendaiwei]
    //若为主mcu则srcid为daemon实例，若为备份mcu回滚模式则srcid为备份实例
    OspPost(pcMsg->srcid, VC_NPLUS_MSG_NOTIF, cServMsg.GetServMsg(), cServMsg.GetServMsgLen());

    return;
}

/*=============================================================================
函 数 名： GetNPlusDataFromConf
功    能： 从会议获得N+1备份所需信息
算法实现： 
全局变量： 
参    数： TNPlusConfData &tNPlusData
           BOOL32          bCharge   :针对计费同步信息的处理，若为计费同步，则
                                      不关心 专门针对N+1的处理部分。否则，会导
                                      致时序问题。影响N+1的备份结果。zbq [03/27/2007]

返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/12/26  4.0			张宝卿                  创建
=============================================================================*/
void CMcuVcInst::GetNPlusDataFromConf( TNPlusConfData &tConfData, TNPlusVmpParam *ptNplusVmpParam, u8 &byVmpNum,BOOL32 bCharge )
{
    memcpy(&tConfData.m_tConf, &m_tConf, sizeof(TConfInfo));

	//20110825 zjl n+1通告会议信息，不设置锁定状态
	tConfData.m_tConf.m_tStatus.m_tConfMode.SetLockMode(CONF_LOCKMODE_NONE);

	//清空录放像，轮询，轮训点名，录放像,HDU轮询状态 [4/27/2013 chendaiwei]
	tConfData.m_tConf.m_tStatus.SetPollMode(CONF_POLLMODE_NONE);
	tConfData.m_tConf.m_tStatus.SetRollCallMode(ROLLCALL_MODE_NONE);
    tConfData.m_tConf.m_tStatus.SetNoRecording();
    tConfData.m_tConf.m_tStatus.SetNoPlaying();
	THduPollInfo tNullInfo;
	tConfData.m_tConf.m_tStatus.SetHduPollInfo(tNullInfo);

	//清空会议自动录像属性[8/6/2013 chendaiwei]
	TConfAutoRecAttrb tNullRecAttrb;
	tConfData.m_tConf.SetAutoRecAttrb(tNullRecAttrb);

    TMtAlias tTmpAlias;
    TMt tTmpMt = m_tConf.GetChairman();    
    if (!tTmpMt.IsNull())
    {
        if (!m_ptMtTable->GetMtAlias(tTmpMt.GetMtId(), mtAliasTypeTransportAddress, &tTmpAlias))
        {
            ConfPrint(LOG_LVL_WARNING, MID_MCU_NPLUS, "[GetNPlusDataFromConf] get chairman ip addr alias failed.\n");            
        }        
    }
    tConfData.m_tConf.SetChairAlias(tTmpAlias);
    
    tTmpAlias.SetNull();
    tTmpMt = m_tConf.GetSpeaker();
    if (!tTmpMt.IsNull())
    {
		//  [2/21/2011 chendaiwei]增加对下级发言人的备份支持
		if(!tTmpMt.IsLocal())
		{
			s8 achAlias[VALIDLEN_ALIAS] = {0};
			if( GetMtAlias(tTmpMt, achAlias) )
			{
				tTmpAlias.SetH323Alias(achAlias);						
			}
			else
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_NPLUS,  "[GetNPlusDataFromConf] get smcu speaker alias failed.\n");
			}
		}
		else
		{
			if (!m_ptMtTable->GetMtAlias(tTmpMt.GetMtId(), mtAliasTypeTransportAddress, &tTmpAlias))
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_NPLUS, "[GetNPlusDataFromConf] get speaker ip addr alias failed.\n");
			}
		}
	}

	tConfData.m_tConf.SetSpeakerAlias(tTmpAlias);
    
    u8 byIdx = 0;
    u16 wDialBitrate;
    for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
    {
		//zjj20130911 主机发送信息给备机时,只要导在线终端信息,如果备机回滚在不在线都回滚
		if( MCU_NPLUS_MASTER_IDLE == g_cNPlusApp.GetLocalNPlusState() || 
			MCU_NPLUS_MASTER_CONNECTED == g_cNPlusApp.GetLocalNPlusState() )
		{
			//只保存与会终端
			if (!m_tConfAllMtInfo.MtJoinedConf(byMtId) )
			{
				continue;
			}
		}

		//只保存主动邀请的终端
		if ( m_ptMtTable->IsNotInvited(byMtId) )
		{
			continue;
		}
		//不保存新录播实体
		if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC)
		{
			continue;
		}
        
        if (m_ptMtTable->GetMtAlias(byMtId, mtAliasTypeTransportAddress, &tTmpAlias))
        {
            tConfData.m_atMtInConf[byIdx].SetMtAddr(tTmpAlias.m_tTransportAddr);
            //wDialBitrate = m_ptMtTable->GetDialBitrate(byMtId);
			wDialBitrate = m_ptMtTable->m_atMtExt[byMtId-1].GetDialBitRate() - GetAudioBitrate(m_tConf.GetMainAudioMediaType());
            tConfData.m_atMtInConf[byIdx].SetCallBitrate(wDialBitrate);            
            byIdx++;
        }
        else
        {
            ConfPrint(LOG_LVL_WARNING, MID_MCU_NPLUS, "[GetNPlusDataFromConf] get mt.%d ip addr alias failed.\n", byMtId);
        }
        tConfData.m_byMtNum = byIdx;
    }

    BOOL32 bConfHasVmpMember = FALSE;
	u8 byLastVmpId = 0;
	for (byIdx=0; byIdx<MAXNUM_CONF_VMP; byIdx++)
	{
		if (!IsValidVmpId(m_abyVmpEqpId[byIdx]))
		{
			continue;
		}

		BOOL32 bHasVMPMem = FALSE;

		TEqp tVmpEqp = g_cMcuVcApp.GetEqp( m_abyVmpEqpId[byIdx] );
		TVMPParam_25Mem tVmpParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
		
        for ( u8 byMtIdx = 0; byMtIdx < tVmpParam.GetMaxMemberNum(); byMtIdx++)
        {
            TVMPMember *ptMemMt = tVmpParam.GetVmpMember(byMtIdx);
			
			//跟随不设置成员
			if( ptMemMt->GetMemberType()!= VMP_MEMBERTYPE_NULL
				&& ptMemMt->GetMemberType()!= VMP_MEMBERTYPE_MCSSPEC)
			{
				ptNplusVmpParam[byVmpNum].m_tVmpMemer.m_tVmpChnnlInfo[byMtIdx].m_byMemberType =ptMemMt->GetMemberType();
				bHasVMPMem = TRUE;
				bConfHasVmpMember = TRUE;

				continue;
			}
			
            if (!m_tConfAllMtInfo.MtJoinedConf(ptMemMt->GetMtId()) || m_ptMtTable->IsNotInvited(ptMemMt->GetMtId())
				|| !ptMemMt->IsLocal())
            {
                continue;
            }
	
            if (m_ptMtTable->GetMtAlias(ptMemMt->GetMtId(), mtAliasTypeTransportAddress, &tTmpAlias))
            {
				ptNplusVmpParam[byVmpNum].m_tVmpMemer.m_tVmpChnnlInfo[byMtIdx].m_tMtInVmp.SetMtAddr(tTmpAlias.m_tTransportAddr);
				ptNplusVmpParam[byVmpNum].m_tVmpMemer.m_tVmpChnnlInfo[byMtIdx].m_byMemberType =ptMemMt->GetMemberType();	

				bHasVMPMem = TRUE;
				bConfHasVmpMember = TRUE;
            }
            else
            {
                ConfPrint(LOG_LVL_WARNING, MID_MCU_NPLUS, "[GetNPlusDataFromConf] get mt.%d ip addr alias failed.\n", tTmpMt.GetMtId());
            }
        }
		
		//定制VMP，无成员且无跟随N+1不备份[4/7/2013 chendaiwei]
		if( !bHasVMPMem && tVmpParam.GetVMPMode()!= CONF_VMPMODE_AUTO)
		{
			continue;
		}
		else
		{
			memcpy(&ptNplusVmpParam[byVmpNum],&tVmpParam,sizeof(TVmpBasicParam)-sizeof(u8));
			ptNplusVmpParam[byVmpNum].m_tVmpBaiscParam.m_byVmpSubType = GetVmpSubType(m_abyVmpEqpId[byIdx]);	
			
			//开启VMP时，该参数始终为空.VMP回ACK时设值[4/11/2013 chendaiwei]
			ptNplusVmpParam[byVmpNum].m_tVmpBaiscParam.m_byVMPMode = CONF_VMPMODE_NONE;
			
			byVmpNum++;
			byLastVmpId = m_abyVmpEqpId[byIdx];
		}
	}

	//启用1画面合成，且25风格以下，启用老的数据组织方式[4/7/2013 chendaiwei]
	if( byVmpNum == 1 && ptNplusVmpParam[0].m_tVmpBaiscParam.m_byVMPStyle < VMP_STYLE_TWENTYFIVE )
	{
		//保存vmp参数到m_tStatus中[4/7/2013 chendaiwei]
		TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byLastVmpId );
		TVMPParam_25Mem tVmpParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
		tConfData.m_tConf.m_tStatus.SetVmpParam((TVMPParam)tVmpParam);

		TTransportAddr tTransportAddr;
		for( u8 byMemIdx = 0; byMemIdx < MAXNUM_MPUSVMP_MEMBER; byMemIdx ++ )
		{
			tTransportAddr = ptNplusVmpParam[0].m_tVmpMemer.m_tVmpChnnlInfo[byMemIdx].m_tMtInVmp.GetMtAddr();
			tConfData.m_tVmpInfo.m_atMtInVmp[byMemIdx].SetMtAddr(tTransportAddr);
			//tConfData.m_tVmpInfo.m_atMtInVmp[byMemIdx].SetMtAddr(ptNplusVmpParam[0].m_tVmpMemer.m_tVmpChnnlInfo[byMemIdx].m_tMtInVmp.GetMtAddr());
			tConfData.m_tVmpInfo.m_abyMemberType[byMemIdx] = ptNplusVmpParam[0].m_tVmpMemer.m_tVmpChnnlInfo[byMemIdx].m_byMemberType;
		}

		//兼容老版本MCU m_tStatus里仍然赋值[4/7/2013 chendaiwei]
		tConfData.m_tConf.m_tStatus.SetVMPMode(tVmpParam.GetVMPMode());
        
		tConfData.m_tConf.SetHasVmpModule( bConfHasVmpMember );

		// 若画面合成模式为自动合成，则模板为空 [01/11/2007-zbq]
        if ( CONF_VMPMODE_AUTO == tConfData.m_tConf.m_tStatus.GetVMPMode() ) 
        {
            tConfData.m_tConf.SetHasVmpModule( FALSE );
        }

		byVmpNum = 0;
	}
	else
	{
		tConfData.m_tConf.SetHasVmpModule(FALSE);
		tConfData.m_tConf.m_tStatus.SetVMPMode(CONF_VMPMODE_NONE);
		tConfData.m_tVmpInfo.Clear();
	}
	    
    // 若会议计费，则加载计费SessionId [12/26/2006-zbq]
    if ( m_tConf.IsSupportGkCharge() )
    {
        memcpy(&tConfData.m_tSsnId, &m_tChargeSsnId, sizeof(m_tChargeSsnId));
    }
    
    return;
}

/*=============================================================================
函 数 名： GetNPlusDataExFromConf
功    能： 从会议获得N+1备份所需扩展信息（包括勾选和SMCU呼叫信息）
算法实现： 
全局变量： 
参    数： TNPlusConfExData &tNPlusDataEx
		   

返 回 值： u16 打包扩展信息长度
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2012/11/16  4.7         chendaiwei               create
=============================================================================*/
u16 CMcuVcInst::GetNPlusDataExFromConf(TNPlusConfExData &tNPlusDataEx)
{
	u16 wPackDataLen = 0;
	if(m_tConf.HasConfExInfo())
	{
		u8 abyConfInfExBuf[CONFINFO_EX_BUFFER_LENGTH] = {0};
		PackConfInfoEx(m_tConfEx,tNPlusDataEx.m_byConInfoExBuf,wPackDataLen);
	}

	TSmcuCallnfo atSmcuInfo[MAXNUM_SUB_MCU];
	u8 bySmcuNum = 0;
	TMtAlias tTmpAlias;
    for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
    {
        if ( !m_tConfAllMtInfo.MtJoinedConf(byMtId) || 
			MT_TYPE_MMCU == m_ptMtTable->GetMt(byMtId).GetMtType() )
        {
            continue;
        }
		
        if (m_ptMtTable->GetMtAlias(byMtId, mtAliasTypeTransportAddress, &tTmpAlias))
        {          			
			TMtAlias tSmcuAlias;
			m_ptMtTable->GetDialAlias(byMtId,&tSmcuAlias);
			if(m_ptMtTable->GetMtType(byMtId) == MT_TYPE_SMCU
				&& tSmcuAlias.m_AliasType == mtAliasTypeE164)
			{
				atSmcuInfo[bySmcuNum].SetE164Alias(tSmcuAlias.m_achAlias);
				atSmcuInfo[bySmcuNum].SetMcuAddr(tTmpAlias.m_tTransportAddr);
				bySmcuNum++;
				if( bySmcuNum >= MAXNUM_SUB_MCU )
				{
					break;
				}
			}
        }
        else
        {
            ConfPrint(LOG_LVL_WARNING, MID_MCU_NPLUS, "[GetNPlusDataExFromConf] get mt.%d ip addr alias failed.\n", byMtId);
        }
    }

	memcpy(tNPlusDataEx.m_atSmcuCallInfo,atSmcuInfo,sizeof(atSmcuInfo));

	return wPackDataLen;
}

/*=============================================================================
函 数 名： ProcNPlusConfInfoUpdate
功    能： N+1备份会议信息同步
算法实现： 
全局变量： 
参    数： void
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/11/22  4.0			许世林                  创建
=============================================================================*/
void CMcuVcInst::ProcNPlusConfInfoUpdate(BOOL32 bStart)
{
    u8 byMode = bStart ? NPLUS_CONF_START : NPLUS_CONF_RELEASE;
    CServMsg cServMsg;
    cServMsg.SetEventId(MCU_NPLUS_CONFINFOUPDATE_REQ);
    cServMsg.SetMsgBody(&byMode, sizeof(byMode));
    cServMsg.SetConfId(m_tConf.GetConfId());

	//20110825 zjl n+1创建会议时同步会议信息，不锁定界面 
	TConfInfo tConfInfo = m_tConf;	
	tConfInfo.m_tStatus.m_tConfMode.SetLockMode(CONF_LOCKMODE_NONE);
	
	//清空录放像，轮询，轮训点名，录放像状态 [4/27/2013 chendaiwei]
	tConfInfo.m_tStatus.SetPollMode(CONF_POLLMODE_NONE);
	tConfInfo.m_tStatus.SetRollCallMode(ROLLCALL_MODE_NONE);
    tConfInfo.m_tStatus.SetNoRecording();
    tConfInfo.m_tStatus.SetNoPlaying();
	THduPollInfo tNullInfo;
	tConfInfo.m_tStatus.SetHduPollInfo(tNullInfo);

	//清空会议自动录像属性[8/6/2013 chendaiwei]
	TConfAutoRecAttrb tNullRecAttrb;
	tConfInfo.SetAutoRecAttrb(tNullRecAttrb);

    cServMsg.CatMsgBody((u8*)&tConfInfo, sizeof(tConfInfo));

	if(m_tConf.HasConfExInfo())
	{
		u8 abyConfInfExBuf[CONFINFO_EX_BUFFER_LENGTH] = {0};
		u16 wPackDataLen = 0;
		PackConfInfoEx(m_tConfEx,abyConfInfExBuf,wPackDataLen);
		cServMsg.CatMsgBody(abyConfInfExBuf, wPackDataLen);
	}

    g_cNPlusApp.PostMsgToNPlusDaemon(VC_NPLUS_MSG_NOTIF, cServMsg.GetServMsg(), cServMsg.GetServMsgLen());

    return;
}

/*=============================================================================
函 数 名： ProcNPlusConfMtInfoUpdate
功    能： N+1备份终端信息同步
算法实现： 
全局变量： 
参    数： void
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/11/22  4.0			许世林                  创建
=============================================================================*/
void CMcuVcInst::ProcNPlusConfMtInfoUpdate(void)
{
    TMtInfo atMtInConf[MAXNUM_CONF_MT];
    u8 byIdx = 0;
    u16 wDialBitrate;
    TMtAlias tTmpAlias;

	TSmcuCallnfo atSmcuInfo[MAXNUM_SUB_MCU];
	u8 bySmcuNum = 0;
    for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
    {
        //只保存 已经加入会议的非上级MCU 终端 [12/20/2006-zbq]
        if ( !m_tConfAllMtInfo.MtJoinedConf(byMtId) || 
             MT_TYPE_MMCU == m_ptMtTable->GetMt(byMtId).GetMtType() ||
			 MT_TYPE_VRSREC == m_ptMtTable->GetMtType(byMtId))
        {
            continue;
        }

        if (m_ptMtTable->GetMtAlias(byMtId, mtAliasTypeTransportAddress, &tTmpAlias))
        {          
            atMtInConf[byIdx].SetMtAddr(tTmpAlias.m_tTransportAddr);
			//呼叫码率应减去主音频格式码率[6/22/2013 chendaiwei]
			wDialBitrate = m_ptMtTable->m_atMtExt[byMtId - 1].GetDialBitRate() - GetAudioBitrate(m_tConf.GetMainAudioMediaType());
            //wDialBitrate = m_ptMtTable->GetDialBitrate(byMtId);
            atMtInConf[byIdx].SetCallBitrate(wDialBitrate);            
            byIdx++;

			TMtAlias tSmcuAlias;
			m_ptMtTable->GetDialAlias(byMtId,&tSmcuAlias);
			if(m_ptMtTable->GetMtType(byMtId) == MT_TYPE_SMCU
				&& tSmcuAlias.m_AliasType == mtAliasTypeE164)
			{
				atSmcuInfo[bySmcuNum].SetE164Alias(tSmcuAlias.m_achAlias);
				atSmcuInfo[bySmcuNum].SetMcuAddr(tTmpAlias.m_tTransportAddr);
				bySmcuNum++;
				if( bySmcuNum >= MAXNUM_SUB_MCU )
				{
					break;
				}
			}
        }
        else
        {
            ConfPrint(LOG_LVL_WARNING, MID_MCU_NPLUS, "[ProcNPlusConfMtInfoUpdate] get mt.%d ip addr alias failed.\n", byMtId);
        }
    }

    CServMsg cServMsg;
    cServMsg.SetEventId(MCU_NPLUS_CONFMTUPDATE_REQ);
    cServMsg.SetConfId(m_tConf.GetConfId());
    cServMsg.SetMsgBody((u8*)atMtInConf, sizeof(TMtInfo)*byIdx);
    g_cNPlusApp.PostMsgToNPlusDaemon(VC_NPLUS_MSG_NOTIF, cServMsg.GetServMsg(), cServMsg.GetServMsgLen());

	CServMsg cSmcuMsg;
	cSmcuMsg.SetEventId(MCU_NPLUS_SMCUINFOUPDATE_REQ);
	cSmcuMsg.SetConfId(m_tConf.GetConfId());
	cSmcuMsg.SetMsgBody((u8*)atSmcuInfo, sizeof(TSmcuCallnfo)*bySmcuNum);
	g_cNPlusApp.PostMsgToNPlusDaemon(VC_NPLUS_MSG_NOTIF, cSmcuMsg.GetServMsg(), cSmcuMsg.GetServMsgLen());

    return;
}

/*=============================================================================
函 数 名： ProcNPlusChairmanUpdate
功    能： N+1备份主席同步
算法实现： 
全局变量： 
参    数： void
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/11/22  4.0			许世林                  创建
=============================================================================*/
void CMcuVcInst::ProcNPlusChairmanUpdate(void)
{
    TMtAlias tTmpAlias;
    TMt tTmpMt = m_tConf.GetChairman();  
    if (!tTmpMt.IsNull())
    {
        if (!m_ptMtTable->GetMtAlias(tTmpMt.GetMtId(), mtAliasTypeTransportAddress, &tTmpAlias))        
        {
            ConfPrint(LOG_LVL_WARNING, MID_MCU_NPLUS, "[ProcNPlusChairmanUpdate] get chairman ip addr alias failed.\n");
        }
    }

    CServMsg cServMsg;
    cServMsg.SetEventId(MCU_NPLUS_CHAIRUPDATE_REQ);
    cServMsg.SetConfId(m_tConf.GetConfId());
    cServMsg.SetMsgBody((u8*)&tTmpAlias, sizeof(tTmpAlias));
    g_cNPlusApp.PostMsgToNPlusDaemon(VC_NPLUS_MSG_NOTIF, cServMsg.GetServMsg(), cServMsg.GetServMsgLen());

    return;
}

/*=============================================================================
函 数 名： ProcNPlusSpeakerUpdate
功    能： N+1备份发言人同步
算法实现： 
全局变量： 
参    数： void
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/11/22  4.0			许世林                  创建
=============================================================================*/
void CMcuVcInst::ProcNPlusSpeakerUpdate(void)
{
    TMtAlias tTmpAlias;
    TMt tTmpMt = m_tConf.GetSpeaker();  
    if (!tTmpMt.IsNull())
    {
		//  [2/21/2011 chendaiwei]增加对下级发言人的备份支持
		if(!tTmpMt.IsLocal())
		{
			s8 achAlias[VALIDLEN_ALIAS] = {0};
			if( GetMtAlias(tTmpMt, achAlias) )
			{
				tTmpAlias.SetH323Alias(achAlias);						
			}
			else
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_NPLUS, "[ProcNPlusSpeakerUpdate] get smcu speaker alias failed.\n");
			}
		}
		else
		{
			if (!m_ptMtTable->GetMtAlias(tTmpMt.GetMtId(), mtAliasTypeTransportAddress, &tTmpAlias))
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_NPLUS, "[ProcNPlusSpeakerUpdate] get speaker ip addr alias failed.\n");
			}
		}
    }

    CServMsg cServMsg;
    cServMsg.SetEventId(MCU_NPLUS_SPEAKERUPDATE_REQ);
    cServMsg.SetConfId(m_tConf.GetConfId());
    cServMsg.SetMsgBody((u8*)&tTmpAlias, sizeof(tTmpAlias));
    g_cNPlusApp.PostMsgToNPlusDaemon(VC_NPLUS_MSG_NOTIF, cServMsg.GetServMsg(), cServMsg.GetServMsgLen());

    return;
}

/*=============================================================================
函 数 名： ProcNPlusVmpUpdate
功    能： N+1备份vmp信息同步
算法实现： 
全局变量： 
参    数： void
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/11/22  4.0			许世林                  创建
=============================================================================*/
void CMcuVcInst::ProcNPlusVmpUpdate(void)
{ 
    TNPlusConfData tConfData;
	TNPlusVmpParam tNplusVmpParam[MAXNUM_PERIEQP];
	u8 byVmpNum = 0;
	
    GetNPlusDataFromConf( tConfData,&tNplusVmpParam[0],byVmpNum);

	CServMsg cServMsg;
    cServMsg.SetEventId(MCU_NPLUS_VMPUPDATE_REQ);
    cServMsg.SetConfId(m_tConf.GetConfId());
	cServMsg.SetMsgBody((u8*)&tConfData.m_tVmpInfo, sizeof(tConfData.m_tVmpInfo)); 
    cServMsg.CatMsgBody((u8*)&tConfData.m_tConf.m_tStatus.m_tVMPParam, sizeof(tConfData.m_tConf.m_tStatus.m_tVMPParam)); 

	cServMsg.CatMsgBody((u8*)&byVmpNum,sizeof(byVmpNum));
	for( u8 byIdx = 0; byIdx < byVmpNum; byIdx ++ )
	{
		cServMsg.CatMsgBody((u8*)&tNplusVmpParam[byIdx].m_tVmpBaiscParam,sizeof(tNplusVmpParam[byIdx].m_tVmpBaiscParam));
		u8 byChnNum = tNplusVmpParam[byIdx].m_tVmpBaiscParam.GetMaxMemberNum();
		cServMsg.CatMsgBody((u8*)&byChnNum,sizeof(u8));
		cServMsg.CatMsgBody((u8*)&tNplusVmpParam[byIdx].m_tVmpMemer.m_tVmpChnnlInfo[0],byChnNum*sizeof(TNPlusVmpChnlMember));
	}
	
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_NPLUS, "[ProcNPlusVmpUpdate] conf:%s VmpNum:%d\n", m_tConf.GetConfName(),byVmpNum);

    g_cNPlusApp.PostMsgToNPlusDaemon(VC_NPLUS_MSG_NOTIF, cServMsg.GetServMsg(), cServMsg.GetServMsgLen());

    return;
}

/*=============================================================================
函 数 名： ProcNPlusAutoMixUpdate
功    能： N+1备份智能混音信息同步
算法实现： 
全局变量： 
参    数： BOOL32 bStart 是表示开启智能混音，否表示关闭智能混音
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2010/09/26  			陈代伟                  创建
=============================================================================*/
void CMcuVcInst::ProcNPlusAutoMixUpdate(BOOL32 bStart)
{ 
    CServMsg cServMsg;
    cServMsg.SetEventId(MCU_NPLUS_AUTOMIXUPDATE_REQ);
    cServMsg.SetConfId(m_tConf.GetConfId());
    cServMsg.SetMsgBody((u8*)&bStart, sizeof(bStart)); 
    g_cNPlusApp.PostMsgToNPlusDaemon(VC_NPLUS_MSG_NOTIF, cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
	
    return;
}

/*=============================================================================
  函 数 名： AdjustConfRecByBrdSrc
  功    能： 调整会议录像状态
  算法实现： 无广播源时，设置定时器，3s内如果都无广播源则停止会议录像（会议内部停止录像）；
             有广播源时恢复会议录像
  全局变量： 
  参    数： void
  返 回 值： void 
  ---------------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  20100929      4.6         pengjie                create
=============================================================================*/
void CMcuVcInst::AdjustConfRecByBrdSrc( void )
{
	CServMsg cServMsg;
	TMt tMt;
	tMt.SetNull();
	cServMsg.SetChnIndex( m_byRecChnnl );
	cServMsg.SetMsgBody( (u8*)&tMt, sizeof( tMt ) );
	cServMsg.CatMsgBody( (u8*)&m_tRecEqp, sizeof( m_tRecEqp ) );

	BOOL32 bIsNeedPauseRec = FALSE;
	if( m_tRecPara.IsRecDStream() )
	{
		// 若需要录双流，还需判断双流源
		if( GetVidBrdSrc().IsNull() && GetAudBrdSrc().IsNull() && m_tDoubleStreamSrc.IsNull() )
		{
			bIsNeedPauseRec = TRUE;
		}
	}
	else
	{
		if( GetVidBrdSrc().IsNull() && GetAudBrdSrc().IsNull() )
		{
			bIsNeedPauseRec = TRUE;
		}
	}

	// 会议无广播源，开启定时器，定时器到了还没广播源就暂停
	if( bIsNeedPauseRec )
	{
		SetTimer( MCUVC_CHECK_CONFBRDSRC_TIMER, 5000 );
	}
	else
	{	
		// 若现在已经暂停了，就恢复录像
		if( m_tConf.m_tStatus.IsRecPauseByInternal() )
		{
			if (m_tRecEqp.GetType() == TYPE_MT && m_tRecEqp.GetMtType() == MT_TYPE_VRSREC)
			{
				// vrs新录播支持,恢复录像
				TMt tRecSrc = GetVidBrdSrc();
				NotifyMtReceive(tRecSrc, m_tRecEqp.GetMtId());
			}
			else
			{
				SendMsgToEqp( m_tRecEqp.GetEqpId(), MCU_REC_RESUMEREC_REQ, cServMsg );
			}
		}
		// 如果定时器未到就有了广播源，清掉定时器
		KillTimer( MCUVC_CHECK_CONFBRDSRC_TIMER );
	}

	return;
}

/*=============================================================================
  函 数 名： AdjustRecordSrcStream
  功    能： 会议录像 录像机 录码流 调整
  算法实现： 
  全局变量： 
  参    数： u8    byMode   : MODE_VIDEO, MODE_AUDIO, MODE_SECVIDEO
			 bIsStart TRUE/FALSE
  返 回 值： void 
  ---------------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2007/06/07    4.0			张宝卿                  创建
  2007/06/12    4.0         顾振华                  修改
  2011/07/20    4.6         zhangli                 修改
=============================================================================*/
void CMcuVcInst::AdjustConfRecordSrcStream(u8 byMode, BOOL32 bIsStart)
{
	if (m_tRecEqp.IsNull())
	{
		return;
	}

	if (MODE_SECVIDEO == byMode)
	{
		if (m_tDoubleStreamSrc.IsNull() || !m_tRecPara.IsRecDStream())
		{
			return;
		}
	}
	else if (MODE_BOTH == byMode)
	{
		AdjustConfRecordSrcStream(MODE_AUDIO, bIsStart);
		AdjustConfRecordSrcStream(MODE_VIDEO, bIsStart);
		return;
	}

	TMt tRealSrc;
	u8 byRecChnlIdx = 0;
	u8 byBasChnId = 0;
	BOOL32 bNeedBas = IsRecordSrcBas(byMode, tRealSrc, byBasChnId, byRecChnlIdx);

	ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_REC, "%d=IsRecordSrcBas(Mode.%d, Src.[%d,%d], Chnnl.%d, OutChnnl.%d)\n", 
		bNeedBas, byMode, tRealSrc.GetMcuId(), tRealSrc.GetMtId(), byBasChnId, byRecChnlIdx);

	if (tRealSrc.IsNull())
	{
		return;
	}

	BOOL32 bVrsRecMt = (m_tRecEqp.GetType() == TYPE_MT && m_tRecEqp.GetMtType() == MT_TYPE_VRSREC);

	//建交换
	if (bIsStart)
	{
		if (MODE_AUDIO == byMode)
		{
// 			if ( IsRecNeedAdapt(MODE_AUDIO) )
// 			{
// 				TRecBasChn tAudBasChn;
// 				if ( m_cRecAdaptMgr.IsExistRecBasChn( MODE_AUDIO,tAudBasChn ) )
// 				{
// 					SetBasChnSrc(tAudBasChn.m_tBas, tAudBasChn.m_byChnId, m_tDoubleStreamSrc);
// 					ChangeAdapt(tAudBasChn.m_tBas, tAudBasChn.m_byChnId);
// 					BOOL32 bStateReady = g_cMcuVcApp.GetBasChnStatus(tAudBasChn.m_tBas, tAudBasChn.m_byChnId) == BASCHN_STATE_READY? TRUE:FALSE;
// 					if ( !bStateReady )
// 					{
// 						TAudioTypeDesc tAudCap;
// 						if ( !m_cRecAdaptMgr.GetRecAudCapSet(tAudCap) )
// 						{
// 							ConfPrint(LOG_LVL_ERROR, MID_MCU_REC, "[AdjustConfRecordSrcStream]GetRecAudCapSet failed\n");	
// 							return;
// 						}
// 						TBasOutInfo tOutInfo;
// 						TMt tRecAudSrc = GetAudBrdSrc();
// 						if (FindBasChnByAudCapForSel(tRecAudSrc, tAudCap, tOutInfo))
// 						{
// 							// 建立从适配器到录像机的交换
// 							StartSwitchToPeriEqp(tOutInfo.m_tBasEqp, tOutInfo.m_byFrontOutNum +  tOutInfo.m_byOutIdx, 
// 								m_tRecEqp.GetEqpId(), m_byRecChnnl, MODE_AUDIO, SWITCH_MODE_SELECT, FALSE, TRUE);
// 						}
// 						else
// 						{
// 							ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[AdjustConfRecordSrcStream]FindBasChnByAudCapForSel failed, please check it\n");		
// 						}
// 					}
// 				}
// 			}
// 			else 
			if (bNeedBas)			//会议录像占用广播适配通道
			{
				//音频适配录像记录下该广播BAS通道
				if ( IsRecNeedAdapt(MODE_AUDIO) )
				{
					TRecBasChn tAudBasChn;
					tAudBasChn.m_tBas = tRealSrc;
					tAudBasChn.m_byChnId = byBasChnId;
					m_cRecAdaptMgr.AddRecBasChn(MODE_AUDIO,tAudBasChn);
				}

				if (m_tConf.m_tStatus.IsAudAdapting())
				{
					StartSwitchToRecorder(tRealSrc, byRecChnlIdx, m_tRecEqp, m_byRecChnnl, MODE_AUDIO, 
							SWITCH_MODE_BROADCAST,TRUE,FALSE);
					/*if (bVrsRecMt)
					{
						StartSwitchToSubMtFromAdp(m_tRecEqp.GetMtId(), MODE_AUDIO);
					}
					else
					{
						StartSwitchToPeriEqp(tRealSrc, byRecChnlIdx, m_tRecEqp.GetEqpId(), m_byRecChnnl, MODE_AUDIO, 
							SWITCH_MODE_BROADCAST, FALSE, TRUE, FALSE, FALSE);
					}*/
				}
				else
				{
					ChangeAdapt(tRealSrc, byBasChnId);
				}
			}
			else		//不占用适配器
			{
				StartSwitchToRecorder(tRealSrc, byRecChnlIdx, m_tRecEqp, m_byRecChnnl, MODE_AUDIO, 
					SWITCH_MODE_BROADCAST,TRUE,FALSE);
				/*if (bVrsRecMt)
				{
					TSwitchGrp tSwitchGrp;
					tSwitchGrp.SetSrcChnl(byRecChnlIdx);
					tSwitchGrp.SetDstMtNum(1);
					tSwitchGrp.SetDstMt(&m_tRecEqp);			
					StartSwitchToAll(tRealSrc, 1, &tSwitchGrp, MODE_AUDIO);
				}
				else
				{
					StartSwitchToPeriEqp(tRealSrc, byRecChnlIdx, m_tRecEqp.GetEqpId(), m_byRecChnnl, MODE_AUDIO, 
						SWITCH_MODE_BROADCAST, FALSE, TRUE, FALSE, FALSE);
				}*/
				if ( IsRecNeedAdapt(MODE_AUDIO) )
				{
					m_cRecAdaptMgr.ClearBasChnForAud();
				}
			}
		}
		else if (MODE_VIDEO == byMode)
		{
			//[nizhijun 2012/06/29] 录像机适配录像，如果源是VMP，不走BAS，直接收VMP的相关码流。
			if ( IsRecAdaptUseBas() )	//会议适配录像
			{
				TRecBasChn tVidBasChn;
				if ( m_cRecAdaptMgr.IsExistRecBasChn( MODE_VIDEO,tVidBasChn ) )
				{
					SetBasChnSrc(tVidBasChn.m_tBas, tVidBasChn.m_byChnId, GetVidBrdSrc());
					ChangeAdapt(tVidBasChn.m_tBas, tVidBasChn.m_byChnId);
				
					//[nizhijun 2012/06/29] 如果BAS状态已经开启，那么需要补建BAS到录像机的RTP交换以及相关RTCP交换
					BOOL32 bStateReady = g_cMcuVcApp.GetBasChnStatus(tVidBasChn.m_tBas, tVidBasChn.m_byChnId) == BASCHN_STATE_READY? TRUE:FALSE;
					if ( !bStateReady )
					{
						TVideoStreamCap tVidCap;
						if ( !m_cRecAdaptMgr.GetRecVideoCapSet(MODE_VIDEO,tVidCap) )
						{
							ConfPrint(LOG_LVL_ERROR, MID_MCU_REC, "[AdjustConfRecordSrcStream]GetRecVideoCapSet for vid failed\n");	
							return;
						}
						TBasOutInfo tOutInfo;
						TMt tRecTempSrc = GetLocalVidBrdSrc();
						if (FindBasChnByVidCapForSel(tRecTempSrc, tVidCap, MODE_VIDEO, tOutInfo))
						{
							StartSwitchToRecorder(tOutInfo.m_tBasEqp, tOutInfo.m_byFrontOutNum +  tOutInfo.m_byOutIdx,
								m_tRecEqp, m_byRecChnnl, MODE_VIDEO, SWITCH_MODE_SELECT,TRUE,TRUE);
							/*if (bVrsRecMt)
							{
								StartSwitchToSubMtFromAdp(m_tRecEqp.GetMtId(), MODE_VIDEO);
							}
							else
							{
								// 建立从适配器到录像机的交换
								StartSwitchToPeriEqp(tOutInfo.m_tBasEqp, tOutInfo.m_byFrontOutNum +  tOutInfo.m_byOutIdx, 
									m_tRecEqp.GetEqpId(), m_byRecChnnl, MODE_VIDEO, SWITCH_MODE_SELECT, FALSE, TRUE);
							}*/
						}
						else
						{
							ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[AdjustConfRecordSrcStream]FindBasChnByCapForSel failed, please check it\n");		
						}
					}
				}
			}
			else if (bNeedBas)					//需要占用广播适配通道
			{
				if (m_tConf.m_tStatus.IsVidAdapting())
				{
					if (m_tRecPara.IsRecLowStream())
					{
						RefreshBasParamForLowBrUse();
					}
					StartSwitchToRecorder(tRealSrc, byRecChnlIdx, m_tRecEqp, m_byRecChnnl, byMode, 
						SWITCH_MODE_BROADCAST,TRUE,FALSE);
					/*if (bVrsRecMt)
					{
						StartSwitchFromBrd(tRealSrc, byRecChnlIdx, 1, &m_tRecEqp);
					}
					else
					{
						StartSwitchToPeriEqp(tRealSrc, byRecChnlIdx, m_tRecEqp.GetEqpId(), m_byRecChnnl, byMode, 
							SWITCH_MODE_BROADCAST, FALSE, TRUE, FALSE, FALSE);
					}*/
				}
				else
				{
					ChangeAdapt(tRealSrc, byBasChnId);
				}
			}
			else			//不占用适配器
			{
				StartSwitchToRecorder(tRealSrc, byRecChnlIdx, m_tRecEqp, m_byRecChnnl, byMode, 
					SWITCH_MODE_BROADCAST,TRUE,FALSE);
				/*if (bVrsRecMt)
				{
					StartSwitchFromBrd(tRealSrc, byRecChnlIdx, 1, &m_tRecEqp);
				}
				else
				{
					StartSwitchToPeriEqp(tRealSrc, byRecChnlIdx, m_tRecEqp.GetEqpId(), m_byRecChnnl, byMode, 
						SWITCH_MODE_BROADCAST, FALSE, TRUE, FALSE, FALSE);
				}*/
			}
		}
		else if (MODE_SECVIDEO == byMode)
		{
			if ( IsRecNeedAdapt(MODE_SECVIDEO) )
			{
				TRecBasChn tDsBasChn;
				if ( m_cRecAdaptMgr.IsExistRecBasChn( MODE_SECVIDEO,tDsBasChn ) )
				{
					SetBasChnSrc(tDsBasChn.m_tBas, tDsBasChn.m_byChnId, m_tDoubleStreamSrc);
					ChangeAdapt(tDsBasChn.m_tBas, tDsBasChn.m_byChnId);
					BOOL32 bStateReady = g_cMcuVcApp.GetBasChnStatus(tDsBasChn.m_tBas, tDsBasChn.m_byChnId) == BASCHN_STATE_READY? TRUE:FALSE;
					if ( !bStateReady && !m_tDoubleStreamSrc.IsNull())
					{
						TVideoStreamCap tSecVidCap;
						if ( !m_cRecAdaptMgr.GetRecVideoCapSet(MODE_SECVIDEO,tSecVidCap) )
						{
							ConfPrint(LOG_LVL_ERROR, MID_MCU_REC, "[AdjustConfRecordSrcStream]GetRecVideoCapSet for sec vid failed\n");	
							return;
						}
						TBasOutInfo tOutInfo;
						TMt tRecTempSrc = m_tDoubleStreamSrc;
						if (FindBasChnByVidCapForSel(tRecTempSrc, tSecVidCap, MODE_SECVIDEO, tOutInfo))
						{
							u16 wSrcChn = m_tPlayEqp == m_tDoubleStreamSrc ? m_byPlayChnnl : 0;
							StartSwitchToPeriEqp(tRecTempSrc, wSrcChn, tOutInfo.m_tBasEqp.GetEqpId(), tOutInfo.m_byChnId, MODE_SECVIDEO, SWITCH_MODE_BROADCAST, TRUE, TRUE, FALSE, FALSE);
							
							StartSwitchToRecorder(tOutInfo.m_tBasEqp, tOutInfo.m_byFrontOutNum +  tOutInfo.m_byOutIdx,
								m_tRecEqp, m_byRecChnnl, MODE_SECVIDEO, SWITCH_MODE_SELECT,TRUE,TRUE);
							/*if (bVrsRecMt)
							{
								StartSwitchToSubMtFromAdp(m_tRecEqp.GetMtId(), MODE_SECVIDEO);
							}
							else
							{
								// 建立从适配器到录像机的交换
								StartSwitchToPeriEqp(tOutInfo.m_tBasEqp, tOutInfo.m_byFrontOutNum +  tOutInfo.m_byOutIdx, 
									m_tRecEqp.GetEqpId(), m_byRecChnnl, MODE_SECVIDEO, SWITCH_MODE_SELECT, FALSE, TRUE);
							}*/
						}
						else
						{
							ConfPrint(LOG_LVL_ERROR, MID_MCU_REC, "[AdjustConfRecordSrcStream]FindBasChnByCapForSel failed, please check it\n");		
						}
					}
				}
				else
				{
					ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[AdjustConfRecordSrcStream]IsExistRecBasChn for secvideo failed!\n");
				}

			}
			else if (bNeedBas)					//需要占用广播适配通道
			{
				TRecBasChn tAudBasChn;
				tAudBasChn.m_tBas = tRealSrc;
				tAudBasChn.m_byChnId = byBasChnId;
				m_cRecAdaptMgr.AddRecBasChn(byMode,tAudBasChn);
				if (m_tConf.m_tStatus.IsDSAdapting())
				{
					StartSwitchToRecorder(tRealSrc, byRecChnlIdx, m_tRecEqp, m_byRecChnnl, byMode, 
						SWITCH_MODE_BROADCAST,TRUE,FALSE);
					//StartSwitchToPeriEqp(tRealSrc, byRecChnlIdx, m_tRecEqp.GetEqpId(), m_byRecChnnl, byMode, 
					//	SWITCH_MODE_BROADCAST, FALSE, TRUE, FALSE, FALSE);
				}
			}
			else
			{
				StartSwitchToRecorder(tRealSrc, byRecChnlIdx, m_tRecEqp, m_byRecChnnl, byMode, 
					SWITCH_MODE_SELECT,TRUE,FALSE);
				/*if (bVrsRecMt)
				{
					TSwitchGrp tSwitchGrp;
					tSwitchGrp.SetSrcChnl(0);
					tSwitchGrp.SetDstMtNum(1);
					tSwitchGrp.SetDstMt(&m_tRecEqp);
					
					StartSwitchToAll(tRealSrc, 1, &tSwitchGrp, MODE_VIDEO2SECOND, SWITCH_MODE_SELECT);
				}
				else
				{
					StartSwitchToPeriEqp(tRealSrc, byRecChnlIdx, m_tRecEqp.GetEqpId(), m_byRecChnnl, byMode, 
						SWITCH_MODE_SELECT, FALSE, TRUE, FALSE, FALSE);
				}*/
			}
		}
	}
	else
	{
		StopSwitchToRecorder(m_tRecEqp, m_byRecChnnl, FALSE, byMode);
		/*if (bVrsRecMt)
		{
			StopSwitchToSubMt(1, &m_tRecEqp, byMode, FALSE);
		}
		else
		{
			StopSwitchToPeriEqp(m_tRecEqp.GetEqpId(), m_byRecChnnl, FALSE, byMode);
		}*/
		if ( IsRecNeedAdapt(MODE_AUDIO) )
		{
			m_cRecAdaptMgr.ClearBasChnForAud();
		}
	}

	TConfAttrb tTempAttrb = m_tConf.GetConfAttrb();
	if (!tTempAttrb.IsResendLosePack())
	{
		return;
	}

	//[nizhijun 2012/06/29] 录像机适配录像，如果源是VMP，不走BAS，直接收VMP的相关码流。
	if (MODE_VIDEO == byMode && IsRecAdaptUseBas())
	{
		return;
	}
	
	AddRemoveRecRtcp(byMode, m_tRecEqp, m_byRecChnnl, tRealSrc, byRecChnlIdx, bIsStart);
}

/*=============================================================================
  函 数 名： AdjustMtRecSrcStream
  功    能： 终端录像 录像机 录码流 调整
  算法实现： 
  全局变量： 
  参    数： u8		byMode：MODE_VIDEO, MODE_AUDIO, MODE_SECVIDEO
			 const	TEqp &tEqp：录像机
			 const	TMt &tSrc：被录像的终端
			 u8		byRecChl：录像机通道
			 BOOL32 bIsStart：TRUE/FALSE			 
  返 回 值： void 
  ---------------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2007/06/20    4.6			zhangli                  创建
  2012/06/12    4.7			nizhijun				修改
=============================================================================*/
void CMcuVcInst::AdjustMtRecSrcStream(u8 byMode, const TEqp &tEqp, u8 byRecChl, const TMt &tSrc, BOOL32 bIsStart)
{
	//该接口需要作出以下调整：
	//1.终端录像的RTCP不需要MCU建立交换，而是在开启录像的时候告知录像机相关RTCP信息，让录像机直接向源请求
	//2.终端录像，录双流时，只能录该终端的双流，其他终端的双流不进行录取，目前还不支持下级终端录双流只录该终端的功能
	if (MODE_BOTH == byMode)
	{
		AdjustMtRecSrcStream(MODE_VIDEO, tEqp, byRecChl, tSrc, bIsStart);
		AdjustMtRecSrcStream(MODE_AUDIO, tEqp, byRecChl, tSrc, bIsStart);
		return;
	}
	else if (MODE_SECVIDEO == byMode)
	{
		if (m_tDoubleStreamSrc.IsNull())
		{
			return;
		}
	}

	BOOL32 bIsVrsRec = FALSE;
	TMt tVrsRec;
	if(tEqp.GetType() == TYPE_MT && tEqp.GetMtType() == MT_TYPE_VRSREC)
	{
		bIsVrsRec = TRUE;
		tVrsRec = tEqp;
	}
	
	if (!bIsStart)
	{
		StopSwitchToRecorder(tEqp, byRecChl, FALSE, byMode);
		/*if (bIsVrsRec)
		{
			// 拆到vrsrec交换
			StopSwitchToSubMt(1, &tVrsRec, byMode);
		}
		else
		{
			StopSwitchToPeriEqp(tEqp.GetEqpId(), byRecChl, FALSE, byMode);
		}*/
	}
	else
	{
		u8 bySrcChnnl = 0;
		
		if (MODE_SECVIDEO == byMode)
		{
			TMt  tRecSrc = GetLocalMtFromOtherMcuMt(tSrc);
			if ( tRecSrc == m_tDoubleStreamSrc  )
			{
				StartSwitchToRecorder(tSrc, bySrcChnnl, tEqp, byRecChl, byMode, 
					SWITCH_MODE_SELECT,TRUE,FALSE);
				/*if (bIsVrsRec)
				{
					TSwitchGrp tSwitchGrp;
					tSwitchGrp.SetSrcChnl(0);
					tSwitchGrp.SetDstMtNum(1);
					tSwitchGrp.SetDstMt(&tVrsRec);
					
					StartSwitchToAll(tSrc, 1, &tSwitchGrp, MODE_VIDEO2SECOND, SWITCH_MODE_SELECT);
				}
				else
				{
					StartSwitchToPeriEqp(tSrc, bySrcChnnl, tEqp.GetEqpId(), byRecChl, byMode, 
						SWITCH_MODE_SELECT, FALSE, TRUE, FALSE, FALSE);
				}*/
				
				TConfAttrb tTempAttrb = m_tConf.GetConfAttrb();
				//终端双流录像告知录像机RTCP信息
				if ( tTempAttrb.IsResendLosePack() )
				{
					if (bIsVrsRec)
					{
						// 建rtcp交换
						BuildRtcpSwitchForSrcToDst(tSrc, tVrsRec, MODE_SECVIDEO);
					}
					else
					{
						TRecRtcpBack  tRecRtcpBack;
						TTransportAddr tRtcpAddr;
						if ( !GetRemoteRtcpAddr(tSrc,0,MODE_SECVIDEO,tRtcpAddr) )
						{
							LogPrint(LOG_LVL_ERROR,MID_MCU_PRS,"[AdjustMtRecSrcStream]GetRemoteRtcpAddr RecSrc:%d-%d failed\n",tSrc.GetMcuId(),tSrc.GetMtId());
						}
						else
						{
							TEqp tRecEqp = tEqp;
							u8	 byIndex = 0;//byIndex=0双流；byIndex=1第一路音视频；byIndex=2第二路音视频...
							tRecRtcpBack.SetDStreamAddr(tRtcpAddr.GetIpAddr(), tRtcpAddr.GetPort());
							
							LogPrint(LOG_LVL_DETAIL,MID_MCU_PRS,"[AdjustMtRecSrcStream]byMode:%d,tRecEqp:%d-%d,byIndex:%d,tRecSrc:%d-%d,rtcpip:%d,rtcpport:%d\n",
								byMode,tRecEqp.GetMcuId(),tRecEqp.GetMtId(),byIndex,
								tSrc.GetMcuId(),tSrc.GetMtId(),tRtcpAddr.GetIpAddr(),tRtcpAddr.GetPort()
								);
							
							CServMsg cServMsg;
							cServMsg.SetMsgBody((u8 *)&tRecEqp, sizeof(TEqp));
							cServMsg.CatMsgBody((u8 *)&byIndex, sizeof(u8));
							cServMsg.CatMsgBody((u8 *)&tRecRtcpBack, sizeof(TRecRtcpBack));
							SendMsgToEqp(tRecEqp.GetEqpId(), MCU_REC_SETRTCP_NFY, cServMsg);
						}
					}
				}
			}
			else
			{
				LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_REC,"[AdjustMtRecSrcStream]tRecSrc:%d-%d is equal to m_tDoubleStreamSrc,so no need to add switch\n");
				return;
			}		
		}
		else
		{
			StartSwitchToRecorder(tSrc, bySrcChnnl, tEqp, byRecChl, byMode, 
				SWITCH_MODE_SELECT,TRUE,FALSE);
			/*if (bIsVrsRec)
			{
				// 建交换
				TSwitchGrp tSwitchGrp;
				tSwitchGrp.SetSrcChnl(0);
				tSwitchGrp.SetDstMtNum(1);
				tSwitchGrp.SetDstMt(&tVrsRec);
				
				StartSwitchToAll(tSrc, 1, &tSwitchGrp, byMode, SWITCH_MODE_SELECT);
			}
			else
			{
				StartSwitchToPeriEqp(tSrc, bySrcChnnl, tEqp.GetEqpId(), byRecChl, byMode, 
					SWITCH_MODE_SELECT, FALSE, TRUE, FALSE, FALSE);
			}*/
		}		
	}
}

/*=============================================================================
  函 数 名： AddRemoveRecRtcp
  功    能： 拆建录像机到PRS/SRC的RTCP交换
  算法实现： 
  全局变量： 
  参    数： u8		byMode：MODE_VIDEO, MODE_AUDIO, MODE_SECVIDEO
			 const	TEqp &tEqp：录像机
			 const	TMt &tSrc：被录像的终端
			 u8		byRecChl：录像机通道
			 u8		byRecChnlIdx：需要适配占用bas通道索引，不占用bas则=0
			 BOOL32 isAdd：TRUE建/FALSE拆
			 BOOL32 bIsConfRec：TRUE会议录像/FALSE终端录像
  返 回 值： void 
  ---------------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2007/06/07    4.0			zhangli                  创建
=============================================================================*/
void CMcuVcInst::AddRemoveRecRtcp(u8 byMode, const TEqp &tEqp, u8 byRecChl, const TMt &tSrc, u8 byRecChnlIdx, BOOL32 isAdd)
{
	TConfAttrb tTempAttrb = m_tConf.GetConfAttrb();
	if (!tTempAttrb.IsResendLosePack())
	{
		return;
	}

	TMt tRealSrc = tSrc;
	if (MODE_SECVIDEO == byMode)
	{
		tRealSrc = m_tDoubleStreamSrc;
	}

	if (tRealSrc.IsNull())
	{
		return;
	}

	//会议录像、双流走广播，建立RTCP：REC------>PRS
	u8 byPrsId = 0;
	u8 byPrsChnnlId = 0;
	
	if(FindPrsChnForSrc(tRealSrc, byRecChnlIdx, byMode, byPrsId, byPrsChnnlId))
	{
		TPeriEqpStatus tPrsStatus;
		if (g_cMcuVcApp.GetPeriEqpStatus(byPrsId, &tPrsStatus))
		{
			BuildRtcpSwitchForSrcToDst(tEqp, TEqp(tPrsStatus), byMode, byRecChl, byPrsChnnlId, isAdd);
		}
	}
	else
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "[AdjustRecordSrcStream]FindPrsChnForSrc<McuId:%d, MtId:%d, Type:%d> failed!\n", 
			tRealSrc.GetMcuId(), tRealSrc.GetMtId(), tRealSrc.GetType());
	}
}

/*=============================================================================
  函 数 名： NotifyMtFastUpdate
  功    能： 请求VCU，只能发送给指定终端
  算法实现： 
  全局变量： 
  参    数： byMode:      MODE_VIDEO 或 MODE_SECVIDEO
  返 回 值： void 
  ---------------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2007/07/27    4.0         顾振华                  修改
=============================================================================*/
void CMcuVcInst::NotifyMtFastUpdate( u8 byMtId, u8 byMode, BOOL32 bSetTimer )
{    
    u32 dwCurTick = OspTickGet();

	//xliang [080802] add print for vga ds test
	BOOL32 bIsSecVideo = FALSE;
	if( byMode==MODE_SECVIDEO )
	{
		bIsSecVideo = TRUE;
	}

	u32 dwCurTickInterval = dwCurTick - m_ptMtTable->GetLastTick(byMtId,bIsSecVideo);

	u8 byFastUpdateNum = 4; //发言人请求最多四次关键帧，默认值[4/6/2012 chendaiwei]
	//发言人请求次数由配置文件决定[4/6/2012 chendaiwei]
	if(m_tConf.GetSpeaker().IsLocal() && m_tConf.GetSpeaker().GetMtId() == byMtId)
	{
		byFastUpdateNum = g_cMcuVcApp.GetFastUpdateToSpeakerNum();

		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CALL, "[NotifyMtFastUpdate] Ask IFR to Speaker for [%d] times!\n",g_cMcuVcApp.GetFastUpdateToSpeakerNum());
	}

	ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[NotifyMtFastUpdate] the MtId is: %u, the video mode is: %u \n",byMtId,byMode);
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[NotifyMtFastUpdate] the cur tick interval is: %u, the VCU interval is: %u\n",dwCurTickInterval,g_dwVCUInterval);
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[NotifyMtFastUpdate] dwCurTick(%u) - GetLastTick(%u) = interval is(%u) g_dwVCUInterval(%u) bSetTimer(%d)\n", 
		dwCurTick, m_ptMtTable->GetLastTick(byMtId), dwCurTick - m_ptMtTable->GetLastTick(byMtId), g_dwVCUInterval, bSetTimer);
    if ( (byMode == MODE_VIDEO && dwCurTick - m_ptMtTable->GetLastTick(byMtId) > g_dwVCUInterval)
         || byMode == MODE_SECVIDEO )
    {
        CServMsg cServMsg;
        cServMsg.SetMsgBody(&byMode, sizeof(u8));
        
        //tandberg屏掉首次请求
        if(MT_MANU_TAIDE == m_ptMtTable->GetManuId(byMtId) &&
		   MODE_VIDEO == byMode)
        {
            bSetTimer = TRUE;
			// 2011-8-4 add by pgf: Bug00059851:第一次取消发言人后，泰德终端掉线
			SendMsgToMt(byMtId, MCU_MT_FASTUPDATEPIC_CMD, cServMsg);
			// 2011-8-4 add end
            ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[NotifyMtFastUpdate] the MtId.%u Fastupdate has been delayed due to MANU.Tandberg\n",byMtId);
        }
        else
        {
            SendMsgToMt(byMtId, MCU_MT_FASTUPDATEPIC_CMD, cServMsg);
			byFastUpdateNum--;

			ConfPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "ask Mt.%d FastUpdate %d\n", byMtId, byMode);

        }
		BOOL32 bIsDoubleStream = FALSE;

		if( byMode==MODE_SECVIDEO )
		{
			bIsDoubleStream = TRUE;
		}
        m_ptMtTable->SetLastTick(byMtId, dwCurTick,bIsDoubleStream);
    }
	
    // 设置定时器，等定时器到强制请求
    if (bSetTimer)
    {
        if (MODE_VIDEO == byMode && byFastUpdateNum > 0)
        {
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[NotifyMtFastUpdate] MODE_VIDEO Request FastUpdate SetTimer Count(%d)\n", byFastUpdateNum);
			SetTimer( MCUVC_FASTUPDATE_TIMER_ARRAY+byMtId, 1200, 100*byMtId+byFastUpdateNum );
        }
        else if (MODE_SECVIDEO == byMode)
        {
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[NotifyMtFastUpdate] MODE_SECVIDEO Request FastUpdate SetTimer Count(%d)\n", byFastUpdateNum);
            SetTimer( MCUVC_SECVIDEO_FASTUPDATE_TIMER, 1200, 100*byMtId+1 );
        }
        else
        {
            ConfPrint( LOG_LVL_WARNING, MID_MCU_MT, "[NotifyMtFastUpdate] unexpected mode.%d, ignore it\n", byMode );
        }
    }
}

/*=============================================================================
  函 数 名： NotifyEqpFastUpdate
  功    能： 请求VCU，只能发给外设
  算法实现： 
  全局变量： 
  参    数： 
  返 回 值： void 
  ---------------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2007/07/27    4.0         顾振华                  修改
=============================================================================*/
void CMcuVcInst::NotifyEqpFastUpdate(const TMt &tDst, u8 byChnl, BOOL32 bSetTimer)
{
    ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[NotifyEqpFastUpdate] the Peri is: %u, the chn is: %u !\n", tDst.GetEqpId(), byChnl);
    
    CServMsg cServMsg;
    u16 wEvent;
    
    u32 dwCurTick = OspTickGet();
    u32 dwLaskTick = 0;
    switch (tDst.GetEqpType())
    {
    case EQP_TYPE_VMP:
        {
            cServMsg.SetChnIndex(byChnl);
            wEvent = MCU_VMP_FASTUPDATEPIC_CMD;
            dwLaskTick = m_dwVmpLastVCUTick;
            if ( dwCurTick - dwLaskTick > g_dwVCUInterval )
            {
                m_dwVmpLastVCUTick = dwCurTick;
            }
            
            SendMsgToEqp(tDst.GetEqpId(), wEvent, cServMsg); 
            return;
        }
        
    case EQP_TYPE_VMPTW:
        wEvent = MCU_VMPTW_FASTUPDATEPIC_CMD;
        /*dwLaskTick = m_dwVmpTwLastVCUTick;
        if ( dwCurTick - dwLaskTick > g_dwVCUInterval )
        {
            m_dwVmpTwLastVCUTick = dwCurTick;
        }*/
        break;

    case EQP_TYPE_BAS:
		{
			cServMsg.SetChnIndex(byChnl);
            wEvent = MCU_BAS_FASTUPDATEPIC_CMD;
            dwLaskTick = GetBasVcuTick(tDst, byChnl);
            if ( dwCurTick - dwLaskTick > g_dwVCUInterval )
            {
                SetBasVcuTick( tDst, byChnl, dwCurTick );
            }
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[NotifyEqpFastUpdate]MCU Send MCU_BAS_FASTUPDATEPIC_CMD to Bas[EqpId.%d, Chnnl.%d]\n", tDst.GetEqpId(), byChnl);
		}
        break;
    case EQP_TYPE_RECORDER:
    default:
        return;
    }
    // 增加对 向外设发送请求关键帧命令的保护, zgc, 2008-04-21
    if ( dwCurTick - dwLaskTick > g_dwVCUInterval )
    {
        SendMsgToEqp(tDst.GetEqpId(), wEvent, cServMsg);  
    }

    // 设置定时器，等定时器到强制请求
    if (bSetTimer)
    {
        u8 byCount = 1;
        u32 dwParam = tDst.GetEqpId() << 16 | byChnl << 8 | byCount;
        SetTimer( MCUVC_FASTUPDATE_TIMER_ARRAY4EQP+tDst.GetEqpId()-MAXNUM_PERIEQP*3, 1200, dwParam );
    }
    return;
}


/*=============================================================================
  函 数 名： NotifyFastUpdate
  功    能： 请求VCU，发送给指定终端、外设
  算法实现： 
  全局变量： 
  参    数： byChnlMode     [in] 对于终端是 MODE_VIDEO 或 MODE_SECVIDEO
                                 对于BAS 是 通道号
                                 对于其他外设没有意义
  返 回 值： void 
  ---------------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2007/07/27    4.0         顾振华                  修改
=============================================================================*/
void CMcuVcInst::NotifyFastUpdate( const TMt &tDst, u8 byChnlMode, BOOL32 bSetTimer )
{
	if (MODE_VIDEO2SECOND == byChnlMode)
	{
		byChnlMode = MODE_VIDEO;
	}

	//zjj20090911 增加类型为mcu
    if (tDst.GetType() == TYPE_MT ||
		tDst.GetType() == TYPE_MCU )  // MT
    {

		TMt tRealDst = tDst;
		if(  tDst.IsLocal() 
			&& m_ptMtTable->GetMtType( tDst.GetMtId() ) == MT_TYPE_SMCU 
			&& MODE_SECVIDEO != byChnlMode)
		{
			if(!m_ptConfOtherMcTable)
			{
				StaticLog("[NotifyFastUpdate]Err, m_ptConfOtherMcTable is null\n");
				return;
			}

			TConfMcInfo *ptInfo = m_ptConfOtherMcTable->GetMcInfo( GetMcuIdxFromMcuId(tDst.GetMtId()) );
			if(ptInfo != NULL)
			{
				tRealDst = ptInfo->m_tMMcuViewMt;
			}			
		}

		// [pengjie 2010/4/15] 增加对非local的处理，支持上层调用直接传非local的Tmt信息
		//TMt tRealDst = tDst;
		

		if( !m_cSMcuSpyMana.IsMtInSpyMember( tRealDst, MODE_VIDEO ) )
		{
			tRealDst = GetLocalMtFromOtherMcuMt( tRealDst );
		}

		ConfPrint( LOG_LVL_DETAIL, MID_MCU_MT, "[NotifyFastUpdate] tRealDst.IsLocal(%d) bSetTimer(%d)\n", tRealDst.IsLocal(), bSetTimer );
		// [pengjie 2010/4/2] 级联多回传，向下级终端发非标的请求关键帧消息
		if( tRealDst.IsLocal() )
		{
			NotifyMtFastUpdate(tRealDst.GetMtId(), byChnlMode, bSetTimer);
		}
		else
		{
			SendMcuMcuSpyFastUpdateCmd( tRealDst, byChnlMode ); 
		}
    }
    else    // Peri Eqp 上级终端不会直接向下级外设请求关键帧的
    {
        NotifyEqpFastUpdate(tDst, byChnlMode, bSetTimer);
    }
}

/*=============================================================================
函 数 名： NotifySrcSend
功    能： 通知源开始发送编关键帧
算法实现： 
全局变量： 
参    数： 
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2010/08/15   4.6		薛亮                  创建
=============================================================================*/
void CMcuVcInst::NotifySrcSend(const TMt &tSrcMt, u8 byMode /* = MODE_BOTH */, u8 bySrcChnnl /* = 0  */, BOOL32 bFastUpdateTimer /* = TRUE */)
{
	if( tSrcMt.GetType() == TYPE_MT )
	{
		TMt tLocalMt = GetLocalMtFromOtherMcuMt(tSrcMt);
		NotifyMtSend( tLocalMt.GetMtId(), byMode, TRUE );
		
        if ( MODE_VIDEO == byMode || MODE_BOTH == byMode )
        {
            NotifyFastUpdate(tSrcMt, MODE_VIDEO, bFastUpdateTimer); //这里带的是原始tmt信息
        }
	}
	else if( tSrcMt.GetType() == TYPE_MCUPERI )
	{
		NotifyEqpFastUpdate(tSrcMt, bySrcChnnl, bFastUpdateTimer);
	}
}

/*=============================================================================
    函 数 名： GetDSSrcSim
    功    能： 获取双流源的能力
    算法实现： 
    全局变量： 
    参    数： 
    返 回 值： void
    ----------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
    2008/11/19  4.5		    张宝卿                  创建
=============================================================================*/
void CMcuVcInst::GetDSBrdSrcSim(TDStreamCap &tDSim)
{
    TMt tSrcMt;
    tSrcMt.SetNull();
    
    if (!m_tDoubleStreamSrc.IsNull())
    {
        tSrcMt = m_tDoubleStreamSrc;
    }
    
    if (tSrcMt.IsNull())
    {
        ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[GetDSSrcSim] no ds src mt in conf\n");
        return;
    }
    
    //考虑录像机
    u8 byType = MEDIA_TYPE_NULL;
    u16 wWidth = 0;
    u16 wHeight = 0;
    if (TYPE_MCUPERI == tSrcMt.GetType() && EQP_TYPE_RECORDER == tSrcMt.GetMtType())
    {
        m_tPlayFileMediaInfo.GetDVideo( byType, wWidth, wHeight );
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[GetDSSrcSim] Type.%d, width.%d, wHeight.%d\n", byType, wWidth, wHeight );     
        
        if ( byType != MEDIA_TYPE_NULL )
        {
            tDSim.SetMediaType( byType);
            tDSim.SetResolution( GetResByWH( wWidth, wHeight ) );
            tDSim.SetMaxBitRate( GetDoubleStreamVideoBitrate(m_tConf.GetBitRate(), FALSE) );
        }
        else
        {
            tDSim.SetMediaType( m_tConf.GetMainVideoMediaType() );
            tDSim.SetResolution( m_tConf.GetMainVideoFormat() );
            tDSim.SetMaxBitRate( GetDoubleStreamVideoBitrate(m_tConf.GetBitRate(), FALSE) );
        }
        u8 byConfFrame = 0;
        if ( m_tConf.GetDStreamMediaType() == MEDIA_TYPE_H264 )
        {
            byConfFrame = m_tConf.GetDStreamUsrDefFPS();
        }
        else
        {
            byConfFrame = m_tConf.GetDStreamFrameRate();
        }
        if ( tDSim.GetMediaType() == MEDIA_TYPE_H264 )
        {
            tDSim.SetUserDefFrameRate( byConfFrame );
        }
        else
        {
            tDSim.SetFrameRate( byConfFrame );
        }
    }
    else
    {
        //zbq[01/09/2009] 双流源能力取后向逻辑通道
        TLogicalChannel tDSRcvChn;
        if (m_ptMtTable->GetMtLogicChnnl(tSrcMt.GetMtId(), LOGCHL_SECVIDEO, &tDSRcvChn, FALSE))
        {
            tDSim.SetMediaType(tDSRcvChn.GetChannelType());
            if (MEDIA_TYPE_H264 == tDSim.GetMediaType())
            {
                tDSim.SetUserDefFrameRate(tDSRcvChn.GetChanVidFPS());
            }
            else
            {
                tDSim.SetFrameRate(tDSRcvChn.GetChanVidFPS());
            }
            tDSim.SetMaxBitRate(tDSRcvChn.GetFlowControl());
            tDSim.SetResolution(tDSRcvChn.GetVideoFormat());
        }
        else
        {
            ConfPrint(LOG_LVL_WARNING, MID_MCU_MT, "[GetDSSrcSim] DSSrc's rcv chn hasn't opened yet!\n");

            TCapSupport tCap;
            m_ptMtTable->GetMtCapSupport(tSrcMt.GetMtId(), &tCap);
            tDSim = tCap.GetDStreamCapSet();
            
            //zbq[10/10/2008] 帧率保护
            u8 byFrmRate = 0;
            if (MEDIA_TYPE_H264 == tDSim.GetMediaType())
            {
                byFrmRate = tDSim.GetUserDefFrameRate();
            }
            else
            {
                byFrmRate = tDSim.GetFrameRate();
            }
            if (0 == byFrmRate)
            {
                if (MEDIA_TYPE_H264 == tDSim.GetMediaType())
                {
                    tDSim.SetUserDefFrameRate(m_tConf.GetMainVidUsrDefFPS());
                }
                else
                {
                    tDSim.SetFrameRate(m_tConf.GetMainVidUsrDefFPS());
                }
            }
            if (tDSim.IsNull())
            {
                ConfPrint(LOG_LVL_WARNING, MID_MCU_MT, "[GetDSSrcSim] DSSrc's ds cap is NULL!\n");
                return;
            }
            tDSim.SetMaxBitRate( m_ptMtTable->GetMtSndBitrate( tSrcMt.GetMtId(), LOGCHL_SECVIDEO ) );
        }
    }
    
    return;
}

/*=============================================================================
    函 数 名： IsMtInMcSrc
    功    能： 判断终端在本会议中是否有对应的源
    算法实现： 
    全局变量： 
    参    数： u8 byChnRes: 打开通道用的Res, 只针对h264的会议处理
               BOOL32 &bAccord2MainCap：是否根据主能力打开主流
    返 回 值： void
    ----------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
    2008/12/30  4.5		    张宝卿                  创建
=============================================================================*/
/*BOOL32 CMcuVcInst::IsMtMatchedSrc(u8 byMtId, u8 &byChnRes, BOOL32 &bAccord2MainCap)
{
    if (byMtId == 0 || byMtId > MAXNUM_CONF_MT)
    {
        return FALSE;
    }
    if (!m_tConfAllMtInfo.MtJoinedConf(byMtId))
    {
        return FALSE;
    }

    TCapSupport tCap;
    if (!m_ptMtTable->GetMtCapSupport(byMtId, &tCap))
    {
        ConfPrint(LOG_LVL_WARNING, MID_MCU_MT, "[IsMtMatchedSrc] get mt.%d's cap failed!\n", byMtId);
        return FALSE;
    }

    TSimCapSet tSimCap;
    tSimCap.Clear();
    tSimCap = tCap.GetMainSimCapSet();

    if (tSimCap.IsNull() ||
        MEDIA_TYPE_NULL == tSimCap.GetVideoMediaType())
    {
        tSimCap = tCap.GetSecondSimCapSet();
    }
    if (tSimCap.IsNull() ||
        MEDIA_TYPE_NULL == tSimCap.GetVideoMediaType())
    {
        ConfPrint(LOG_LVL_WARNING, MID_MCU_MT, "[IsMtMatchedSrc] mt.%d cap is null already, ignore it!\n", byMtId);
        return FALSE;
    }
    
    u8 byMediaType = tSimCap.GetVideoMediaType();
    u8 byRes = tSimCap.GetVideoResolution();

    if (MEDIA_TYPE_H264 != byMediaType)
    {
        if (byMediaType == m_tConf.GetMainVideoMediaType() ||
            byMediaType == m_tConf.GetSecVideoMediaType() )
        {
            bAccord2MainCap = TRUE;
            byChnRes = m_tConf.GetMainVideoFormat();
            return TRUE;
        }
    }
    else
    {
        if (byMediaType != m_tConf.GetMainVideoMediaType())
        {
            return FALSE;
        }
        if (byRes == m_tConf.GetMainVideoFormat() ||
            (byRes == VIDEO_FORMAT_HD1080 && m_tConf.GetConfAttrbEx().IsResEx1080()) ||
            (byRes == VIDEO_FORMAT_HD720 && m_tConf.GetConfAttrbEx().IsResEx720()) ||
            (byRes == VIDEO_FORMAT_4CIF && m_tConf.GetConfAttrbEx().IsResEx4Cif()) ||
            (byRes == VIDEO_FORMAT_CIF && m_tConf.GetConfAttrbEx().IsResExCif()))
        {
            //zbq[05/22/2009] 适配资源紧凑模式下，同会议主分辨率降速打开不再支持；此处需作降分辨率打开处理.
            if (byRes == m_tConf.GetMainVideoFormat())
            {
                u16 wDialBR = m_ptMtTable->GetDialBitrate(byMtId);
                u16 wConfBR = m_tConf.GetBitRate();
                
                //低速呼叫粗略鉴定
                BOOL32 bCallLowBR = (wConfBR - wDialBR) * 100 / wConfBR > 5;
                if (bCallLowBR)
                {
                    //尝试取临近分辨率
                }
                else
                {
                    bAccord2MainCap = TRUE;
                    byChnRes = byRes;
                    return TRUE;
                }
            }
            else
            {
                bAccord2MainCap = TRUE;
                byChnRes = byRes;
                return TRUE;
            }
        }

        //zbq[04/22/2009] 尝试取会议支持的临近分辨率
        byChnRes = 0xff;
		if (byRes == VIDEO_FORMAT_HD1080)
		{
			if (m_tConf.GetConfAttrbEx().IsResEx720())
			{
				byChnRes = VIDEO_FORMAT_HD720;
			}
			else if (m_tConf.GetConfAttrbEx().IsResEx4Cif())
			{
				byChnRes = VIDEO_FORMAT_4CIF;
			}
			else if (m_tConf.GetConfAttrbEx().IsResExCif())
			{
				byChnRes = VIDEO_FORMAT_CIF;
			}
		}
		else if (byRes == VIDEO_FORMAT_HD720)
		{
			if (m_tConf.GetConfAttrbEx().IsResEx4Cif())
			{
				byChnRes = VIDEO_FORMAT_4CIF;
			}
			else if (m_tConf.GetConfAttrbEx().IsResExCif())
			{
				byChnRes = VIDEO_FORMAT_CIF;
			}
		}
		else if (byRes == VIDEO_FORMAT_4CIF)
		{
			if (m_tConf.GetConfAttrbEx().IsResExCif())
			{
				byChnRes = VIDEO_FORMAT_CIF;
			}
		}
		else
		{
			//Do nothing
		}
        
        if (0xff != byChnRes)
        {
            bAccord2MainCap = TRUE;
            return TRUE;
        }
    }
	
    //zbq[04/22/2009] 双格式支持考虑
    tSimCap.Clear();
    tSimCap = tCap.GetSecondSimCapSet();
    if (!tSimCap.IsNull())
    {
        if (tSimCap.GetVideoMediaType() == m_tConf.GetSecVideoMediaType())
        {
            bAccord2MainCap = FALSE;
            byChnRes = tSimCap.GetVideoResolution();
            return TRUE;
        }
    }
    return FALSE;
}*/

/*=============================================================================
    函 数 名： GetProximalGrp
    功    能： 获取向下最临近群组
    算法实现： 
    全局变量： 
    参    数： 
    返 回 值： void
    ----------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
	2012/02/20  4.7			倪志俊					创建
=============================================================================*/
BOOL32 CMcuVcInst::GetProximalGrp(TVideoStreamCap &tSimCapSet)
{
	if ( IsConfNeedReserveMainCap(m_tConf,m_tConfEx) )
	{
		tSimCapSet = m_tConf.GetMainSimCapSet().GetVideoCap();
#ifdef _8KH_
		if ( m_tConf.GetProfileAttrb() == emHpAttrb )
		{
			// HP的话能力填 720 30 HP
			tSimCapSet.SetResolution(VIDEO_FORMAT_HD720);
			tSimCapSet.SetH264ProfileAttrb(emHpAttrb);
			if (  tSimCapSet.GetUserDefFrameRate() == 60 ||
				  tSimCapSet.GetUserDefFrameRate() == 50
				)
			{
				tSimCapSet.SetUserDefFrameRate( tSimCapSet.GetUserDefFrameRate()/2 );
			}
		}
		else
		{
			if ( m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H264 &&
				 (m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_HD1080 || m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_HD720) &&
				(m_tConf.GetMainVidUsrDefFPS() == 60 || m_tConf.GetMainVidUsrDefFPS() == 50) 
				)
			{
				tSimCapSet.SetUserDefFrameRate( tSimCapSet.GetUserDefFrameRate()/2 );
			}
		}
#endif	
		return TRUE;
	}
	else
	{
		//获得主流模板勾选
		TVideoStreamCap tVideoCap[MAX_CONF_CAP_EX_NUM];
		u8 byCapNUm = MAX_CONF_CAP_EX_NUM;
		if ( m_tConfEx.GetMainStreamCapEx(tVideoCap,byCapNUm) )
		{
			if ( byCapNUm >0  )
			{
#ifdef  _8KH_
				//判断是否存在720 60,如存在返回720 30那一出，因为8KH只可能出720 30，不可能出720 60
				if ( tVideoCap[0].GetMediaType() == MEDIA_TYPE_H264 &&
					tVideoCap[0].GetResolution()== VIDEO_FORMAT_HD720 &&
					( tVideoCap[0].GetUserDefFrameRate() == 60 || tVideoCap[0].GetUserDefFrameRate() == 50)
					)
				{
					tVideoCap[0].SetUserDefFrameRate(tVideoCap[0].GetUserDefFrameRate()/2);
					tSimCapSet = tVideoCap[0];
					return TRUE;
				}
#else
				//判断是否存在720 60 和720 30一起勾选的情况，如果一起勾选，返回720 30那一出
				if ( tVideoCap[0].GetMediaType() == MEDIA_TYPE_H264 &&
					tVideoCap[0].GetResolution() == VIDEO_FORMAT_HD720 &&
					( tVideoCap[0].GetUserDefFrameRate() == 60 || tVideoCap[0].GetUserDefFrameRate() == 50)
					)
				{
					if ( m_tConfEx.IsMSSupportCapEx(VIDEO_FORMAT_HD720,tVideoCap[0].GetUserDefFrameRate()/2,tVideoCap[0].GetH264ProfileAttrb()) )
					{
						tVideoCap[0].SetUserDefFrameRate(tVideoCap[0].GetUserDefFrameRate()/2);
						tSimCapSet = tVideoCap[0];
						return TRUE;
					}
				}
#endif
				//返回第一个勾选，因为勾选必预留
				tSimCapSet=tVideoCap[0];
				return TRUE;
			}
		}
	}
    return FALSE;
}


/*====================================================================
    函数名      ：IsDelayVidBrdVCU
    功能        ：是否推迟视频源的VCU和youareseeing的发送
	              通知MC，MT和
    算法实现    ：针对Tandberg在VMP轮询跟随时，进VMP码流慢的情况 特殊处理 判断实现
    引用全局变量：
    输入参数说明：
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	03/11/25    3.0         胡昌威        创建
====================================================================*/
BOOL32 CMcuVcInst::IsDelayVidBrdVCU()
{
    if (IsVidBrdSrcNull() ||
        MT_MANU_TAIDE == m_ptMtTable->GetManuId(GetLocalVidBrdSrc().GetMtId()))
    {
        return FALSE;
    }
    if (CONF_POLLMODE_VIDEO != m_tConf.m_tStatus.GetPollMode() &&
        CONF_POLLMODE_SPEAKER != m_tConf.m_tStatus.GetPollMode() )
    {
        return FALSE;
    }

    BOOL32 bVmpSelPoll = FALSE;

    u8 byIdx = 0;
	TVMPParam_25Mem tConfVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
    for (byIdx = 0; byIdx < MAXNUM_VMP_MEMBER; byIdx++)
    {
        TVMPMember *ptVmpMem = tConfVmpParam.GetVmpMember(byIdx);
        if (ptVmpMem->IsNull())
        {
            continue;
        }
        if (ptVmpMem->GetMemberType() == VMP_MEMBERTYPE_POLL)
        {
            bVmpSelPoll = TRUE;
            break;
        }
    }

    return bVmpSelPoll;
}

/*=============================================================================
    函 数 名： GetMtMatchedRes
    功    能： 获取指定终端在指定视频格式下最接近会议支持的分辨率
    算法实现： 
    全局变量： 
    参    数： byMtId:     指定终端
			   byChnType:  指定视频格式
			   byChnRes:   返回指定视频格式最符合会议的可支持分辨率
    返 回 值： void
    ----------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
    09/05/19    4.5		    付秀华                  创建
=============================================================================*/
BOOL32 CMcuVcInst::GetMtMatchedRes(u8 byMtId, u8 byChnType, u8& byChnRes)
{
    if (byMtId == 0 || byMtId > MAXNUM_CONF_MT)
    {
        return FALSE;
    }
    if (!m_tConfAllMtInfo.MtJoinedConf(byMtId))
    {
        return FALSE;
    }

    TCapSupport tCap;
    if (!m_ptMtTable->GetMtCapSupport(byMtId, &tCap))
    {
        ConfPrint(LOG_LVL_WARNING, MID_MCU_MT, "[GetMtMatchedRes] get mt.%d's cap failed!\n", byMtId);
        return FALSE;
    }

	if (tCap.GetMainVideoType() == byChnType)
	{
		byChnRes  = tCap.GetMainVideoResolution();
	}
	else if (tCap.GetSecVideoType() == byChnType)
	{
		byChnRes  = tCap.GetSecVideoResolution();
	}
	else
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_MT, "[GetMtMatchedRes] mt not support this media type(%d)\n", byChnType);
		return FALSE;
	}

	u8 byConfRes = 0;
	if (m_tConf.GetMainVideoMediaType() == byChnType)
	{
		byConfRes = m_tConf.GetMainVideoFormat();
	}
	else
	{
		byConfRes = m_tConf.GetSecVideoFormat();
	}
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[GetMtMatchedRes] conf res(%d) cap of mediatype(%d)\n", byConfRes, byChnType);

	// 对于mpeg4自适应特殊处理
	if (VIDEO_FORMAT_AUTO == byConfRes || VIDEO_FORMAT_AUTO == byChnRes)
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[GetMtMatchedRes] open mt video channl with mt res(%d)\n", byChnRes);
		return TRUE;
	}
	else if (IsResGE(byChnRes, byConfRes))
	{
		/*
        //zbq[05/22/2009] 适配资源紧凑模式下，同会议主分辨率降速打开不再支持；此处需作降分辨率打开处理.
        u16 wDialBR = m_ptMtTable->GetDialBitrate(byMtId);
        u16 wConfBR = m_tConf.GetBitRate();
        
        //低速呼叫粗略鉴定
        BOOL32 bCallLowBR = (wConfBR - wDialBR) * 100 / wConfBR > 5;
        
        if (bCallLowBR && g_cMcuVcApp.IsAdpResourceCompact())
        {
            u8 byResTmp = byChnRes;

            //尝试取临近分辨率
			//zjj20090924 紧凑适配模式下 1080和720分辨率分开判断
            if ( VIDEO_FORMAT_HD1080 == byChnRes)
            {
				if (m_tConf.GetConfAttrbEx().IsResEx720())
				{
					byChnRes = VIDEO_FORMAT_HD720;
				}
                else if (m_tConf.GetConfAttrbEx().IsResEx4Cif())
                {
                    byChnRes = VIDEO_FORMAT_4CIF;
                }
                else if (m_tConf.GetConfAttrbEx().IsResExCif())
                {
                    byChnRes = VIDEO_FORMAT_CIF;
                }
            }
			else if ( VIDEO_FORMAT_HD720 == byChnRes ) 
			{
				if (m_tConf.GetConfAttrbEx().IsResEx4Cif())
                {
                    byChnRes = VIDEO_FORMAT_4CIF;
                }
                else if (m_tConf.GetConfAttrbEx().IsResExCif())
                {
                    byChnRes = VIDEO_FORMAT_CIF;
                }
			}
            else if (byChnRes == VIDEO_FORMAT_4CIF)
            {
                if (m_tConf.GetConfAttrbEx().IsResExCif())
                {
                    byChnRes = VIDEO_FORMAT_CIF;
                }
            }
            else
            {
                //Do nothing
			}

            if ( byResTmp != byChnRes )
            {
                ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[GetMtMatchedRes] open mt video channl adj res(%d) to res(%d)\n", byResTmp, byChnRes);
                return TRUE;
            }
            else
            {
                //zjl 20100520 双速单格式紧凑适配，无法节约适配通道
                ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[GetMtMatchedRes] useless AdpResourceCompact, open mt video channl with res(%d)\n", byChnRes);
				//return FALSE;
                return TRUE;
            }
        }
        else
        {
            byChnRes = byConfRes;
            ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[GetMtMatchedRes] open mt video channl with conf res(%d)\n", byChnRes);
            return TRUE;
        }*/

		ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[GetMtMatchedRes] open mt video channl with conf res(%d)\n", byChnRes);
        
		return TRUE;
	}
	else
	{
        if (byChnType != MEDIA_TYPE_H264 || byChnType != m_tConf.GetMainVideoMediaType())
        {
            return FALSE;
        }

		if (g_cMcuVcApp.IsSendFakeCap2Polycom() &&
			MT_MANU_POLYCOM == m_ptMtTable->GetManuId(byMtId))
		{
			byChnRes = VIDEO_FORMAT_4SIF;
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[GetMtMatchedRes] Open Mt.%d video logic chnnl adjusted to 4SIF due to it's Polycom!\n", byMtId);
			return TRUE;
		}
		// 对于VCS会议,H264会议,允许所有分辨率的终端入会,按照比会议小的终端支持的分辨率开通道
		// 对于组呼目前走会议逻辑
// 		else if (VCS_CONF == m_tConf.GetConfSource() &&
// 			     !ISGROUPMODE(m_cVCSConfStatus.GetCurVCMode()) &&
// 				 // [pengjie 2010/5/14] vcs多方多画面以及vcs下级会议都按会议实际能力开逻辑通道
// 				 m_cVCSConfStatus.GetCurVCMode() != VCS_MULVMP_MODE &&
// 				 m_byCreateBy != CONF_CREATE_MT)
// 		{
// 			//第二组共同能力集不依赖于勾选，只依赖于主能力集[12/16/2011 chendaiwei]
// 			TMultiCapSupport tMultiCap;
// 			TVideoStreamCap tVideoCap;
// 			m_ptMtTable->GetMtMultiCapSupport(byMtId,&tMultiCap);
// 			tMultiCap.GetExtraVideoCap(tVideoCap,0);
// 			byChnRes = tVideoCap.GetResolution();
// 
// 			ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[GetMtMatchedRes] open mt video channl with res(%d) for vcs\n", byChnRes);
// 			return TRUE;
// 		}
		else
		{
			/*
			//zbq[04/22/2009] 尝试取会议支持的临近分辨率
			u8 byTmpChnRes = byChnRes;
            byChnRes = 0xff;
			if (VIDEO_FORMAT_HD720 == byTmpChnRes ||
                VIDEO_FORMAT_HD1080 == byTmpChnRes)
			{
				if (m_tConf.GetConfAttrbEx().IsResEx720())
				{
					byChnRes = VIDEO_FORMAT_HD720;
				}
				else if (m_tConf.GetConfAttrbEx().IsResEx4Cif())
				{
					byChnRes = VIDEO_FORMAT_4CIF;
				}
				else if (m_tConf.GetConfAttrbEx().IsResExCif())
				{
					byChnRes = VIDEO_FORMAT_CIF;
				}
			}
			else if (byTmpChnRes == VIDEO_FORMAT_4CIF)
			{
				if (m_tConf.GetConfAttrbEx().IsResEx4Cif())
				{
					byChnRes = VIDEO_FORMAT_4CIF;
				}
				else if (m_tConf.GetConfAttrbEx().IsResExCif())
				{
					byChnRes = VIDEO_FORMAT_CIF;
				}
			}
			else if (byTmpChnRes == VIDEO_FORMAT_CIF)
			{
				if (m_tConf.GetConfAttrbEx().IsResExCif())
				{
					byChnRes = VIDEO_FORMAT_CIF;
				}
			}
			else
			{
				//Do nothing
			}
        
			if (byChnRes != 0xff)
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[GetMtMatchedRes] open mt video channl with res(%d) with use of adp\n", byChnRes);
				return TRUE;
			}
            else
            {
                ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[GetMtMatchedRes] mt vid chn.%d matchless with confAttb resEx<%d, %d, %d, %d>, check it\n",
                         byTmpChnRes,
                         m_tConf.GetConfAttrbEx().IsResEx1080(),
                         m_tConf.GetConfAttrbEx().IsResEx720(),
                         m_tConf.GetConfAttrbEx().IsResEx4Cif(),
                         m_tConf.GetConfAttrbEx().IsResExCif());
            }*/
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[GetMtMatchedRes] open mt video channl with res(%d) with use of adp\n", byChnRes);

			return TRUE;
		}
    }
}

/*====================================================================
函数名      ：GetMtLegalCapExAccord2CallBR
功能        ：根据终端的呼叫码率调开启通道的能力集（分辨率帧率码率HP/BP属性）
算法实现    ：
引用全局变量：
输入参数说明：u16 wCallBR[in] 呼入码率
			  TVideoStreamCap &tLegalCap[IN][OUT] 传入传出的能力集
			  u8 byChnnltype[IN] 通道媒体类型
			  u8 byProfileAttrb[IN]标识终端支持的HP/BP属性
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/12  4.7         陈代伟        创建
====================================================================*/
BOOL32 CMcuVcInst::GetMtLegalCapExAccord2CallBR(u16 wCallBR,
										  TVideoStreamCap tSrcCap,
                                          TVideoStreamCap &tMatchedCap)
{
	BOOL32 bResult = FALSE;
	
	//BP处理
	if(tSrcCap.GetH264ProfileAttrb() == emBpAttrb)
	{
		if (wCallBR < g_cMcuVcApp.GetCifLeastBR())
		{
			if (IsResGE(tSrcCap.GetResolution(), VIDEO_FORMAT_CIF))
			{
				u8 byFps = tSrcCap.GetUserDefFrameRate() > 30 ? tSrcCap.GetUserDefFrameRate()/2 :tSrcCap.GetUserDefFrameRate();
				if(FindMSMatchedCapEx(tMatchedCap,tSrcCap,VIDEO_FORMAT_CIF,byFps))
				{
					bResult = TRUE;
				}
			}

		}
		else if (wCallBR < g_cMcuVcApp.Get4CifLeastBR())
		{
			if (IsResGE(tSrcCap.GetResolution(), VIDEO_FORMAT_4CIF))
			{
				u8 byFps = tSrcCap.GetUserDefFrameRate() > 30 ? tSrcCap.GetUserDefFrameRate()/2 :tSrcCap.GetUserDefFrameRate();
				if(FindMSMatchedCapEx(tMatchedCap,tSrcCap,VIDEO_FORMAT_4CIF,byFps))
				{
					bResult = TRUE;
				}
			}

		}
		else if (wCallBR < g_cMcuVcApp.Get720P3025FpsBpLeastBR())
		{
			u8 byFps = tSrcCap.GetUserDefFrameRate() > 30 ? tSrcCap.GetUserDefFrameRate()/2 :tSrcCap.GetUserDefFrameRate();
			if (IsResGE(tSrcCap.GetResolution(), VIDEO_FORMAT_HD720))
			{
				if(FindMSMatchedCapEx(tMatchedCap,tSrcCap,VIDEO_FORMAT_HD720,byFps))
				{
					bResult = TRUE;
				}
			}
		}
		else if (wCallBR < g_cMcuVcApp.Get720P6050FpsBpLeastBR())
		{
			if (IsResGE(tSrcCap.GetResolution(), VIDEO_FORMAT_HD720))
			{
				if(FindMSMatchedCapEx(tMatchedCap,tSrcCap,VIDEO_FORMAT_HD720,tSrcCap.GetUserDefFrameRate()))
				{
					bResult = TRUE;
				}
			}
		}
		else if (wCallBR < g_cMcuVcApp.Get1080P3025FpsBpLeastBR())
		{
			if (IsResGE(tSrcCap.GetResolution(), VIDEO_FORMAT_HD1080))
			{
				u8 byFps = tSrcCap.GetUserDefFrameRate() > 30 ? tSrcCap.GetUserDefFrameRate()/2 :tSrcCap.GetUserDefFrameRate();

				if(FindMSMatchedCapEx(tMatchedCap,tSrcCap,VIDEO_FORMAT_HD1080,byFps))
				{
					bResult = TRUE;
				}
			}
		}
		//  [3/31/2011 chendaiwei]新增1080p/60/50帧的阀值
		else if (wCallBR < g_cMcuVcApp.Get1080P6050FpsBpLeastBR())
		{
			if (IsResGE(tSrcCap.GetResolution(), VIDEO_FORMAT_HD1080))
			{			
				if(FindMSMatchedCapEx(tMatchedCap,tSrcCap,VIDEO_FORMAT_HD1080, tSrcCap.GetUserDefFrameRate()))
				{	
					bResult = TRUE;
				}
			}
		}
	}
	//HP处理
	else
	{
		if (wCallBR < g_cMcuVcApp.GetCifLeastBR())
		{
			if (IsResGE(tSrcCap.GetResolution(), VIDEO_FORMAT_CIF))
			{
				tSrcCap.SetH264ProfileAttrb( emBpAttrb );
				u8 byFps = tSrcCap.GetUserDefFrameRate() > 30 ? tSrcCap.GetUserDefFrameRate()/2 :tSrcCap.GetUserDefFrameRate();
				if(FindMSMatchedCapEx(tMatchedCap,tSrcCap,VIDEO_FORMAT_CIF,byFps))
				{
					bResult = TRUE;
				}
			}
		}
		else if (wCallBR < g_cMcuVcApp.Get4CifLeastBR())
		{
			if (IsResGE(tSrcCap.GetResolution(), VIDEO_FORMAT_4CIF))
			{
				tSrcCap.SetH264ProfileAttrb( emBpAttrb );
				u8 byFps = tSrcCap.GetUserDefFrameRate() > 30 ? tSrcCap.GetUserDefFrameRate()/2 :tSrcCap.GetUserDefFrameRate();
				if(FindMSMatchedCapEx(tMatchedCap,tSrcCap,VIDEO_FORMAT_4CIF,byFps))
				{
					bResult = TRUE;
				}
			}
		}
		else if (wCallBR < g_cMcuVcApp.Get720P3025FpsHpLeastBR())
		{
			u8 byFps = tSrcCap.GetUserDefFrameRate() > 30 ? tSrcCap.GetUserDefFrameRate()/2 :tSrcCap.GetUserDefFrameRate();
			if (IsResGE(tSrcCap.GetResolution(), VIDEO_FORMAT_HD720))
			{
				if(FindMSMatchedCapEx(tMatchedCap,tSrcCap,VIDEO_FORMAT_HD720,byFps))
				{
					bResult = TRUE;
				}
			}
		}
		else if (wCallBR < g_cMcuVcApp.Get720P6050FpsHpLeastBR())
		{
			if (IsResGE(tSrcCap.GetResolution(), VIDEO_FORMAT_HD720))
			{
				if(FindMSMatchedCapEx(tMatchedCap,tSrcCap,VIDEO_FORMAT_HD720,tSrcCap.GetUserDefFrameRate()))
				{
					bResult = TRUE;
				}
			}
		}
		else if (wCallBR < g_cMcuVcApp.Get1080P3025FpsHpLeastBR())
		{
			if (IsResGE(tSrcCap.GetResolution(), VIDEO_FORMAT_HD1080))
			{
				u8 byFps = tSrcCap.GetUserDefFrameRate() > 30 ? tSrcCap.GetUserDefFrameRate()/2 :tSrcCap.GetUserDefFrameRate();
				
				if(FindMSMatchedCapEx(tMatchedCap,tSrcCap,VIDEO_FORMAT_HD1080,byFps))
				{
					bResult = TRUE;
				}
			}
		}
		else if (wCallBR < g_cMcuVcApp.Get1080P6050FpsHpLeastBR())
		{
			if (IsResGE(tSrcCap.GetResolution(), VIDEO_FORMAT_HD1080))
			{			
				if(FindMSMatchedCapEx(tMatchedCap,tSrcCap,VIDEO_FORMAT_HD1080, tSrcCap.GetUserDefFrameRate()))
				{	
					bResult = TRUE;
				}
			}
		}
	}

    return bResult;
}


/*====================================================================
函数名      IsNeedAdapt
功能        ：判嗄康慕K端是否需要m配
算法实现    ：
引用全局变量：
输入参数说明：TMt tSrc		  源信息
			  TMt tDst		  目的信息
			  u8 byMediaMode  媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::IsNeedAdapt(TMt tSrc, TMt tDst, u8 byMediaMode)
{
	if (TYPE_MCUPERI == tSrc.GetType() && EQP_TYPE_VMP == tSrc.GetEqpType())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsNeedAdapt]vmp don't need adapt!\n");
		return FALSE;
	}

	// [11/29/2011 liuxu] 如果源或目的为空, 可直接返回
	if (tSrc.IsNull() || tDst.IsNull())
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "tSrc[%d,%d] or tDst[%d,%d] is null!\n", tSrc.GetMcuId(), tSrc.GetMtId(), tDst.GetMcuId(), tDst.GetMtId());
		return FALSE;
	}

	TAudioTypeDesc tSrcAudCap;
	TAudioTypeDesc tDstAudCap;
	TSimCapSet  tMVSrcCap;
	TSimCapSet  tMVDstCap;
	TDStreamCap tDSSrcCap;
	TDStreamCap tDSDstCap;
	if (TYPE_MCUPERI == tSrc.GetType() && EQP_TYPE_RECORDER == tSrc.GetEqpType())
	{
		u16 wRawBiteRate = m_tConf.GetBitRate() + GetAudioBitrate( m_tConfEx.GetMainAudioTypeDesc().GetAudioMediaType() );
		u16 wRealBiteRate = wRawBiteRate - GetMaxAudioBiterate(m_tConfEx);
		if ( MODE_AUDIO == byMediaMode )
		{
			tSrcAudCap.SetAudioMediaType( m_tPlayEqpAttrib.GetAudioType() );
			tSrcAudCap.SetAudioTrackNum( m_tPlayEqpAttrib.GetAudTrackNum() );

			TMt tLocalMt = GetLocalMtFromOtherMcuMt( tDst );
			TLogicalChannel tDstAudLgc;
			if (!m_ptMtTable->GetMtLogicChnnl(tLocalMt.GetMtId(), MODE_AUDIO, &tDstAudLgc, TRUE))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[IsNeedAdapt] GetMtLogicChnnl Dst Aud Mt%d failed!\n", tDst.GetMtId());
				return FALSE;
			}
			
			tDstAudCap.SetAudioMediaType( tDstAudLgc.GetChannelType() );
			tDstAudCap.SetAudioTrackNum( tDstAudLgc.GetAudioTrackNum() );
		}
		else if (MODE_VIDEO == byMediaMode)
		{
			u8 byVidType = 0;
			u16 wWidth = 0;
			u16 wHeight = 0;
			m_tPlayFileMediaInfo.GetVideo( byVidType, wWidth,  wHeight );
			u8 Res = GetResByWH( wWidth, wHeight);

			tMVSrcCap.SetVideoResolution( Res );
			tMVSrcCap.SetVideoMediaType( byVidType );
			//zjj20130719 如果261格式放像强行降到1920，因为协议栈写死了1920，261格式码率最大都对齐到1920
			if( MEDIA_TYPE_H261 == byVidType && wRealBiteRate > 1920 )
			{
				wRealBiteRate = 1920;
			}
			ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[IsNeedAdapt]m_tPlayFileHpAttrib:%d\n",m_tPlayFileHpAttrib.GetFirstVideHpAttrib());
			tMVSrcCap.SetVideoProfileType( m_tPlayFileHpAttrib.GetFirstVideHpAttrib() );
			//放像机正在同时放主流和双流，目前娶不到录像机双流码率信息，先按会议双流比率折半计算
			if(m_tDoubleStreamSrc == tSrc)
			{
				tMVSrcCap.SetVideoMaxBitRate(GetDoubleStreamVideoBitrate(wRealBiteRate, TRUE));
			}
			else
			{
				tMVSrcCap.SetVideoMaxBitRate( wRealBiteRate );
			}
			
			if( byVidType == MEDIA_TYPE_H264 )
			{
				tMVSrcCap.SetUserDefFrameRate( m_tConf.GetMainVidUsrDefFPS() );
			}
			else
			{
				tMVSrcCap.SetVideoFrameRate( m_tConf.GetSecVidFrameRate() );
			}

			tMVSrcCap.SetAudioMediaType(m_tPlayEqpAttrib.GetAudioType());

			// [9/16/2010 liuxu] tMVDstCap没有被初始化，这里补上
			tDst = GetLocalMtFromOtherMcuMt(tDst);
			tMVDstCap = m_ptMtTable->GetDstSCS(tDst.GetMtId());
			if( tMVDstCap.IsNull() || tMVSrcCap.IsNull() )
			{
				return FALSE;
			}
		}
	    else if (MODE_SECVIDEO == byMediaMode)
		{
			u16 wWidth  = 0;
			u16 wHeight = 0;
			u8  byType  = 0;
			m_tPlayFileMediaInfo.GetDVideo( byType, wWidth, wHeight );
			if (MEDIA_TYPE_NULL != byType)
			{
				tDSSrcCap.SetMediaType(byType);
				tDSSrcCap.SetResolution( GetResByWH( wWidth, wHeight ) );
			    tDSSrcCap.SetMaxBitRate( GetDoubleStreamVideoBitrate(wRealBiteRate, FALSE) );
			}
			else
			{
				tDSSrcCap.SetMediaType( m_tConf.GetMainVideoMediaType() );
				tDSSrcCap.SetResolution( m_tConf.GetMainVideoFormat() );
                tDSSrcCap.SetMaxBitRate( GetDoubleStreamVideoBitrate(wRealBiteRate, FALSE) );
			}

			if( tDSSrcCap.GetMediaType() == MEDIA_TYPE_H264 )
			{
				tDSSrcCap.SetUserDefFrameRate( m_tConf.GetDStreamUsrDefFPS() );
			}
			else
			{
				if( 25 ==  FrameRateMac2Real(m_tConf.GetDStreamFrameRate()) )
				{
					tDSSrcCap.SetFrameRate( 30 );
				}
				else
				{
					tDSSrcCap.SetFrameRate( FrameRateMac2Real(m_tConf.GetDStreamFrameRate()) );
				}
				
			}
			
			tDSSrcCap.SetH264ProfileAttrb( m_tPlayFileHpAttrib.GetSecVideHpAttrib() );

			// [9/16/2010 liuxu] 没有为tDSDstCap赋值，这里补上
			//目的双流能力
			TMt tLocalMt = GetLocalMtFromOtherMcuMt( tDst );
			TLogicalChannel tDstDsLgc;
			if (!m_ptMtTable->GetMtLogicChnnl(tLocalMt.GetMtId(), LOGCHL_SECVIDEO, &tDstDsLgc, TRUE))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[IsNeedAdapt] GetMtLogicChnnl Dst Ds Mt%d failed!\n", tDst.GetMtId());
				return FALSE;
			}
			tDSDstCap.SetResolution(tDstDsLgc.GetVideoFormat());
			tDSDstCap.SetMaxBitRate(tDstDsLgc.GetFlowControl());
			tDSDstCap.SetMediaType(tDstDsLgc.GetChannelType());
			if (MEDIA_TYPE_H264 == tDSDstCap.GetMediaType())
			{	
				tDSDstCap.SetH264ProfileAttrb(tDstDsLgc.GetProfileAttrb());
				tDSDstCap.SetUserDefFrameRate(tDstDsLgc.GetChanVidFPS());
			}
			else
			{
				if( 25 ==  FrameRateMac2Real(tDstDsLgc.GetChanVidFPS()) )
				{
					tDSDstCap.SetFrameRate( 30 );
				}
				else
				{
					tDSDstCap.SetFrameRate( FrameRateMac2Real(tDstDsLgc.GetChanVidFPS()) );
				}
			}
		}	
	}
	else if(tSrc.GetType() == TYPE_MT)
	{ 
		if ( MODE_AUDIO == byMediaMode )
		{
			TMt tLocalSrcMt = GetLocalMtFromOtherMcuMt( tSrc );
			TLogicalChannel tSrcAudLgc;
			if (!m_ptMtTable->GetMtLogicChnnl(tLocalSrcMt.GetMtId(), MODE_AUDIO, &tSrcAudLgc, FALSE))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[IsNeedAdapt] GetMtLogicChnnl Src AUD Mt%d failed!\n", tLocalSrcMt.GetMtId());
				return FALSE;
			}

			tSrcAudCap.SetAudioMediaType( tSrcAudLgc.GetChannelType() );
			tSrcAudCap.SetAudioTrackNum( tSrcAudLgc.GetAudioTrackNum() );
			
			TMt tLocalDstMt = GetLocalMtFromOtherMcuMt( tDst );
			TLogicalChannel tDstAudLgc;
			if (!m_ptMtTable->GetMtLogicChnnl(tLocalDstMt.GetMtId(), MODE_AUDIO, &tDstAudLgc, TRUE))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[IsNeedAdapt] GetMtLogicChnnl Dst Aud Mt%d failed!\n", tLocalDstMt.GetMtId());
				return FALSE;
			}
			
			tDstAudCap.SetAudioMediaType( tDstAudLgc.GetChannelType() );
			tDstAudCap.SetAudioTrackNum( tDstAudLgc.GetAudioTrackNum() );
		}
		else if (MODE_VIDEO == byMediaMode)
		{
			tSrc = GetLocalMtFromOtherMcuMt(tSrc);
			tMVSrcCap = m_ptMtTable->GetSrcSCS(tSrc.GetMtId());
			tDst = GetLocalMtFromOtherMcuMt(tDst);
			tMVDstCap = m_ptMtTable->GetDstSCS(tDst.GetMtId());

			// [pengjie 2010/9/1] 对能力集判断做下保护,如果为空则认为不过适配
			if( tMVDstCap.IsNull() || tMVSrcCap.IsNull() )
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsNeedAdapt] tMVDstCap:%d or tMVSrcCap:%d is null!\n",
							tMVDstCap.IsNull(), tMVSrcCap.IsNull());
				return FALSE;
			}

			//E1终端降速不再此处理
// 			//zjj20101209 如果目标终端是E1降速终端要设置为原始的呼叫速率为终端接收码率,这样就不会造成误会要起适配,
// 			//因为E1终端降速直接降源的发送码率
// 			if( m_ptMtTable->GetMtType(tDst.GetMtId()) == MT_TYPE_MT &&
// 				m_ptMtTable->GetMtTransE1(tDst.GetMtId()) &&
// 				m_ptMtTable->GetMtBRBeLowed(tDst.GetMtId())
// 				)
// 			{
// 				tMVDstCap.SetVideoMaxBitRate( m_ptMtTable->GetDialBitrate(tDst.GetMtId() ) );
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS,  "[IsNeedAdapt] Mt(%d) is TansE1,so set it's bitrate to dial birtate(%d)\n",
// 						tDst.GetMtId(),m_ptMtTable->GetDialBitrate(tDst.GetMtId())
// 						);
// 			}
		}
		else if (MODE_SECVIDEO == byMediaMode)
		{
			TLogicalChannel tSrcDsLgc;
			TLogicalChannel tDstDsLgc;
			TMt tLocalMt = GetLocalMtFromOtherMcuMt( tSrc );
			//双流源能力
			if (!m_ptMtTable->GetMtLogicChnnl(tLocalMt.GetMtId(), LOGCHL_SECVIDEO, &tSrcDsLgc, FALSE))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[IsNeedAdapt] GetMtLogicChnnl Src Ds Mt%d failed!\n", tLocalMt.GetMtId());
				return FALSE;
			}
			tDSSrcCap.SetResolution(tSrcDsLgc.GetVideoFormat());
			tDSSrcCap.SetMaxBitRate(tSrcDsLgc.GetFlowControl());
			//[nizhijun 2012/3/14]双流也支持码率适配，如果源终端发送码率未调整，这里先进行计算
			u16 wSndBandWidth = m_ptMtTable->GetDialBitrate( tLocalMt.GetMtId() );
			//GetSndBandWidth获得的是终端呼叫带宽，而GetFlowControl里面的值为已经去除音频码率最大格式所占用的码率
			//故此处比较时，需要重新计算wSndBandWidth
			TLogicalChannel tAudSrcChn;
			if ( m_ptMtTable->GetMtLogicChnnl(tLocalMt.GetMtId(), LOGCHL_AUDIO, &tAudSrcChn, FALSE) )
			{
				wSndBandWidth+=GetAudioBitrate( tAudSrcChn.GetChannelType() );
			}
			wSndBandWidth-=GetMaxAudioBiterate(m_tConfEx);
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS,  "[IsNeedAdapt] GetSndBandWidth Src Ds wSndBandWidth%d !\n", wSndBandWidth);
			tDSSrcCap.SetMaxBitRate(GetDoubleStreamVideoBitrate(wSndBandWidth, FALSE));	
		
// 
// 			//zjj20100901 如果终端双流发送码率还未调整,就计算终端实际双流发送码率
// 			if( m_ptMtTable->GetSndBandWidth( tLocalMt.GetMtId() ) == 
// 				tDSSrcCap.GetMaxBitRate()
// 				)
// 			{
// 				u16 wMinDialBitrate = m_ptMtTable->GetRcvBandWidth(tLocalMt.GetMtId());
// 				u16 wMtDialBitrate = 0;
// 				TLogicalChannel tLogicalChannel;
// 				for ( u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
// 				{         
// 					if (byLoop == m_tDoubleStreamSrc.GetMtId() || !m_tConfAllMtInfo.MtJoinedConf(byLoop))
// 					{
// 						continue;
// 					}				
// 
// 					wMtDialBitrate = m_ptMtTable->GetRcvBandWidth(byLoop);					
// 					
// 					//zbq[09/25/2008] 保护被错误清0的第一路通道影响到双流带宽
// 					if (m_ptMtTable->GetMtLogicChnnl( byLoop, LOGCHL_VIDEO, &tLogicalChannel, TRUE) &&
// 						0 != wMtDialBitrate &&
// 						wMinDialBitrate > wMtDialBitrate 
// 						)
// 					{
// 						wMinDialBitrate = wMtDialBitrate;
// 					}
// 				}
// 				tDSSrcCap.SetMaxBitRate(GetDoubleStreamVideoBitrate(wMinDialBitrate, FALSE));
// 			}
			tDSSrcCap.SetMediaType(tSrcDsLgc.GetChannelType());
			if (MEDIA_TYPE_H264 == tDSSrcCap.GetMediaType())
			{	
				tDSSrcCap.SetH264ProfileAttrb(tSrcDsLgc.GetProfileAttrb());
				tDSSrcCap.SetUserDefFrameRate(tSrcDsLgc.GetChanVidFPS());
			}
			else
			{
				if( 25 == FrameRateMac2Real(tSrcDsLgc.GetChanVidFPS()) )
				{
					tDSSrcCap.SetFrameRate( 30 );
				}
				else
				{
					tDSSrcCap.SetFrameRate(FrameRateMac2Real(tSrcDsLgc.GetChanVidFPS()));
				}				
			}
			//目的双流能力
			tLocalMt = GetLocalMtFromOtherMcuMt( tDst );
			if (!m_ptMtTable->GetMtLogicChnnl(tLocalMt.GetMtId(), LOGCHL_SECVIDEO, &tDstDsLgc, TRUE))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsNeedAdapt] GetMtLogicChnnl Dst Ds Mt%d failed!\n", tDst.GetMtId());
				return FALSE;
			}
			tDSDstCap.SetResolution(tDstDsLgc.GetVideoFormat());
			tDSDstCap.SetMaxBitRate(tDstDsLgc.GetFlowControl());
			tDSDstCap.SetMediaType(tDstDsLgc.GetChannelType());
			if (MEDIA_TYPE_H264 == tDSDstCap.GetMediaType())
			{	
				tDSDstCap.SetH264ProfileAttrb(tDstDsLgc.GetProfileAttrb());
				tDSDstCap.SetUserDefFrameRate(tDstDsLgc.GetChanVidFPS());
			}
			else
			{
				if( 25 == FrameRateMac2Real(tDstDsLgc.GetChanVidFPS()) )
				{
					tDSDstCap.SetFrameRate( 30 );
				}
				else
				{
					tDSDstCap.SetFrameRate(FrameRateMac2Real(tDstDsLgc.GetChanVidFPS()));
				}
			}
		}
		else if (MODE_VIDEO2SECOND == byMediaMode)
		{
			tSrc = GetLocalMtFromOtherMcuMt(tSrc);
			tMVSrcCap = m_ptMtTable->GetSrcSCS(tSrc.GetMtId());
			
			tDst = GetLocalMtFromOtherMcuMt(tDst);
			tMVDstCap = m_ptMtTable->GetDstDSSCS(tDst.GetMtId());
			
			if(tMVDstCap.IsNull() || tMVSrcCap.IsNull())
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsNeedAdapt] tMVDstCap:%d or tMVSrcCap:%d is null!\n",
					tMVDstCap.IsNull(), tMVSrcCap.IsNull());
				return FALSE;
			}
		}
	}
	else
	{
		LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[IsNeedAdapt:Sec]no need adpt for src:%d-%d to dst:%d-%d,because of tSrc type:%d\n",
			tSrc.GetMcuId(), tSrc.GetMtId(),tDst.GetMcuId(),tDst.GetMtId(),tSrc.GetType()
						);
		return FALSE;
	}
	
	switch (byMediaMode)
	{
	case MODE_SECVIDEO:
		{
			//双流单格式会议,非双双流会议，源能力BP，目的能力HP，认为不需要适配
			if (  m_tConf.GetSecBitRate()==0 && 
				  !IsConfDoubleDual(m_tConf)&&
				  !m_tConfEx.IsDoubleHasCapEx() &&
				  tDSSrcCap.GetH264ProfileAttrb()== emBpAttrb &&
				  tDSDstCap.GetH264ProfileAttrb() == emHpAttrb
				)
			{
				LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[IsNeedAdapt:Sec]no need adpt for src:%d-%d to dst:%d-%d\n",
					     tSrc.GetMcuId(), tSrc.GetMtId(),tDst.GetMcuId(),tDst.GetMtId()
						);
				return FALSE;
			}

			u8 bySrcFrameRate = MEDIA_TYPE_H264 == tDSSrcCap.GetMediaType() ? tDSSrcCap.GetUserDefFrameRate() : tDSSrcCap.GetFrameRate();
			u8 byDstFrameRate = MEDIA_TYPE_H264 == tDSDstCap.GetMediaType() ? tDSDstCap.GetUserDefFrameRate() : tDSDstCap.GetFrameRate();

			//源能力BP，目的能力HP，且没用到适配器，则可以直接打交换
			if ( tDSSrcCap.GetMediaType() == MEDIA_TYPE_H264 &&
				 tDSSrcCap.GetH264ProfileAttrb() == emBpAttrb && 
				 tDSDstCap.GetMediaType() == MEDIA_TYPE_H264 && 
				 tDSDstCap.GetH264ProfileAttrb() == emHpAttrb 		
				)
			{
				u8 byBasChnNum = 0;
				CBasChn *apcSecBasChn[MAXNUM_PERIEQP]={NULL};
				if ( !GetBasBrdChnGrp(byBasChnNum,apcSecBasChn,byMediaMode) )
				{
					LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[IsNeedAdapt:Sec]no need adpt for src:%d-%d to dst:%d-%d,because of no brd chn\n",
						tSrc.GetMcuId(), tSrc.GetMtId(),tDst.GetMcuId(),tDst.GetMtId()
						);
					return FALSE;
				}
			}

			if ( tDSDstCap.GetMaxBitRate() < tDSSrcCap.GetMaxBitRate())
			{
				//单速会议，目的是E1终端，纯码率适配的话不过适配
				TBasOutInfo tSecOutInfo;
				TMt tSecTempLocalMt = GetLocalMtFromOtherMcuMt(tSrc);
				if (  m_tConf.GetSecBitRate() == 0 &&					   
					   m_ptMtTable->GetMtTransE1(tDst.GetMtId()) &&
						tDSSrcCap.GetMediaType() == tDSDstCap.GetMediaType()&&
						tDSSrcCap.GetResolution() <= tDSDstCap.GetResolution()&&
						bySrcFrameRate <= byDstFrameRate &&
						( tDSSrcCap.GetH264ProfileAttrb() == tDSDstCap.GetH264ProfileAttrb() ||
						  ( tDSSrcCap.GetH264ProfileAttrb() < tDSDstCap.GetH264ProfileAttrb() && !FindBasChn2BrdForMt(tSecTempLocalMt.GetMtId(),MODE_SECVIDEO,tSecOutInfo))
						)
					)
				{
					LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[IsNeedAdapt:Sec]e1 dtsmt:%d-%d don't need adpt\n",tDst.GetMcuId(),tDst.GetMtId());
					return FALSE;
				}

				ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedAdapt:Sec] SrcCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d, Profile:%d> -- DstCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d, Profile:%d>!\n",
					tSrc.GetMcuId(), tSrc.GetMtId(),
					tDSSrcCap.GetMediaType(), tDSSrcCap.GetResolution(), tDSSrcCap.GetMaxBitRate(), 
					MEDIA_TYPE_H264 == tDSSrcCap.GetMediaType() ? tDSSrcCap.GetUserDefFrameRate() : tDSSrcCap.GetFrameRate() , tDSSrcCap.GetH264ProfileAttrb(),
					tDst.GetMcuId(), tDst.GetMtId(),
					tDSDstCap.GetMediaType(), tDSDstCap.GetResolution(), tDSDstCap.GetMaxBitRate(),
					MEDIA_TYPE_H264 == tDSDstCap.GetMediaType() ? tDSDstCap.GetUserDefFrameRate() : tDSDstCap.GetFrameRate(),tDSDstCap.GetH264ProfileAttrb() 
					);
				
				return TRUE;
			}
			else if( tDSDstCap.GetMediaType() != tDSSrcCap.GetMediaType() )
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedAdapt:Sec] SrcCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d, Profile:%d> -- DstCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d, Profile:%d>!\n",
					tSrc.GetMcuId(), tSrc.GetMtId(),
					tDSSrcCap.GetMediaType(), tDSSrcCap.GetResolution(), tDSSrcCap.GetMaxBitRate(), 
					MEDIA_TYPE_H264 == tDSSrcCap.GetMediaType() ? tDSSrcCap.GetUserDefFrameRate() : tDSSrcCap.GetFrameRate() , tDSSrcCap.GetH264ProfileAttrb(),
					tDst.GetMcuId(), tDst.GetMtId(),
					tDSDstCap.GetMediaType(), tDSDstCap.GetResolution(), tDSDstCap.GetMaxBitRate(),
					MEDIA_TYPE_H264 == tDSDstCap.GetMediaType() ? tDSDstCap.GetUserDefFrameRate() : tDSDstCap.GetFrameRate(),tDSDstCap.GetH264ProfileAttrb() 
					);
				
				return TRUE;
			}
			else if( byDstFrameRate < bySrcFrameRate )
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedAdapt:Sec] SrcCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d, Profile:%d> -- DstCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d, Profile:%d>!\n",
					tSrc.GetMcuId(), tSrc.GetMtId(),
					tDSSrcCap.GetMediaType(), tDSSrcCap.GetResolution(), tDSSrcCap.GetMaxBitRate(), 
					MEDIA_TYPE_H264 == tDSSrcCap.GetMediaType() ? tDSSrcCap.GetUserDefFrameRate() : tDSSrcCap.GetFrameRate() , tDSSrcCap.GetH264ProfileAttrb(),
					tDst.GetMcuId(), tDst.GetMtId(),
					tDSDstCap.GetMediaType(), tDSDstCap.GetResolution(), tDSDstCap.GetMaxBitRate(),
					MEDIA_TYPE_H264 == tDSDstCap.GetMediaType() ? tDSDstCap.GetUserDefFrameRate() : tDSDstCap.GetFrameRate(),tDSDstCap.GetH264ProfileAttrb() 
					);
				
				return TRUE;
			}
			else if(  tDSDstCap.IsSrcCapLowerThanDst( tDSDstCap.GetResolution(), byDstFrameRate, tDSSrcCap.GetResolution(),bySrcFrameRate) )
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedAdapt:Sec] SrcCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d, Profile:%d> -- DstCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d, Profile:%d>!\n",
					tSrc.GetMcuId(), tSrc.GetMtId(),
					tDSSrcCap.GetMediaType(), tDSSrcCap.GetResolution(), tDSSrcCap.GetMaxBitRate(), 
					MEDIA_TYPE_H264 == tDSSrcCap.GetMediaType() ? tDSSrcCap.GetUserDefFrameRate() : tDSSrcCap.GetFrameRate() , tDSSrcCap.GetH264ProfileAttrb(),
					tDst.GetMcuId(), tDst.GetMtId(),
					tDSDstCap.GetMediaType(), tDSDstCap.GetResolution(), tDSDstCap.GetMaxBitRate(),
					MEDIA_TYPE_H264 == tDSDstCap.GetMediaType() ? tDSDstCap.GetUserDefFrameRate() : tDSDstCap.GetFrameRate(),tDSDstCap.GetH264ProfileAttrb() 
					);
				
				return TRUE;
			}
//			else if ( tDSDstCap.GetH264ProfileAttrb() != tDSSrcCap.GetH264ProfileAttrb() )
//			{
//				ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedAdapt:Sec] SrcCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d, Profile:%d> -- DstCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d, Profile:%d>!\n",
//					tSrc.GetMcuId(), tSrc.GetMtId(),
//					tDSSrcCap.GetMediaType(), tDSSrcCap.GetResolution(), tDSSrcCap.GetMaxBitRate(), 
//					MEDIA_TYPE_H264 == tDSSrcCap.GetMediaType() ? tDSSrcCap.GetUserDefFrameRate() : tDSSrcCap.GetFrameRate() ,tDSSrcCap.GetH264ProfileAttrb(),
//					tDst.GetMcuId(), tDst.GetMtId(),
//					tDSDstCap.GetMediaType(), tDSDstCap.GetResolution(), tDSDstCap.GetMaxBitRate(),
//					MEDIA_TYPE_H264 == tDSDstCap.GetMediaType() ? tDSDstCap.GetUserDefFrameRate() : tDSDstCap.GetFrameRate(), tDSDstCap.GetH264ProfileAttrb() 
//					);
//				return TRUE;
//			}
//			else if (tDSDstCap < tDSSrcCap)
//			{
//				ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedAdapt:Sec] SrcCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d,Profile:%d> -- DstCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d,Profile:%d>!\n",
//					tSrc.GetMcuId(), tSrc.GetMtId(),
//					tDSSrcCap.GetMediaType(), tDSSrcCap.GetResolution(), tDSSrcCap.GetMaxBitRate(), 
//					MEDIA_TYPE_H264 == tDSSrcCap.GetMediaType() ? tDSSrcCap.GetUserDefFrameRate() : tDSSrcCap.GetFrameRate() ,tDSSrcCap.GetH264ProfileAttrb(),
//					tDst.GetMcuId(), tDst.GetMtId(),
//					tDSDstCap.GetMediaType(), tDSDstCap.GetResolution(), tDSDstCap.GetMaxBitRate(),
//					MEDIA_TYPE_H264 == tDSDstCap.GetMediaType() ? tDSDstCap.GetUserDefFrameRate() : tDSDstCap.GetFrameRate(),tDSDstCap.GetH264ProfileAttrb() 
//					);
//				
//				return TRUE;
//			}
			else
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedAdapt:Sec] no need adpt,SrcCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d,Profile:%d> -- DstCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d,Profile:%d>!\n",
					tSrc.GetMcuId(), tSrc.GetMtId(),
					tDSSrcCap.GetMediaType(), tDSSrcCap.GetResolution(), tDSSrcCap.GetMaxBitRate(), 
					MEDIA_TYPE_H264 == tDSSrcCap.GetMediaType() ? tDSSrcCap.GetUserDefFrameRate() : tDSSrcCap.GetFrameRate() ,tDSSrcCap.GetH264ProfileAttrb(),
					tDst.GetMcuId(), tDst.GetMtId(),
					tDSDstCap.GetMediaType(), tDSDstCap.GetResolution(), tDSDstCap.GetMaxBitRate(),
					MEDIA_TYPE_H264 == tDSDstCap.GetMediaType() ? tDSDstCap.GetUserDefFrameRate() : tDSDstCap.GetFrameRate(),tDSDstCap.GetH264ProfileAttrb() 
					);
				return FALSE;
			}
		}

	case MODE_AUDIO:
		{
			if ( tSrcAudCap.GetAudioMediaType() != MEDIA_TYPE_NULL &&
				 tDstAudCap.GetAudioMediaType() != MEDIA_TYPE_NULL &&
				 ( tSrcAudCap.GetAudioMediaType() != tDstAudCap.GetAudioMediaType() 
				 ||tSrcAudCap.GetAudioTrackNum() != tDstAudCap.GetAudioTrackNum()
				  )
				)
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedAdapt] tSrc<McuId:%d, MtId:%d> --> tDst<McuId:%d, MtId:%d> need aud adp!\n",
					tSrc.GetMcuId(), tSrc.GetMtId(), tDst.GetMcuId(), tDst.GetMtId());
				return TRUE;
			}
			else
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedAdapt] tSrc<McuId:%d, MtId:%d> --> tDst<McuId:%d, MtId:%d> not need aud adp!\n",
					tSrc.GetMcuId(), tSrc.GetMtId(), tDst.GetMcuId(), tDst.GetMtId());
				return FALSE;
			}
		}

	case MODE_VIDEO:
	case MODE_VIDEO2SECOND:
		{
			//主流单格式会议并且无辅格式，源能力BP，目的能力HP，认为不需要适配
			if (  m_tConf.GetSecBitRate()==0 && 
				!m_tConfEx.IsMainHasCapEx() &&
				tMVSrcCap.GetVideoProfileType()== emBpAttrb &&
				tMVDstCap.GetVideoProfileType() == emHpAttrb &&
				m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_NULL
				)
			{
				LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[IsNeedAdapt:vid]no need adpt for src:%d-%d to dst:%d-%d\n",
					tSrc.GetMcuId(), tSrc.GetMtId(),tDst.GetMcuId(),tDst.GetMtId()
					);
				return FALSE;
			}

			//源能力BP，目的能力HP，且没用到适配器，则可以直接打交换
			if (tMVSrcCap.GetVideoMediaType()== MEDIA_TYPE_H264 &&
				tMVSrcCap.GetVideoProfileType()== emBpAttrb &&
				tMVDstCap.GetVideoMediaType() == MEDIA_TYPE_H264&&
				tMVDstCap.GetVideoProfileType() == emHpAttrb
				)
			{
				u8 byBasChnNum = 0;
				CBasChn *apcSecBasChn[MAXNUM_PERIEQP]={NULL};
				if ( !GetBasBrdChnGrp(byBasChnNum,apcSecBasChn,byMediaMode) )
				{
					return FALSE;
				}
			}

			//zjj20101115 防止未得到能力的情况，保护一下
			if( tMVSrcCap.GetVideoMediaType() == MEDIA_TYPE_NULL ||
				tMVDstCap.GetVideoMediaType() == MEDIA_TYPE_NULL
				)
			{
				// [2013/01/23 chenbing]  目的卫星终端接收逻辑通道未打开, 则不允许接收组播地址码流
				if (IsMultiCastMt(tDst.GetMtId()) && tMVDstCap.GetVideoMediaType() == MEDIA_TYPE_NULL)
				{
					return TRUE;
				}
				else
				{
					return FALSE;
				}
			}
			//对于POLOCOM终端进行选看，支持不进行分辨率判断，直接建交换
			if (g_cMcuVcApp.IsVidAdjustless4Polycom() && MT_MANU_POLYCOM == m_ptMtTable->GetManuId(tDst.GetMtId()))
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedAdapt] polocom no need to use bas\n");
				return FALSE;
			}
			else if (tMVDstCap < tMVSrcCap)
			{
				//单速会议，目的是E1终端，纯码率适配的话不过适配
				TBasOutInfo tVidOutInfo;
				TMt tVidTempLocalMt = GetLocalMtFromOtherMcuMt(tSrc);
				if ( m_tConf.GetSecBitRate() == 0 &&					
					m_ptMtTable->GetMtTransE1(tDst.GetMtId()) &&
					tMVSrcCap.GetVideoMaxBitRate() > tMVDstCap.GetVideoMaxBitRate() &&
					tMVSrcCap.GetVideoMediaType() == tMVDstCap.GetVideoMediaType()&&
					tMVSrcCap.GetVideoResolution() <= tMVDstCap.GetVideoResolution()&&
					tMVSrcCap.GetUserDefFrameRate() <= tMVDstCap.GetUserDefFrameRate()&&
					 ( tMVSrcCap.GetVideoProfileType() == tMVDstCap.GetVideoProfileType() ||
						( tMVSrcCap.GetVideoProfileType() < tMVDstCap.GetVideoProfileType() && !FindBasChn2BrdForMt(tVidTempLocalMt.GetMtId(),MODE_VIDEO,tVidOutInfo) )
					 )
					)
				{
					LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[IsNeedAdapt]e1 dtsmt:%d-%d don't need adpt\n",tDst.GetMcuId(),tDst.GetMtId());
					return FALSE;
				}
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedAdapt:vid] SrcCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d,Profile:%d> -- DstCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d,Profile:%d>!\n",
					tSrc.GetMcuId(), tSrc.GetMtId(),
					tMVSrcCap.GetVideoMediaType(), tMVSrcCap.GetVideoResolution(), tMVSrcCap.GetVideoMaxBitRate(), 
					MEDIA_TYPE_H264 == tMVSrcCap.GetVideoMediaType() ? tMVSrcCap.GetUserDefFrameRate() : tMVSrcCap.GetVideoFrameRate() ,tMVSrcCap.GetVideoProfileType(),
					tDst.GetMcuId(), tDst.GetMtId(),
					tMVDstCap.GetVideoMediaType(), tMVDstCap.GetVideoResolution(), tMVDstCap.GetVideoMaxBitRate(),
					MEDIA_TYPE_H264 == tMVDstCap.GetVideoMediaType() ? tMVDstCap.GetUserDefFrameRate() : tMVDstCap.GetVideoFrameRate(),tMVDstCap.GetVideoProfileType()
					);
				return TRUE;
			}
			else
			{
				if ( m_tConf.GetSecBitRate() != 0 )
				{
					//获得源的原始主流视频码率
					u16 wSrcTempBiteRate = 0;
					if ( TYPE_MCUPERI == tSrc.GetType() && EQP_TYPE_RECORDER == tSrc.GetEqpType() )
					{
						wSrcTempBiteRate = m_tConf.GetBitRate() + GetAudioBitrate( m_tConfEx.GetMainAudioTypeDesc().GetAudioMediaType() );
						wSrcTempBiteRate -= GetMaxAudioBiterate(m_tConfEx);
					}
					else if (tSrc.GetMtType() == TYPE_MT )
					{
						wSrcTempBiteRate  = m_ptMtTable->GetDialBitrate( tSrc.GetMtId() ); 
						wSrcTempBiteRate += GetAudioBitrate( tMVSrcCap.GetAudioMediaType() );
						wSrcTempBiteRate -= GetMaxAudioBiterate(m_tConfEx);
					}
					else
					{
						ConfPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[IsNeedAdapt:vid]tSrc type:%d is error!\n",tSrc.GetMtType());
						return FALSE;
					}
					
					//获得目的原始码率来进行比较
					u16 wDstTempBiteRate = m_ptMtTable->GetDialBitrate( tDst.GetMtId() );
					wDstTempBiteRate+=GetAudioBitrate( tMVDstCap.GetAudioMediaType() );
					wDstTempBiteRate-=GetMaxAudioBiterate(m_tConfEx);
					if ( wDstTempBiteRate >0 && wDstTempBiteRate<=m_tConf.GetBitRate() )
					{
						tMVDstCap.SetVideoMaxBitRate( wDstTempBiteRate );
					}

					tMVSrcCap.SetVideoMaxBitRate( wSrcTempBiteRate );
					if ( tMVDstCap < tMVSrcCap )
					{
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedAdapt:vid] SrcCapFake-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d,Profile:%d> -- DstCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d,Profile:%d>!\n",
							tSrc.GetMcuId(), tSrc.GetMtId(),
							tMVSrcCap.GetVideoMediaType(), tMVSrcCap.GetVideoResolution(), tMVSrcCap.GetVideoMaxBitRate(), 
							MEDIA_TYPE_H264 == tMVSrcCap.GetVideoMediaType() ? tMVSrcCap.GetUserDefFrameRate() : tMVSrcCap.GetVideoFrameRate() ,tMVSrcCap.GetVideoProfileType(),
							tDst.GetMcuId(), tDst.GetMtId(),
							tMVDstCap.GetVideoMediaType(), tMVDstCap.GetVideoResolution(), tMVDstCap.GetVideoMaxBitRate(),
							MEDIA_TYPE_H264 == tMVDstCap.GetVideoMediaType() ? tMVDstCap.GetUserDefFrameRate() : tMVDstCap.GetVideoFrameRate(),tMVDstCap.GetVideoProfileType()
							);
						return TRUE;
					}
				}
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedAdapt:vid]no need adpt SrcCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d,Profile:%d> -- DstCap-%d-%d<Media:%d, Res:%d, BR:%d, Fps:%d,Profile:%d>!\n",
					tSrc.GetMcuId(), tSrc.GetMtId(),
					tMVSrcCap.GetVideoMediaType(), tMVSrcCap.GetVideoResolution(), tMVSrcCap.GetVideoMaxBitRate(), 
					MEDIA_TYPE_H264 == tMVSrcCap.GetVideoMediaType() ? tMVSrcCap.GetUserDefFrameRate() : tMVSrcCap.GetVideoFrameRate() ,tMVSrcCap.GetVideoProfileType(),
					tDst.GetMcuId(), tDst.GetMtId(),
					tMVDstCap.GetVideoMediaType(), tMVDstCap.GetVideoResolution(), tMVDstCap.GetVideoMaxBitRate(),
					MEDIA_TYPE_H264 == tMVDstCap.GetVideoMediaType() ? tMVDstCap.GetUserDefFrameRate() : tMVDstCap.GetVideoFrameRate(),tMVDstCap.GetVideoProfileType()
					);
			}
		}
		break;
		
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsNeedAdapt] unexpected byMediaMode:%d!\n", byMediaMode);
		break;
	}

	return FALSE;
}

/*====================================================================
函数名      IsNeedSelAdpt
功能        ：判嗄康慕K端是否需要选看m配(选看不进行单速率适配)
算法实现    ：
引用全局变量：
输入参数说明：TMt tSrc		  源信息
			  TMt tDst		  目的信息
			  u8 byMediaMode  媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::IsNeedSelAdpt(TMt tSrc, TMt tDst, u8 byMediaMode)
{
	//[nizhijun 2010/12/02] 过滤到tDst和tSrc是同一终端或者MCU的情况
	if (tSrc == tDst && (tSrc.GetType() == TYPE_MT ||tSrc.GetType() == TYPE_MCU))
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedAdapt]Don't need adapt,because tSrc == tDst!\n");
		return FALSE;
	}

	if (byMediaMode == MODE_VIDEO && 
		IsSelInDoubleMedia(tSrc,tDst))
	{
		return FALSE;
	}

	TSimCapSet  tMVSrcCap;
	TSimCapSet  tMVDstCap;
	TAudioTypeDesc	tSrcAudCap;
	TAudioTypeDesc	tDstAudCap;
	BOOL32 bIsNeedBas = FALSE;
	if(tSrc.GetType() == TYPE_MT)
	{ 
		if (  MODE_AUDIO == byMediaMode )
		{
			TMt tLocalSrcMt = GetLocalMtFromOtherMcuMt( tSrc );
			TLogicalChannel tSrcAudLgc;
			if (!m_ptMtTable->GetMtLogicChnnl(tLocalSrcMt.GetMtId(), MODE_AUDIO, &tSrcAudLgc, FALSE))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[IsNeedAdapt] GetMtLogicChnnl Src AUD Mt%d failed!\n", tLocalSrcMt.GetMtId());
				return FALSE;
			}
			
			tSrcAudCap.SetAudioMediaType( tSrcAudLgc.GetChannelType() );
			tSrcAudCap.SetAudioTrackNum( tSrcAudLgc.GetAudioTrackNum() );
			
			TMt tLocalDstMt = GetLocalMtFromOtherMcuMt( tDst );
			TLogicalChannel tDstAudLgc;
			if (!m_ptMtTable->GetMtLogicChnnl(tLocalDstMt.GetMtId(), MODE_AUDIO, &tDstAudLgc, TRUE))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[IsNeedAdapt] GetMtLogicChnnl Dst Aud Mt%d failed!\n", tLocalDstMt.GetMtId());
				return FALSE;
			}
			
			tDstAudCap.SetAudioMediaType( tDstAudLgc.GetChannelType() );
			tDstAudCap.SetAudioTrackNum( tDstAudLgc.GetAudioTrackNum() );
		}
		else if (MODE_VIDEO == byMediaMode)
		{
			tSrc = GetLocalMtFromOtherMcuMt(tSrc);
			tMVSrcCap = m_ptMtTable->GetSrcSCS(tSrc.GetMtId());
			tDst = GetLocalMtFromOtherMcuMt(tDst);
			tMVDstCap = m_ptMtTable->GetDstSCS(tDst.GetMtId());

			if( MODE_VIDEO == byMediaMode &&  
				(MEDIA_TYPE_NULL == tMVSrcCap.GetVideoMediaType() || 
				 MEDIA_TYPE_NULL == tMVDstCap.GetVideoMediaType()))
			{
				return FALSE;
			}
		}
		else if (MODE_VIDEO2SECOND == byMediaMode)
		{
			tSrc = GetLocalMtFromOtherMcuMt(tSrc);
			tMVSrcCap = m_ptMtTable->GetSrcSCS(tSrc.GetMtId());
			
			tDst = GetLocalMtFromOtherMcuMt(tDst);
			tMVDstCap = m_ptMtTable->GetDstDSSCS(tDst.GetMtId());
			
			if (MEDIA_TYPE_NULL == tMVSrcCap.GetVideoMediaType() || MEDIA_TYPE_NULL == tMVDstCap.GetVideoMediaType())
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	switch (byMediaMode)
	{
	case MODE_AUDIO:
		{
			if ( tSrcAudCap.GetAudioMediaType() != MEDIA_TYPE_NULL &&
				tDstAudCap.GetAudioMediaType() != MEDIA_TYPE_NULL &&
				( tSrcAudCap.GetAudioMediaType() != tDstAudCap.GetAudioMediaType() 
				||tSrcAudCap.GetAudioTrackNum() != tDstAudCap.GetAudioTrackNum()
				)
			  )
			{
				bIsNeedBas = TRUE;
			}
		}
		break;
	case MODE_VIDEO:
	case MODE_VIDEO2SECOND:
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedSelAdpt:vid] SrcCap<Media:%d, Res:%d, BR:%d, Fps:%d,Profile:%d> -- DstCap<Media:%d, Res:%d, BR:%d, Fps:%d,Profile:%d>!\n",
				tMVSrcCap.GetVideoMediaType(), tMVSrcCap.GetVideoResolution(), tMVSrcCap.GetVideoMaxBitRate(), 
				MEDIA_TYPE_H264 == tMVSrcCap.GetVideoMediaType() ? tMVSrcCap.GetUserDefFrameRate() : tMVSrcCap.GetVideoFrameRate() ,tMVSrcCap.GetVideoProfileType(),
				tMVDstCap.GetVideoMediaType(), tMVDstCap.GetVideoResolution(), tMVDstCap.GetVideoMaxBitRate(),
			    MEDIA_TYPE_H264 == tMVDstCap.GetVideoMediaType() ? tMVDstCap.GetUserDefFrameRate() : tMVDstCap.GetVideoFrameRate(),tMVDstCap.GetVideoProfileType()
				);

			//对于POLOCOM终端进行选看，支持不进行分辨率判断，直接建交换
 			if (g_cMcuVcApp.IsVidAdjustless4Polycom() && MT_MANU_POLYCOM == m_ptMtTable->GetManuId(tDst.GetMtId()))
 			{
 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[IsNeedSelAdpt] polocom no need to use bas\n");
				bIsNeedBas = FALSE;
 			}
			//格式适配
			else if (tMVDstCap.GetVideoMediaType() != tMVSrcCap.GetVideoMediaType())
			{
				bIsNeedBas =  TRUE;
			}
			//选看或者多回传 需要HP>BP才过适配
			else if ( tMVDstCap.GetVideoProfileType() < tMVSrcCap.GetVideoProfileType() )
			{
				bIsNeedBas = TRUE;
			}
			//分辨率适配
			else if(tMVDstCap.GetVideoMediaType() == tMVSrcCap.GetVideoMediaType() &&
				    IsResG(tMVSrcCap.GetVideoResolution(), tMVDstCap.GetVideoResolution()))
			{
				bIsNeedBas = TRUE;
			}
			//帧率适配
			else
			{
				if (MEDIA_TYPE_H264 == tMVSrcCap.GetVideoMediaType() && 
					MEDIA_TYPE_H264 == tMVDstCap.GetVideoMediaType())
				{
					//源能力：h264 cif 30fps 目的能力:h264 cif 25fps 不走适配
					if(VIDEO_FORMAT_CIF == tMVSrcCap.GetVideoResolution() && 
					   VIDEO_FORMAT_CIF == tMVDstCap.GetVideoResolution() &&
					   tMVDstCap.GetUserDefFrameRate() == 25 && 
					   tMVSrcCap.GetUserDefFrameRate() == 30)
					{
						bIsNeedBas = FALSE;
					}
					else
					{
						u16 wSrcWidth  = 0;
						u16 wSrcHeight = 0;
						GetWHByRes(tMVSrcCap.GetVideoResolution(), wSrcWidth, wSrcHeight);

						u16 wDstWidth  = 0;
						u16 wDstHeight = 0;
						GetWHByRes(tMVDstCap.GetVideoResolution(), wDstWidth, wDstHeight);

						if (wDstWidth * wDstHeight * tMVDstCap.GetUserDefFrameRate() < 
							wSrcWidth * wSrcHeight * tMVSrcCap.GetUserDefFrameRate())
						{
							bIsNeedBas = TRUE;
						}
					}
				}
				else
				{
					if (tMVDstCap.GetVideoFrameRate() < tMVSrcCap.GetVideoFrameRate())
					{
						bIsNeedBas =  TRUE;
					}
				}
			}
		}
		break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsNeedSelAdpt] unexpected byMediaMode:%d!\n", byMediaMode);
		break;
	}
	return bIsNeedBas;
}
/*====================================================================
函数名      IsNeedSpyAdpt
功能        ：判嗄康慕K端是否需要回传m配(不进行单速率适配)
算法实现    ：
引用全局变量：
输入参数说明：TMt tSrc		  源信息
TMt tDst		  目的信息
u8 byMediaMode  媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::IsNeedSpyAdpt(const TMt &tSrc, const TSimCapSet &tDstCap, u8 byMediaMode)
{
	if( byMediaMode != MODE_AUDIO && byMediaMode != MODE_VIDEO )
	{
		return FALSE;
	}

    if (tSrc.IsNull() || 
		( tDstCap.IsNull() && byMediaMode == MODE_VIDEO )
		)
    {
		return FALSE;
    }
	
	
	TMt tMt = GetLocalMtFromOtherMcuMt(tSrc);
	//取本级能力集
	
	//是否科达终端
	BOOL32 bKedaMt = (MT_MANU_KDC == m_ptMtTable->GetManuId(tMt.GetMtId()) ||
					  MT_MANU_KDCMCU == m_ptMtTable->GetManuId(tMt.GetMtId()));

						
	if (MODE_VIDEO == byMediaMode)
	{
		TSimCapSet tSrcCap = m_ptMtTable->GetSrcSCS(tMt.GetMtId());
		
		if (tSrcCap.IsNull())
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsNeedSpyAdpt] tSrc<McuId:%d, MtId:%d>'s Cap IsNull()!\n", tMt.GetMcuId(), tMt.GetMtId());
			return FALSE;
		}
		
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS,  "[IsNeedSpyAdpt:vid] SrcCap<Media:%d, Res:%d, BR:%d, Fps:%d,Profile:%d> -- DstCap<Media:%d, Res:%d, BR:%d, Fps:%d,Profile:%d>!\n",
						   tSrcCap.GetVideoMediaType(), tSrcCap.GetVideoResolution(), tSrcCap.GetVideoMaxBitRate(), 
								 MEDIA_TYPE_H264 == tSrcCap.GetVideoMediaType() ? tSrcCap.GetUserDefFrameRate() : tSrcCap.GetVideoFrameRate() ,
								 tSrcCap.GetVideoProfileType(),
						   tDstCap.GetVideoMediaType(), tDstCap.GetVideoResolution(), tDstCap.GetVideoMaxBitRate(),
								 MEDIA_TYPE_H264 == tDstCap.GetVideoMediaType() ? tDstCap.GetUserDefFrameRate() : tDstCap.GetVideoFrameRate(),
								 tDstCap.GetVideoProfileType()
								 );
		//格式
		if (tSrcCap.GetVideoMediaType() != MEDIA_TYPE_NULL &&
			tDstCap.GetVideoMediaType() != MEDIA_TYPE_NULL &&
			tSrcCap.GetVideoMediaType() != tDstCap.GetVideoMediaType())
		{
			ConfPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[IsNeedSpyAdpt:vid]need MediaType adpt\n");
			return TRUE;
		}

		// 选看或者多回传 HP>BP 才需要过适配
		if ( tSrcCap.GetVideoProfileType() > tDstCap.GetVideoProfileType())
		{
			ConfPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[IsNeedSpyAdpt:vid]need profile adpt\n");
			return TRUE;
		}

		if (MEDIA_TYPE_H264 == tSrcCap.GetVideoMediaType() && 
			MEDIA_TYPE_H264 == tDstCap.GetVideoMediaType())
		{
			//源能力：h264 cif 30fps 目的能力:h264 cif 25fps 不走适配
			if(VIDEO_FORMAT_CIF == tSrcCap.GetVideoResolution() && 
				VIDEO_FORMAT_CIF == tDstCap.GetVideoResolution() &&
				tDstCap.GetUserDefFrameRate() == 25 && 
				tSrcCap.GetUserDefFrameRate() == 30)
			{
				return FALSE;
			}
			//帧率适配
			else
			{
				if (tDstCap.GetVideoCap().IsH264CapLower(tSrcCap.GetVideoResolution(), tSrcCap.GetUserDefFrameRate()))
				{
					//对源为KEDACOM,可降低源分辨率为目的终端分辨率
					if (bKedaMt)
					{
						if (tDstCap.GetVideoCap().IsH264CapLower(tDstCap.GetVideoResolution(), tSrcCap.GetUserDefFrameRate()))
						{
							if (tDstCap.GetVideoCap().IsH264CapLower(tDstCap.GetVideoResolution(), tDstCap.GetUserDefFrameRate()))
							{
								ConfPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[IsNeedSpyAdpt:vid]need H264CapLower adpt\n");
								return TRUE;
							}
							else
							{
								return FALSE;
							}							
						}
						else
						{
							return FALSE;
						}
					}
					else
					{
						ConfPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[IsNeedSpyAdpt:vid]not kedamt need H264CapLower adpt\n");
						return TRUE;
					}
				}
				else
				{
					return FALSE;
				}
			}
		}
		else
		{
			if (tDstCap.GetVideoFrameRate() < tSrcCap.GetVideoFrameRate())
			{
				ConfPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[IsNeedSpyAdpt:vid]need FrameRate adpt\n");
				return TRUE;
			}
		}
	}
	else if (MODE_AUDIO == byMediaMode)
	{
		TAudioTypeDesc tSrcAudCap;		
		TMt tLocalSrcMt = GetLocalMtFromOtherMcuMt( tSrc );
		TLogicalChannel tSrcAudLgc;
		if (!m_ptMtTable->GetMtLogicChnnl(tLocalSrcMt.GetMtId(), MODE_AUDIO, &tSrcAudLgc, FALSE))
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[IsNeedAdapt] GetMtLogicChnnl Src AUD Mt%d failed!\n", tLocalSrcMt.GetMtId());
			return FALSE;
		}
		
		tSrcAudCap.SetAudioMediaType( tSrcAudLgc.GetChannelType() );
		tSrcAudCap.SetAudioTrackNum( tSrcAudLgc.GetAudioTrackNum() );

		TAudioTypeDesc tDstAudCap;
		TLogicalChannel tDstAudLgc;
		if (!m_ptMtTable->GetMtLogicChnnl(m_tCascadeMMCU.GetMtId(), MODE_AUDIO, &tDstAudLgc, TRUE))
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[IsNeedSpyAdpt] GetMtLogicChnnl Dst Aud Mt%d failed!\n", m_tCascadeMMCU.GetMtId());
			return FALSE;
		}
		
		tDstAudCap.SetAudioMediaType( tDstAudLgc.GetChannelType() );
		tDstAudCap.SetAudioTrackNum( tDstAudLgc.GetAudioTrackNum() );


		if (  tSrcAudCap.GetAudioMediaType() != MEDIA_TYPE_NULL &&
			  tDstAudCap.GetAudioMediaType() != MEDIA_TYPE_NULL &&
			  ( tSrcAudCap.GetAudioMediaType() != tDstAudCap.GetAudioMediaType() 
				||tSrcAudCap.GetAudioTrackNum() != tDstAudCap.GetAudioTrackNum()
			  )
		   )
		{
			ConfPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[IsNeedSpyAdpt:AUD]need aud adpt\n");
			return TRUE;
		}
	}
	
	return FALSE;
}
/*====================================================================
函数名      StartBrdAdapt
功能        ：开启广播适配
算法实现    ：
引用全局变量：
输入参数说明：u8 byMediaMode 媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::StartBrdAdapt(u8 byMediaMode)
{
	TMt tBrdSrc = GetBrdSrc(byMediaMode);
	if (tBrdSrc.IsNull())
	{
		ConfPrint(LOG_LVL_WARNING,  MID_MCU_BAS, "[StartBrdAdapt] GetBrdSrc failed!\n");
		return FALSE;
	}
	// [10/18/2010 xliang] vmp won't broadcast through bas
	if (TYPE_MCUPERI == tBrdSrc.GetType() && EQP_TYPE_VMP == tBrdSrc.GetEqpType())
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartBrdAdapt] BrdSrc is VMP, so no startBrdAdapt!\n");
		return FALSE;
	}

	if (TYPE_MCUPERI == tBrdSrc.GetType() && EQP_TYPE_MIXER == tBrdSrc.GetEqpType())
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartBrdAdapt] BrdSrc is mixer, so no startBrdAdapt!\n");
		return FALSE;
	}
	
	//重新挂载适配参数
	RefreshBasBrdAdpParam(byMediaMode);
	
	//根据终端信息刷新适配参数
	RefreshBrdBasParam4AllMt(byMediaMode);
	
	//低速录像刷新码率
	if (!m_tConf.m_tStatus.IsNoRecording() &&
		m_tRecPara.IsRecLowStream() && 
		MODE_VIDEO == byMediaMode)
	{
		TMt tRecSrc;
		u8  byBasChnId   = 0;
		u8  byRecChnlIdx = 0;
        BOOL32 bNeedBas = IsRecordSrcBas(MODE_VIDEO, tRecSrc, byBasChnId, byRecChnlIdx);
		if (bNeedBas)
		{
 			RefreshBasParamForLowBrUse();
		}
	}

	// [5/5/2011 xliang] 低速组播刷新码率
	if (m_tConf.GetConfAttrb().IsMulticastMode() && m_tConf.GetConfAttrb().IsMulcastLowStream())
	{	
		RefreshBasParamForLowBrUse();
	}

	u8 byNum = 0;
	CBasChn *apcBasChn[MAXNUM_PERIEQP]={NULL};
	if(!GetBasBrdChnGrp(byNum, apcBasChn, byMediaMode))
	{
		ConfPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[StartBrdAdapt] GetBrdChnGrp failed:%d!\n",byMediaMode);
		return FALSE;
	}

	for (u8 byIdx = 0; byIdx <byNum; byIdx++)
	{
		if ( NULL == apcBasChn[byIdx] )
		{
			continue;
		}
		SetBasChnSrc(apcBasChn[byIdx]->GetBas(), apcBasChn[byIdx]->GetChnId(),tBrdSrc);
		SetBasChnMode(apcBasChn[byIdx]->GetBas(), apcBasChn[byIdx]->GetChnId(),byMediaMode);
		ChangeAdapt(apcBasChn[byIdx]->GetBas(), apcBasChn[byIdx]->GetChnId());
	}

	//更新适配模式
	u8 byAdaptMode = GetAdaptMode(byMediaMode);
	m_tConf.m_tStatus.SetAdaptMode(byAdaptMode, TRUE);

	return TRUE;
}

/*====================================================================
函数名      StopBrdAdapt
功能        ：停止广播适配
算法实现    ：
引用全局变量：
输入参数说明：u8 byMediaMode 媒体模式
			  BOOL32 bSelSelf  是否看自己，切换成VMP广播，停BAS时候为了保证
							   终端不看自己，那么bSelSelf置成FALSE，平时停都默认看自己

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::StopBrdAdapt(u8 byMediaMode,BOOL32 bSelSelf /*= TRUE*/)
{
	u8 byNum = 0;
	CBasChn *apcBasChn[MAXNUM_PERIEQP]={NULL};
	if(!GetBasBrdChnGrp(byNum, apcBasChn, byMediaMode))
	{
		ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"[StopBrdAdapt]conf:%d GetBasBrdChnGrp failed:byNum:%d,byMediaMode:%d!\n",
					m_byConfIdx, byNum,byMediaMode
				 );
		return FALSE;
	}

	ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"[StopBrdAdapt]conf:%d byNum:%d,byMediaMode:%d!\n", m_byConfIdx,byNum,byMediaMode);
	for (u8 byIdx = 0; byIdx < byNum; byIdx++)
	{
		if ( NULL == apcBasChn[byIdx] )
		{
			continue;
		}
		TEqp tBas = apcBasChn[byIdx]->GetBas();
		tBas.SetConfIdx(m_byConfIdx);

		emBASCHNSTATUS emBasState = g_cMcuVcApp.GetBasChnStatus(tBas, apcBasChn[byIdx]->GetChnId());

		ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"[StopBrdAdapt]tBas:%d,chnid:%d,state:%d,bSelSelf:%d!\n", tBas.GetEqpId(),apcBasChn[byIdx]->GetChnId(),emBasState,bSelSelf);
		
		//zyl 20121129 停bas广播的时候先不让过bas的目的终端看自己，防止切到不过bas的时候（如vmp广播）中间闪下看自己
		if ( emBasState != BASCHN_STATE_READY && !StopBasAdapt(tBas, apcBasChn[byIdx]->GetChnId(),bSelSelf) )
		{
			ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"[StopBrdAdapt]failed tBas:%d,chnid:%d!\n", tBas.GetEqpId(),apcBasChn[byIdx]->GetChnId());
		}
	}
	return TRUE;
}
/*====================================================================
函数名      StartBasPrsSupport
功能        ：开启BAS prs支持
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp 外设(BAS)信息
			  u8	     byChnId BAS通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/09/8     4.0         倪志俊		  创建
11/0620		4.0			周嘉麟        重整
====================================================================*/
void CMcuVcInst::StartBasPrsSupport(const TEqp &tEqp, u8 byChnId)
{
	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
	if (!tConfAttrb.IsResendLosePack())
	{
		return;
	}

	if (tEqp.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StartBasPrsSupport] tEqp is null!\n");
		return;
	}


	//[2011/07/05/zhangli]bas开启之后再操作
	if (g_cMcuVcApp.GetBasChnStatus(tEqp, byChnId) != BASCHN_STATE_RUNNING)
	{
		return;
	}

	u8 byChnMode = GetBasChnMode(tEqp, byChnId);
	if (MODE_NONE == byChnMode)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StartBasPrsSupport] GetBasChnMode failed!\n");
		return;
	}

	TMt tBasSrc = GetBasChnSrc(tEqp, byChnId);
	if (tBasSrc.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StartBasPrsSupport] GetBasChnSrc failed!\n");
		return;
	}

	//获得交换模式
	u8 byChnGrp = GetBasGrpType(tEqp, byChnId);
	u8 bySwitchMode = SWITCH_MODE_NONE;
	if (CHN_ADPMODE_BRD == byChnGrp)
	{
		bySwitchMode = SWITCH_MODE_BROADCAST;
	}
	else if(CHN_ADPMODE_SEL == byChnGrp)
	{
		bySwitchMode = SWITCH_MODE_SELECT;
	}
	else
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StartBasPrsSupport] nexpected byChnGrp:%d!\n", byChnGrp);
	}
	
	//建立BAS到BAS源的RTCP
	BuildRtcpSwitchForSrcToDst(tEqp, tBasSrc, byChnMode, byChnId, TRUE);
	
	//建立PRS到BAS之间的RTCP

    u8 byOutNum = 0;
	u8 byFrontOutNum = 0;
	if ( !GetBasChnOutputNum(tEqp,byChnId,byOutNum,byFrontOutNum) )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StartBasPrsSupport] GetBasChnOutputNum:%d-%d failed!\n",
				  tEqp.GetEqpId(),byChnId
				 );
		return;
	}
		
	if (SWITCH_MODE_BROADCAST == bySwitchMode)
	{
		THDAdaptParam atParam[MAXNUM_BASOUTCHN];
		TAudAdaptParam atAudParam[MAXNUM_BASOUTCHN];
		memset(atAudParam,0,sizeof(atAudParam));
		memset(atParam,0,sizeof(atParam));	

		if ( byChnMode == MODE_AUDIO  )
		{
			if(!g_cMcuVcApp.GetAudBasOutPutParam(tEqp, byChnId, byOutNum, atAudParam))
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_PRS, "[StartBasPrsSupport] GetAudBasOutPutParam failed!\n");
				return;
			}
		}
		else
		{
			if(!g_cMcuVcApp.GetBasOutPutParam(tEqp, byChnId, byOutNum, atParam))
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_PRS, "[StartBasPrsSupport] GetBasOutPutParam failed!\n");
				return;
			}
		}
	

		u8 byPrsId = 0;
		u8 byPrsChnId = 0;

		for ( u8 byOutChnnl = 0; byOutChnnl < byOutNum; byOutChnnl++ )
		{
			//判断适配参数是否为空
			if ( byChnMode == MODE_AUDIO )
			{
				if (atAudParam[byOutChnnl].IsNull())
				{
					continue;
				}
			}
			else
			{
				if (atParam[byOutChnnl].IsNull())
				{
					continue;
				}
			}
		
			
			byPrsId = 0;
	     	byPrsChnId = 0;

			if (FindPrsChnForSrc(tEqp, byFrontOutNum+byOutChnnl, byChnMode, byPrsId, byPrsChnId))
			{
				BuildRtcpAndRtpSwithForPrs(byPrsId, byPrsChnId);
			} 
			else
			{
				if (g_cMcuVcApp.GetIdlePrsChls(1, &byPrsId, &byPrsChnId))
				{
					if (ChangePrsSrc(byPrsId, byPrsChnId, byChnMode,tEqp, byFrontOutNum + byOutChnnl)

						 && AssignPrsChn(byPrsId, byPrsChnId, byChnMode))
					{
						SetPrsChnSrc(byPrsId, byPrsChnId, tEqp, byFrontOutNum + byOutChnnl);

						OccupyPrsChnl(byPrsId, byPrsChnId);
					}
				}
				else
				{
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StartBasPrsSupport]warning Not enough idle prs channel for the channel%d of eqp%d\n",
							  byFrontOutNum + byOutChnnl, tEqp.GetEqpId());
				}
			}
		}
	}
	else if (SWITCH_MODE_SELECT == bySwitchMode)
	{
		if (!tBasSrc.IsLocal() && GetLocalMtFromOtherMcuMt(tBasSrc).GetMtType() != MT_TYPE_SMCU)
		{
			return;
		}

		//非终端 || 非VMP 比如录像机没有选看，省略以下循环
		
		if (tBasSrc.GetMtType() != TYPE_MT 
			&& (tBasSrc.GetMtType() == TYPE_MCUPERI && tBasSrc.GetEqpType() != EQP_TYPE_VMP))
		{
			return;
		}

		// [2011/07/07/zhangli][add] 自定义录像
		if ( IsRecNeedAdapt(byChnMode) )
		{
			TBasOutInfo tRecOutInfo;
			if ( byChnMode == MODE_AUDIO )
			{
				TAudioTypeDesc tTempAudCap;
				m_cRecAdaptMgr.GetRecAudCapSet(tTempAudCap);
				
				TMt	tRecAudSrc = GetAudBrdSrc();
				if ( !FindBasChnByAudCapForSel( tRecAudSrc, tTempAudCap, tRecOutInfo) )
				{
					return;
				}
			}
			else
			{
				TVideoStreamCap tTempVidCap;
				m_cRecAdaptMgr.GetRecVideoCapSet(byChnMode,tTempVidCap);
	
				TMt	tRecSrc;	
				if ( MODE_VIDEO == byChnMode )
				{
					tRecSrc = GetVidBrdSrc();
				}
				else
				{
					tRecSrc = m_tDoubleStreamSrc;
				}
	
				if ( !FindBasChnByVidCapForSel( tRecSrc, tTempVidCap, byChnMode, tRecOutInfo) )
				{
					return;
				}
			}

		
			//rtcp:recoder--->bas
			TTransportAddr tBasRemoteAddr;
			if (!GetRemoteRtcpAddr(tEqp, byFrontOutNum + tRecOutInfo.m_byOutIdx, byChnMode, tBasRemoteAddr))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StartBasPrsSupport] GetRemoteRtcpAddr Bas<EqpId.%d, Chn.%d, OutNum.%d, OutIdx.%d> failed!\n",
					tEqp.GetEqpId(), byChnId, byOutNum, tRecOutInfo.m_byOutIdx);
				return;
			}

			AddRemoveRtcpToDst(tBasRemoteAddr.GetIpAddr(), tBasRemoteAddr.GetPort(), m_tRecEqp, m_byRecChnnl, byChnMode, TRUE);
			return;
		}
		//zhangli and end

		//选看
		TMtStatus tDstStatus;
		TBasOutInfo	tOutInfo;
		TMt  tDstMt;

		u8 byOtherMode = MODE_NONE;
		if (MODE_VIDEO == byChnMode)
		{
			byOtherMode = MODE_VIDEO2SECOND;
		}

		for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
		{
			if(!m_tConfAllMtInfo.MtJoinedConf(byMtId))
			{
				continue;
			}
			tDstMt = m_ptMtTable->GetMt(byMtId);
			
			if (m_ptMtTable->GetMtStatus(byMtId, &tDstStatus) &&
				tDstStatus.GetSelectMt(byChnMode) == tBasSrc && 
				IsNeedSelAdpt(tBasSrc, tDstMt, byChnMode))
			{
				if (!FindBasChn2SelForMt(tBasSrc, tDstMt, byChnMode, tOutInfo))
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StartBasPrsSupport] FindBasChn2SelForMt Mt.%d failed!\n", byMtId);
					continue;
				}

				TTransportAddr tBasRemoteAddr;
				if (!GetRemoteRtcpAddr(tOutInfo.m_tBasEqp, tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx, byChnMode, tBasRemoteAddr))
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StartBasPrsSupport] GetRemoteRtcpAddr Bas<EqpId.%d, Chn.%d, OutNum.%d, OutIdx.%d> failed!\n",
						tOutInfo.m_tBasEqp.GetEqpId(), tOutInfo.m_byChnId, tOutInfo.m_byOutNum, tOutInfo.m_byOutIdx);
					continue;
				}

				AddRemoveRtcpToDst(tBasRemoteAddr.GetIpAddr(), tBasRemoteAddr.GetPort(), tDstMt, 0, byChnMode, TRUE);
			}

			if (byOtherMode != MODE_NONE && !m_ptMtTable->GetMtSelMtByMode(byMtId, byOtherMode).IsNull()
				&& IsNeedSelAdpt(tBasSrc, tDstMt, byOtherMode))
			{
				if (!FindBasChn2SelForMt(tBasSrc, tDstMt, byOtherMode, tOutInfo))
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StartBasPrsSupport] FindBasChn2SelForMt Mt.%d failed!\n", byMtId);
					continue;
				}
				
				TTransportAddr tBasRemoteAddr;
				if (!GetRemoteRtcpAddr(tOutInfo.m_tBasEqp, tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx, MODE_VIDEO, tBasRemoteAddr))
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StartBasPrsSupport] GetRemoteRtcpAddr Bas<EqpId.%d, Chn.%d, OutNum.%d, OutIdx.%d> failed!\n",
						tOutInfo.m_tBasEqp.GetEqpId(), tOutInfo.m_byChnId, tOutInfo.m_byOutNum, tOutInfo.m_byOutIdx);
					continue;
				}
				
				AddRemoveRtcpToDst(tBasRemoteAddr.GetIpAddr(), tBasRemoteAddr.GetPort(), tDstMt, 0, MODE_SECVIDEO, TRUE);
			}
 		}
	}
	else
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS,"[StartBasPrsSupport] Unexpected bySwitchMode.%d!\n", bySwitchMode);
	}
	return;
}

/*====================================================================
函数名      StopBasPrsSupport
功能        ：开启BAS prs支持
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp 外设(BAS)信息
			  u8	     byChnId BAS通道Id

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/06/20     4.0        周嘉麟		   创建
====================================================================*/
void CMcuVcInst::StopBasPrsSupport(const TEqp &tEqp, u8 byChnId)
{
	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
	if (!tConfAttrb.IsResendLosePack())
	{
		return;
	}
	if (tEqp.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StopBasPrsSupport] tEqp is null!\n");
		return;
	}

	u8 byBasChnMode = GetBasChnMode(tEqp, byChnId);
	if (MODE_NONE == byBasChnMode)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StopBasPrsSupport] GetBasChnMode failed!\n");
		return;
	}

	TMt tBasSrc = GetBasChnSrc(tEqp, byChnId);
	if (tBasSrc.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StopBasPrsSupport] GetBasChnSrc failed!\n");
		return;
	}

	//[2011/08/11/zhangli]bas-->src的rtcp交换在StopSwitchToPeriEqp时拆，这里去掉
	//BuildRtcpSwitchForSrcToDst(tEqp, tBasSrc, byBasChnMode, byChnId, 0, FALSE);

	u8 byBasGrpType = GetBasGrpType(tEqp, byChnId);
	if (CHN_ADPMODE_NONE == byBasGrpType)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StopBasPrsSupport] GetBasGrpType failed!\n");
		return;
	}

	u8	byOutNum = 0;
	u8  byFormalOutNum = 0;
	if ( !GetBasChnOutputNum(tEqp,byChnId,byOutNum,byFormalOutNum) )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StopBasPrsSupport] GetBasChnOutputNum:%d-%d failed!\n",
				 tEqp.GetEqpId(),byChnId
				);
		return;
	}

	if (CHN_ADPMODE_BRD == byBasGrpType)
	{
		u8  byPrsId =  0;
		u8  byPrsChnlId = 0;
				
		for(u8 byOutChnl = 0; byOutChnl < byOutNum; byOutChnl++)
		{
			if (FindPrsChnForSrc(tEqp, byFormalOutNum + byOutChnl, byBasChnMode,
				byPrsId, byPrsChnlId))
			{
				StopPrs(byPrsId, byPrsChnlId,byBasChnMode);
				RlsPrsChnl(byPrsId, byPrsChnlId);				
			}
 		}
	}
	else if(CHN_ADPMODE_SEL == byBasGrpType)
	{
		for(u8 byOutChnl = 0; byOutChnl < byOutNum; byOutChnl++)
		{
			StopRtcpSwitchAlltoOne(tEqp, byFormalOutNum + byOutChnl, byBasChnMode);
		}		
	}
	return;
}
/*====================================================================
函数名      StartBasPrsSupportEx
功能        ：开启BAS prs支持
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp 外设(BAS)信息
			  u8	     byChnId BAS通道Id
			  u8		 byChnMode 通道模式
			  TMt		 tBasSrc   BAS源
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/10/21     4.0         倪志俊		  创建
====================================================================*/
void CMcuVcInst::StartBasPrsSupportEx(u8 byMediaMode)
{
	u8 byNum = 0;
	CBasChn *apcBasChn[MAXNUM_PERIEQP]={NULL};
	if(!GetBasBrdChnGrp(byNum, apcBasChn, byMediaMode))
	{
		return;
	}
	
	for (u8 byLoop = 0; byLoop < byNum; byLoop++)
	{	
		if ( NULL == apcBasChn[byLoop] )
		{
			continue;
		}
		TEqp tBas = apcBasChn[byLoop]->GetBas();
		tBas.SetConfIdx(m_byConfIdx);
		StartBasPrsSupport(tBas, apcBasChn[byLoop]->GetChnId());
	}
	return;
}

/*====================================================================
函数名     : StartMultiSpyBasPrsSupport
功能        ：开启多回传BAS到源的RTCP交换
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp 外设(BAS)信息
u8	     byChnId BAS通道Id
u8		 byChnMode 通道模式
TMt		 tBasSrc   BAS源
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/01/17     4.0         倪志俊		  创建
====================================================================*/
// void CMcuVcInst::StartMultiSpyBasPrsSupport(const TEqp &tEqp, u8 byChnId, u8 byChnMode, TMt tBasSrc)
// {
// 	//获得交换模式
// 	u8 byChnGrp = GetBasGrpType(tEqp, byChnId);
// 	u8 bySwitchMode = SWITCH_MODE_NONE;
// 	if (CHN_ADPMODE_BRD == byChnGrp)
// 	{
// 		bySwitchMode = SWITCH_MODE_BROADCAST;
// 	}
// 	else if(CHN_ADPMODE_SEL == byChnGrp)
// 	{
// 		bySwitchMode = SWITCH_MODE_SELECT;
// 	}
// 	else
// 	{
// 		ConfLog(FALSE, "[StartBasPrsSupport] nexpected byChnGrp:%d!\n", byChnGrp);
// 	}
// 	
// 	//BAS丢包rtcp申述建立(向SrcMt申述)
// 	u32 dwDstIp		  = 0;
// 	u16 dwDstRtcpPort = 0;
// 	//[nizhijun 2010/12/13] 区分src是本地终端还是下级终端
// 	if (tBasSrc.IsLocal())
// 	{
// 		TLogicalChannel tLogiclChannel;
// 		
// 		if (MODE_VIDEO == byChnMode)
// 		{
// 			m_ptMtTable->GetMtLogicChnnl(tBasSrc.GetMtId(), LOGCHL_VIDEO, &tLogiclChannel, FALSE);
// 		}
// 		else if(MODE_SECVIDEO == byChnMode)
// 		{  
// 			m_ptMtTable->GetMtLogicChnnl(tBasSrc.GetMtId(), LOGCHL_SECVIDEO, &tLogiclChannel, FALSE);
// 		}
// 		else if (MODE_AUDIO == byChnMode)
// 		{
// 			m_ptMtTable->GetMtLogicChnnl(tBasSrc.GetMtId(), LOGCHL_AUDIO, &tLogiclChannel, FALSE);
// 		}
// 		
// 		dwDstIp		  = tLogiclChannel.GetSndMediaCtrlChannel().GetIpAddr();
// 		dwDstRtcpPort = tLogiclChannel.GetSndMediaCtrlChannel().GetPort(); 
// 		
// 		if (dwDstIp > 0 && dwDstRtcpPort >0)
// 		{
// 			ConfLog(FALSE,"[StartBasPrsSupport]MODE:%d RTCP Swicth: BAS.%d----->MT.%d (%s@%d)\n",
// 				byChnMode, tEqp.GetEqpId(), tBasSrc.GetMtId(), StrOfIP(dwDstIp), dwDstRtcpPort);
// 			AddRemoveRtcpToDst(dwDstIp,dwDstRtcpPort,tEqp,byChnId,byChnMode,bySwitchMode,TRUE);
// 		}
// 		else
// 		{
// 			ConfLog(FALSE,"[StartBasPrsSupport]Get SrcMT's IP or RtcpPort Failed!\n");
// 		}
// 	}
// 	else
// 	{
// 		u16 wSpyPort = 0;
// 		CRecvSpy tSpyResource;	
// 		TMt tLocalSrcMt = GetLocalMtFromOtherMcuMt(tBasSrc);		
// 		if( m_cSMcuSpyMana.GetRecvSpy(tBasSrc, tSpyResource ) )
// 		{
// 			wSpyPort = tSpyResource.m_tSpyAddr.GetPort();
// 			if (MODE_VIDEO == byChnMode)
// 			{
// 				dwDstRtcpPort = wSpyPort + 1; 
// 			}
// 			else if(MODE_AUDIO == byChnMode)
// 			{
// 				dwDstRtcpPort = wSpyPort + 3; 
// 			}
// 			
// 			dwDstIp = g_cMcuVcApp.GetMpIpAddr( m_ptMtTable->GetMpId( tLocalSrcMt.GetMtId()) );
// 			
// 			if (dwDstIp > 0 && dwDstRtcpPort >0)
// 			{
// 				ConfLog(FALSE,"[StartBasPrsSupport]MODE:%d RTCP Swicth,BAS.%d----->MT.%d (%s@%d)\n",
// 					byChnMode, tEqp.GetEqpId(), tLocalSrcMt.GetMtId(), StrOfIP(dwDstIp), dwDstRtcpPort);
// 				AddRemoveRtcpToDst(dwDstIp,dwDstRtcpPort,tEqp,byChnId,byChnMode,bySwitchMode,TRUE);
// 			}
// 			else
// 			{
// 				ConfLog(FALSE,"[StartBasPrsSupport]Get SrcMT's IP or RtcpPort Failed!\n");
// 			}
// 		}
// 	}
// }
/*====================================================================
函数名      GetBasParamExt
功能        ：广播适配
算法实现    ：
引用全局变量：
输入参数说明：u8 byMediaMode			
			  TBasAdaptParamExt &tBasParamExt
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/26	4.7			倪志俊		  创建
====================================================================*/
BOOL32	CMcuVcInst::GetBasParamExt(TMt &tSrc,u8 byMediaMode, TBasAdaptParamExt &tBasParamExt)
{
	if (tSrc.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasParamExt] tSrc is null!\n");
		return FALSE;
	}

	//视音频解码类型
	if (!GetBasDecPT(tSrc, byMediaMode, tBasParamExt.m_byBasVidDectPT, tBasParamExt.m_byBasAudDecPT,tBasParamExt.m_tSrcLgcChn))
	{
		return FALSE;
	}
	
	//一些特殊分辨率的处理，因为随后BAS有策略会根据源调编码分辨率，故此处对这些分辨率另外处理
	if (  byMediaMode!= MODE_AUDIO )
	{
		if (  tBasParamExt.m_tSrcLgcChn.GetChannelType() == MEDIA_TYPE_H264 &&
			  tBasParamExt.m_tSrcLgcChn.GetVideoFormat() == VIDEO_FORMAT_AUTO
			)
		{
			tBasParamExt.m_tSrcLgcChn.SetVideoFormat(VIDEO_FORMAT_CIF);
		}
		else if (  tBasParamExt.m_tSrcLgcChn.GetChannelType() == MEDIA_TYPE_MP4 &&
			tBasParamExt.m_tSrcLgcChn.GetVideoFormat() == VIDEO_FORMAT_16CIF
			)
		{
			tBasParamExt.m_tSrcLgcChn.SetVideoFormat(VIDEO_FORMAT_4CIF);
		}
		else if (  tBasParamExt.m_tSrcLgcChn.GetChannelType() == MEDIA_TYPE_MP4 &&
			tBasParamExt.m_tSrcLgcChn.GetVideoFormat() == VIDEO_FORMAT_AUTO
			)
		{
			u8 byNewRes = GetAutoResByBitrate( VIDEO_FORMAT_AUTO,tBasParamExt.m_tSrcLgcChn.GetFlowControl() );
			tBasParamExt.m_tSrcLgcChn.SetVideoFormat(byNewRes);
		}
	}


	//加密参数
	tBasParamExt.m_tEncrypt = m_tConf.GetMediaKey();

	//TDoublePayload tDVPayload;
	if (MEDIA_TYPE_H264 == tBasParamExt.m_byBasVidDectPT || 
		MEDIA_TYPE_H263PLUS == tBasParamExt.m_byBasVidDectPT || 
		CONF_ENCRYPTMODE_NONE != tBasParamExt.m_tEncrypt.GetEncryptMode()||
		m_tConf.GetCapSupportEx().IsVideoSupportFEC()
	   )
	{
		tBasParamExt.m_tDVPayload.SetActivePayload(GetActivePayload(m_tConf, tBasParamExt.m_byBasVidDectPT));
	}
	else
	{
		tBasParamExt.m_tDVPayload.SetActivePayload(tBasParamExt.m_byBasVidDectPT);
	}
	tBasParamExt.m_tDVPayload.SetRealPayLoad(tBasParamExt.m_byBasVidDectPT); 

	//TDoublePayload tDAPayload;
	if (MODE_AUDIO == byMediaMode)
	{
		//音频暂时没有不加密下的动态载荷需求
		if (CONF_ENCRYPTMODE_NONE != tBasParamExt.m_tEncrypt.GetEncryptMode() ||
			// zbq [10/29/2007] 适应FEC支持其他格式
			m_tConf.GetCapSupportEx().IsAudioSupportFEC() )
		{
			tBasParamExt.m_tDAPayload.SetActivePayload(GetActivePayload(m_tConf, tBasParamExt.m_byBasAudDecPT));
		}
		else
		{
			tBasParamExt.m_tDAPayload.SetActivePayload(tBasParamExt.m_byBasAudDecPT);
		}
		tBasParamExt.m_tDAPayload.SetRealPayLoad(tBasParamExt.m_byBasAudDecPT);
	}
	
	//TCapSupportEx,主要是VPU使用
	tBasParamExt.m_tCapSupportEx = m_tConf.GetCapSupportEx();

	tBasParamExt.m_byIsRcvH264DependInMark = 0;
	if( TYPE_MT == tSrc.GetType() )
	{
		if( !tSrc.IsLocal() )
		{
			tSrc = GetLocalMtFromOtherMcuMt( tSrc );
		}
		tBasParamExt.m_byIsRcvH264DependInMark = IsRcvH264DependInMark( tSrc.GetMtId() ) ? 1 : 0;
	}

	return TRUE;
}


/*====================================================================
函数名      ChangeAdapt
功能        ：广播适配
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp 外设信息
			  u8	   byChnId 通道Id
			  BOOL32    bStart 是否开启bas
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::ChangeAdapt(const TEqp &tEqp, u8 byChnId)
{	
	//获得额外参数信息
	u8 byMediaMode = GetBasChnMode(tEqp, byChnId);
	TMt	tBasSrc = GetBasChnSrc(tEqp,byChnId);
	TBasAdaptParamExt tBasParamExt;
	if ( !GetBasParamExt(tBasSrc,byMediaMode,tBasParamExt) )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ChangeAdapt] GetBasParamExt failed!\n");
		return FALSE;
	}
	
	//获取该通道是否适配录像通道，为保证MPU2下参时，不进行参数调整，从而不切文件
	if ( IsBasChnForRecAdapt(tEqp,byChnId) ||
		 CHN_ADPMODE_SEL == GetBasGrpType(tEqp,byChnId) 
		)
	{
		tBasParamExt.m_bIsSpecialChn = TRUE;
		LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[ChangeAdapt]tEqp:%d byChnId:%d is recdapchn\n",tEqp.GetEqpId(), byChnId);
	}

	//Bug00103790,bas在线，才启动BAS
	TPeriEqpStatus tBasStatus;	
	g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tBasStatus);
	if (!ISTRUE(tBasStatus.m_byOnline))
	{
		//Bug00104047 选看源非空，不停交换,此处不再使用GetMtSrc来判断
		//因为对于BAS掉线，需要对一些视频交换拆除
		StopSwitchToSubMtNeedAdp(tEqp,byChnId);
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ChangeAdapt] tBas:%d-%d is not online!\n",tEqp.GetEqpId(),byChnId);
		return FALSE;
    }

	//开启适配
	if ( !StartBasChnAdapt(tEqp,byChnId,tBasParamExt) )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[ChangeAdapt] start bas:%d-%d adapt failed!\n",tEqp.GetEqpId(), byChnId);
		return FALSE;
	}
	
	//设置定时器
	BOOL32 bStateReady = g_cMcuVcApp.GetBasChnStatus(tEqp, byChnId) == BASCHN_STATE_READY? TRUE:FALSE;
	if (bStateReady)
	{
		u32 dwTimerId = MCUVC_WAITHDVIDBASRSP_TIMER + GetBasPosition(tEqp, byChnId);
		SetTimer(dwTimerId, 20*1000);
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[ChangeAdapt] CMcuVcInst.%d Set timer %d\n",  GetInsID(), dwTimerId);
	}
	
	return TRUE;
}

/*====================================================================
函数名        StopBasAdaptOnlyForRecAdp
功能        ：适配录像备份恢复时停止适配，不停到外设REC的交换
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp 外设信息
			  u8	   byChnId 通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/11/21   4.7         倪志俊        创建
====================================================================*/
BOOL32 CMcuVcInst::StopBasAdaptOnlyForRecAdp(const TEqp &tEqp, u8 byChnId)
{
	//通道停止适配
	StopBasChnAdapt(tEqp,byChnId);
	//RTP交换拆除
	u8 byMediaMode  = GetBasChnMode(tEqp, byChnId);
	BOOL32 bStopAud = byMediaMode == MODE_VIDEO;
	if (MODE_NONE == byMediaMode)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[StopBasAdaptOnlyForRecAdp] byMediaMode is MODE_NONE!\n");
		return FALSE;
	}
	
	//拆除到m配器交Q
	StopSwitchToPeriEqp(tEqp.GetEqpId(), byChnId, TRUE, byMediaMode);
	if (bStopAud)
	{
		StopSwitchToPeriEqp(tEqp.GetEqpId(), byChnId, TRUE, MODE_AUDIO);
	}

	//RTCP交换拆除
	StopBasPrsSupport(tEqp, byChnId);

	return TRUE;
}


/*====================================================================
函数名        StopAdapt
功能        ：停止适配
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp 外设信息
			  u8	   byChnId 通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::StopBasAdapt(const TEqp &tEqp, u8 byChnId,BOOL32 bSelSelf /*= TRUE*/)
{
	//通道停止适配
	StopBasChnAdapt(tEqp,byChnId);
	//RTP交换拆除
	StopBasSwitch(tEqp, byChnId,bSelSelf);
	//RTCP交换拆除
	StopBasPrsSupport(tEqp, byChnId);

	u8 byMode = GetBasChnMode(tEqp, byChnId);
	if ( MODE_AUDIO == byMode || MODE_VIDEO == byMode || byMode == MODE_SECVIDEO )
	{
		u8 byAdaptMode = GetAdaptMode(byMode);
		m_tConf.m_tStatus.SetAdaptMode(byAdaptMode, FALSE);
	}
	else
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StopBasAdapt] unexpected Mode:%d!\n", byMode);
	}

	return TRUE;
}

/*====================================================================
函数名      GetBrdSrc
功能        ：根据媒体模式获取广播源
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::StartSelAdapt(TMt tSrc, TMt tDst, u8 byMediaMode, BOOL32 bInnerSelect)
{	
	TMt tOrigSrc = tSrc;
	TMt tOrigDst = tDst;
	if (tSrc.IsNull() || tDst.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[StartSelAdapt] tSrc or tDst is null!\n");
		return FALSE;
	}
	if (MODE_NONE == byMediaMode)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartSelAdapt] byMediaMode is MODE_NONE!\n");
		return FALSE;
	}

	if (!IsNeedSelAdpt(tSrc, tDst, byMediaMode))
	{
		return FALSE;
	}
	
 	tSrc = GetLocalMtFromOtherMcuMt(tSrc);
 	tDst = GetLocalMtFromOtherMcuMt(tDst);
	
	TSimCapSet tSrcCap = m_ptMtTable->GetSrcSCS(tSrc.GetMtId());
	TSimCapSet tDstCap;

	if (MODE_VIDEO2SECOND == byMediaMode)
	{
		tDstCap = m_ptMtTable->GetDstDSSCS(tDst.GetMtId());
	}
	else
	{
		tDstCap = m_ptMtTable->GetDstSCS(tDst.GetMtId());
	}

	//[nizhijun 2012/06/19] 对于8KH选看，如果目的能力时720 60，那么作假成720 30能力
	//以便于单方调度时，能占用到通道
#ifdef _8KH_
	if ( tDstCap.GetVideoMediaType() == MEDIA_TYPE_H264 &&
		 tDstCap.GetVideoResolution() == VIDEO_FORMAT_HD720 &&
		 ( tDstCap.GetUserDefFrameRate() == 60 ||  tDstCap.GetUserDefFrameRate() == 50)
		)
	{
		tDstCap.SetUserDefFrameRate( tDstCap.GetUserDefFrameRate()/2 );
		LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[StartSelAdapt]Fabricate special cap for mt:%d\n",tDst.GetMtId() );
	}
#endif

#ifdef _8KI_
	if ( tDstCap.GetVideoMediaType() == MEDIA_TYPE_H264 )
	{
		if( tDstCap.GetVideoResolution() > VIDEO_FORMAT_4CIF )
		{
			tDstCap.SetVideoResolution( VIDEO_FORMAT_4CIF );
			LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[StartSelAdapt]Fabricate special cap res for mt:%d\n",tDst.GetMtId() );
		}
		if( tDstCap.GetUserDefFrameRate() == 60 ||  tDstCap.GetUserDefFrameRate() == 50 )
		{
			tDstCap.SetUserDefFrameRate( tDstCap.GetUserDefFrameRate()/2 );
			LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[StartSelAdapt]Fabricate special cap fps for mt:%d\n",tDst.GetMtId() );
		}		
	}
#endif

	if ((MODE_VIDEO == byMediaMode || MODE_VIDEO2SECOND == byMediaMode) &&
		(MEDIA_TYPE_NULL == tSrcCap.GetVideoMediaType() || 
		 MEDIA_TYPE_NULL == tDstCap.GetVideoMediaType()))
	{
		return FALSE;
	}
	
	//源分辨率小于目的分辨率，根据源来找通道
	//目前选看只有格式适配存在该情况
	BOOL32 bIsRelyOnSrc = FALSE;
	if( tDstCap.GetVideoMediaType() != tSrcCap.GetVideoMediaType() ||
		tDstCap.GetVideoProfileType() != tSrcCap.GetVideoProfileType() )
	{
		TVideoStreamCap tSrcVidCap = tSrcCap.GetVideoCap();
		if( tSrcCap.GetVideoResolution() == VIDEO_FORMAT_AUTO  && tSrcCap.GetVideoMediaType() == MEDIA_TYPE_MP4 )
		{
			//mpe4 auto分辨率依赖于码率，选看的话，源码率会根据目的码率调整，故此处要重新计算码率
			u16 wSrcBiteRate=m_ptMtTable->GetSndBandWidth(tSrc.GetMtId());
			u16 wDstBiteRate = tDstCap.GetVideoMaxBitRate();
			wSrcBiteRate = min(wSrcBiteRate,wDstBiteRate);
			tSrcVidCap.SetMaxBitRate( wSrcBiteRate );
		}
		TVideoStreamCap tDstVidCap = tDstCap.GetVideoCap();
		if ( IsNeedAdjustCapBySrc(tSrcVidCap,tDstVidCap) )
		{
			tDstCap.SetVideoResolution( tDstVidCap.GetResolution() );
			if ( tDstCap.GetVideoMediaType() == MEDIA_TYPE_H264 )
			{
				tDstCap.SetUserDefFrameRate( tDstVidCap.GetUserDefFrameRate() );
			}
			bIsRelyOnSrc = TRUE;
		}
	}


	if (MODE_AUDIO == byMediaMode &&
		(MEDIA_TYPE_NULL == tSrcCap.GetAudioMediaType() || 
		 MEDIA_TYPE_NULL == tDstCap.GetAudioMediaType()))
	{
		return FALSE;
	}

	TAudioTypeDesc  tAudDstCap; 
    if (  MODE_AUDIO == byMediaMode)
    {
        TLogicalChannel tDstAudLgc;
        if (!m_ptMtTable->GetMtLogicChnnl(tDst.GetMtId(), MODE_AUDIO, &tDstAudLgc, TRUE))
        {
            ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[FindBasChn2SelForMt] GetMtLogicChnnl Dst Aud Mt%d failed!\n", tDst.GetMtId());
            return FALSE;
        }
        
        tAudDstCap.SetAudioMediaType( tDstAudLgc.GetChannelType() );
        tAudDstCap.SetAudioTrackNum( tDstAudLgc.GetAudioTrackNum() );
    }
	
	//当终端过适配建交换到上级mcu的上传端口时，如果上传端口为264格式就直接适配到cif,
	//因为如果上级开启画面合成且如果上传端口的格式时264高清格式，适配的码流直接建到上级画面合成会导致画面合成撑死,
	//所以策略改为都适配到264cif
// 	if( !m_tCascadeMMCU.IsNull() && tDst == m_tCascadeMMCU &&
// 		MODE_VIDEO == byMediaMode &&
// 		tDstCap.GetVideoMediaType() == MEDIA_TYPE_H264 &&
// 		tSrcCap.GetVideoMediaType() != MEDIA_TYPE_H264 &&
// 		tDstCap.GetVideoResolution() != VIDEO_FORMAT_CIF )
// 	{
// 		if( ( VIDEO_FORMAT_HD720 == tDstCap.GetVideoResolution() ||
// 			VIDEO_FORMAT_HD1080 == tDstCap.GetVideoResolution() ) &&
// 			tDstCap.GetUserDefFrameRate() >= 50 
// 			)
// 		{
// 			tDstCap.SetUserDefFrameRate( 25 );		
// 		}
// 		tDstCap.SetVideoResolution( VIDEO_FORMAT_CIF );		
// 	}

	TBasOutInfo	tOutInfo;
	BOOL32 bIsNeedBas = !FindBasChn2SelForMt(tOrigSrc, tOrigDst, byMediaMode, tOutInfo);
	
	CBasChn *pcBasChn = NULL;
	TBasChnCapData tChnCapData;
	BOOL32 bIsNeedChangeAdapt = FALSE;	//是否需要开启BAS
	BOOL32 bIsSameBasChn = FALSE;	//是否是原来已经占用的BAS通道
	if (bIsNeedBas)
	{
		if ( byMediaMode == MODE_AUDIO )
        {
            if ( !GetBasChnForAudSel(tOrigSrc,tAudDstCap,&pcBasChn,tChnCapData) )
            {
                NotifyMcsAlarmInfo(0, ERR_MCU_SELAUDBASISNOTENOUGH);
                ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartSelAdapt] no idle sel aud bas!\n");
                return FALSE;
            }
        }
        else
        {
            if ( !GetBasChnForSel(tOrigSrc,tDstCap,byMediaMode,&pcBasChn,tChnCapData) )
            {
                NotifyMcsAlarmInfo(0, ERR_MCU_SELVIDBASISNOTENOUGH);
                ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartSelAdapt] no idle sel bas!\n");
                return FALSE;
            }
        }
 		
		if ( NULL == pcBasChn )
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartSelAdapt] pcBasChn is NULL!\n");
			return FALSE;
		}
		
		//非同源的新通道
		if ( !(pcBasChn->GetSrc() == tOrigSrc) )
		{
			bIsSameBasChn = FALSE;
			TEqp tTempBas = pcBasChn->GetBas();
			tTempBas.SetConfIdx(m_byConfIdx);
			pcBasChn->SetBas(tTempBas);
			//添加选看通道入选看组
			AssignBasSelChn(pcBasChn,tChnCapData,m_tConf.GetConfId());
			//设置通道源信息
			SetBasChnSrc(pcBasChn->GetBas(), pcBasChn->GetChnId(), tOrigSrc);
			//设置通道媒体模式
			SetBasChnMode(pcBasChn->GetBas(), pcBasChn->GetChnId(), byMediaMode);
		}
		//同源通道添加参数
		else
		{
			bIsSameBasChn = TRUE;
			AddBasSelChnParam(pcBasChn->GetBas(), pcBasChn->GetChnId(),tChnCapData);	
		}
		bIsNeedChangeAdapt = TRUE;
	}
    else
	{
		//BAS参数是否还需要调整,在同源通道上添加更精确的参数，因为获得BAS输出可能是模糊匹配的，此处判断是否可以不使用模糊的匹配的做法
		if (!bIsRelyOnSrc && IsNeedAdjustSelParam(tOrigSrc,tDst,tOutInfo,byMediaMode,&pcBasChn,tChnCapData))
		{
			bIsNeedChangeAdapt = TRUE;
			bIsSameBasChn = TRUE;
			AddBasSelChnParam(pcBasChn->GetBas(), pcBasChn->GetChnId(),tChnCapData);
		}
		else
		{			
			//刷新选看适配参数
			RefreshSelBasParam(tOrigSrc, tDst, byMediaMode);
			//从bas建交换到目的终端
			tOutInfo.m_tBasEqp.SetConfIdx(m_byConfIdx);
			//Rtp
			TSwitchGrp tSwitchGrp;
			tSwitchGrp.SetSrcChnl(tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx);
			tSwitchGrp.SetDstMtNum(1);
			tSwitchGrp.SetDstMt(&tDst);
			g_cMpManager.StartSwitchToAll(tOutInfo.m_tBasEqp, 1, &tSwitchGrp, byMediaMode, SWITCH_MODE_SELECT, TRUE);
			//Rtcp
			TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
			if (tConfAttrb.IsResendLosePack())
			{
				BuildRtcpSwitchForSrcToDst(tDst, tOutInfo.m_tBasEqp, byMediaMode, 0, tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx, TRUE);
			}		
		}
	}
	
	if ( bIsNeedChangeAdapt &&  pcBasChn != NULL)
	{
		switch(byMediaMode)
        {
        case MODE_AUDIO:
            {
                TAudAdaptParam tAudParam;
                tAudParam.SetAudCodeType( tAudDstCap.GetAudioMediaType() );
				tAudParam.SetAudActiveType( GetActivePayload(m_tConf,tAudDstCap.GetAudioMediaType()) );
                tAudParam.SetTrackNum( tAudDstCap.GetAudioTrackNum() );
                TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
                tAudParam.SetIsNeedByPrs(tConfAttrb.IsResendLosePack());
                
                //保存适配参数
                if( !SetBasSelAudChnParam( pcBasChn->GetBas(),pcBasChn->GetChnId(),tAudParam ) ) 
                {
                    ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartSelAdapt] SetBasSelAudChnParam failed!\n");
                    return FALSE;
                }
            }
            break;
		case MODE_VIDEO:
		case MODE_SECVIDEO:
		case MODE_VIDEO2SECOND:
			{
				//使用tChnIdxParam来设置分辨率
				THDAdaptParam tParam;
				u16 wWidth  = 0;	
				u16 wHeight = 0;
				
				// deal with mp4 16cif 
				TVideoStreamCap tTempVidCap;
				if ( !tChnCapData.atBasChnCap[0].GetVideoCapSet(tTempVidCap) )
				{
					ConfPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[StartSelAdapt]GetVideoCapSet failed\n");
					return FALSE;
				}
				u8 byDstRes = tTempVidCap.GetResolution();
				if ( byMediaMode == MODE_VIDEO )
				{
					if (MEDIA_TYPE_MP4 == tDstCap.GetVideoMediaType()
						)
					{
						if ( VIDEO_FORMAT_16CIF == byDstRes )
						{
							byDstRes = VIDEO_FORMAT_4CIF;
						}
						else if ( VIDEO_FORMAT_AUTO == byDstRes )
						{
							byDstRes = GetAutoResByBitrate(VIDEO_FORMAT_AUTO,tTempVidCap.GetMaxBitRate());
						}
					}
				}
				
				GetWHByRes(byDstRes, wWidth, wHeight);
				tParam.SetAudType(tDstCap.GetAudioMediaType());
				tParam.SetVidType(tDstCap.GetVideoMediaType());
				tParam.SetVidActiveType(GetActivePayload(m_tConf, tDstCap.GetVideoMediaType()));
				tParam.SetResolution(wWidth, wHeight);
				tParam.SetBitRate(tDstCap.GetVideoMaxBitRate());
				if (MEDIA_TYPE_H264 == tDstCap.GetVideoMediaType())
				{
					tParam.SetFrameRate(tDstCap.GetUserDefFrameRate());
					tParam.SetProfileType(tDstCap.GetVideoProfileType());
				}
				else
				{	
					tParam.SetFrameRate(tDstCap.GetVideoFrameRate());
				}
				tParam.SetProfileType( tDstCap.GetVideoProfileType() );
				
				
				TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
				tParam.SetIsNeedByPrs(tConfAttrb.IsResendLosePack());
				
				//保存适配参数
				if( !SetBasSelChnParam( pcBasChn->GetBas(),pcBasChn->GetChnId(),byMediaMode,tParam ) ) 
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartSelAdapt] SetBasAdaptParam failed!\n");
					return FALSE;
				}
			}
			break;
		default:
			ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartSelAdapt] byMediaMode:%d is error!\n",byMediaMode);
			break;
        }
		//开启单通道适配
		ChangeAdapt(pcBasChn->GetBas(), pcBasChn->GetChnId());
		
		//对于同源的需要补建交换，因为发的是CMD消息
		if ( bIsSameBasChn )
		{
			TBasOutInfo	tTempOutInfo;
			if ( FindBasChn2SelForMt(tOrigSrc, tOrigDst, byMediaMode, tTempOutInfo) )
			{
				//音频交换等change回ack后建立
				if ( byMediaMode != MODE_AUDIO  )
				{
					//Rtp
					TSwitchGrp tTempSwitchGrp;
					tTempSwitchGrp.SetSrcChnl(tTempOutInfo.m_byFrontOutNum + tTempOutInfo.m_byOutIdx);
					tTempSwitchGrp.SetDstMtNum(1);
					tTempSwitchGrp.SetDstMt(&tDst);
					tTempOutInfo.m_tBasEqp.SetConfIdx(m_byConfIdx);
					g_cMpManager.StartSwitchToAll(tTempOutInfo.m_tBasEqp, 1, &tTempSwitchGrp, byMediaMode, SWITCH_MODE_SELECT, TRUE);
					//Rtcp
					TConfAttrb tConfattrb = m_tConf.GetConfAttrb();
					if (tConfattrb.IsResendLosePack())
					{
						BuildRtcpSwitchForSrcToDst(tDst, tTempOutInfo.m_tBasEqp, byMediaMode, 0, tTempOutInfo.m_byFrontOutNum + tTempOutInfo.m_byOutIdx, TRUE);
					}		
				}
			}
			else
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartSelAdapt] FindBasChn2SelForMt:%d-%d failed!\n",tOrigDst.GetMcuId(), tOrigDst.GetMtId() );
				return FALSE;
			}
		}
	}


	//代码合并
    //选看标识置位
    m_ptMtTable->SetMtSrc(tDst.GetMtId(), &tOrigSrc, byMediaMode);
	
    //通知发送
    NotifyMtSend(tSrc.GetMtId(), byMediaMode);

	if ( byMediaMode != MODE_AUDIO )
	{
		//通知目的终端接收视频
		NotifyMtReceive(tSrc, tDst.GetMtId());
		//通知源终端发送关键帧
		if( tOrigSrc.IsLocal())
		{
			NotifyFastUpdate(tSrc, byMediaMode);
		}
		else
		{
			if(m_cSMcuSpyMana.IsMtInSpyMember( tOrigSrc, byMediaMode ))
			{
				NotifyFastUpdate(tOrigSrc, byMediaMode);
			}
		}
	}

    //刷新界面
    TMtStatus tMtStatus;
    m_ptMtTable->GetMtStatus( tDst.GetMtId(), &tMtStatus );

	if (0 == m_tCascadeMMCU.GetMtId() || m_tCascadeMMCU.GetMtId() != tDst.GetMtId())
	{
		if( tSrc.GetType() == TYPE_MT && tSrc.GetMtId() != tDst.GetMtId())
		{
			TMtStatus tSrcMtStatus;
			u8 byAddSelByMcsMode = MODE_NONE;
			m_ptMtTable->GetMtStatus( tSrc.GetMtId(), &tSrcMtStatus );
			
			TMt tLocalVidBrdSrc = GetLocalVidBrdSrc();
			
			//zbq[12/06/2007] VMP点名时序问题
			if( tSrcMtStatus.IsSendVideo() && 
				( MODE_VIDEO == byMediaMode || MODE_BOTH == byMediaMode ) )
			{
				byAddSelByMcsMode = MODE_VIDEO;
			}
			if(  tSrcMtStatus.IsSendAudio() && 
				( MODE_AUDIO == byMediaMode || MODE_BOTH == byMediaMode ) )
			{
				if( MODE_VIDEO == byAddSelByMcsMode )
				{
					byAddSelByMcsMode = MODE_BOTH;
				}
				else
				{
					byAddSelByMcsMode = MODE_AUDIO;
				}
			}
			
			if( MODE_NONE != byAddSelByMcsMode )
			{
				// 非内部选看才需要更新mcsdragmode
				if (!bInnerSelect)
				{
					tMtStatus.AddSelByMcsMode( byMediaMode );
				}
			}
			else
			{
				tMtStatus.RemoveSelByMcsMode( byMediaMode );
			}
		}
		else
		{
			tMtStatus.RemoveSelByMcsMode( byMediaMode );
		}
	}
    
	m_ptMtTable->SetMtStatus( tDst.GetMtId(), &tMtStatus );
	// 单独更新SelMt,VIDEO2SECOND支持
	m_ptMtTable->SetMtSelMtByMode(tDst.GetMtId(), byMediaMode, tOrigSrc);
    MtStatusChange(&tDst, TRUE);
	
	return TRUE;
}

/*====================================================================
函数名        StartSpyAudAdapt
功能        ：开启回传适配
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/14    4.7       倪志俊        创建
====================================================================*/
BOOL32 CMcuVcInst::StartSpyAudAdapt(TMt tSrc)
{
	TMt tOrigSrc = tSrc;
	if (tSrc.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartSpyAdapt] tSrc is null!\n");
		return FALSE;
	}
	
 	tSrc = GetLocalMtFromOtherMcuMt(tSrc);
	
	TAudioTypeDesc tDstAudCap;
	TLogicalChannel tDstAudLgc;
	if (!m_ptMtTable->GetMtLogicChnnl(m_tCascadeMMCU.GetMtId(), MODE_AUDIO, &tDstAudLgc, TRUE))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[StartSpyAudAdapt] GetMtLogicChnnl Dst Aud Mt%d failed!\n", m_tCascadeMMCU.GetMtId());
		return FALSE;
	}
	
	tDstAudCap.SetAudioMediaType( tDstAudLgc.GetChannelType() );
	tDstAudCap.SetAudioTrackNum( tDstAudLgc.GetAudioTrackNum() );
	

	TBasOutInfo tOutInfo;
	tOutInfo.m_tBasEqp.SetNull();
	BOOL32 bNeedNewBas = !FindBasChn2SelForMt(tOrigSrc, m_tCascadeMMCU,MODE_AUDIO,tOutInfo);
	
	if (bNeedNewBas)
	{		
		CBasChn *pcBasChn=NULL;
		TBasChnCapData tBasChnCapData;
		BOOL32 bOcuppyOK = FALSE; 

		if ( GetBasChnForAudSel(tOrigSrc,tDstAudCap, &pcBasChn,tBasChnCapData) )
		{
			bOcuppyOK = TRUE;
		}

		if(!bOcuppyOK)
		{
			NotifyMcsAlarmInfo(0, ERR_MCU_SELAUDBASISNOTENOUGH);
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartSpyAudAdapt] no idle sel bas!\n");
			return FALSE;
		}
		
		//非同源的新通道
		BOOL32 bIsSameSrc = FALSE;
		if ( !(pcBasChn->GetSrc() == tOrigSrc) )
		{
			TEqp tTempBas = pcBasChn->GetBas();
			tTempBas.SetConfIdx(m_byConfIdx);
			pcBasChn->SetBas(tTempBas);
			//添加选看通道入选看组
			AssignBasSelChn(pcBasChn,tBasChnCapData,m_tConf.GetConfId());
			//设置通道源信息
			SetBasChnSrc(pcBasChn->GetBas(), pcBasChn->GetChnId(), tOrigSrc);
			//设置通道媒体模式
			SetBasChnMode(pcBasChn->GetBas(), pcBasChn->GetChnId(), MODE_AUDIO);
		}
		//同源通道添加参数
		else
		{
			bIsSameSrc = TRUE;
			AddBasSelChnParam(pcBasChn->GetBas(), pcBasChn->GetChnId(),tBasChnCapData);	
		}

		TAudAdaptParam tParam;
		tParam.SetAudCodeType( tDstAudCap.GetAudioMediaType() );
		tParam.SetAudActiveType( GetActivePayload(m_tConf, tDstAudCap.GetAudioMediaType())  );
		tParam.SetTrackNum( tDstAudCap.GetAudioTrackNum() );
		TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
		tParam.SetIsNeedByPrs(tConfAttrb.IsResendLosePack());

		//保存适配参数
		if( !SetBasSelAudChnParam(pcBasChn->GetBas(), pcBasChn->GetChnId(),tParam) )
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[StartSpyAudAdapt] SetBasAdaptParam failed!\n");
			return FALSE;
		}
	
		//开启单通道适配
		ChangeAdapt(pcBasChn->GetBas(), pcBasChn->GetChnId());

		//对于同源的需要补建交换
		if ( bIsSameSrc )
		{
			TBasOutInfo	tTempOutInfo;
			if ( FindBasChn2SelForMt(tOrigSrc, m_tCascadeMMCU,MODE_AUDIO, tTempOutInfo) )
			{
				CSendSpy tSpySnd;	
				u16 wSpyPort = SPY_CHANNL_NULL;
				if( m_cLocalSpyMana.GetSpyChannlInfo( tOrigSrc, tSpySnd ) )
				{
					wSpyPort = tSpySnd.m_tSpyAddr.GetPort();
				}
				else
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS,"[StartSpyAudAdapt]tbasSrc-McuId:%d--MtId:%d is not in m_cLocalSpyMana\n",tOrigSrc.GetMcuId(), tOrigSrc.GetMtId());
				}
				tTempOutInfo.m_tBasEqp.SetConfIdx(m_byConfIdx);
				g_cMpManager.StartSwitchToMmcu(tTempOutInfo.m_tBasEqp, tTempOutInfo.m_byFrontOutNum + tTempOutInfo.m_byOutIdx, m_tCascadeMMCU, MODE_AUDIO, 
													SWITCH_MODE_SELECT, FALSE, TRUE, FALSE, wSpyPort);	
			}
			else
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartSpyAudAdapt] FindBasChn2SpyForMt tDstCap failed\n");
				return FALSE;
			}
		}
	}
    else
	{
		CRecvSpy tSpyRcv;
		if( m_cSMcuSpyMana.GetRecvSpy( tOrigSrc, tSpyRcv ) )
		{
			//wSrcChnnl = tSpyRcv.m_tSpyAddr.GetPort();
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartSpyAudAdapt]tBasSrc-McuId:%d--MtId:%d is come from smcu\n",tOrigSrc.GetMcuId(), tOrigSrc.GetMtId());
		}
		else
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartSpyAudAdapt]tbasSrc-McuId:%d--MtId:%d is not in m_cSMcuSpyMana\n",tOrigSrc.GetMcuId(), tOrigSrc.GetMtId());
		}

		//从BAS到上级MCU的RTP交换建立
		CSendSpy tSpySnd;	
		u16 wSpyPort = SPY_CHANNL_NULL;
		if( m_cLocalSpyMana.GetSpyChannlInfo( tOrigSrc, tSpySnd ) )
		{
			wSpyPort = tSpySnd.m_tSpyAddr.GetPort();
		}
		else
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS,"[StartSpyAudAdapt]tbasSrc-McuId:%d--MtId:%d is not in m_cLocalSpyMana\n",tOrigSrc.GetMcuId(), tOrigSrc.GetMtId());
		}
		tOutInfo.m_tBasEqp.SetConfIdx(m_byConfIdx);
		g_cMpManager.StartSwitchToMmcu(tOutInfo.m_tBasEqp, tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx, m_tCascadeMMCU, MODE_AUDIO, 
													SWITCH_MODE_SELECT, FALSE, TRUE, FALSE, wSpyPort);	
	}
	
    //通知发送
    NotifyMtSend(tSrc.GetMtId(), MODE_AUDIO);	
	return  TRUE;

}

/*====================================================================
函数名        StartSpyAdapt
功能        ：开启回传适配
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::StartSpyAdapt(TMt tSrc, const TSimCapSet &tDstCap, u8 byMediaMode)
{
	TMt tOrigSrc = tSrc;
	if (tSrc.IsNull() || tDstCap.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartSpyAdapt] tSrc or tDstCap is null!\n");
		return FALSE;
	}
	if (MODE_NONE == byMediaMode)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartSpyAdapt] byMediaMode is MODE_NONE!\n");
		return FALSE;
	}
	
 	tSrc = GetLocalMtFromOtherMcuMt(tSrc);
	TSimCapSet tSrcCap = m_ptMtTable->GetSrcSCS(tSrc.GetMtId());

TSimCapSet tTmpDstCap = tDstCap;
#ifdef _8KI_
	if ( tTmpDstCap.GetVideoMediaType() == MEDIA_TYPE_H264 )
	{
		if( tTmpDstCap.GetVideoResolution() > VIDEO_FORMAT_4CIF )
		{
			tTmpDstCap.SetVideoResolution( VIDEO_FORMAT_4CIF );
			LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[StartSpyAdapt]Fabricate special cap res \n" );
		}
		if( tTmpDstCap.GetUserDefFrameRate() == 60 ||  tTmpDstCap.GetUserDefFrameRate() == 50 )
		{
			tTmpDstCap.SetUserDefFrameRate( tTmpDstCap.GetUserDefFrameRate()/2 );
			LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[StartSpyAdapt]Fabricate special cap fps \n" );
		}		
	}
#endif

	TBasOutInfo tOutInfo;
	tOutInfo.m_tBasEqp.SetNull();
	BOOL32 bNeedNewBas = !FindBasChn2SpyForMt(tOrigSrc, tTmpDstCap, byMediaMode,tOutInfo);
	
	//如果找不到，就调高分辨率，向上找，如果找到，就强刷那一出参数,这样保持与调分辨率策略一致性
	if ( bNeedNewBas )
	{
		TSimCapSet tTempSrcCap = tTmpDstCap;
		u8 byNextUpStandRes = GetUpStandRes(tTmpDstCap.GetVideoResolution());
		while (VIDEO_FORMAT_INVALID != byNextUpStandRes)
		{
			tTempSrcCap.SetVideoResolution(byNextUpStandRes);
			if ( FindBasChn2SpyForMt(tOrigSrc, tTempSrcCap, MODE_VIDEO, tOutInfo) )
			{
				CBasChn *pTempBasChn = NULL;
				pTempBasChn = g_cMcuVcApp.GetBasChnAddr(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId);
				TVideoStreamCap tTempVidStreamCap = tTmpDstCap.GetVideoCap();
				if ( pTempBasChn != NULL  &&
					pTempBasChn->IsSupportEncCap(tTempVidStreamCap,tOutInfo.m_byOutIdx)
					)
				{
					THDAdaptParam atParam[MAXNUM_BASOUTCHN];
					u8 byCurrOutNum = 0;
					if( !g_cMcuVcApp.GetBasOutPutParam(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId, byCurrOutNum, atParam) )
					{
						ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartSpyAdapt] GetBasOutPutParam error!\n");
						return FALSE;
					}
					THDAdaptParam tTempBasParam = atParam[tOutInfo.m_byOutIdx];
					u16 wWidth  = 0;
					u16 wHeight = 0;
					u8 byRes = tTmpDstCap.GetVideoResolution();
					GetWHByRes(byRes, wWidth, wHeight);
					tTempBasParam.SetResolution(wWidth, wHeight);
					RefreshBasParambyOutIdx(tOutInfo,tTempBasParam);
					ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[StartSpyAdapt]refreshparam bas:%d-%d-%d to res:%d\n",
							  tOutInfo.m_tBasEqp.GetEqpId(), tOutInfo.m_byChnId, tOutInfo.m_byOutIdx, byRes
							  );
					bNeedNewBas = FALSE;
					break;
				}
			}
			byNextUpStandRes = GetUpStandRes(byNextUpStandRes);
		}
	}

	//TSimCapSet tTmpDstCap = tDstCap;
	if (bNeedNewBas)
	{		
		CBasChn *pcBasChn=NULL;
		TBasChnCapData tBasChnCapData;
		BOOL32 bOcuppyOK = FALSE; 
		//根据源和目的能力循序尝试获取最合适的空闲适配通道
		if ( GetBasChnForMultiSpy(tOrigSrc,tTmpDstCap,byMediaMode, &pcBasChn,tBasChnCapData) )
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS,  "[StartSpyAdapt] ByEncRes is %d!\n", tTmpDstCap.GetVideoResolution());
			bOcuppyOK = TRUE;
		}

		if(!bOcuppyOK)
		{
			NotifyMcsAlarmInfo(0, ERR_MCU_SELVIDBASISNOTENOUGH);
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartSpyAdapt] no idle sel bas!\n");
			return FALSE;
		}
		
		//非同源的新通道
		BOOL32 bIsSameSrc = FALSE;
		if ( !(pcBasChn->GetSrc() == tOrigSrc) )
		{
			TEqp tTempBas = pcBasChn->GetBas();
			tTempBas.SetConfIdx(m_byConfIdx);
			pcBasChn->SetBas(tTempBas);
			//添加选看通道入选看组
			AssignBasSelChn(pcBasChn,tBasChnCapData,m_tConf.GetConfId());
			//设置通道源信息
			SetBasChnSrc(pcBasChn->GetBas(), pcBasChn->GetChnId(), tOrigSrc);
			//设置通道媒体模式
			SetBasChnMode(pcBasChn->GetBas(), pcBasChn->GetChnId(), byMediaMode);
		}
		//同源通道添加参数
		else
		{
			bIsSameSrc = TRUE;
			AddBasSelChnParam(pcBasChn->GetBas(), pcBasChn->GetChnId(),tBasChnCapData);	
		}
	
		u8 byEncRes = tTmpDstCap.GetVideoResolution();
		THDAdaptParam tParam;
		u16 wWidth  = 0;
		u16 wHeight = 0;
		// deal with mp4 16cif
		if( MEDIA_TYPE_MP4 == tTmpDstCap.GetVideoMediaType() &&
			VIDEO_FORMAT_16CIF == byEncRes 
			)
		{
			byEncRes = VIDEO_FORMAT_4CIF;
		}

		GetWHByRes(byEncRes/*tTmpDstCap.GetVideoResolution()*/, wWidth, wHeight);
        tParam.SetAudType(tTmpDstCap.GetAudioMediaType());
		tParam.SetVidType(tTmpDstCap.GetVideoMediaType());
		tParam.SetVidActiveType(GetActivePayload(m_tConf, tTmpDstCap.GetVideoMediaType()));
		tParam.SetResolution(wWidth, wHeight);
		tParam.SetBitRate(tTmpDstCap.GetVideoMaxBitRate());
		if (MEDIA_TYPE_H264 == tTmpDstCap.GetVideoMediaType())
		{
			tParam.SetFrameRate(tTmpDstCap.GetUserDefFrameRate());
		}
		else
		{	
			tParam.SetFrameRate(tTmpDstCap.GetVideoFrameRate());
		}
		tParam.SetProfileType( tTmpDstCap.GetVideoProfileType() );
		TConfAttrb tTempAttrb = m_tConf.GetConfAttrb();
		tParam.SetIsNeedByPrs(tTempAttrb.IsResendLosePack());

		//保存适配参数
		if( !SetBasSelChnParam(pcBasChn->GetBas(), pcBasChn->GetChnId(), byMediaMode,tParam) )
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[StartSpyAdapt] SetBasAdaptParam failed!\n");
			return FALSE;
		}
	
		//开启单通道适配
		ChangeAdapt(pcBasChn->GetBas(), pcBasChn->GetChnId());

		//对于同源的需要补建交换
		if ( bIsSameSrc )
		{
			TBasOutInfo	tTempOutInfo;
			if ( FindBasChn2SpyForMt(tOrigSrc, tDstCap, byMediaMode, tTempOutInfo) )
			{
				CSendSpy tSpySnd;	
				u16 wSpyPort = SPY_CHANNL_NULL;
				if( m_cLocalSpyMana.GetSpyChannlInfo( tOrigSrc, tSpySnd ) )
				{
					wSpyPort = tSpySnd.m_tSpyAddr.GetPort();
				}
				else
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS,"[StartSpyAdapt]tbasSrc-McuId:%d--MtId:%d is not in m_cLocalSpyMana\n",tOrigSrc.GetMcuId(), tOrigSrc.GetMtId());
				}
				tTempOutInfo.m_tBasEqp.SetConfIdx(m_byConfIdx);
				g_cMpManager.StartSwitchToMmcu(tTempOutInfo.m_tBasEqp, tTempOutInfo.m_byFrontOutNum + tTempOutInfo.m_byOutIdx, m_tCascadeMMCU, byMediaMode, 
													SWITCH_MODE_SELECT, FALSE, TRUE, FALSE, wSpyPort);	
			}
			else
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartSpyAdapt] FindBasChn2SpyForMt tDstCap failed\n");
				return FALSE;
			}
		}
	}
    else
	{
		//刷新选课那适配参数
		RefreshSpyBasParam(tSrc, tTmpDstCap, byMediaMode);
		
		//从源到BAS的RTP交换建立
		//u16 wSrcChnnl = 0;
		CRecvSpy tSpyRcv;
		if( m_cSMcuSpyMana.GetRecvSpy( tOrigSrc, tSpyRcv ) )
		{
			//wSrcChnnl = tSpyRcv.m_tSpyAddr.GetPort();
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartSpyAdapt]tBasSrc-McuId:%d--MtId:%d is come from smcu\n",tOrigSrc.GetMcuId(), tOrigSrc.GetMtId());
		}
		else
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartSpyAdapt]tbasSrc-McuId:%d--MtId:%d is not in m_cSMcuSpyMana\n",tOrigSrc.GetMcuId(), tOrigSrc.GetMtId());
		}

		//从BAS到上级MCU的RTP交换建立
		CSendSpy tSpySnd;	
		u16 wSpyPort = SPY_CHANNL_NULL;
		if( m_cLocalSpyMana.GetSpyChannlInfo( tOrigSrc, tSpySnd ) )
		{
			wSpyPort = tSpySnd.m_tSpyAddr.GetPort();
		}
		else
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS,"[StartSpyAdapt]tbasSrc-McuId:%d--MtId:%d is not in m_cLocalSpyMana\n",tOrigSrc.GetMcuId(), tOrigSrc.GetMtId());
		}
		tOutInfo.m_tBasEqp.SetConfIdx(m_byConfIdx);
		g_cMpManager.StartSwitchToMmcu(tOutInfo.m_tBasEqp, tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx, m_tCascadeMMCU, byMediaMode, 
													SWITCH_MODE_SELECT, FALSE, TRUE, FALSE, wSpyPort);	
	}
	
    //通知发送
    NotifyMtSend(tSrc.GetMtId(), byMediaMode);	
	// [pengjie 2010/4/2] 多回传请求关键帧支持
	if( tOrigSrc.IsLocal())
	{
		NotifyFastUpdate(tSrc, byMediaMode, TRUE);
	}
	else
	{
		if(m_cSMcuSpyMana.IsMtInSpyMember( tOrigSrc, byMediaMode ))
		{
			NotifyFastUpdate(tOrigSrc, byMediaMode);
		}
	}
	return  TRUE;
}
/*====================================================================
函数名        StopSelAdapt
功能        ：停止适配
算法实现    ：
引用全局变量：
输入参数说明：TMt tSrc
			  TMt tDst 
			  u8 byMediaMode
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::StopSelAdapt(TMt tSrc, TMt tDst, u8 byMediaMode, BOOL32 bIsStopSwitchToMt /*= TRUE*/, BOOL32 bIsStopSpySwitch /*= TRUE*/)
{
	TMt tOrigSrc = tSrc;
	TMt tOrigDst = tDst;
	if (byMediaMode != MODE_AUDIO && byMediaMode != MODE_VIDEO && byMediaMode != MODE_VIDEO2SECOND)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StopSelAdapt] unexpected Mode:%d!\n", byMediaMode);
		return FALSE;
	}

	tSrc = GetLocalMtFromOtherMcuMt(tSrc);
 	tDst = GetLocalMtFromOtherMcuMt(tDst);

	if (!IsNeedSelAdpt(tSrc, tDst, byMediaMode))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StopSelAdapt] Mt%d see Mt%d not need bas!\n", tDst.GetMtId(), tSrc.GetMtId());
		return FALSE;
	}
	TBasOutInfo tRlsOutInfo;
	//获取适配通道
	if (!FindBasChn2SelForMt(tOrigSrc, tOrigDst, byMediaMode, tRlsOutInfo))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StopSelAdapt] FindBasChn2SelForMt:%d failed!\n", tDst.GetMtId());
		return FALSE;
	}

	ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[StopSelAdapt]src:%d-%d dst:%d-%d bIsStopSwitchToMt:%d\n", 
			  tSrc.GetMcuId(), tSrc.GetMtId(), tDst.GetMcuId(),tDst.GetMtId(),bIsStopSwitchToMt
			  );
	TBasOutInfo tOutInfo;
	BOOL32 bStopBas = TRUE;
	TMt tSelSrc;
	//遍历所有终端有没有同样收相同适配通道的码流
	for (u8 byMtIdx = 1; byMtIdx < MAXNUM_CONF_MT; byMtIdx++)
	{
		if (!m_tConfAllMtInfo.MtJoinedConf(byMtIdx))
		{
			continue;
		}
		if (tSrc.GetMtId() == byMtIdx || tDst.GetMtId() == byMtIdx)
		{
			continue;
		}
		
		tSelSrc.SetNull();
		tSelSrc = m_ptMtTable->GetMtSelMtByMode(byMtIdx, byMediaMode);

		if (tSelSrc == tOrigSrc &&
			IsNeedSelAdpt(tSrc, m_ptMtTable->GetMt(byMtIdx), byMediaMode) &&
			FindBasChn2SelForMt(tOrigSrc, m_ptMtTable->GetMt(byMtIdx), byMediaMode,tOutInfo) &&
			tOutInfo.m_tBasEqp.GetEqpId() == tRlsOutInfo.m_tBasEqp.GetEqpId() && tOutInfo.m_byChnId == tRlsOutInfo.m_byChnId)
		{
			bStopBas = FALSE;
			break;
		}
	}

	//回传有占用相同适配通道的不能释放
	if(bStopBas && IsSupportMultiSpy())
	{
		TSimCapSet tSrcCap = m_ptMtTable->GetSrcSCS(tSrc.GetMtId());
		CSendSpy *ptSndSpy = NULL;
		for (u8 bySpyIdx = 0; bySpyIdx < MAXNUM_CONF_SPY; bySpyIdx++)
		{
			ptSndSpy = m_cLocalSpyMana.GetSendSpy(bySpyIdx);
			if (NULL == ptSndSpy)
			{
				continue;
			}
			if (!(ptSndSpy->GetSpyMt() == tOrigSrc))
			{
				continue;
			}
		
			TBasOutInfo  tSpyBasOutInfo;
			/*[2011/12/14/zhangli]上级mcu通道H264-720P，MT通道H264-1080P，把MT拖入上传通道(过适配)，
			然后MT做全局发言人(不过适配)，取消上传无法释放bas*/
			if (IsNeedSpyAdpt(tOrigSrc, ptSndSpy->GetSimCapset(), byMediaMode)
				&& FindBasChn2SpyForMt(tOrigSrc, ptSndSpy->GetSimCapset(), byMediaMode,tSpyBasOutInfo) 
				&&tSpyBasOutInfo.m_tBasEqp.GetEqpId() == tRlsOutInfo.m_tBasEqp.GetEqpId() && tSpyBasOutInfo.m_byChnId == tRlsOutInfo.m_byChnId)
			{
				bStopBas = FALSE;
				break;
			}
		}
	}
	
	
	if (bStopBas)
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[StopSelAdapt] release tEqp(%d,%d),src(%d,%d),dst(%d,%d)\n", 
			tRlsOutInfo.m_tBasEqp.GetEqpId(), tRlsOutInfo.m_byChnId, tOrigSrc.GetMcuId(), tOrigSrc.GetMtId(), tOrigDst.GetMcuId(), tOrigDst.GetMtId());

		//移除Rtcp且释放Prs通道
		StopBasPrsSupport(tRlsOutInfo.m_tBasEqp, tRlsOutInfo.m_byChnId);
		//停止bas
		StopBasChnAdapt(tRlsOutInfo.m_tBasEqp,tRlsOutInfo.m_byChnId);
		//释放资源
		g_cMcuVcApp.ReleaseBasChn(tRlsOutInfo.m_tBasEqp, tRlsOutInfo.m_byChnId);

		//[2011/08/12/zhangli]停止到eqp的RTP交换都调用vc层的接口，以便能同时处理拆RTCP交换
		//g_cMpManager.StopSwitchToPeriEqp(m_byConfIdx, tRlsBas.GetEqpId(), byRlsChnId, byMediaMode);
		StopSwitchToPeriEqp(tRlsOutInfo.m_tBasEqp.GetEqpId(), tRlsOutInfo.m_byChnId, TRUE, byMediaMode);
		//移除选看通道资源
		ReMoveBasSelChn(tRlsOutInfo.m_tBasEqp, tRlsOutInfo.m_byChnId);
		//更新外设状态为ready
		g_cMcuVcApp.UpdateBasChnStatus(tRlsOutInfo.m_tBasEqp, tRlsOutInfo.m_byChnId, BASCHN_STATE_READY);
	}	
	else
	{
		RefreshSelBasParam(tOrigSrc, tDst, byMediaMode, TRUE);
		TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
		if (tConfAttrb.IsResendLosePack())
		{
			BuildRtcpSwitchForSrcToDst(tDst, tRlsOutInfo.m_tBasEqp, 
									   byMediaMode,
									   0, 
									   tRlsOutInfo.m_byFrontOutNum + tRlsOutInfo.m_byOutIdx,
									   FALSE);
		}	
	}

	CSendSpy cSendSpy;
	u16 wSpyPort = SPY_CHANNL_NULL;
	if( bIsStopSpySwitch && m_cLocalSpyMana.GetSpyChannlInfo( tSrc, cSendSpy ) )
	{
		wSpyPort = cSendSpy.m_tSpyAddr.GetPort();
	}
	
	//zjl 20110510 Mp: StopSwitchToSubMt 接口重载替换 
	//g_cMpManager.StopSwitchToSubMt(tDst, byMediaMode, FALSE, wSpyPort);
	if ( bIsStopSwitchToMt )
	{
		g_cMpManager.StopSwitchToSubMt(m_byConfIdx, 1, &tDst, byMediaMode, wSpyPort);
	}
		
	//选看标识复位
	m_ptMtTable->RemoveMtSelMtByMode(tDst.GetMtId(), byMediaMode);

	if (MODE_VIDEO2SECOND != byMediaMode)
	{
		TMt tMtNull;
        tMtNull.SetNull();
        m_ptMtTable->SetMtSrc(tDst.GetMtId(), &tMtNull, byMediaMode);
    }
	return TRUE;
}


/*====================================================================
函数名        StopSpyAdapt
功能        ：停止回传适配
算法实现    ：
引用全局变量：
输入参数说明：TMt tSrc
			  TMt tDst 
			  u8 byMediaMode
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.6         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::StopSpyAdapt(TMt tSrc, const TSimCapSet &tDstCap, u8 byMediaMode)
{
	if (tSrc.IsNull() || tDstCap.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StopSpyAdapt] tSrc<McuId:%d, MtId:%d> or tDstCap is null!\n",
					tSrc.GetMcuId(), tSrc.GetMtId());
	}
    TMt tOrigSrc = tSrc;
	if (byMediaMode != MODE_AUDIO && byMediaMode != MODE_VIDEO)
	{   
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StopSpyAdapt] unexpected Mode:%d!\n", byMediaMode);
		return FALSE;
	}

	tSrc = GetLocalMtFromOtherMcuMt(tSrc);
	TSimCapSet tSrcCap = m_ptMtTable->GetSrcSCS(tSrc.GetMtId());
	if ( byMediaMode != MODE_AUDIO )
	{	
		if (!(tDstCap < tSrcCap))
		{
			return FALSE;
		}
	}
	
	TBasOutInfo tRlsBasOutInfo;
	//获取适配通道
	if ( !FindBasChn2SpyForMt(tOrigSrc, tDstCap, byMediaMode, tRlsBasOutInfo) )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StopSpyAdapt] FindBasChn2SpyForMt failed!\n");
		return FALSE;
	}

	TBasOutInfo tOutInfo;
	TMtStatus tMtStatus;
	BOOL32 bStopBas = TRUE;
	//遍历所有终端有没有同样收相同适配通道的码流
	for (u8 byMtIdx = 1; byMtIdx < MAXNUM_CONF_MT; byMtIdx++)
	{
		if (!m_tConfAllMtInfo.MtJoinedConf(byMtIdx))
		{
			continue;
		}
		if (tSrc.GetMtId() == byMtIdx)
		{
			continue;
		}
		
		tMtStatus.SetNull();
		m_ptMtTable->GetMtStatus(byMtIdx, &tMtStatus);
		if (tMtStatus.GetSelectMt(byMediaMode) == tOrigSrc &&
			IsNeedSelAdpt(tSrc, m_ptMtTable->GetMt(byMtIdx), byMediaMode) &&
			FindBasChn2SelForMt(tOrigSrc, m_ptMtTable->GetMt(byMtIdx), byMediaMode, tOutInfo) &&
			tOutInfo.m_tBasEqp.GetEqpId() == tRlsBasOutInfo.m_tBasEqp.GetEqpId() && tOutInfo.m_byChnId == tRlsBasOutInfo.m_byChnId)
		{
			bStopBas = FALSE;
			break;
		}
	}

	if (bStopBas)
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[StopSpyAdapt] release tEqp(%d,%d),src(%d,%d)\n", 
			tRlsBasOutInfo.m_tBasEqp.GetEqpId(), tRlsBasOutInfo.m_byChnId, tOrigSrc.GetMcuId(), tOrigSrc.GetMtId());

		//停止bas
		StopBasChnAdapt(tRlsBasOutInfo.m_tBasEqp,tRlsBasOutInfo.m_byChnId);
		//释放资源
		g_cMcuVcApp.ReleaseBasChn(tRlsBasOutInfo.m_tBasEqp, tRlsBasOutInfo.m_byChnId);

		//[2011/08/12/zhangli]停止到eqp的RTP交换都调用vc层的接口，以便能同时处理拆RTCP交换
		//g_cMpManager.StopSwitchToPeriEqp(m_byConfIdx, tRlsBas.GetEqpId(), byRlsChnId, byMediaMode);
		StopSwitchToPeriEqp(tRlsBasOutInfo.m_tBasEqp.GetEqpId(), tRlsBasOutInfo.m_byChnId, TRUE, byMediaMode);
		//移除选看通道资源
		ReMoveBasSelChn(tRlsBasOutInfo.m_tBasEqp, tRlsBasOutInfo.m_byChnId);
		//更新外设状态为ready
		g_cMcuVcApp.UpdateBasChnStatus(tRlsBasOutInfo.m_tBasEqp, tRlsBasOutInfo.m_byChnId, BASCHN_STATE_READY);
	}	

	CSendSpy cSendSpy;
	u16 wSpyPort = SPY_CHANNL_NULL;
	if( !m_cLocalSpyMana.GetSpyChannlInfo( tSrc, cSendSpy ) )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StopSpyAdapt] Stop tSrc(%d.%d)  Multispy Failed.Mt is not in spy member.\n",
			tSrc.GetMcuId(),tSrc.GetMtId()
			);
		
		return FALSE;
	}
	wSpyPort = cSendSpy.m_tSpyAddr.GetPort();
	//zjl 20110510 Mp: StopSwitchToSubMt 接口重载替换 
	//g_cMpManager.StopSwitchToSubMt(m_tCascadeMMCU , byMediaMode, FALSE, wSpyPort);
	g_cMpManager.StopSwitchToSubMt(m_byConfIdx, 1, &m_tCascadeMMCU, byMediaMode, wSpyPort);

	return TRUE;
}
/*====================================================================
    函数名      StartBasSwitch
    功能        ：建立bas相关交换
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2010/07/14  3.0         周嘉麟         创建
====================================================================*/
BOOL32 CMcuVcInst::StartBasSwitch(const TEqp &tEqp, u8 byChnId)
{
	if (tEqp.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartBasSwitch] tEqp is null!\n");
		return FALSE;
	}	

	TMt tSrc;
	tSrc.SetNull();
	u8 bySrcChn = 0;

	//根据通道媒体模式获取源信息
	u8 byChnMode    = GetBasChnMode(tEqp, byChnId);

	//[nizhijun 2010/9/25] 判断是否需要音频伴随
// 	BOOL32 bNeedAud =  ( g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tBasStatus) ) &&
// 					   ( tBasStatus.m_tStatus.tHdBas.GetEqpType() == TYPE_MPU ||
// 					     tBasStatus.m_tStatus.tHdBas.GetEqpType() == TYPE_MPU_H )     &&
// 					   (byChnMode == MODE_VIDEO);

    if (MODE_VIDEO == byChnMode)//从通道信息里取源信息
    {
        bySrcChn = m_tPlayEqp == GetLocalVidBrdSrc() ? m_byPlayChnnl : 0;
        tSrc = GetVidBrdSrc();
    }
    else if (MODE_SECVIDEO == byChnMode)
    {
        bySrcChn = m_tPlayEqp == m_tDoubleStreamSrc ? m_byPlayChnnl : 0;
        tSrc = m_tDoubleStreamSrc;
    }
	else if(MODE_AUDIO == byChnMode)
	{
		bySrcChn = m_tPlayEqp == GetLocalAudBrdSrc() ? m_byPlayChnnl : 0;
		tSrc = GetAudBrdSrc(); 
	}
	else
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartBasSwitch] unexpected byChnMode:%d!\n", byChnMode);
		return FALSE;
	}

	if (tSrc.IsNull())
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartBasSwitch] tSrc.IsNull(), failed!\n");
        return FALSE;
    }
	
	u8 byChnGrp = GetBasGrpType(tEqp, byChnId);
	u8 bySwitchMode = SWITCH_MODE_NONE;
	if (CHN_ADPMODE_BRD == byChnGrp)
	{
		bySwitchMode = SWITCH_MODE_BROADCAST;
	}
	else if(CHN_ADPMODE_SEL == byChnGrp)
	{
		bySwitchMode = SWITCH_MODE_SELECT;
	}
	else
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartBasSwitch] nexpected byChnGrp:%d!\n", byChnGrp);
		return FALSE;
	}
	
	u8	byOutNum = 0;
	u8  byFormalOutNum = 0;
	if ( !GetBasChnOutputNum(tEqp,byChnId,byOutNum,byFormalOutNum) )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StartBasSwitch] GetBasChnOutputNum:%d-%d failed!\n",
				  tEqp.GetEqpId(),byChnId
				 );
		return FALSE;
	}

	//对于mpu2，由于下参时按顺序下参，故根据当前下参路数，来设置桥
	TPeriEqpStatus tBasStatus;
	if ( !g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tBasStatus) )
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartBasSwitch] GetPeriEqpStatus failed!\n");
		return FALSE;
	}
	// 无视pclint对ptBasChnData的内存未释放的检查
	/*lint -save -esym(429,pcBasChnData)*/		
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
	if (g_cMcuAgent.IsEqpBasHD(tEqp.GetEqpId()))
#endif
	{
		u8 byHDBasType = tBasStatus.m_tStatus.tHdBas.GetEqpType();
		if ( TYPE_MPU2_BASIC == byHDBasType || TYPE_MPU2_ENHANCED == byHDBasType )
		{
			THDAdaptParam atParam[MAXNUM_BASOUTCHN];
			memset(atParam,0,sizeof(atParam));
			if(!g_cMcuVcApp.GetBasOutPutParam(tEqp, byChnId, byOutNum, atParam))
			{
				LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartBasSwitch] GetBasOutPutParam--><EqpId:%d, ChnId:%d> failed!\n", 
					tEqp.GetEqpId(), byChnId
					);
				return FALSE;
			}
			
			u8 byEncNum = 0;
			for ( u8 byEncNumIdx=0; byEncNumIdx < byOutNum; byEncNumIdx++ )
			{
				if ( atParam[byEncNumIdx].IsNull() || atParam[byEncNumIdx].GetVidType() == 0)
				{
					break;
				}
				byEncNum++;
			}
			byOutNum = byEncNum;
		}
	}

	LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[StartBasSwitch]<EqpId:%d, ChnId:%d> real outnum:%d\n",tEqp.GetEqpId(), byChnId,byOutNum);
	for(u8 byIdx = 0; byIdx < byOutNum; byIdx++)
	{
		//建桥
		g_cMpManager.SetSwitchBridge(tEqp, byFormalOutNum + byIdx, byChnMode, TRUE );
	}
	
	//交换到适配器
	StartSwitchToPeriEqp(tSrc,  bySrcChn, tEqp.GetEqpId(), byChnId, byChnMode, bySwitchMode, TRUE, TRUE, FALSE, FALSE);

	//交换到各个目的终端
	StartSwitchToSubMtNeedAdp(tEqp, byChnId);
	
	// [5/5/2011 xliang] 辅助码率组播, 收适配码流
	if (m_tConf.GetConfAttrb().IsMulticastMode() && m_tConf.GetConfAttrb().IsMulcastLowStream())
	{
		TEqp tLowBRBas;
		tLowBRBas.SetNull();
		u8 byLowBRBasChnId = 0;
		u8 byUseBasOutNum = 0;
		u8 byOutIdx = 0;
		//判断所需低码率适配输出与当前适配通道是否一样
		if (GetLowBrUseBasOutPutInfo(tLowBRBas, byLowBRBasChnId, byUseBasOutNum,  byOutIdx))
		{
			tLowBRBas.SetConfIdx(m_byConfIdx);	// must set confIdx
			if (tLowBRBas == tEqp && byLowBRBasChnId == byChnId)
			{
				u8 byUseBasFromalOutNum = 0;
				if ( !GetBasChnOutputNum(tLowBRBas,byLowBRBasChnId,byUseBasOutNum,byUseBasFromalOutNum) )
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StartBasSwitch] GetBasChnOutputNum:%d-%d failed!\n",
							tLowBRBas.GetEqpId(),byLowBRBasChnId
							);
					return FALSE;
				}
				g_cMpManager.StartMulticast(tLowBRBas, byUseBasFromalOutNum + byOutIdx, MODE_VIDEO);
				m_ptMtTable->SetMtMulticasting(tEqp.GetEqpId());
			}
		}
	}

	//音频适配录像也走广播BAS
	BOOL32 bIsAudRecAdapt = FALSE;
	TRecBasChn tRecBasChn;
	if ( byChnMode == MODE_AUDIO &&
		IsRecNeedAdapt(MODE_AUDIO)&&
		m_cRecAdaptMgr.IsExistRecBasChn(MODE_AUDIO,tRecBasChn) &&
		tRecBasChn.m_tBas == tEqp &&
		tRecBasChn.m_byChnId == byChnId
		)
	{
		bIsAudRecAdapt = TRUE;
	}
	//非自定义适配录像，需要考虑源是否BAS的情况
	//包括：(1)低速录像 (2)源格式与会议主格式不同
	if ( ( !m_tConf.m_tStatus.IsNoRecording() && !IsRecNeedAdapt(byChnMode) ) 
		 || bIsAudRecAdapt
		)
    {		
		TMt tRealSrc;
		u8 byRecChnlIdx = 0;
		u8 byBasChnId = 0;
		if(IsRecordSrcBas(byChnMode, tRealSrc, byBasChnId, byRecChnlIdx))
		{
			if(tRealSrc == tEqp && byBasChnId == byChnId)
			{
				if ( m_tRecPara.IsRecLowStream() )
				{
					RefreshBasParamForLowBrUse();
				}	
				StartSwitchToPeriEqp(tRealSrc, byRecChnlIdx, m_tRecEqp.GetEqpId(), m_byRecChnnl, byChnMode, 
					SWITCH_MODE_BROADCAST, TRUE, TRUE, FALSE, FALSE);
			}
		}
		else
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_REC, "[StartBasSwitch] don't need recording from bas!\n");
		}
    }

	//[nizhijun 2010/09/8] bas prs支持建立
	TConfAttrb tAttrb = m_tConf.GetConfAttrb();
	if (tAttrb.IsResendLosePack())
	{
		StartBasPrsSupport(tEqp,byChnId);
	}

	return TRUE;
}

/*====================================================================
函数名      StopBasSwitch
功能        ：停止bas相P交Q
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp 外设信息
			  u8	   byChnId 通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::StopBasSwitch(const TEqp &tEqp, u8 byChnId,BOOL32 bSelSelf/* = TRUE*/)
{
	if (tEqp.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[StopBasSwitch] tEqp is null!\n");
		return FALSE;
	}
	
	u8 byMediaMode  = GetBasChnMode(tEqp, byChnId);
	BOOL32 bStopAud = byMediaMode == MODE_VIDEO;
	if (MODE_NONE == byMediaMode)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[StopBasSwitch] byMediaMode is MODE_NONE!\n");
		return FALSE;
	}
	
	//1.拆除到m配器交Q
	StopSwitchToPeriEqp(tEqp.GetEqpId(), byChnId, TRUE, byMediaMode);
	if (bStopAud)
	{
		StopSwitchToPeriEqp(tEqp.GetEqpId(), byChnId, TRUE, MODE_AUDIO);
	}
	
	u8 byOutNum = 0;
	u8 byFrontOutNum = 0;
	if ( !GetBasChnOutputNum(tEqp,byChnId,byOutNum,byFrontOutNum) )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StopBasSwitch] GetBasChnOutputNum:%d-%d failed!\n",
				tEqp.GetEqpId(),byChnId
				);
		return FALSE;
	}

	if (0 == byOutNum)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StopBasSwitch] GetBasOutPutChnNum failed!\n");
		return FALSE;
	}

	//2.^河拆
	for (u8 byIdx = 0; byIdx < byOutNum; byIdx++)
	{
		g_cMpManager.RemoveSwitchBridge(tEqp, byFrontOutNum + byIdx, byMediaMode, TRUE);
		if (bStopAud)
		{
			g_cMpManager.RemoveSwitchBridge(tEqp, byFrontOutNum + byIdx, MODE_AUDIO, TRUE);
		}
	}
	//3.拆除到各需要m配K端的交Q
	StopSwitchToSubMtNeedAdp(tEqp, byChnId,bSelSelf);

	// [10/29/2010 liuxu][ADD]
	//4.拆除自定义录像时到录像机的交换
	if ( IsBasChnForRecAdapt(tEqp,byChnId) )
	{
		StopSwitchToPeriEqp(m_tRecEqp.GetEqpId(), m_byRecChnnl, TRUE, byMediaMode);
	}
	//OVER
	
	return TRUE;
}
/*====================================================================
函数名      StopAllBrdAdapt
功能        ：停止所有广播适配
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
void CMcuVcInst::StopAllBrdAdapt()
{
	StopBrdAdapt(MODE_VIDEO);
	StopBrdAdapt(MODE_SECVIDEO);
	StopBrdAdapt(MODE_AUDIO);
	return;
}


/*====================================================================
函数名      StopAllSelAdapt
功能        ：停止所有选看适配
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
void CMcuVcInst::StopAllSelAdapt()
{
	TMt tVidSrc;
	TMt tAudSrc;
	TMt tSecVidSrc;
	TMtStatus tDstStatus;

	//1.停止本级所有选看适配
	for (u8 byMtIdx = 1; byMtIdx < MAXNUM_CONF_MT; byMtIdx++)
	{
		if (!m_tConfAllMtInfo.MtJoinedConf(byMtIdx))
		{
			continue;
		}
		tVidSrc.SetNull();
		tAudSrc.SetNull();
		tSecVidSrc.SetNull();
		m_ptMtTable->GetMtStatus(byMtIdx, &tDstStatus);
		tVidSrc = tDstStatus.GetSelectMt(MODE_VIDEO);
		tAudSrc = tDstStatus.GetSelectMt(MODE_AUDIO);
		if (!tVidSrc.IsNull() && 
			IsNeedSelAdpt(tVidSrc, m_ptMtTable->GetMt(byMtIdx), MODE_VIDEO))
		{
			StopSelAdapt(tVidSrc, m_ptMtTable->GetMt(byMtIdx), MODE_VIDEO);
		}
		if (!tAudSrc.IsNull() && 
			IsNeedSelAdpt(tAudSrc, m_ptMtTable->GetMt(byMtIdx), MODE_AUDIO))
		{
			StopSelAdapt(tAudSrc, m_ptMtTable->GetMt(byMtIdx), MODE_AUDIO);
		}

		tSecVidSrc = m_ptMtTable->GetMtSelMtByMode(byMtIdx, MODE_VIDEO2SECOND);
		if (!tSecVidSrc.IsNull() && IsNeedSelAdpt(tSecVidSrc, m_ptMtTable->GetMt(byMtIdx), MODE_VIDEO2SECOND))
		{
			StopSelAdapt(tSecVidSrc, m_ptMtTable->GetMt(byMtIdx), MODE_VIDEO2SECOND);
		}
	}


	//TLogicalChannel tDstAudLgc,tSrcAudLgc;	


		

	//2. 停止本级回传到上级占用的适配器
	if(IsSupportMultiSpy())
	{
		TSimCapSet tSrcCap;
		CSendSpy *ptSndSpy = NULL;
		for (u8 bySpyIdx = 0; bySpyIdx < MAXNUM_CONF_SPY; bySpyIdx++)
		{
			ptSndSpy = m_cLocalSpyMana.GetSendSpy(bySpyIdx);
			if (NULL == ptSndSpy)
			{
				continue;
			}
			if (ptSndSpy->GetSpyMt().IsNull() || ptSndSpy->GetSimCapset().IsNull())
			{
				continue;
			}
			tSrcCap = m_ptMtTable->GetSrcSCS(GetLocalMtFromOtherMcuMt(ptSndSpy->GetSpyMt()).GetMtId());
			if(ptSndSpy->GetSimCapset() < tSrcCap)
			{
				StopSpyAdapt(ptSndSpy->GetSpyMt(), ptSndSpy->GetSimCapset(), MODE_VIDEO);
			}

			if( IsNeedSpyAdpt( ptSndSpy->GetSpyMt(),tSrcCap,MODE_AUDIO ) )
			{
				StopSpyAdapt(ptSndSpy->GetSpyMt(), ptSndSpy->GetSimCapset(), MODE_AUDIO);
			}

			/*if( m_ptMtTable->GetMtLogicChnnl(GetLocalMtFromOtherMcuMt(ptSndSpy->GetSpyMt()).GetMtId(), MODE_AUDIO, &tSrcAudLgc, FALSE) &&
				m_ptMtTable->GetMtLogicChnnl(m_tCascadeMMCU.GetMtId(), MODE_AUDIO, &tDstAudLgc, TRUE) )
			{
				if( ptSndSpy->GetSimCapset().GetAudioMediaType() != MEDIA_TYPE_NULL  &&
					tSrcCap.GetAudioMediaType() != MEDIA_TYPE_NULL && 
					( ptSndSpy->GetSimCapset().GetAudioMediaType() != tSrcCap.GetAudioMediaType() || 					
						tSrcAudLgc.GetAudioTrackNum() != tDstAudLgc.GetAudioTrackNum() )
					)
				{
					StopSpyAdapt(ptSndSpy->GetSpyMt(), ptSndSpy->GetSimCapset(), MODE_AUDIO);
				}
			}*/
		}
	}

	// [11/11/2010 liuxu][Add]
	//3. 停止录像自定义适配
	if (IsRecNeedAdapt())
	{
		ResetRecAdptParam();
	}
}

/*====================================================================
函数名      ReleaseBasChn
功能        ：放basY源
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
void CMcuVcInst::ReleaseBasChn()
{
	//如果适配器在工作则先停适配器和拆交换
	u8 byNum = 0;
	CBasChn *apcBasChn[MAXNUM_PERIEQP]={NULL};
	if (  GetBasAllBrdChn(byNum, apcBasChn)  )
	{
		for (u8 byIdx = 0; byIdx < byNum; byIdx ++)
		{
			if ( NULL == apcBasChn[byIdx] )
			{
				continue;
			}

			g_cMcuVcApp.ReleaseBasChn(apcBasChn[byIdx]->GetBas(), apcBasChn[byIdx]->GetChnId());
			ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"[ReleaseBasChn]conf:%d GetBasAllBrdChn-%d-%d IsReserved:%d!\n", 
					 m_byConfIdx,apcBasChn[byIdx]->GetBas().GetEqpId(),apcBasChn[byIdx]->GetChnId(),apcBasChn[byIdx]->IsReserved()
					 );
		}	
	}
	else
	{
		ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"[ReleaseBasChn]conf:%d GetBasAllBrdChn byNum:%d !\n", m_byConfIdx,byNum);
	}

	memset(apcBasChn,0,sizeof(apcBasChn));
	if (  GetBasAllSelChn(byNum, apcBasChn)  )
	{
		for (u8 byIdx = 0; byIdx < byNum; byIdx ++)
		{
			if ( NULL == apcBasChn[byIdx] )
			{
				continue;
			}
			g_cMcuVcApp.ReleaseBasChn(apcBasChn[byIdx]->GetBas(), apcBasChn[byIdx]->GetChnId());
			ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"[ReleaseBasChn]conf:%d GetBasAllSelChn-%d-%d IsReserved:%d!\n", 
					  m_byConfIdx,apcBasChn[byIdx]->GetBas().GetEqpId(),apcBasChn[byIdx]->GetChnId(),apcBasChn[byIdx]->IsReserved()
					 );
		}		
	}
	else
	{
		ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"[ReleaseBasChn]conf:%d GetBasAllSelChn byNum:%d !\n", m_byConfIdx,byNum);
	}


	ClearBasMgr();
	return;
}

/*====================================================================
函数名      RefreshBasBrdAdpParam
功能        ：刷新广播适配参数
算法实现    ：
引用全局变量：
输入参数说明：u8 byMediaMode 媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::RefreshBasBrdAdpParam(u8 byMediaMode)
{
	u16 wBiteRate = 0;
    switch (byMediaMode)
    {
	case MODE_VIDEO:
		{
			BOOL32 bIsExistDsSrc = m_tDoubleStreamSrc.IsNull() ? FALSE:TRUE;
			wBiteRate =m_tConf.GetBitRate();
			if (bIsExistDsSrc )
			{
				wBiteRate = GetDoubleStreamVideoBitrate(m_tConf.GetBitRate(),TRUE);
			}
			RefreshBasParam4VidBrd(wBiteRate);
		}
		break;
	case MODE_SECVIDEO:
		{
			wBiteRate = GetDoubleStreamVideoBitrate(m_tConf.GetBitRate(),FALSE);
			RefreshBasParam4DSBrd(wBiteRate);
		}
		break;
	case MODE_AUDIO:
		{
			wBiteRate = GetAudioBitrate(m_tConf.GetSecAudioMediaType());
			RefreshBasParam4AudBrd(wBiteRate);
		}
		break;
	default:
		ConfPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[RefreshBasBrdAdpParam] unexpected MediaMode:%d!\n", byMediaMode);
		break;
    }
	return TRUE;
}

/*====================================================================
函数名      RefreshBasParam4VidBrd
功能        ：刷新视频广播适配参数
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
2011/02/02  4.7	        倪志俊		   修改
====================================================================*/
BOOL32 CMcuVcInst::RefreshBasParam4VidBrd(u16 wBiteRate)
{
	TMt tSrc = GetBrdSrc(MODE_VIDEO);
	if ( tSrc.IsNull() )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[RefreshBasParam4VidBrd]tSrc is NULL!\n");
		return FALSE;
	}
	tSrc = GetLocalMtFromOtherMcuMt(tSrc);

	//双格式
	BOOL32 bDoubleMedia = m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_NULL? FALSE : TRUE;
	//双other会议特殊处理,根据发言人切换
	if (  bDoubleMedia &&
		  !IsConfNeedReserveMainCap(m_tConf,m_tConfEx)
#ifndef _MINIMCU_ 
		  &&
		  m_tConf.GetMainSimCapSet().GetVideoMediaType() != MEDIA_TYPE_NULL && //主格式非H264
		  m_tConf.GetMainSimCapSet().GetVideoMediaType() != MEDIA_TYPE_H264 && 
		  m_tConf.GetSecSimCapSet().GetVideoMediaType() != MEDIA_TYPE_NULL &&  //辅格式非H264
		  m_tConf.GetSecSimCapSet().GetVideoMediaType() != MEDIA_TYPE_H264   
#endif
	  )
	{	
			
		//需要刷新的能力
		TVideoStreamCap	tTempSimCapSet;

		// [4/8/2011 xliang] modify the logical as following:
		/*
		|-main != sec
		|	|- SrcMedia is sec
		|	|		|- !doubleBR: set certain param
		|	|		|- doubleBR : set sec param		[6/17/2011 zhangli]
		|	|- SrcMedia is main
		|			|- set certain param no matter doubleBR or not
		|-main == sec == mp4
			|- set certain param
		*/

		//获得源格式与分辨率
		u8 bySrcMediaType = MEDIA_TYPE_NULL;
		u8 bySrcVideoFormat = VIDEO_FORMAT_INVALID;
		if (TYPE_MCUPERI == tSrc.GetType() && EQP_TYPE_RECORDER == tSrc.GetEqpType())
		{
			bySrcMediaType = m_tPlayEqpAttrib.GetVideoType();
		}
		else
		{
			TLogicalChannel tSrcLGC;
			if(m_ptMtTable->GetMtLogicChnnl(tSrc.GetMtId(), LOGCHL_VIDEO, &tSrcLGC, FALSE))
			{
				bySrcMediaType = tSrcLGC.GetChannelType();
				bySrcVideoFormat = tSrcLGC.GetVideoFormat();
			}
		}

		//main != sec，主辅格式都不同	
		if ( m_tConf.GetSecVideoMediaType() != m_tConf.GetMainVideoMediaType() )
		{
			BOOL32 bChangeFormat = FALSE;
			BOOL32 bIsSecVideo = TRUE;
			// SrcMedia is main
			if (bySrcMediaType == m_tConf.GetMainVideoMediaType())
			{	
				bIsSecVideo = TRUE;
				//mp4_auto 按照码率编对应分辨率
				if (MEDIA_TYPE_MP4 == m_tConf.GetSecVideoMediaType() && VIDEO_FORMAT_AUTO == m_tConf.GetSecVideoFormat())
				{
					bChangeFormat = TRUE;
				}
			}
			// SrcMedia is sec
			else if(bySrcMediaType == m_tConf.GetSecVideoMediaType())
			{	
				bIsSecVideo = FALSE;
				if (MEDIA_TYPE_MP4 == m_tConf.GetMainVideoMediaType() && VIDEO_FORMAT_AUTO == m_tConf.GetMainVideoFormat())
				{
					bChangeFormat = TRUE;
				}
			}


			//set video type and rate
			if (bIsSecVideo)
			{
				tTempSimCapSet = m_tConf.GetSecSimCapSet().GetVideoCap();		//辅格式做参数
				if( MEDIA_TYPE_MP4 == tTempSimCapSet.GetMediaType() && VIDEO_FORMAT_16CIF == tTempSimCapSet.GetResolution() )
				{
					tTempSimCapSet.SetResolution(VIDEO_FORMAT_4CIF);
				}
			}
			else
			{	
				tTempSimCapSet = m_tConf.GetMainSimCapSet().GetVideoCap();					//主格式做参数
				if( MEDIA_TYPE_MP4 == tTempSimCapSet.GetMediaType() && VIDEO_FORMAT_16CIF == tTempSimCapSet.GetResolution() )
				{
					tTempSimCapSet.SetResolution(VIDEO_FORMAT_4CIF);
				}
			}	
			
			//mp4 auto的话刷新分辨率
			if (bChangeFormat)
			{
				u8 byEncRes = GetAutoResByBitrate(tTempSimCapSet.GetResolution(), m_tConf.GetBitRate());
				tTempSimCapSet.SetResolution(byEncRes);
			}
		}
		//main == sec == mp4
		else if(bySrcMediaType == MEDIA_TYPE_MP4 
			&& m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_MP4 
			&& m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_MP4)
		{
			tTempSimCapSet = m_tConf.GetSecSimCapSet().GetVideoCap();
			u8 byEncRes = m_tConf.GetSecVideoFormat();
			if ( VIDEO_FORMAT_16CIF == bySrcVideoFormat )
			{					
				if(VIDEO_FORMAT_16CIF == byEncRes)
				{
					byEncRes = VIDEO_FORMAT_4CIF;
				}
				else if(VIDEO_FORMAT_AUTO == byEncRes)
				{
					byEncRes = GetAutoResByBitrate(byEncRes, m_tConf.GetBitRate());
				}
			}
			//4CIF/CIF发言不需要走适配(除非双速)，因为模板只能配置主MP4 16CIF，辅格式 MP4 4CIF/CIF
			else if( VIDEO_FORMAT_4CIF == bySrcVideoFormat || VIDEO_FORMAT_CIF == bySrcVideoFormat)
			{	
				return TRUE;
			}

			tTempSimCapSet.SetResolution(byEncRes);
		}

		if ( tTempSimCapSet.GetMediaType() != MEDIA_TYPE_NULL )
		{
			RefreshSpecialCapForVidBrd(m_tConf, tTempSimCapSet,MODE_VIDEO);
		}
		else
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshBasParam4VidBrd]RefreshSpecialCapForBasBrd:tTempSimCapSet is NULL!\n");
			return FALSE;
		}
	}

	if ( !RefreshBasBrdParam(MODE_VIDEO,wBiteRate) )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[RefreshBasParam4VidBrd]RefreshBasBrdParam error!\n");
		return FALSE;
	}

	return  TRUE;
}

/*====================================================================
函数名      RefreshBasParam4SecVidBrd
功能        ：刷新双流广播适配参数
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::RefreshBasParam4DSBrd(u16 wBiteRate)
{
	//增加判断当前广播源信息
	TMt tSrc = GetBrdSrc(MODE_SECVIDEO);
	if ( tSrc.IsNull() )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[RefreshBasParam4DSBrd]tSrc is NULL!\n");
		return FALSE;
	}
	tSrc = GetLocalMtFromOtherMcuMt(tSrc);
	
	BOOL32  bDoubleDual= IsConfDoubleDual(m_tConf);	
	//1.双双流且双流主格式为H264 XGA,根据源切换
	if ( bDoubleDual && 
		 MEDIA_TYPE_H264 == m_tConf.GetDStreamMediaType() &&
		 VIDEO_FORMAT_XGA == m_tConf.GetCapSupport().GetDStreamCapSet().GetResolution() &&
		 !IsConfNeedReserveDSMainCap(m_tConf,m_tConfEx)
		)
	{
		//获得源格式与分辨率
		u8 bySrcMediaType = MEDIA_TYPE_NULL;
		//u8 bySrcVideoFormat = VIDEO_FORMAT_INVALID;
		if (TYPE_MCUPERI == tSrc.GetType() && EQP_TYPE_RECORDER == tSrc.GetEqpType())
		{
			bySrcMediaType = m_tPlayEqpAttrib.GetVideoType();
		}
		else
		{
			TLogicalChannel tSrcLGC;
			if(m_ptMtTable->GetMtLogicChnnl(tSrc.GetMtId(), LOGCHL_SECVIDEO, &tSrcLGC, FALSE))
			{
				bySrcMediaType = tSrcLGC.GetChannelType();
				//bySrcVideoFormat = tSrcLGC.GetVideoFormat();
			}
		}

		BOOL32 bIsSecVideo = TRUE;
		// SrcMedia is main
		if ( bySrcMediaType == m_tConf.GetCapSupport().GetDStreamCapSet().GetMediaType() )
		{	
			bIsSecVideo = TRUE;
		}
		// SrcMedia is sec
		else if(bySrcMediaType == m_tConf.GetCapSupportEx().GetSecDSType() )
		{	
			bIsSecVideo = FALSE;
		}
			
		//set video type and rate
		TVideoStreamCap tTempVideoCap;
		if (bIsSecVideo)
		{
			tTempVideoCap = m_tConf.GetCapSupportEx().GetSecDSVideoCap();//辅格式做参数	
		}
		else
		{	
			tTempVideoCap = m_tConf.GetCapSupport().GetDStreamCapSet().GetVideoStremCap();//主格式做参数
		}	
		
		//刷新
		if ( tTempVideoCap.GetMediaType() != MEDIA_TYPE_NULL )
		{
			if ( tTempVideoCap.GetMediaType() == MEDIA_TYPE_H264 &&
				 tTempVideoCap.GetResolution() == VIDEO_FORMAT_XGA
				)
			{
				tTempVideoCap.SetUserDefFrameRate(5);
			}
			RefreshSpecialCapForVidBrd(m_tConf, tTempVideoCap,MODE_SECVIDEO);
		}
	}

	if ( !RefreshBasBrdParam(MODE_SECVIDEO,wBiteRate) )
	{
		LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[RefreshBasParam4DSBrd]RefreshBasBrdParam error!\n");
		return FALSE;
	}
	

	return TRUE;
}

/*====================================================================
函数名      RefreshBasParam4AudBrd
功能        ：刷新音频广播适配参数
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::RefreshBasParam4AudBrd(u16 wBiteRate)
{
	//1.刷一下参数
	RefreshBasBrdParam(MODE_AUDIO,wBiteRate);

	//apu2 bas编码支持编码四路。不做反向适配刷参
	//2.反向适配刷参
	TAudioTypeDesc tSrcDesc;
	TMt tSrc = GetBrdSrc(MODE_AUDIO);	
	tSrc = GetLocalMtFromOtherMcuMt(tSrc);
	if (TYPE_MCUPERI == tSrc.GetType() && EQP_TYPE_RECORDER == tSrc.GetEqpType())
	{
		tSrcDesc.SetAudioMediaType( m_tPlayEqpAttrib.GetAudioType() );
		tSrcDesc.SetAudioTrackNum( m_tPlayEqpAttrib.GetAudTrackNum() ); 
	}
	else
	{
		TLogicalChannel tSrcLGC;
		if( !m_ptMtTable->GetMtLogicChnnl(tSrc.GetMtId(), LOGCHL_AUDIO, &tSrcLGC, FALSE))
		{
			ConfPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[RefreshBasParam4AudBrd]GetMtLogicChnnl for src:%d-%d failed\n",
						tSrc.GetMcuId(), tSrc.GetMtId()
					  );
			return FALSE;
		}

		tSrcDesc.SetAudioMediaType( tSrcLGC.GetChannelType() );
		tSrcDesc.SetAudioTrackNum( tSrcLGC.GetAudioTrackNum() );
	}

	RefreshSpecialCapForAudBrd(m_tConf,m_tConfEx,tSrcDesc);

	return TRUE;
}

/*=============================================================================
函 数 名：      RefreshBasParam4AllMt
功    能： 根据所有与会终端信息刷新适配参数
算法实现：

  全局变量： 
  参    数： u8 byMediaMode 媒体模式
  返 回 值：  
  ----------------------------------------------------------------------
  修改记录    ：
  日  期		版本		修改人		走读人    修改内容
  2010/07/16  4.5		    周嘉麟                  创建
=============================================================================*/
BOOL32 CMcuVcInst::RefreshBrdBasParam4AllMt(u8 byMediaMode)
{
    for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
    {
        if (!m_tConfAllMtInfo.MtJoinedConf(byMtId))
        {
            continue;
        }
		// 过滤vrs新录播实体
		if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC)
		{
			continue;
		}

        RefreshBrdBasParamForSingleMt(byMtId, byMediaMode);
    }
    return TRUE;
}

/*=============================================================================
    函 数 名： RefreshBasParam
    功    能： 
    算法实现：
               
    全局变量： 
    参    数： u8 byMtId 终端ID
			   u8 byMediaMode 媒体类型
			   BOOL32 bUpAdjust 码率是否上调
			   BOOL32 bIncludeSelf 码率上调升速时是否计算自己，因为码率上调有两种情况，终端挂断或者普通码率上调，挂断时不需要自己码率，
								   普通码率上调码率时需要计算自己码率
								   TRUE 上调时计算自己，
								   FALSE 上调时不计算自己（默认不计算）
							
    返 回 值： TMt 
    -------------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
    2008/11/29  4.5		    周嘉麟                  创建
	2011/12/22  4.7         倪志俊					修改
=============================================================================*/
BOOL32 CMcuVcInst::RefreshBrdBasParamForSingleMt(u8 byMtId, u8 byMediaMode,  BOOL32 bUpAdjust /*= FALSE*/, BOOL32 bIncludeSelf /*= FALSE*/)
{
	if ( byMediaMode == MODE_AUDIO )
	{
		return TRUE;
	}
	
	ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt]  mtid.%d byMediaMode:%d bUpAdjust:%d bIncludeSelf:%d\n", 
			   byMtId,byMediaMode,bUpAdjust,bIncludeSelf);
    if (byMtId == 0 || byMtId > MAXNUM_CONF_MT)
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt] unexpected mtid.%d\n", byMtId);
        return FALSE;
    }

	//如果是广播源则跳过
	TMt tSrc = GetBrdSrc(byMediaMode);
	if (tSrc.IsNull() || (tSrc.IsLocal() && tSrc.GetMtId() == byMtId))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt] BrdSrc is null or BrdSrc's MtId.%d = MtId.%d\n", tSrc.GetMtId(), byMtId);
		return FALSE;
	}


	u8 byLgcMode = 0;
	switch (byMediaMode)
	{
	case MODE_AUDIO:    byLgcMode = LOGCHL_AUDIO;    break;
	case MODE_VIDEO:	byLgcMode = LOGCHL_VIDEO;    break;
	case MODE_SECVIDEO: byLgcMode = LOGCHL_SECVIDEO; break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt] unexpected byMediaMode:%d!\n", byMediaMode);
		return FALSE;
	}


	TLogicalChannel tDstLogChn;
	if (!m_ptMtTable->GetMtLogicChnnl(byMtId, byLgcMode, &tDstLogChn,TRUE))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt] tmt:%d mode:%d GetMtLogicChnnl failed!\n", byMtId,byMediaMode);
		return FALSE;
	}
	
	//不需要适配跳过
	if (!IsNeedAdapt(tSrc, m_ptMtTable->GetMt(byMtId), byMediaMode))
	{
		return TRUE;
	}
	
	TBasOutInfo	tOutInfo;

	if(!FindBasChn2BrdForMt(byMtId, byMediaMode, tOutInfo))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt] FindAcceptBasChnForMt%d failed!\n", byMtId);
		return FALSE;
	}
	
	THDAdaptParam atParam[MAXNUM_PERIEQP];
	memset(atParam, 0, sizeof(atParam));
	if(!g_cMcuVcApp.GetBasOutPutParam(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId, tOutInfo.m_byOutNum, atParam))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt] GetBasOutPutParam failed!\n");
		return FALSE;
	}
	u16 wAdpBR  = atParam[tOutInfo.m_byOutIdx].GetBitrate();
//	u8  byAdpFR = atParam[tOutInfo.m_byOutIdx].GetFrameRate();
	
	TBasOutInfo tAcceptOutInfo;
	u8   byMinFR		= 0xff;
	u16  wMinBR		    = 0xffff;
	BOOL32 bChanged		= FALSE;
	TLogicalChannel tMtLgc;
	
	if (tDstLogChn.GetFlowControl() < wAdpBR)
	{
		
		//外设BAS现在能根据码率自动调整分辨率，故此处不需要对主流码率再进行保护
		atParam[tOutInfo.m_byOutIdx].SetBitRate(tDstLogChn.GetFlowControl());
// 		if( m_tConf.GetSecBitRate() != 0 && 
// 			tDstLogChn.GetFlowControl() < m_tConf.GetSecBitRate() &&
// 			byMediaMode != MODE_SECVIDEO
// 			)
// 		{
// 			if( m_tConf.GetSecBitRate() == wAdpBR )
// 			{
// 				ConfPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[RefreshBrdBasParamForSingleMt] Mt%d bitRate(%d) is lower than secBitRate(%d) and wAdpBR(%d) is equal secBitRate.so not refresh bas param\n",
// 					byMtId,	tDstLogChn.GetFlowControl(), m_tConf.GetSecBitRate(), wAdpBR );
// 				return FALSE;
// 			}
// 			ConfPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[RefreshBrdBasParamForSingleMt] Mt%d bitRate(%d) is lower than secBitRate(%d),so adjust bas bitRate to secBitrate.\n",
// 				byMtId,	tDstLogChn.GetFlowControl(), m_tConf.GetSecBitRate() );
// 			atParam[tOutInfo.m_byOutIdx].SetBitRate( m_tConf.GetSecBitRate() );
// 		}
// 		else
// 		{
// 			atParam[tOutInfo.m_byOutIdx].SetBitRate(tDstLogChn.GetFlowControl());
// 		}

		//mp4分辨率随码率调整
		//双速会议 + 主辅格式MP4
		if (0 != m_tConf.GetSecBitRate() &&
			((MEDIA_TYPE_MP4  == m_tConf.GetMainVideoMediaType() && VIDEO_FORMAT_AUTO == m_tConf.GetMainVideoFormat()) ||
			(MEDIA_TYPE_MP4  == m_tConf.GetSecVideoMediaType()  && VIDEO_FORMAT_AUTO == m_tConf.GetSecVideoFormat())) &&		
			MEDIA_TYPE_MP4  == atParam[tOutInfo.m_byOutIdx].GetVidType())
		{
			u16 wWidth  = 0;
			u16 wHeight = 0;
			u8 byEncRes = GetAutoResByBitrate(VIDEO_FORMAT_AUTO, atParam[tOutInfo.m_byOutIdx].GetBitrate());
			GetWHByRes(byEncRes, wWidth, wHeight);
			atParam[tOutInfo.m_byOutIdx].SetResolution(wWidth, wHeight);
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt] Mt%d Refresh bas param to Mp4.%d because EncBR:%d!\n", 
					GetResByWH(wWidth, wHeight), atParam[tOutInfo.m_byOutIdx].GetBitrate());
		}
		
		bChanged = TRUE;		
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt] Mt%d<Media:%d, Res:%d, BR:%d> adjust AdaptParam's BR to %d!\n", 
						byMtId, tDstLogChn.GetChannelType(), tDstLogChn.GetVideoFormat(), 
						tDstLogChn.GetFlowControl(),tDstLogChn.GetFlowControl());
	}
	else if(tDstLogChn.GetFlowControl() >= wAdpBR)
	{
		if ( tDstLogChn.GetFlowControl() >  m_tConf.GetBitRate())
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt] mt:%d biterate:%d is more than conf biterate:%d\n",
				byMtId,tDstLogChn.GetFlowControl(),m_tConf.GetBitRate()
				);
			return FALSE;
		}

		
		if(bUpAdjust)
		{			
			for (u8 byIdx = 1; byIdx <= MAXNUM_CONF_MT; byIdx++)
			{
				if (!m_tConfAllMtInfo.MtJoinedConf(byIdx))
				{
					continue;
				}

				//如果终端是升速，那么判断计算码率时，是否需要过滤自己
				//bIncludeSelf为TRUE说明计算时需要包含自己(比如E1终端码率恢复)
				//bIncludeSelf为FALSE说明计算时不需要包含自己，即过滤自己，终端挂断场景
				if ( !bIncludeSelf )
				{
					if ( byIdx == byMtId ||
						( tSrc.IsLocal() && byIdx == tSrc.GetMtId() ) 
						)
					{
						continue;
					}
				}
			
				if (!m_ptMtTable->GetMtLogicChnnl(byIdx, byLgcMode, &tMtLgc, TRUE))
				{
					continue;
				}
				if (!IsNeedAdapt(tSrc, m_ptMtTable->GetMt(byIdx), byMediaMode))
				{
					continue;
				}
			
				if(!FindBasChn2BrdForMt(byIdx, byMediaMode, tAcceptOutInfo))
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt] FindAcceptBasChnForMt%d failed!\n", byIdx);
					continue;
				}
					
				if (tAcceptOutInfo.m_tBasEqp.GetEqpId() != tOutInfo.m_tBasEqp.GetEqpId() || tAcceptOutInfo.m_byChnId != tOutInfo.m_byChnId || tAcceptOutInfo.m_byOutIdx != tOutInfo.m_byOutIdx )
				{
					continue;
				}

				const u16 wFlCtrl = tMtLgc.GetFlowControl();
				wMinBR = min(wMinBR, wFlCtrl);
				atParam[tOutInfo.m_byOutIdx].SetBitRate(wMinBR);
				bChanged = TRUE;
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt] Mt%d<Media:%d, Res:%d, BR:%d> adjust AdaptParam's BR to %d!\n", 
								byMtId, tMtLgc.GetChannelType(), tMtLgc.GetVideoFormat(), 
								tMtLgc.GetFlowControl(), wMinBR);
			}
			//当前已无对应分辨率的终端，恢复到会议码率
			if (0xffff == wMinBR)
			{	
				bChanged = TRUE;
				atParam[tOutInfo.m_byOutIdx].SetBitRate(m_tConf.GetBitRate());
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt] Mt%d<Media:%d, Res:%d, BR:%d> adjust AdaptParam's BR to %d!\n", 
					byMtId, tDstLogChn.GetChannelType(), tDstLogChn.GetVideoFormat(), 
								tDstLogChn.GetFlowControl(), m_tConf.GetBitRate());
			}
		}
	}

	//目前适配已经按照帧率严格适配，故不存在帧率调整问题
// 	//other目前不存在帧率刷新
//     if (tDstLogChn.GetChanVidFPS() < byAdpFR &&
// 		tDstLogChn.GetChannelType() == MEDIA_TYPE_H264
// 		)
//     {		
// 		//呼叫终端下调帧率
// 		atParam[tOutInfo.m_byOutIdx].SetFrameRate(tDstLogChn.GetChanVidFPS());
// 		bChanged = TRUE;
// 		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt] Mt%d<Media:%d, Res:%d, FR:%d> adjust AdaptParam's FR to %d!\n", 
// 						byMtId, tDstLogChn.GetChannelType(), tDstLogChn.GetVideoFormat(), 
// 						tDstLogChn.GetChanVidFPS(),tDstLogChn.GetChanVidFPS());
//     }
// 	else if(tDstLogChn.GetChanVidFPS() == byAdpFR &&
// 			tDstLogChn.GetChannelType() == MEDIA_TYPE_H264
// 		   )
// 	{
// 		//挂断终端上调帧率
// 		if(bUpAdjust)
// 		{
// 			for (u8 byIdx = 1; byIdx <= MAXNUM_CONF_MT; byIdx++)
// 			{
// 				if (!m_tConfAllMtInfo.MtJoinedConf(byIdx))
// 				{
// 					continue;
// 				}
// 				//过滤被删终端和当前广播源,广播源是下级终端，则不过滤该终端所在MCU
// 				if ( byIdx == byMtId ||
// 					( tSrc.IsLocal() && byIdx == tSrc.GetMtId() ) 
// 					)
// 				{
// 					continue;
// 				}
// 				if (!m_ptMtTable->GetMtLogicChnnl(byIdx, byLgcMode, &tMtLgc, TRUE))
// 				{
// 					continue;
// 				}
// 				if (!IsNeedAdapt(tSrc, m_ptMtTable->GetMt(byIdx), byMediaMode))
// 				{
// 					continue;
// 				}
// 				if(!FindBasChn2BrdForMt(byIdx, byMediaMode, tAcceptOutInfo))
// 				{
// 					ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt] FindAcceptBasChnForMt%d failed!\n", byIdx);
// 					continue;
// 				}
// 				tAcceptOutInfo.m_tBasEqp = tAcceptOutInfo.m_tBasEqp;
// 				tAcceptOutInfo.m_byChnId  = tAcceptOutInfo.m_byChnId;
// 				tAcceptOutInfo.m_byOutNum = tAcceptOutInfo.m_byOutNum;
// 				tAcceptOutInfo.m_byOutIdx = tAcceptOutInfo.m_byOutIdx;
// 				if (tAcceptOutInfo.m_tBasEqp.GetEqpId() != tOutInfo.m_tBasEqp.GetEqpId() || tAcceptOutInfo.m_byChnId != tOutInfo.m_byChnId || tAcceptOutInfo.m_byOutIdx != tOutInfo.m_byOutIdx)
// 				{
// 					continue;
// 				}
// 				
// 				const u8 byChanFps = tMtLgc.GetChanVidFPS();
// 				byMinFR = min(byMinFR, byChanFps);
// 
// 				atParam[tOutInfo.m_byOutIdx].SetFrameRate(byMinFR);
// 				bChanged = TRUE;
// 				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshBrdBasParamForSingleMt] Mt%d<Media:%d, Res:%d, FR:%d> adjust AdaptParam's FR to %d!\n", 
// 								byMtId, tMtLgc.GetChannelType(), tMtLgc.GetVideoFormat(), 
// 								tMtLgc.GetChanVidFPS(),byMinFR);
// 			}
// 			//当前已无对应分辨率的终端，帧率调成会议第一速率，待终端上线后依次往下刷
// 			if (0xff == byMinFR)
// 			{	
// 				bChanged = TRUE;
// 				if (MEDIA_TYPE_H264 == m_tConf.GetMainVideoMediaType())
// 				{
// 					atParam[tOutInfo.m_byOutIdx].SetFrameRate(m_tConf.GetMainVidUsrDefFPS());
// 				}
// 				else
// 				{
// 					atParam[tOutInfo.m_byOutIdx].SetFrameRate(m_tConf.GetSecVidFrameRate());
// 				}
// 			}
// 		}
// 	}

	//对于MPU2通道，每次终端参数刷新时，都认为参数有调整
	TPeriEqpStatus tBasStatus;
	if ( g_cMcuVcApp.GetPeriEqpStatus(tOutInfo.m_tBasEqp.GetEqpId(), &tBasStatus) )
	{
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
		if ( g_cMcuAgent.IsEqpBasHD(tOutInfo.m_tBasEqp.GetEqpId()) )
#endif
		{
			u8 byHDBasType = tBasStatus.m_tStatus.tHdBas.GetEqpType();
			if ( byHDBasType == TYPE_MPU2_BASIC || byHDBasType == TYPE_MPU2_ENHANCED )
			{
				bChanged = TRUE;
				//终端上调码率，并且bIncludeSelf为false说明是终端是挂掉
				//临时清空该终端逻辑通道，以方便下参时判断是否将码率调整,下参完毕恢复
				if ( bUpAdjust == TRUE && bIncludeSelf == FALSE )
				{
					TLogicalChannel tNullLogicChnnl;
					m_ptMtTable->SetMtLogicChnnl(byMtId, byLgcMode, &tNullLogicChnnl, TRUE);
				}
			}
		}
	}

	//有调整刷新mcu保存参数
	if (bChanged)
	{	
		//[nizhijun 20120705]对于MP4 AUTO使用模糊匹配方式，为了让MP4 AUTO能够根据码率调整分辨
		if ( MEDIA_TYPE_MP4 == atParam[tOutInfo.m_byOutIdx].GetVidType() && 		
			 ( (m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_MP4 && m_tConf.GetSecVideoFormat() == VIDEO_FORMAT_AUTO)
			   ||
			   (m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_MP4 && m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_AUTO)
			 )
		   )
		{
			u8 byNewRes = GetAutoResByBitrate(VIDEO_FORMAT_AUTO,atParam[tOutInfo.m_byOutIdx].GetBitrate() );
			if ( byNewRes != VIDEO_FORMAT_INVALID )
			{
				u16 byNewWidth = 0;
				u16 byNewHeight = 0;
				GetWHByRes(byNewRes,byNewWidth,byNewHeight);
				atParam[tOutInfo.m_byOutIdx].SetResolution(byNewWidth,byNewHeight);
				LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[RefreshBrdBasParamForSingleMt]refresh eqp:%d-chid:%d-outid:%d to res:%d\n",
						tOutInfo.m_tBasEqp.GetEqpId(),tOutInfo.m_byChnId,tOutInfo.m_byOutIdx,byNewRes
						);
			}
			else
			{
				LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[RefreshBrdBasParamForSingleMt]GetAutoResByBitrate failed!\n");
			}
		}

		RefreshBasParambyOutIdx(tOutInfo,atParam[tOutInfo.m_byOutIdx]);
		//如果适配器已经启动则发消息刷新参数
		if (BASCHN_STATE_WAITSTART == g_cMcuVcApp.GetBasChnStatus(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId) ||
			BASCHN_STATE_RUNNING == g_cMcuVcApp.GetBasChnStatus(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId))
		{
			ChangeAdapt(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId);
		}	    
	}
	m_ptMtTable->SetMtLogicChnnl(byMtId, byLgcMode, &tDstLogChn, TRUE);
	return TRUE;
}


/*=============================================================================
    函 数 名： RefreshSelBasParam
    功    能： 
    算法实现：
               
    全局变量： 
    参    数： 
    返 回 值： TMt 
    -------------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
    2008/11/29  4.5		    周嘉麟                  创建
=============================================================================*/
BOOL32 CMcuVcInst::RefreshSelBasParam(TMt tSrc, TMt tDst, u8 byMediaMode, BOOL32 bUpAdjust /* = FALSE */, BOOL32 bIncludeSelf /*= FALSE*/)
{
	if ( byMediaMode == MODE_AUDIO )
	{
		return TRUE;
	}

	ConfPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[RefreshSelBasParam]tSrc:%d-%d tDst:%d-%d,byMediaMode:%d,bUpAdjust:%d,bIncludeSelf:%d\n",
			tSrc.GetMcuId(), tSrc.GetMtId(),tDst.GetMcuId(),tDst.GetMtId(), bUpAdjust, bIncludeSelf
			);

	if (tSrc.GetMtId() == tDst.GetMtId())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshSelBasParam] bySrcMtId:%d = byDstMtId:%d!\n", tSrc.GetMtId(), tDst.GetMtId());
		return FALSE;
	}

	if (MODE_VIDEO != byMediaMode && MODE_AUDIO != byMediaMode && MODE_VIDEO2SECOND != byMediaMode)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshSelBasParam] unexpected Mode:%d!\n", byMediaMode);
		return FALSE;
	}
	//不需要适配跳过
	if (!IsNeedSelAdpt(tSrc, tDst, byMediaMode))
	{
		return TRUE;
	}

	u8 byLgcMode = 0;
	switch (byMediaMode)
	{
	case MODE_AUDIO:    byLgcMode = LOGCHL_AUDIO;    break;
	case MODE_VIDEO:	byLgcMode = LOGCHL_VIDEO;    break;
	case MODE_SECVIDEO: byLgcMode = LOGCHL_SECVIDEO; break;
		case MODE_VIDEO2SECOND:byLgcMode = LOGCHL_SECVIDEO; break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshSelBasParam] unexpected byMediaMode:%d!\n", byMediaMode);
		return FALSE;
	}
	
	TLogicalChannel tDstLogChn;
	if (!m_ptMtTable->GetMtLogicChnnl(tDst.GetMtId(), byLgcMode, &tDstLogChn,TRUE))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshSelBasParam]GetMtLogicChnnl-->Mt%d failed!\n", tDst.GetMtId());
		return FALSE;
	}

	TBasOutInfo tRealOutInfo;
	if(!FindBasChn2SelForMt(tSrc, tDst, byMediaMode, tRealOutInfo))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshSelBasParam]FindBasChn2SelFor<SrcMt:%d ->DstMt:%d> failed!\n", tSrc.GetMtId(), tDst.GetMtId());
		return FALSE;
	}
	
	THDAdaptParam atParam[MAXNUM_PERIEQP];
	memset(atParam, 0, sizeof(atParam));
	if(!g_cMcuVcApp.GetBasOutPutParam(tRealOutInfo.m_tBasEqp, tRealOutInfo.m_byChnId, tRealOutInfo.m_byOutNum, atParam))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshSelBasParam] GetBasOutPutParam failed!\n");
		return FALSE;
	}
	u16 wAdpBR  = atParam[tRealOutInfo.m_byOutIdx].GetBitrate();
	u8  byAdpFR = atParam[tRealOutInfo.m_byOutIdx].GetFrameRate();
	
	TBasOutInfo tOutInfo;
	u8   byMinFR		= 0xff;
	u16  wMinBR		    = 0xffff;
	BOOL32 bChanged		= FALSE;
	TMtStatus tDstStatus;
	TLogicalChannel tMtLgc;
	if (tDstLogChn.GetFlowControl() < wAdpBR)
	{
		//呼叫终端下调码率
		atParam[tRealOutInfo.m_byOutIdx].SetBitRate(tDstLogChn.GetFlowControl());
		
		//mp4分辨率随码率调整
		//双速会议 + 主辅格式MP4
		if (0 != m_tConf.GetSecBitRate() &&
			((MEDIA_TYPE_MP4  == m_tConf.GetMainVideoMediaType() && VIDEO_FORMAT_AUTO == m_tConf.GetMainVideoFormat()) ||
			(MEDIA_TYPE_MP4  == m_tConf.GetSecVideoMediaType()  && VIDEO_FORMAT_AUTO == m_tConf.GetSecVideoFormat())) &&		
			 MEDIA_TYPE_MP4  == atParam[tRealOutInfo.m_byOutIdx].GetVidType())
		{
			u16 wWidth  = 0;
			u16 wHeight = 0;
			u8 byEncRes = GetAutoResByBitrate(VIDEO_FORMAT_AUTO, atParam[tRealOutInfo.m_byOutIdx].GetBitrate());
			GetWHByRes(byEncRes, wWidth, wHeight);
			atParam[tRealOutInfo.m_byOutIdx].SetResolution(wWidth, wHeight);
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshSelBasParam] Mt%d Refresh bas param to Mp4.%d because EncBR:%d!\n", 
				GetResByWH(wWidth, wHeight), atParam[tRealOutInfo.m_byOutIdx].GetBitrate());
		}
		
		bChanged = TRUE;		
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshSelBasParam] Mt%d<Media:%d, Res:%d, BR:%d> adjust AdaptParam's BR to %d!\n", 
			tDst.GetMtId(), tDstLogChn.GetChannelType(), tDstLogChn.GetVideoFormat(), 
						tDstLogChn.GetFlowControl(),tDstLogChn.GetFlowControl());
	}
	else if (tDstLogChn.GetFlowControl() >= wAdpBR)
	{
		if(bUpAdjust)
		{	
			u8 bySecMediaType = MEDIA_TYPE_NULL;
			u8 bySecLgcMode = 0;
			if (MODE_VIDEO == byMediaMode)
			{
				bySecMediaType = MODE_VIDEO2SECOND;
				bySecLgcMode = LOGCHL_SECVIDEO;
			}
			else if (MODE_VIDEO2SECOND == byMediaMode)
			{
				bySecMediaType = MODE_VIDEO;
				bySecLgcMode = LOGCHL_VIDEO;
			}
			
			for (u8 byIdx = 1; byIdx <= MAXNUM_CONF_MT; byIdx++)
			{
				tDstStatus.SetNull();
				if (!m_tConfAllMtInfo.MtJoinedConf(byIdx))
				{
					continue;
				}
				//过滤被删终端和当前选看源
				if ( !bIncludeSelf )
				{
					if (byIdx == tSrc.GetMtId() || byIdx == tDst.GetMtId())
					{
						continue;
					}
				}
			
				if (!m_ptMtTable->GetMtLogicChnnl(byIdx, byLgcMode, &tMtLgc, TRUE)
					&& (bySecLgcMode >0 && !m_ptMtTable->GetMtLogicChnnl(byIdx, bySecLgcMode, &tMtLgc, TRUE)))
				{
					continue;
				}
				if (!m_ptMtTable->GetMtStatus(byIdx, &tDstStatus))
				{
					continue;
				}
				
				BOOL32 bIsNeedAdp = tSrc == m_ptMtTable->GetMtSelMtByMode(byIdx, byMediaMode)
					&& IsNeedSelAdpt(tSrc, m_ptMtTable->GetMt(byIdx), byMediaMode);
				
				BOOL32 bSecIsNeedAdp = FALSE;
				
				if (MEDIA_TYPE_NULL != bySecMediaType)
				{
					bSecIsNeedAdp = tSrc == m_ptMtTable->GetMtSelMtByMode(byIdx, bySecMediaType)
						&& IsNeedSelAdpt(tSrc, m_ptMtTable->GetMt(byIdx), bySecMediaType);
				}
				
				if (!bIsNeedAdp && !bSecIsNeedAdp)
				{
					continue;
				}
				
				if (bIsNeedAdp && FindBasChn2SelForMt(tSrc, m_ptMtTable->GetMt(byIdx), byMediaMode,tOutInfo))
				{
					if (tOutInfo.m_tBasEqp.GetEqpId() == tRealOutInfo.m_tBasEqp.GetEqpId() && tOutInfo.m_byChnId == tRealOutInfo.m_byChnId 
						&& tOutInfo.m_byOutIdx == tRealOutInfo.m_byOutIdx)
					{
						const u16 wFlCtrl = tMtLgc.GetFlowControl();
						wMinBR = min(wMinBR, wFlCtrl);
						
						atParam[tRealOutInfo.m_byOutIdx].SetBitRate(wMinBR);
						bChanged = TRUE;
						ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshSelBasParam] Mt%d<Media:%d, Res:%d, BR:%d> adjust AdaptParam's BR to %d!\n", 
							tDst.GetMtId(), tMtLgc.GetChannelType(), tMtLgc.GetVideoFormat(), 
							tMtLgc.GetFlowControl(), wMinBR);
					}
				}
				
				if (bSecIsNeedAdp && FindBasChn2SelForMt(tSrc, m_ptMtTable->GetMt(byIdx), bySecMediaType,tOutInfo))
				{
					if (tOutInfo.m_tBasEqp.GetEqpId() == tRealOutInfo.m_tBasEqp.GetEqpId() && tOutInfo.m_byChnId == tRealOutInfo.m_byChnId 
						&& tOutInfo.m_byOutIdx == tRealOutInfo.m_byOutIdx)
					{
						const u16 wFlCtrl = tMtLgc.GetFlowControl();
						wMinBR = min(wMinBR, wFlCtrl);
						
						atParam[tRealOutInfo.m_byOutIdx].SetBitRate(wMinBR);
						bChanged = TRUE;
						ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshSelBasParam] Mt%d<Media:%d, Res:%d, BR:%d> adjust AdaptParam's BR to %d!\n", 
							tDst.GetMtId(), tMtLgc.GetChannelType(), tMtLgc.GetVideoFormat(), 
							tMtLgc.GetFlowControl(), wMinBR);
					}
				}
			}
			//当前已无对应分辨率的终端，码率调成会议第一速率，待终端上线后依次往下刷
			if (0xffff == wMinBR)
			{	
				bChanged = TRUE;
				atParam[tRealOutInfo.m_byOutIdx].SetBitRate(m_tConf.GetBitRate());
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshSelBasParam]  Mt%d<Media:%d, Res:%d, BR:%d> adjust AdaptParam's BR to %d!\n", 
					tDst.GetMtId(), tDstLogChn.GetChannelType(), tDstLogChn.GetVideoFormat(), 
								tDstLogChn.GetFlowControl(), m_tConf.GetBitRate());
			
			}
		}
	}

	if (tDstLogChn.GetChanVidFPS() < byAdpFR)
    {		
		//呼叫终端下调帧率
		atParam[tRealOutInfo.m_byOutIdx].SetFrameRate(tDstLogChn.GetChanVidFPS());
		bChanged = TRUE;
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshSelBasParam] Mt%d<Media:%d, Res:%d, FR:%d> adjust AdaptParam's FR to %d!\n", 
			tDst.GetMtId(), tDstLogChn.GetChannelType(), tDstLogChn.GetVideoFormat(), 
			tDstLogChn.GetChanVidFPS(),tDstLogChn.GetChanVidFPS());
    }
	else if(tDstLogChn.GetChanVidFPS() == byAdpFR)
	{
		//挂断终端上调帧率
		if(bUpAdjust)
		{
			u8 bySecMediaType = MEDIA_TYPE_NULL;
			u8 bySecLgcMode = 0;
			if (MODE_VIDEO == byMediaMode)
			{
				bySecMediaType = MODE_VIDEO2SECOND;
				bySecLgcMode = LOGCHL_SECVIDEO;
			}
			else if (MODE_VIDEO2SECOND == byMediaMode)
			{
				bySecMediaType = MODE_VIDEO;
				bySecLgcMode = LOGCHL_VIDEO;
			}
			
			for (u8 byIdx = 1; byIdx <= MAXNUM_CONF_MT; byIdx++)
			{
				tDstStatus.SetNull();
				if (!m_tConfAllMtInfo.MtJoinedConf(byIdx))
				{
					continue;
				}
				//过滤被删终端和当前选看源
				if (byIdx == tSrc.GetMtId() || byIdx == tDst.GetMtId())
				{
					continue;
				}
				
				if (!m_ptMtTable->GetMtStatus(byIdx, &tDstStatus))
				{
					continue;
				}
				
				if (!m_ptMtTable->GetMtLogicChnnl(byIdx, byLgcMode, &tMtLgc, TRUE)
					|| (bySecLgcMode > 0 && !m_ptMtTable->GetMtLogicChnnl(byIdx, bySecLgcMode, &tMtLgc, TRUE)))
				{
					continue;
				}
				
				BOOL32 bIsNeedAdp = tSrc == m_ptMtTable->GetMtSelMtByMode(byIdx, byMediaMode)
					&& IsNeedSelAdpt(tSrc, m_ptMtTable->GetMt(byIdx), byMediaMode);
				
				BOOL32 bSecIsNeedAdp = FALSE;
				
				if (MEDIA_TYPE_NULL != bySecMediaType)
				{
					bSecIsNeedAdp = tSrc == m_ptMtTable->GetMtSelMtByMode(byIdx, bySecMediaType)
						&& IsNeedSelAdpt(tSrc, m_ptMtTable->GetMt(byIdx), bySecMediaType);
				}
				
				if (!bIsNeedAdp && !bSecIsNeedAdp)
				{
					continue;
				}
				
				if(bIsNeedAdp && FindBasChn2SelForMt(tSrc, m_ptMtTable->GetMt(byIdx), byMediaMode, tOutInfo))
				{
					if (tOutInfo.m_tBasEqp.GetEqpId() == tRealOutInfo.m_tBasEqp.GetEqpId() && tOutInfo.m_byChnId == tRealOutInfo.m_byChnId 
						&& tOutInfo.m_byOutIdx == tRealOutInfo.m_byOutIdx)
					{
						const u8 byChanFps = tMtLgc.GetChanVidFPS();
						byMinFR = min(byMinFR, byChanFps);
						
						atParam[tRealOutInfo.m_byOutIdx].SetFrameRate(byMinFR);
						bChanged = TRUE;
						ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshSelBasParam] Mt%d<Media:%d, Res:%d, FR:%d> adjust AdaptParam's FR to %d!\n", 
							tDst.GetMtId(), tMtLgc.GetChannelType(), tMtLgc.GetVideoFormat(), tMtLgc.GetChanVidFPS(),byMinFR);
					}
				}
				
				if(bSecIsNeedAdp && FindBasChn2SelForMt(tSrc, m_ptMtTable->GetMt(byIdx), bySecMediaType, tOutInfo))
				{
					if (tOutInfo.m_tBasEqp.GetEqpId() == tRealOutInfo.m_tBasEqp.GetEqpId() && tOutInfo.m_byChnId == tRealOutInfo.m_byChnId 
						&& tOutInfo.m_byOutIdx == tRealOutInfo.m_byOutIdx)
					{
						const u8 byChanFps = tMtLgc.GetChanVidFPS();
						byMinFR = min(byMinFR, byChanFps);
						
						atParam[tRealOutInfo.m_byOutIdx].SetFrameRate(byMinFR);
						bChanged = TRUE;
						ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshSelBasParam] Mt%d<Media:%d, Res:%d, FR:%d> adjust AdaptParam's FR to %d!\n", 
							tDst.GetMtId(), tMtLgc.GetChannelType(), tMtLgc.GetVideoFormat(), tMtLgc.GetChanVidFPS(),byMinFR);
					}
				}
			}
			//选看无需上调帧率，现在帧率适配不会和码率适配一样出在同一编码上
// 			//当前已无对应分辨率的终端，帧率调成会议第一速率，待终端上线后依次往下刷
// 			if (0xff == byMinFR)
// 			{	
// 				bChanged = TRUE;
// 				if (MEDIA_TYPE_H264 == m_tConf.GetMainVideoMediaType())
// 				{
// 					atParam[tRealOutInfo.m_byOutIdx].SetFrameRate(m_tConf.GetMainVidUsrDefFPS());
// 				}
// 				else
// 				{
// 					atParam[tRealOutInfo.m_byOutIdx].SetFrameRate(m_tConf.GetSecVidFrameRate());
// 				}
// 			}
		}
	}
	//有调整刷新mcu保存参数
	if (bChanged)
	{
		RefreshBasParambyOutIdx(tRealOutInfo,atParam[tRealOutInfo.m_byOutIdx]);
		//如果适配器已经启动则发消息刷新参数
		if (BASCHN_STATE_RUNNING == g_cMcuVcApp.GetBasChnStatus(tRealOutInfo.m_tBasEqp, tRealOutInfo.m_byChnId) ||
			BASCHN_STATE_WAITSTART == g_cMcuVcApp.GetBasChnStatus(tRealOutInfo.m_tBasEqp, tRealOutInfo.m_byChnId))
		{
			ChangeAdapt(tRealOutInfo.m_tBasEqp, tRealOutInfo.m_byChnId);
		}	    
	}

	return TRUE;
}

/*=============================================================================
    函 数 名： RefreshSelBasParam
    功    能： 
    算法实现：
               
    全局变量： 
    参    数： 
    返 回 值： TMt 
    -------------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
    2008/11/29  4.5		    周嘉麟                  创建
=============================================================================*/
BOOL32 CMcuVcInst::RefreshSpyBasParam(TMt tSrc, TSimCapSet &tDstCap, u8 byMediaMode, BOOL32 bUpAdjust /* = FALSE */,BOOL32 bIncludeSelf/* = FALSE*/)
{
	ConfPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[RefreshSpyBasParam]tSrc:%d-%d byMediaMode:%d,bUpAdjust:%d,bIncludeSelf:%d\n",
		tSrc.GetMcuId(), tSrc.GetMtId(), bUpAdjust, bIncludeSelf
			);

	if (tSrc.IsNull() || tDstCap.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshSpyBasParam] tSrc<McuId:%d, MtId:%d> or tDstCap is null!\n", tSrc.GetMcuId(), tSrc.GetMtId());
	}

	if (MODE_VIDEO != byMediaMode && MODE_AUDIO != byMediaMode)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshSpyBasParam] unexpected Mode:%d!\n", byMediaMode);
		return FALSE;
	}
	//不需要适配跳过
	TSimCapSet tSrcCap = m_ptMtTable->GetSrcSCS(tSrc.GetMtId());
	if (tSrcCap < tDstCap)
	{
		return TRUE;
	}

	u8 byLgcMode = 0;
	switch (byMediaMode)
	{
	case MODE_AUDIO:    byLgcMode = LOGCHL_AUDIO;    break;
	case MODE_VIDEO:	byLgcMode = LOGCHL_VIDEO;    break;
	case MODE_SECVIDEO: byLgcMode = LOGCHL_SECVIDEO; break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshSelBasParam] unexpected byMediaMode:%d!\n", byMediaMode);
		return FALSE;
	}

	TBasOutInfo tBasOutInfo;
	if(!FindBasChn2SpyForMt(tSrc, tDstCap, byMediaMode, tBasOutInfo))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshSpyBasParam]FindBasChn2SpyForMt<SrcMt:%d ->DstCap<Media:%d, Res:%d, Fps:%d> failed!\n",
						tSrc.GetMtId(), tDstCap.GetVideoMediaType(), tDstCap.GetVideoResolution(),
						MEDIA_TYPE_H264 == tDstCap.GetVideoMediaType()? tDstCap.GetUserDefFrameRate():tDstCap.GetVideoFrameRate());
		return FALSE;
	}
	
	THDAdaptParam atParam[MAXNUM_PERIEQP];
	memset(atParam, 0, sizeof(atParam));
	if(!g_cMcuVcApp.GetBasOutPutParam(tBasOutInfo.m_tBasEqp, tBasOutInfo.m_byChnId, tBasOutInfo.m_byOutNum, atParam))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[RefreshSpyBasParam] GetBasOutPutParam failed!\n");
		return FALSE;
	}
	u16 wAdpBR  = atParam[tBasOutInfo.m_byOutIdx].GetBitrate();
	u8  byAdpFR = atParam[tBasOutInfo.m_byOutIdx].GetFrameRate();
	
	TBasOutInfo tAcceptOutInfo;
	u8   byMinFR		= 0xff;
	u16  wMinBR		    = 0xffff;
	BOOL32 bChanged		= FALSE;
	TMtStatus tDstStatus;
	TLogicalChannel tMtLgc;
	if (tDstCap.GetVideoMaxBitRate() < wAdpBR)
	{
		//呼叫终端下调码率
		atParam[tBasOutInfo.m_byOutIdx].SetBitRate(tDstCap.GetVideoMaxBitRate());
		
		//mp4分辨率随码率调整
		//双速会议 + 主辅格式MP4
		if (0 != m_tConf.GetSecBitRate() &&
			((MEDIA_TYPE_MP4  == m_tConf.GetMainVideoMediaType() && VIDEO_FORMAT_AUTO == m_tConf.GetMainVideoFormat()) ||
			(MEDIA_TYPE_MP4  == m_tConf.GetSecVideoMediaType()  && VIDEO_FORMAT_AUTO == m_tConf.GetSecVideoFormat())) &&		
			 MEDIA_TYPE_MP4  == atParam[tBasOutInfo.m_byOutIdx].GetVidType())
		{
			u16 wWidth  = 0;
			u16 wHeight = 0;
			u8 byEncRes = GetAutoResByBitrate(VIDEO_FORMAT_AUTO, atParam[tBasOutInfo.m_byOutIdx].GetBitrate());
			GetWHByRes(byEncRes, wWidth, wHeight);
			atParam[tBasOutInfo.m_byOutIdx].SetResolution(wWidth, wHeight);
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshSpyBasParam] Mt%d Refresh bas param to Mp4.%d because EncBR:%d!\n", 
				GetResByWH(wWidth, wHeight), atParam[tBasOutInfo.m_byOutIdx].GetBitrate());
		}
		
		bChanged = TRUE;		
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshSpyBasParam] DstMt<Media:%d, Res:%d, BR:%d> adjust AdaptParam's BR to %d!\n", 
						tDstCap.GetVideoMediaType(),  tDstCap.GetVideoResolution(), 
						tDstCap.GetVideoMaxBitRate(), tDstCap.GetVideoMaxBitRate());
	}
	else if (tDstCap.GetVideoMaxBitRate() >= wAdpBR)
	{
		if(bUpAdjust)
		{			
			for (u8 byIdx = 1; byIdx <= MAXNUM_CONF_MT; byIdx++)
			{
				tDstStatus.SetNull();
				if (!m_tConfAllMtInfo.MtJoinedConf(byIdx))
				{
					continue;
				}

				if (  !bIncludeSelf )
				{
					//过滤被删终端和当前选看源
					if (byIdx == tSrc.GetMtId())
					{
						continue;
					}
				}
			
				if (!m_ptMtTable->GetMtStatus(byIdx, &tDstStatus) ||
					!(tSrc == tDstStatus.GetSelectMt(byMediaMode)) ||
					!IsNeedSelAdpt(tSrc, m_ptMtTable->GetMt(byIdx), byMediaMode))
				{
					continue;
				}
				if (!m_ptMtTable->GetMtLogicChnnl(byIdx, byLgcMode, &tMtLgc, TRUE))
				{
					continue;
				}

				if(!FindBasChn2SelForMt(tSrc, m_ptMtTable->GetMt(byIdx), byMediaMode, tAcceptOutInfo))
				{
					ConfPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[RefreshSelBasParam] FindAcceptBasChnForMt%d failed!\n", byIdx);
					continue;
				}
				if (tAcceptOutInfo.m_tBasEqp.GetEqpId() != tBasOutInfo.m_tBasEqp.GetEqpId() || 
					tAcceptOutInfo.m_byChnId != tBasOutInfo.m_byChnId || 
					tAcceptOutInfo.m_byOutIdx != tBasOutInfo.m_byOutIdx
					)
				{
					continue;
				}
				
				const u16 wFlCtrl = tMtLgc.GetFlowControl();
				wMinBR = min(wMinBR, wFlCtrl);

				atParam[tBasOutInfo.m_byOutIdx].SetBitRate(wMinBR);
				bChanged = TRUE;
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshSpyBasParam] DstMt<Media:%d, Res:%d, BR:%d> adjust AdaptParam's BR to %d!\n", 
					tMtLgc.GetChannelType(), tMtLgc.GetVideoFormat(), 
					tMtLgc.GetFlowControl(), wMinBR);
			}
			//当前已无对应分辨率的终端，码率调成会议第一速率，待终端上线后依次往下刷
			if (0xffff == wMinBR)
			{	
				bChanged = TRUE;
				atParam[tBasOutInfo.m_byOutIdx].SetBitRate(m_tConf.GetBitRate());
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshSpyBasParam]  Mt%d<Media:%d, Res:%d, BR:%d> adjust AdaptParam's BR to %d!\n", 
					m_tCascadeMMCU.GetMtId(), tDstCap.GetVideoMediaType(), tDstCap.GetVideoResolution(), 
						tDstCap.GetVideoMaxBitRate(), m_tConf.GetBitRate());
				
			}
		}
	}

	u8 byDstFRM = 0;

	(tDstCap.GetVideoMediaType() == MEDIA_TYPE_H264) \
		? (byDstFRM = tDstCap.GetUserDefFrameRate()) \
		: (byDstFRM = tDstCap.GetVideoFrameRate());
												   
	if (byDstFRM < byAdpFR)
    {		
		//呼叫终端下调帧率
		atParam[tBasOutInfo.m_byOutIdx].SetFrameRate(byDstFRM);
		bChanged = TRUE;
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshSpyBasParam] DstMt<Media:%d, Res:%d, FR:%d> adjust AdaptParam's FR to %d!\n", 
				tDstCap.GetVideoMediaType(), tDstCap.GetVideoResolution(), 
				byDstFRM, byDstFRM);
    }
	else if(byDstFRM == byAdpFR)
	{
		//挂断终端上调帧率
		if(bUpAdjust)
		{
			for (u8 byIdx = 1; byIdx <= MAXNUM_CONF_MT; byIdx++)
			{
				tDstStatus.SetNull();
				if (!m_tConfAllMtInfo.MtJoinedConf(byIdx))
				{
					continue;
				}
				//过滤被删终端和当前选看源
				if (byIdx == tSrc.GetMtId())
				{
					continue;
				}
				if (!m_ptMtTable->GetMtStatus(byIdx, &tDstStatus) ||
					!(tSrc == tDstStatus.GetSelectMt(byMediaMode)) ||
					!IsNeedSelAdpt(tSrc, m_ptMtTable->GetMt(byIdx), byMediaMode))
				{
					continue;
				}
				if (!m_ptMtTable->GetMtLogicChnnl(byIdx, byLgcMode, &tMtLgc, TRUE))
				{
					continue;
				}
	
				if(!FindBasChn2SelForMt(tSrc, m_ptMtTable->GetMt(byIdx), byMediaMode, tAcceptOutInfo))
				{
					ConfPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[RefreshSpyBasParam] FindAcceptBasChnForMt%d failed!\n", byIdx);
					continue;
				}
				if (tAcceptOutInfo.m_tBasEqp.GetEqpId() != tBasOutInfo.m_tBasEqp.GetEqpId() || 
					tAcceptOutInfo.m_byChnId != tBasOutInfo.m_byChnId|| 
					tAcceptOutInfo.m_byOutIdx != tBasOutInfo.m_byOutIdx)
				{
					continue;
				}

				const u8 byChanFps = tMtLgc.GetChanVidFPS();
				byMinFR = min(byMinFR, byChanFps);

				atParam[tBasOutInfo.m_byOutIdx].SetFrameRate(byMinFR);
				bChanged = TRUE;
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[RefreshSpyBasParam] DstMt<Media:%d, Res:%d, FR:%d> adjust AdaptParam's FR to %d!\n", 
					    tMtLgc.GetChannelType(), tMtLgc.GetVideoFormat(), tMtLgc.GetChanVidFPS(),byMinFR);
			}
			//当前已无对应分辨率的终端，帧率调成会议第一速率，待终端上线后依次往下刷
			if (0xff == byMinFR)
			{	
				bChanged = TRUE;
				if (MEDIA_TYPE_H264 == m_tConf.GetMainVideoMediaType())
				{
					atParam[tBasOutInfo.m_byOutIdx].SetFrameRate(m_tConf.GetMainVidUsrDefFPS());
				}
				else
				{
					atParam[tBasOutInfo.m_byOutIdx].SetFrameRate(m_tConf.GetSecVidFrameRate());
				}
			}
		}
	}
	//有调整刷新mcu保存参数
	if (bChanged)
	{
		TBasOutInfo tOutInfo;
		tOutInfo.m_tBasEqp = tBasOutInfo.m_tBasEqp;
		tOutInfo.m_byChnId = tBasOutInfo.m_byChnId;
		tOutInfo.m_byOutNum = tBasOutInfo.m_byOutNum;
		tOutInfo.m_byOutIdx = tBasOutInfo.m_byOutIdx;
		RefreshBasParambyOutIdx(tOutInfo,atParam[tOutInfo.m_byOutIdx]);
		//如果适配器已经启动则发消息刷新参数
		if (BASCHN_STATE_RUNNING == g_cMcuVcApp.GetBasChnStatus(tBasOutInfo.m_tBasEqp, tBasOutInfo.m_byChnId) ||
			BASCHN_STATE_WAITSTART == g_cMcuVcApp.GetBasChnStatus(tBasOutInfo.m_tBasEqp,  tBasOutInfo.m_byChnId))
		{
			ChangeAdapt(tBasOutInfo.m_tBasEqp, tBasOutInfo.m_byChnId);
		}	    
	}

	return TRUE;
}

/*====================================================================
函数名           GetBrdSrc
功能        ：根据媒体模式获取广播源
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
TMt CMcuSingleConfAllInfo::GetBrdSrc(u8 byMediaMode)
{
	TMt tBrdSrc;
	tBrdSrc.SetNull();
	switch(byMediaMode)
	{
	case MODE_VIDEO:
		{
			tBrdSrc = GetVidBrdSrc();
		}
		break;
	case MODE_SECVIDEO:
		{
			tBrdSrc = m_tDoubleStreamSrc;
		}
		break;
	case MODE_AUDIO:
		{
			tBrdSrc = GetAudBrdSrc();
		}
		break;
	case MODE_VIDEO2SECOND:
		{
			tBrdSrc = GetSecVidBrdSrc();
		}
		break;
	default:
		break;
	}
	return tBrdSrc;
}

/*====================================================================
函数名          GetAdaptMode
功能        ：根据媒体模式获取广播源
算法实现    ：
引用全局变量：
输入参数说明：u8 byMediaMode 媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
u8 CMcuVcInst::GetAdaptMode(u8 byMediaMode)
{
	u8 byAdaptMode = ADAPT_MODE_NONE;
	switch(byMediaMode)
	{
	case MODE_VIDEO:    byAdaptMode = ADAPT_MODE_VID;    break;
	case MODE_AUDIO:    byAdaptMode = ADAPT_MODE_AUD;    break;
	case MODE_SECVIDEO: byAdaptMode = ADAPT_MODE_SECVID; break;
	default:
		break;
	}
	return byAdaptMode;
}
/*====================================================================
函数名			FindBasChn2BrdForMtExt
功能        ：寻找对应终端所能接受适配的通道
算法实现    ：
引用全局变量：
输入参数说明：u8 byMtId		  终端Id
			  u8 byMediaMode  媒体模式
			  TBasOutInfo    返回所在通道和输出
返回值说明  ：找到对应通道
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/11/23    4.7        倪志俊        创建
====================================================================*/
BOOL32 CMcuVcInst::FindBasChn2BrdForMtExt(const TMt &tSrc, u8 byMtId, u8 byMediaMode,TBasOutInfo &tOutInfo)
{
	if (!m_tConfAllMtInfo.MtJoinedConf(byMtId))
	{
		//ConfPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[FindBasChn2BrdForMtExt]byMtId:%d isn't conf member\n",byMtId);
		return FALSE;
	}

	//不交换给自己,但要交换给下级mcu
	if ( tSrc == m_ptMtTable->GetMt(byMtId) &&
		MT_TYPE_SMCU != m_ptMtTable->GetMtType(byMtId) )
	{
		//ConfPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[FindBasChn2BrdForMtExt]byMtId:%d isn't conf member\n",byMtId);
		return FALSE;
	}
	
	//不交换给上级mcu
	if (m_tCascadeMMCU.GetMtId() == byMtId && byMediaMode != MODE_SECVIDEO)
	{
		//ConfPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[FindBasChn2BrdForMtExt]byMtId:%d equal to m_tCascadeMMCU:%d\n",byMtId,m_tCascadeMMCU.GetMtId());
		return FALSE;
	}
	
	if (m_tConf.GetChairman().GetMtId() == byMtId)
	{
		TMtStatus tMtStatus;
		TMt tSelSrc;
		m_ptMtTable->GetMtStatus(byMtId, &tMtStatus);
		tSelSrc = tMtStatus.GetSelectMt( byMediaMode );
		// 新策略,主席有选看源时,不看广播源
		if (!tSelSrc.IsNull())
		{
			return FALSE;
		}				
	}
	
	tOutInfo.clear();
	TMt tDst = m_ptMtTable->GetMt(byMtId);
	//因为现在存在比较特殊的场景：
	//会议码率8M，双流打折50%，8M终端发言，4M终端接收过只过码率适配，随后会议发双流，发言终端码率调整成4M，
	//如果此时调用刷新BAS参数的接口，会把码率调整0，因为发言和接收不存在适配了，但交换还是从适配出
	//故目前针对主流：双速会议、存在双流源,那么把源的码率暂时调整成呼叫码率来比是否需要适配
	//比较完成后，恢复成当前码率
	BOOL32 bIsNeedAdapt = IsNeedAdapt(tSrc, tDst, byMediaMode);
	if (bIsNeedAdapt)
	{
		if( FindBasChn2BrdForMt(byMtId, byMediaMode, tOutInfo))
		{
			return TRUE;
		}
	}
	
	return FALSE;
}


/*====================================================================
函数名			FindAcceptBasChnForMt
功能        ：寻找对应终端所能接受适配的通道
算法实现    ：
引用全局变量：
输入参数说明：u8 byMtId		  终端Id
			  u8 byMediaMode  媒体模式
返回值说明  ：TEqp &tBas      终端源（bas）
			  u8 &byChnId     bas入通道号
			  u8 &byOutNum    bas输出通道数
			  u8 &byOutIdx    bas输出索引
			  BOOL32 bExactMatch 是否完全匹配分辨率
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::FindBasChn2BrdForMt(u8 byMtId, u8 byMediaMode,TBasOutInfo &tOutInfo)
{
	TMtStatus tTempMtStatus;
	if ( m_ptMtTable->GetMtStatus(byMtId,&tTempMtStatus) &&
		 !tTempMtStatus.GetSelectMt(byMediaMode).IsNull()
		)
	{
		ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[FindBasChn2BrdForMt]byMtId:%d still has selectsrc:%d-%d,so don't need brd adpt\n",
				  byMtId,tTempMtStatus.GetSelectMt(byMediaMode).GetMcuId(),tTempMtStatus.GetSelectMt(byMediaMode).GetMtId()
				 );
		return FALSE;
	}

	if (byMtId > MAXNUM_CONF_MT)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[FindBasChn2BrdForMt] byMtId:%d is unexpected!\n", byMtId);
		return FALSE;
	}

	switch (byMediaMode)
	{
	case MODE_AUDIO:
		{
			TAudioTypeDesc tMtAudCap;
			TLogicalChannel tDstAudLgc;
			if (!m_ptMtTable->GetMtLogicChnnl(byMtId, MODE_AUDIO, &tDstAudLgc, TRUE))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[FindBasChn2BrdForMt] GetMtLogicChnnl Dst Aud Mt%d failed!\n", byMtId);
				return FALSE;
			}		
			tMtAudCap.SetAudioMediaType( tDstAudLgc.GetChannelType() );
			tMtAudCap.SetAudioTrackNum( tDstAudLgc.GetAudioTrackNum() );
			
			if ( tMtAudCap.GetAudioMediaType() == MEDIA_TYPE_NULL )
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[FindBasChn2BrdForMt]tMtAudCap MtId:%d failed!\n", byMtId);
				return FALSE;
			}
			
			if ( !FindBasChnForAudBrd(tMtAudCap,tOutInfo) )
			{
				LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[FindBasChnForAudBrd]for byMtId:%d failed!\n",byMtId);
				return FALSE;
			}
		}
		break;
	case MODE_VIDEO:
	case MODE_SECVIDEO:
	case MODE_VIDEO2SECOND:
		{
			TSimCapSet tMtSimCapSet;
			if ( byMediaMode == MODE_VIDEO )
			{
				tMtSimCapSet = m_ptMtTable->GetDstSCS(byMtId);
			}
			else if ( byMediaMode==MODE_SECVIDEO || byMediaMode == MODE_VIDEO2SECOND)
			{
				tMtSimCapSet = m_ptMtTable->GetDstDSSCS(byMtId);
			}
			else
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[FindBasChn2BrdForMt]byMediaMode:%d is illegal!\n", byMediaMode);
				return FALSE;
			}
			
			if ( tMtSimCapSet.IsNull() )
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[FindBasChn2BrdForMt]GetDstDSSCS MtId:%d failed!\n", byMtId);
				return FALSE;
			}
			
			//非科达终端，考虑是否要伪装能力集，让非科达终端能够在主格式不预留的情况下收勾选中的HP能力
			//伪装目前只针对HP会议
			if ( m_tConf.GetProfileAttrb() == emHpAttrb )
			{
				u8 byManuId = m_ptMtTable->GetManuId( byMtId );
				if( byManuId != MT_MANU_KDC && byManuId != MT_MANU_KDCMCU) 
				{
					TSimCapSet tTempSimCapSet = tMtSimCapSet;
					tTempSimCapSet.SetVideoMaxBitRate( m_tConf.GetBitRate() );
					
					//主格式没有预留的情况下，非科达的能力集如果和主格式能力一样，则需要伪装能力集
					if ( byMediaMode == MODE_VIDEO  && 
						tTempSimCapSet.GetVideoCap() == m_tConf.GetMainSimCapSet().GetVideoCap() &&
						!IsConfNeedReserveMainCap(m_tConf,m_tConfEx)
						)
					{
						TVideoStreamCap tVideoCap[MAX_CONF_CAP_EX_NUM];
						u8 byCapNUm = MAX_CONF_CAP_EX_NUM;
						if ( m_tConfEx.GetMainStreamCapEx(tVideoCap,byCapNUm) )
						{
							for ( u8 byIdx = 0; byIdx<byCapNUm; byIdx++)
							{
								if ( tVideoCap[byIdx].GetH264ProfileAttrb() == emHpAttrb )
								{
									tMtSimCapSet.SetVideoCap(tVideoCap[byIdx]);
									break;
								}
							}
						}
					}
					else if ( byMediaMode == MODE_SECVIDEO &&
						tTempSimCapSet.GetVideoCap() ==  m_tConf.GetCapSupport().GetDStreamCapSet().GetVideoStremCap()&&
						!IsConfNeedReserveDSMainCap(m_tConf,m_tConfEx)
						)
					{
						TVideoStreamCap tSecVideoCap[MAX_CONF_CAP_EX_NUM];
						u8 byDSCapNum = MAX_CONF_CAP_EX_NUM;
						if ( m_tConfEx.GetDoubleStreamCapEx(tSecVideoCap,byDSCapNum) )
						{
							for ( u8 byIdx = 0; byIdx<byDSCapNum; byIdx++)
							{
								if ( tSecVideoCap[byIdx].GetH264ProfileAttrb() == emHpAttrb )
								{
									tMtSimCapSet.SetVideoCap( tSecVideoCap[byIdx] );
									break;
								}
							}
						}
					}
				}
			}
			
			TVideoStreamCap tTempVidCap = tMtSimCapSet.GetVideoCap();
			if ( !FindBasChnByCapForVidBrd(tTempVidCap,byMediaMode,tOutInfo) )
			{
				LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[FindBasChn2BrdForMt]for byMtId:%d failed!\n",byMtId);
				return FALSE;
			}
		}
		break;
	default:
		{
			LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[FindBasChn2BrdForMt]byMediaMode:%d is error!\n",byMediaMode);
			return FALSE;
		}
	}
	return !tOutInfo.m_tBasEqp.IsNull();
}

/*====================================================================
函数名      FindBasChn2SelForMt
功能        ：寻找对应终端所能接受适配的通道
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::FindBasChn2SelForMt(TMt tSrc,  TMt tDst,  u8 byMediaMode,TBasOutInfo &tOutInfo)
{
	TMt tOrigSrc = tSrc;
	//TMt tOrigDst = tDst;

	tSrc = GetLocalMtFromOtherMcuMt(tSrc);
 	tDst = GetLocalMtFromOtherMcuMt(tDst);

	if (tSrc.IsNull() || tDst.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[FindBasChn2SelForMt] tSrc or tDst is null!\n");
		return FALSE;
	}
	if (MODE_NONE == byMediaMode || MODE_BOTH == byMediaMode)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[FindBasChn2SelForMt] byMediaMode<%d> is error!\n", byMediaMode);
		return FALSE;
	}
		
	switch (byMediaMode)
	{
	case MODE_AUDIO:
		{
			TAudioTypeDesc  tAudCap;
			TLogicalChannel tDstAudLgc;
			if (!m_ptMtTable->GetMtLogicChnnl(tDst.GetMtId(), MODE_AUDIO, &tDstAudLgc, TRUE))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[FindBasChn2SelForMt] GetMtLogicChnnl Dst Aud Mt%d failed!\n", tDst.GetMtId());
				return FALSE;
			}
			
			tAudCap.SetAudioMediaType( tDstAudLgc.GetChannelType() );
			tAudCap.SetAudioTrackNum( tDstAudLgc.GetAudioTrackNum() );
			
			if ( !FindBasChnByAudCapForSel(tOrigSrc, tAudCap,tOutInfo) )
			{
				LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[FindBasChn2SelForMt]for tDst:%d-%d failed!\n",tDst.GetMcuId(), tDst.GetMtId());
				return FALSE;
			}
		}
		break;
	case MODE_VIDEO:
	case MODE_SECVIDEO:
	case MODE_VIDEO2SECOND:
		{
			TSimCapSet tDstSimCapSet;
			if ( byMediaMode == MODE_VIDEO )
			{
				tDstSimCapSet = m_ptMtTable->GetDstSCS(tDst.GetMtId());
				// 		TSimCapSet tSrcCap = m_ptMtTable->GetSrcSCS(tSrc.GetMtId());
				// 		//当终端过适配建交换到上级mcu的上传端口时，如果上传端口为264格式就直接适配到cif,
				// 		//因为如果上级开启画面合成且如果上传端口的格式是264高清格式，适配的码流直接建到上级画面合成会导致画面合成撑死,
				// 		//所以策略改为都适配到264cif
				// 		if( !m_tCascadeMMCU.IsNull() && tDst == m_tCascadeMMCU &&		
				// 			tDstSimCapSet.GetVideoMediaType() == MEDIA_TYPE_H264 &&
				// 			tSrcCap.GetVideoMediaType() != MEDIA_TYPE_H264 &&
				// 			tDstSimCapSet.GetVideoResolution() != VIDEO_FORMAT_CIF )
				// 		{
				// 			tDstSimCapSet.SetVideoResolution( VIDEO_FORMAT_CIF );
				// 		}
				
			}
			else if ( byMediaMode==MODE_SECVIDEO )
			{
				tDstSimCapSet = m_ptMtTable->GetDstDSSCS(tDst.GetMtId());
			}
			else if (byMediaMode == MODE_VIDEO2SECOND)
			{
				tDstSimCapSet = m_ptMtTable->GetDstDSSCS(tDst.GetMtId());
				byMediaMode = MODE_VIDEO;
			}
			
			TVideoStreamCap tTempVidCap = tDstSimCapSet.GetVideoCap();
			if ( !FindBasChnByVidCapForSel(tOrigSrc, tTempVidCap, byMediaMode,tOutInfo) )
			{
				LogPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[FindBasChn2SelForMt]for tDst:%d-%d failed!\n",tDst.GetMcuId(), tDst.GetMtId());
				return FALSE;
			}
		}
		break;
	default:
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[FindBasChn2SelForMt]byMediaMode:%d is illegal!\n", byMediaMode);
			return FALSE;
		}
	}
	return TRUE;
}

/*====================================================================
函数名      GetBasChnForAudSel
功能        ：获得BAS可用通道
算法实现    ：
引用全局变量：
输入参数说明：const TMt &tSrc 选看源
TAudioTypeDesc &tAudCap 选看目的能力
CBasChn **pcBasChn  返回通道指针的地址
TBasChnIdxParam &tChnIdxParam 参数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/14  4.7         倪志俊        创建
====================================================================*/
BOOL32	CMcuVcInst::GetBasChnForAudSel(const TMt &tSrc, TAudioTypeDesc &tDstAudCap,CBasChn **pcBasChn, TBasChnCapData &tChnCapData)
{	
	TMt tLocalSrcMt = GetLocalMtFromOtherMcuMt( tSrc );
	TLogicalChannel tSrcAudLgc;
	if (!m_ptMtTable->GetMtLogicChnnl(tLocalSrcMt.GetMtId(), MODE_AUDIO, &tSrcAudLgc, FALSE))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[IsNeedAdapt] GetMtLogicChnnl Src AUD Mt%d failed!\n", tLocalSrcMt.GetMtId());
		return FALSE;
	}
	TAudioTypeDesc tSrcAudCap;
	tSrcAudCap.SetAudioMediaType( tSrcAudLgc.GetChannelType() );
	tSrcAudCap.SetAudioTrackNum( tSrcAudLgc.GetAudioTrackNum() );
	
	
	TNeedAudAdaptData	tBasNeeds;
	tBasNeeds.m_atAudTypeDesc[0] = tDstAudCap;
	tBasNeeds.m_atAudTypeDesc[1]=  tSrcAudCap;
	tBasNeeds.m_byNeedAudEncNum = 1;
	
	//1.先查找是否有可用的同源通道支持
	CBasChn *apcBasChn[MAXNUM_PERIEQP]={NULL};
	u8		byChnNum = 0;
	if ( GetBasSelChnGrp(byChnNum,apcBasChn,MODE_AUDIO) )
	{
		for ( u8 byIdx = 0; byIdx<byChnNum; byIdx++ )
		{
			if ( NULL == apcBasChn[byIdx] )
			{
				continue;
			}
			
			if ( apcBasChn[byIdx]->GetSrc() == tSrc &&
				apcBasChn[byIdx]->GetMediaMode() == MODE_AUDIO
				)
			{
				
				if ( apcBasChn[byIdx]->IsBasChnSupportAudNeeds(tBasNeeds) )
				{				
					tChnCapData.atBasChnCap[0].SetAudCapSet( tDstAudCap);
					*pcBasChn = apcBasChn[byIdx];
					return TRUE;
				}
			}
		}
	}
	
	
	//2.再查找是否有空闲通道
	BOOL32 bOcuppyOK = FALSE; 
	if( g_cMcuVcApp.GetIdleAudBasChn( tSrcAudCap, tDstAudCap, pcBasChn) )
	{
		tChnCapData.atBasChnCap[0].SetAudCapSet( tDstAudCap);
		return TRUE;
	}
	
	return FALSE;
}

/*====================================================================
函数名      GetBasChnForSel
功能        ：获得BAS可用通道
算法实现    ：
引用全局变量：
输入参数说明：const TMt &tSrc 选看源
			  TSimCapSet &tDstCap 选看目的能力
			  u8 byMediaMode	  媒体类型
			  CBasChn **pcBasChn  返回通道指针的地址
			  TBasChnIdxParam &tChnIdxParam 参数
			  BOOL32 bRecursive		是否递归寻找BAS通道
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/27  4.7         倪志俊        创建
====================================================================*/
BOOL32	CMcuVcInst::GetBasChnForSel(const TMt &tSrc, TSimCapSet &tDstCap,u8 byMediaMode, CBasChn **pcBasChn, TBasChnCapData &tChnCapData, BOOL32 bRecursive /*= TRUE*/)
{	
	if (MODE_VIDEO2SECOND == byMediaMode)
	{
		byMediaMode = MODE_VIDEO;
	}

	TMt tLocalSrc = GetLocalMtFromOtherMcuMt(tSrc);

	TSimCapSet tSrcCap = m_ptMtTable->GetSrcSCS(tLocalSrc.GetMtId());
	//1.先查找是否有可用的同源通道支持
	CBasChn *apcBasChn[MAXNUM_PERIEQP]={NULL};
	u8		byChnNum = 0;
	TVideoStreamCap	atOccpiedSimCapSet[MAX_CONF_BAS_ADAPT_NUM];
	if ( GetBasSelChnGrp(byChnNum,apcBasChn,byMediaMode) )
	{
		for ( u8 byIdx = 0; byIdx<byChnNum; byIdx++ )
		{
			if ( NULL == apcBasChn[byIdx] )
			{
				continue;
			}

			if ( apcBasChn[byIdx]->GetSrc() == tSrc &&
				 apcBasChn[byIdx]->GetMediaMode() == byMediaMode
				)
			{
				TNeedVidAdaptData	tBasNeeds;
				if ( GetBasNeedResDataByCap(tSrcCap, tDstCap,byMediaMode, tBasNeeds) )
				{
					TNeedVidAdaptData tTempBasNeeds;
					memcpy(&tTempBasNeeds,&tBasNeeds,sizeof(TNeedVidAdaptData));
					if ( apcBasChn[byIdx]->IsBasChnSupportNeeds(tTempBasNeeds,atOccpiedSimCapSet) )
					{
						if ( tTempBasNeeds.m_byRealEncNum != 0 )
						{
							continue;
						}

						tChnCapData.atBasChnCap[0].SetVidepCapSet( tBasNeeds.m_atSimCapSet[0] );
						*pcBasChn = apcBasChn[byIdx];
						return TRUE;
					}
				}
			}
		}
	}
	
	
	//2.再查找是否有空闲通道
	if (MODE_VIDEO == byMediaMode &&
		(MEDIA_TYPE_NULL == tSrcCap.GetVideoMediaType() || 
		MEDIA_TYPE_NULL == tDstCap.GetVideoMediaType())
	   )
	{
		return FALSE;
	}

	BOOL32 bOcuppyOK = FALSE; 
	//根据源和目的实际能力获取最合适的空闲适配通道
	if( g_cMcuVcApp.GetIdleBasChn( tSrcCap, tDstCap, byMediaMode, pcBasChn,&tChnCapData ) )
	{
		return TRUE;
	}

	//尝试源和目的分辨率取小
	if(!bOcuppyOK && bRecursive)
	{
		u8 bySrcRes = tSrcCap.GetVideoResolution();
		if ( byMediaMode == MODE_VIDEO && 
			tSrcCap.GetVideoMediaType() == MEDIA_TYPE_MP4 &&
			tSrcCap.GetVideoResolution() == VIDEO_FORMAT_AUTO
			)
		{
			//如果源码率为0，则填呼叫码率
			if ( tSrcCap.GetVideoMaxBitRate() == 0 )
			{
				tSrcCap.SetVideoMaxBitRate( m_ptMtTable->GetDialBitrate( tLocalSrc.GetMtId() ) );
			}
			bySrcRes = GetAutoResByBitrate( tSrcCap.GetVideoResolution(), tSrcCap.GetVideoMaxBitRate() );	

			if ( VIDEO_FORMAT_2CIF == bySrcRes  )
			{
				bySrcRes = VIDEO_FORMAT_CIF;
			}
		}

		u8 byDstRes = tDstCap.GetVideoResolution();
		if ( byMediaMode == MODE_VIDEO && 
			tDstCap.GetVideoMediaType() == MEDIA_TYPE_MP4 &&
			 tDstCap.GetVideoResolution() == VIDEO_FORMAT_AUTO
			)
		{
			byDstRes = GetAutoResByBitrate( tDstCap.GetVideoResolution(), tDstCap.GetVideoMaxBitRate() );	
		}
		
		//分辨率取小，只递归一次
		tDstCap.SetVideoResolution(min(bySrcRes, byDstRes));
		return GetBasChnForSel(tSrc,tDstCap,byMediaMode,pcBasChn,tChnCapData,FALSE);
	}
	return FALSE;
}

/*====================================================================
函数名      GetBasChnForMultiSpy
功能        ：获得BAS可用通道
算法实现    ：
引用全局变量：
输入参数说明：const TMt &tSrc     回传源，非local
			  TSimCapSet &tDstCap 选看目的能力
			  u8 byMediaMode	  媒体类型
			  CBasChn **pcBasChn  返回通道指针的地址
			  TBasChnIdxParam &tChnIdxParam 参数
			  BOOL32 bRecursive		是否递归寻找BAS通道
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/03/01  4.7         倪志俊        创建
====================================================================*/
BOOL32	CMcuVcInst::GetBasChnForMultiSpy(const TMt &tSpySrc,TSimCapSet &tDstCap,u8 byMediaMode,CBasChn **pcBasChn, TBasChnCapData &tChnCapData)
{
	TMt tLocalSrc = GetLocalMtFromOtherMcuMt(tSpySrc);
	
	TSimCapSet tSrcCap = m_ptMtTable->GetSrcSCS(tLocalSrc.GetMtId());
	//1.先查找是否有可用的同源通道支持
	CBasChn *apcBasChn[MAXNUM_PERIEQP]={NULL};
	u8		byChnNum = 0;
	TVideoStreamCap	atOccpiedSimCapSet[MAX_CONF_BAS_ADAPT_NUM];
	if ( GetBasSelChnGrp(byChnNum,apcBasChn,byMediaMode) )
	{
		for ( u8 byIdx = 0; byIdx<byChnNum; byIdx++ )
		{
			if ( NULL == apcBasChn[byIdx] )
			{
				continue;
			}
			
			if ( apcBasChn[byIdx]->GetSrc() == tSpySrc &&
				apcBasChn[byIdx]->GetMediaMode() == byMediaMode
				)
			{
				TNeedVidAdaptData	tBasNeeds;
				if ( GetBasNeedResDataByCap(tSrcCap, tDstCap,byMediaMode, tBasNeeds) )
				{
					TNeedVidAdaptData tTempBasNeeds;
					memcpy(&tTempBasNeeds,&tBasNeeds,sizeof(TNeedVidAdaptData));
					if ( apcBasChn[byIdx]->IsBasChnSupportNeeds(tTempBasNeeds,atOccpiedSimCapSet) )
					{
						if ( tTempBasNeeds.m_byRealEncNum != 0 )
						{
							continue;
						}
						
						tChnCapData.atBasChnCap[0].SetVidepCapSet( tBasNeeds.m_atSimCapSet[0] );
						*pcBasChn = apcBasChn[byIdx];
						return TRUE;
					}
				}
			}
		}
	}
	
	//找不到，找可用空闲通道		
	if ( g_cMcuVcApp.GetIdleBasChnPossible(tSrcCap, tDstCap, byMediaMode, pcBasChn,&tChnCapData) )
	{
		return TRUE;
	}
	return FALSE;
}

/*====================================================================
函数名      FindBasChn2SpyForMt
功能        ：寻找对应终端所能接受适配的通道
算法实现    ：
引用全局变量：
输入参数说明：TMt tSrc 源信息
			  const TSimCapSet &tDstCap 目的能力
			  u8 byMediaMode		    媒体模式

返回值说明  ：TEqp &tBas                可使用的适配器
			  u8   &byChnId             该适配器的通道号
			  u8   &byOutNum			通道输出数
			  u8   &byOutIdx            通道输出索引   
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
2012/2/29   4.7			倪志俊		  修改
====================================================================*/
BOOL32 CMcuVcInst::FindBasChn2SpyForMt(TMt tSrc,  const TSimCapSet &tDstCap,  u8 byMediaMode, TBasOutInfo &tOutInfo)
{
	if( tSrc.IsNull() || (tDstCap.IsNull() && byMediaMode == MODE_VIDEO) )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[FindBasChn2SpyForMt:Cap] tSrc or tDstCap is null!\n");
		return FALSE;
	}

	TMt tOrigSrc = tSrc;	
	u8 byNum    = 0;
	CBasChn   *apcBasChn[MAXNUM_PERIEQP]={NULL};
	if(!GetBasSelChnGrp(byNum, apcBasChn, byMediaMode))
	{
		return FALSE;
	}


	if( MODE_AUDIO == byMediaMode )
	{
			//获得目的能力
			TAudioTypeDesc tDstAudCap;
			TLogicalChannel tDstAudLgc;
			if (!m_ptMtTable->GetMtLogicChnnl(m_tCascadeMMCU.GetMtId(), MODE_AUDIO, &tDstAudLgc, TRUE))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[IsNeedSpyAdpt] GetMtLogicChnnl Dst Aud Mt%d failed!\n", m_tCascadeMMCU.GetMtId());
				return FALSE;
			}
			tDstAudCap.SetAudioMediaType( tDstAudLgc.GetChannelType() );
			tDstAudCap.SetAudioTrackNum( tDstAudLgc.GetAudioTrackNum() );
			return FindBasChnByAudCapForSel(tOrigSrc,tDstAudCap,tOutInfo);
	}

	TMt tTempSrcMt;
	if( MODE_VIDEO == byMediaMode || MODE_SECVIDEO == byMediaMode )
	{
		THDAdaptParam atParam[MAXNUM_BASOUTCHN];
		for (u8 byIdx = 0; byIdx < byNum; byIdx++)
		{
			if ( NULL == apcBasChn[byIdx] )
			{
				continue;
			}
			//获取同源
			if (apcBasChn[byIdx]->GetSrc().IsNull() )
			{
				continue;
			}
			
			tTempSrcMt = apcBasChn[byIdx]->GetSrc();
			if (!tOrigSrc.IsLocal() && IsMcu(tTempSrcMt) )
			{
				TMt tRealMt = GetSMcuViewMt(tTempSrcMt, TRUE);
				if ( !tRealMt.IsNull() )
				{
					tTempSrcMt = tRealMt;
				}
			}
			
			
			if ( !(tTempSrcMt == tOrigSrc) )
			{
				continue;
			}

			//获取同模式
			if (apcBasChn[byIdx]->GetMediaMode() != byMediaMode)
			{
				continue;
			}

			u8 byCurrOutNum = 0;
			//获取适配参数
			if(!g_cMcuVcApp.GetBasOutPutParam(apcBasChn[byIdx]->GetBas(), 
											  apcBasChn[byIdx]->GetChnId(), byCurrOutNum, atParam))
			{
				continue;
			}

			//获取前面通道的输出通道数
			u8			  byFrontOutNum = 0;
			if ( !g_cMcuVcApp.GetBasChnFrontOutPutNum(apcBasChn[byIdx]->GetBas(), apcBasChn[byIdx]->GetChnId(),byCurrOutNum,byFrontOutNum) )
			{
				continue;
			}

			//临时返回用于级联调分辨率重下参数
			tOutInfo.m_tBasEqp  = apcBasChn[byIdx]->GetBas();
			tOutInfo.m_byChnId  = apcBasChn[byIdx]->GetChnId();

			for (u8 byOut = 0; byOut < byCurrOutNum; byOut++)
			{
				if (MODE_VIDEO == byMediaMode || MODE_SECVIDEO == byMediaMode)
				{
					if (tDstCap.GetVideoMediaType() == atParam[byOut].GetVidType())
					{
						//适配参数和目的接收格式均为mp4不匹配分辨率(mp4编码既具有唯一性，同时模糊处理mp4_auto匹配)
						if (MEDIA_TYPE_MP4 == tDstCap.GetVideoMediaType() && MEDIA_TYPE_MP4 == atParam[byOut].GetVidType())
						{
							tOutInfo.m_tBasEqp  = apcBasChn[byIdx]->GetBas();
							tOutInfo.m_byChnId  = apcBasChn[byIdx]->GetChnId();
							tOutInfo.m_byOutIdx = byOut;
							tOutInfo.m_byOutNum = byCurrOutNum;
							tOutInfo.m_byFrontOutNum = byFrontOutNum;
							return TRUE;
						}
						else /*if (IsResGE(tDstCap.GetVideoResolution(), GetResByWH(atParam[byOut].GetWidth(), atParam[byOut].GetHeight())))*/
						{
							u16 wDstWidth  = 0;
							u16 wDstHeight = 0;
							GetWHByRes(tDstCap.GetVideoResolution(), wDstWidth, wDstHeight);
							if (wDstWidth == 0 || wDstHeight == 0)
							{
								ConfPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[FindBasChn2SpyForMt] GetWHByRes %d failed!\n", tDstCap.GetVideoResolution());
								continue;
							}

							if (   tDstCap.GetVideoProfileType() >= atParam[byOut].GetProfileType()  &&
									tDstCap.GetUserDefFrameRate() >= atParam[byOut].GetFrameRate()
								)
							{							
								if ( (wDstWidth * wDstHeight) >= (atParam[byOut].GetWidth() * atParam[byOut].GetHeight()) )
								{
									tOutInfo.m_tBasEqp  = apcBasChn[byIdx]->GetBas();
									tOutInfo.m_byChnId  = apcBasChn[byIdx]->GetChnId();
									tOutInfo.m_byOutIdx = byOut;
									tOutInfo.m_byOutNum = byCurrOutNum;
									tOutInfo.m_byFrontOutNum = byFrontOutNum;
									return TRUE;
								}	
							}
			
						}
					}
				}
			}
		}

		//对于H264分辨率尝试降分辨率找对应可适配输出
		if (MODE_VIDEO == byMediaMode)
		{
			if (MEDIA_TYPE_H264 == tDstCap.GetVideoMediaType())
			{
				u8 byNextDownStandRes = GetDownStandRes(tDstCap.GetVideoResolution());
				if (VIDEO_FORMAT_INVALID != byNextDownStandRes)
				{
					TSimCapSet tTmpDstCap = tDstCap;
					tTmpDstCap.SetVideoResolution(byNextDownStandRes);
					if ( tTmpDstCap.GetVideoResolution() == VIDEO_FORMAT_4CIF ||
						tTmpDstCap.GetVideoResolution() == VIDEO_FORMAT_CIF
						)
					{
						tTmpDstCap.SetVideoProfileType(emBpAttrb);
					}
					return FindBasChn2SpyForMt(tOrigSrc, tTmpDstCap, byMediaMode, tOutInfo);
				}
				else
				{
					return FALSE;
				}
			}	
			else
			{
				return FALSE;
			}
		}
	}
			

	
	return FALSE;
}


/*====================================================================
函数名         FindBasOutIdxByVidCapSet
功能        ：寻找tBas的byChnId通道里，符合媒体类型为byMediaType，分辨率为byRes的输出
算法实现    ：
引用全局变量：
输入参数说明：tBas 要寻找的bas
			  byChnId 要寻找的bas的某一通道
			  TSimCapSet tSimCapSet 要求的能力集

返回值说明  ：byOutIdx 符合要求的那路输出
			  byOutNum 该通道的总输出路数
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/02/20    4.7       倪志俊        创建
====================================================================*/
BOOL32 CMcuVcInst::FindBasOutIdxByVidCapSet(TEqp &tBas, u8 byChnId, u8 byMediaMode,TVideoStreamCap &tSimCapSet,u8 &byOutIdx, u8 &byFrontOutNum)
{
	THDAdaptParam atParam[MAXNUM_BASOUTCHN];
	u8 byOutNum = 0;
	if(!g_cMcuVcApp.GetBasOutPutParam(tBas, byChnId, byOutNum, atParam))
	{
		return FALSE;
	}
	
	//获取前面通道的输出通道数
	if ( !g_cMcuVcApp.GetBasChnFrontOutPutNum(tBas, byChnId,byOutNum,byFrontOutNum) )
	{
		return FALSE;
	}

	for (u8 byOut = 0; byOut < byOutNum; byOut++)
	{
		if (MODE_VIDEO == byMediaMode || MODE_SECVIDEO == byMediaMode)
		{
			if (tSimCapSet.GetMediaType() != MEDIA_TYPE_NULL &&
				tSimCapSet.GetMediaType() == atParam[byOut].GetVidType()&& 
				tSimCapSet.GetResolution() == GetResByWH(atParam[byOut].GetWidth(), atParam[byOut].GetHeight())&& 
				tSimCapSet.GetH264ProfileAttrb() == atParam[byOut].GetProfileType()&&
				tSimCapSet.GetUserDefFrameRate() == atParam[byOut].GetFrameRate()
				)
			{
				byOutIdx = byOut;
				return TRUE;
			}
		}
	}
	
	return FALSE;
}

/*====================================================================
函数名         FindBasOutIdxByAudCap
功能        ：寻找tBas的byChnId通道里，符合分辨率为byRes的输出
算法实现    ：
引用全局变量：
输入参数说明：tBas 要寻找的bas
			  byChnId 要寻找的bas的某一通道
			  TAudioTypeDesc &tAudCap 音频能力集

返回值说明  ：byOutIdx 符合要求的那路输出
			  byOutNum 该通道的总输出路数
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/22    4.7       倪志俊        创建
====================================================================*/
BOOL32 CMcuVcInst::FindBasOutIdxByAudCap(TEqp &tBas, u8 byChnId,TAudioTypeDesc &tAudCap,u8 &byOutIdx, u8 &byFrontOutNum)
{
	TAudAdaptParam atParam[MAXNUM_BASOUTCHN];
	u8 byOutNum = 0;
	if(!g_cMcuVcApp.GetAudBasOutPutParam(tBas, byChnId, byOutNum, atParam))
	{
		return FALSE;
	}
	
	//获取前面通道的输出通道数
	if ( !g_cMcuVcApp.GetBasChnFrontOutPutNum(tBas, byChnId,byOutNum,byFrontOutNum) )
	{
		return FALSE;
	}

	for (u8 byOut = 0; byOut < byOutNum; byOut++)
	{
		if ( tAudCap.GetAudioMediaType() != MEDIA_TYPE_NULL &&
			tAudCap.GetAudioMediaType() == atParam[byOut].GetAudCodeType() &&
			tAudCap.GetAudioTrackNum() == atParam[byOut].GetTrackNum()
			)
		{
			byOutIdx = byOut;
			return TRUE;
		}
	}
	
	return FALSE;
}

/*====================================================================
函数名         RefreshBasParamForReplace
功能        ： 为寻找到的新BAS通道刷参
算法实现    ：
引用全局变量：
输入参数说明：CBasChn *pBasChn				寻找到的通道
			  TBasChnCapData &tBasChnCapData 对应通道的CAP参数

返回值说明  ：成功替换返回TRUE
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/30	4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuVcInst::RefreshBasParamForReplace(CBasChn* pBasChn,const TBasChnCapData &tChnEncCapData,u8 byMediaMode)
{
	if ( pBasChn == NULL )
	{
		return FALSE;
	}
	
	for ( u8 byIdx = 0; byIdx < MAX_CONF_BAS_ADAPT_NUM; byIdx++ )
	{
		if ( !tChnEncCapData.atBasChnCap[byIdx].IsNull())
		{
			if ( byMediaMode == MODE_AUDIO )
			{	
				TAudAdaptParam tAudParam;
				memset(&tAudParam, 0, sizeof(tAudParam));
				tAudParam.SetAudCodeType( tChnEncCapData.atBasChnCap[byIdx].GetMediaType() );
				tAudParam.SetAudActiveType( GetActivePayload(m_tConf, tChnEncCapData.atBasChnCap[byIdx].GetMediaType()) );
				tAudParam.SetTrackNum( tChnEncCapData.atBasChnCap[byIdx].GetTrackNum() );
				
				TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
				tAudParam.SetIsNeedByPrs(tConfAttrb.IsResendLosePack());	
				if (  !pBasChn->SetAudAdaptParam(tAudParam)  )
				{
					LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[RefreshBasParamForReplace]SetAdapatParam:MediaType:%d tracknum:%dfor chn-%d-%d error!\n",
						tAudParam.GetAudCodeType(),
						tAudParam.GetTrackNum(),
						pBasChn->GetBas().GetEqpId(),
						pBasChn->GetChnId()
						);
					return FALSE;
 				}
			}
			else
			{
				if ( tChnEncCapData.atBasChnCap[byIdx].GetMediaType() == 0 ||
					 tChnEncCapData.atBasChnCap[byIdx].GetMediaType() == MEDIA_TYPE_NULL
					)
				{
					continue;
				}
				THDAdaptParam tParam;
				u16 wWidth, wHeight;
				tParam.SetVidType( tChnEncCapData.atBasChnCap[byIdx].GetMediaType() );
				tParam.SetVidActiveType( GetActivePL(m_tConf, tChnEncCapData.atBasChnCap[byIdx].GetMediaType()) );
				TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
				tParam.SetIsNeedByPrs(tConfAttrb.IsResendLosePack());
				
				u8 byEncRes = tChnEncCapData.atBasChnCap[byIdx].GetVideoResolution();
				if ( tChnEncCapData.atBasChnCap[byIdx].GetMediaType() == MEDIA_TYPE_MP4 )
				{
					if( tChnEncCapData.atBasChnCap[byIdx].GetVideoResolution() == VIDEO_FORMAT_16CIF )
					{
						byEncRes = VIDEO_FORMAT_4CIF;
					}
					else if( tChnEncCapData.atBasChnCap[byIdx].GetVideoResolution() == VIDEO_FORMAT_AUTO )
					{
						byEncRes = GetAutoResByBitrate( tChnEncCapData.atBasChnCap[byIdx].GetVideoResolution(), m_tConf.GetBitRate());
					}
				}
				
				//4CIF 和 CIF帧率做保护
				u8 byFrameRate = tChnEncCapData.atBasChnCap[byIdx].GetFrameRate();
				if (  tChnEncCapData.atBasChnCap[byIdx].GetVideoResolution() == VIDEO_FORMAT_4CIF ||
					tChnEncCapData.atBasChnCap[byIdx].GetVideoResolution() == VIDEO_FORMAT_CIF
					)
				{
					if ( byFrameRate == 60 || byFrameRate == 50 )
					{
						byFrameRate = byFrameRate/2;
					}
				}
				
				GetWHByRes(byEncRes, wWidth,wHeight);
				tParam.SetResolution( wWidth, wHeight );
				tParam.SetBitRate( tChnEncCapData.atBasChnCap[byIdx].GetVideoMaxBitRate() );
				tParam.SetFrameRate( byFrameRate );
				tParam.SetProfileType( (u8)tChnEncCapData.atBasChnCap[byIdx].GetVideoProfileType() );
				if ( !pBasChn->SetAdaptParam(tParam) )
				{
					LogPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[RefreshAllChnsParam]SetAdapatParam:MediaType:%d-Res:%d-ProfieType:%d-Frame:%d-BitRate%d for chn-%d-%d error!\n",
						tParam.GetVidType(),
						byEncRes,
						tParam.GetProfileType(),
						tParam.GetFrameRate(),
						tParam.GetBitrate(),
						pBasChn->GetBas().GetEqpId(),
						pBasChn->GetChnId()
						);
					return FALSE;
				}
			}
		}
	}

	return TRUE;
}

/*====================================================================
函数名         FindBasChnForRecAptReplace
功能        ：为掉链的适配通道寻找合适的替代
算法实现    ：
引用全局变量：
输入参数说明：

返回值说明  ：成功替换返回TRUE
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/11/21	4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuVcInst::FindBasChnForRecAptReplace(u8 byMediaMode)
{	
	//临时记录以下BAS通道，比便备份成功时，释放
	TRecBasChn tTempRecBasChn;
	if ( byMediaMode != MODE_AUDIO &&
		m_cRecAdaptMgr.IsExistRecBasChn(byMediaMode,tTempRecBasChn) )
	{
		//预占新的BAS通道，如果预占成功释放先前BAS通道
		if ( InitRecAdptParamByMediaMode(byMediaMode) )
		{
			ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[FindBasChnForRecAptReplace]InitRecAdptParamByMediaMode :%d success\n",byMediaMode);
			
			//找到新的录像适配通道后，清除老通道的预占资源
			StopBasAdaptOnlyForRecAdp(tTempRecBasChn.m_tBas, tTempRecBasChn.m_byChnId);
			//释放资源
			g_cMcuVcApp.ReleaseBasChn(tTempRecBasChn.m_tBas, tTempRecBasChn.m_byChnId);
			//移除选看通道资源
			ReMoveBasSelChn(tTempRecBasChn.m_tBas, tTempRecBasChn.m_byChnId);
			//更新外设状态为ready
			g_cMcuVcApp.UpdateBasChnStatus(tTempRecBasChn.m_tBas, tTempRecBasChn.m_byChnId, BASCHN_STATE_READY);
		
			return TRUE;
		}
		else
		{
			ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[FindBasChnForRecAptReplace]can't find baschn to replace failed\n");
		}
		return FALSE;
	}
	return TRUE;
}

/*====================================================================
函数名         FindBasChnForReplace
功能        ：为掉链的适配通道寻找合适的替代
算法实现    ：
引用全局变量：
输入参数说明：TEqp tDiscBas				掉链BAS
			  CBasChn **ptRplChn		寻找到的通道
			  TBasChnCapData *ptBasChnCapData 对应通道的CAP参数

返回值说明  ：成功替换返回TRUE
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
2011/08/22  4.6         zhangli       修改
2011/12/30	4.7			倪志俊		  重写
====================================================================*/
BOOL32 CMcuVcInst::FindBasChnForReplace(TEqp *ptDiscBas, u8 byDiscNum, CBasChn **ptRplChn, TBasChnCapData *ptBasChnCapData)
{
	if (ptDiscBas == NULL)
	{
		ConfPrint(LOG_LVL_ERROR,MID_MCU_BAS,"[FindBasChnForReplace]ptDiscBas is NULL\n");
		return FALSE;
	}
	 
	TNeedVidAdaptData atReqResource[emMODE_END];	//主流视频、主流音频、双流
	GetBasResDataByEqp(ptDiscBas[0],atReqResource);
	if ( byDiscNum ==2 )
	{
		TNeedVidAdaptData atSecEqpResource[emMODE_END];	//第二块BAS的能力
		GetBasResDataByEqp(ptDiscBas[1],atSecEqpResource);
			

		for ( u8 byIdx = emMODE_VIDEO; byIdx < (emMODE_END); byIdx++ )
		{
			u8 byStart = atReqResource[byIdx].m_byRealEncNum;
			if ( 0 == byStart )
			{
				atReqResource[byIdx].m_byMediaMode = atSecEqpResource[byIdx].m_byMediaMode;
			}
			for ( u8 byLoop = 0; byLoop<atSecEqpResource[byIdx].m_byRealEncNum; byLoop++ )
			{
				if ( byStart < MAX_CONF_BAS_ADAPT_NUM )
				{
					atReqResource[byIdx].m_atSimCapSet[byStart] = atSecEqpResource[byIdx].m_atSimCapSet[byLoop]; 
					byStart++;
					atReqResource[byIdx].m_byRealEncNum = byStart;
				}
			}
		}
	
	}
	
	//加上解码能力,并将编码能力及排序
	//获得会议解码能力(获得主流视频与双流能力解码能力，音频解码能力最后获得)
	for ( u8 byIdx = emMODE_VIDEO; byIdx < (emMODE_END); byIdx++ )
	{
		//编码能力排序,降序
		TVideoStreamCap tTempSimCap;
		for ( u8 bySortIdx = 0; bySortIdx<atReqResource[byIdx].m_byRealEncNum-1; bySortIdx++ )
		{
			for(u8 byInnerIdx = 0; byInnerIdx <atReqResource[byIdx].m_byRealEncNum - bySortIdx -1; byInnerIdx ++)
			{
				atReqResource[byIdx].m_atSimCapSet[byInnerIdx].SetMaxBitRate(m_tConf.GetBitRate());
				atReqResource[byIdx].m_atSimCapSet[byInnerIdx+1].SetMaxBitRate(m_tConf.GetBitRate());
				u16 wSrcWidth =0;
				u16 wSrcHeight = 0;
				GetWHByRes(atReqResource[byIdx].m_atSimCapSet[byInnerIdx].GetResolution(), wSrcWidth, wSrcHeight  );
				u16 wDstWidth =0;
				u16 wDstHeight = 0;
				GetWHByRes(atReqResource[byIdx].m_atSimCapSet[byInnerIdx+1].GetResolution(), wDstWidth, wDstHeight  );
				//分辨率小的往后排，格式非H264的也往后排,分辨率一样情况下，如果帧率小的也往后排
				if (  wSrcWidth*wSrcHeight < wDstWidth*wDstHeight ||
				      atReqResource[byIdx].m_atSimCapSet[byInnerIdx].GetMediaType() != MEDIA_TYPE_H264 ||
					  ( wSrcWidth*wSrcHeight == wDstWidth*wDstHeight &&
						atReqResource[byIdx].m_atSimCapSet[byInnerIdx].GetUserDefFrameRate() < atReqResource[byIdx].m_atSimCapSet[byInnerIdx+1].GetUserDefFrameRate()	
					  )
					)
				{
					tTempSimCap = atReqResource[byIdx].m_atSimCapSet[byInnerIdx];
					atReqResource[byIdx].m_atSimCapSet[byInnerIdx] = atReqResource[byIdx].m_atSimCapSet[byInnerIdx+1];
					atReqResource[byIdx].m_atSimCapSet[byInnerIdx+1] = tTempSimCap;
				} 
			}
		}

		if ( byIdx == emMODE_VIDEO && m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H261 )
		{
			atReqResource[byIdx].m_byDecNeedRes = (u8)1 << CBasChn::emDecH261;
		}
		else if ( m_tConf.GetProfileAttrb() == emHpAttrb)
		{
			atReqResource[byIdx].m_byDecNeedRes = (u8)1 <<CBasChn::emDecHp;
		}
		else if ( m_tConf.GetProfileAttrb() == emBpAttrb )
		{
			BOOL32 bHighFps = IsConfFR50OR60(m_tConf);
			BOOL32 bMainMediaH264   =  m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H264;
			BOOL32 bSecMediaH264	=   m_tConf.GetSecVideoMediaType() != MEDIA_TYPE_NULL &&
				m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_H264;
			if(bHighFps)
			{
				atReqResource[byIdx].m_byDecNeedRes = (u8)1 <<CBasChn::emDecHighFps;
			}
			else if((IsResGE(m_tConf.GetMainVideoFormat(), VIDEO_FORMAT_4CIF) && bMainMediaH264) ||
				(IsResGE(m_tConf.GetSecVideoFormat(), VIDEO_FORMAT_4CIF) && bSecMediaH264))
			{
				atReqResource[byIdx].m_byDecNeedRes = (u8)1 <<CBasChn::emDecHD;
			}
			else
			{
				atReqResource[byIdx].m_byDecNeedRes = (u8)1 <<CBasChn::emDecSD;
			}
		}
		else
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasCapConfNeed]tConfInfo.GetProfileAttrb() failed!\n");
			return FALSE;
		}
	}
	
	//加上音频
	TNeedAudAdaptData tAudReqResource;
	tAudReqResource.m_byNeedAudEncNum = 0;
	GetBasResAudDataByEqp(ptDiscBas[0],&tAudReqResource);
	if ( byDiscNum ==2 )
	{
		TNeedAudAdaptData tSecEqpResource;	//第二块BAS的能力
		tSecEqpResource.m_byNeedAudEncNum = 0;
		GetBasResAudDataByEqp(ptDiscBas[1],&tSecEqpResource);
		
		u8 byStart = tAudReqResource.m_byNeedAudEncNum;
		u8 byEnd = MAXNUM_CONF_AUDIOTYPE - tAudReqResource.m_byNeedAudEncNum;
		if (  byStart>0 )
		{
			for ( u8 byLoop = 0; byLoop<tSecEqpResource.m_byNeedAudEncNum; byLoop++ )
			{
				if ( byStart < byEnd )
				{
					tAudReqResource.m_atAudTypeDesc[byStart] = tSecEqpResource.m_atAudTypeDesc[byLoop]; 
					byStart++;
					tAudReqResource.m_byNeedAudEncNum = byStart;
				}
			}
		}
		else
		{
			tAudReqResource = tSecEqpResource;
		}
	}

	if ( !g_cMcuVcApp.IsBasChnEnoughForReq(atReqResource,&tAudReqResource,ptRplChn, ptBasChnCapData) )
	{
		return FALSE;
	}

	//清空断链通道的相关信息
	for ( u8 byNum =0 ; byNum<byDiscNum; byNum++ )
	{
		u8  byDisChnNum = g_cMcuVcApp.GetBasInPutChnNum(ptDiscBas[byNum]);
		for ( u8 byDisIdx =0; byDisIdx<byDisChnNum; byDisIdx++ )
		{
			if ( ReMoveBasBrdChn(ptDiscBas[byNum], byDisIdx) )
			{
				g_cMcuVcApp.ReleaseBasChn(ptDiscBas[byNum], byDisIdx);
			}
		}
	}

	
	//占用新通道
	g_cMcuVcApp.OcuppyBasChn(ptRplChn, MAXNUM_PERIEQP);
	AssignBasBrdChn(ptRplChn, ptBasChnCapData, MAXNUM_PERIEQP,m_tConf.GetConfId());
	
	//设置通道广播源以及刷参
	BOOL32 bIsExitVidAdp = FALSE;
	BOOL32 bIsExitSecVidAdp = FALSE;
	BOOL32 bIsExitAudAdp = FALSE;
	for (u8 byLoop = 0; byLoop < MAXNUM_PERIEQP; byLoop++ )
	{
		if ( ptRplChn[byLoop] == NULL )
		{
			continue;
		}
		
		if ( ptRplChn[byLoop]->GetMediaMode() == MODE_VIDEO )
		{
			SetBasChnSrc(ptRplChn[byLoop]->GetBas(), ptRplChn[byLoop]->GetChnId(),GetVidBrdSrc());
			SetBasChnMode(ptRplChn[byLoop]->GetBas(), ptRplChn[byLoop]->GetChnId(),MODE_VIDEO);
			RefreshBasParamForReplace(ptRplChn[byLoop],ptBasChnCapData[byLoop],MODE_VIDEO);
			bIsExitVidAdp = TRUE;
		}
		else if ( ptRplChn[byLoop]->GetMediaMode() == MODE_SECVIDEO)
		{
			SetBasChnSrc(ptRplChn[byLoop]->GetBas(), ptRplChn[byLoop]->GetChnId(),m_tDoubleStreamSrc);
			SetBasChnMode(ptRplChn[byLoop]->GetBas(), ptRplChn[byLoop]->GetChnId(),MODE_SECVIDEO);
			RefreshBasParamForReplace(ptRplChn[byLoop],ptBasChnCapData[byLoop],MODE_SECVIDEO);
			bIsExitSecVidAdp = TRUE;
		}
		else if ( ptRplChn[byLoop]->GetMediaMode() == MODE_AUDIO )
		{
			SetBasChnSrc(ptRplChn[byLoop]->GetBas(), ptRplChn[byLoop]->GetChnId(),GetAudBrdSrc());
			SetBasChnMode(ptRplChn[byLoop]->GetBas(), ptRplChn[byLoop]->GetChnId(),MODE_AUDIO);
			RefreshBasParamForReplace(ptRplChn[byLoop],ptBasChnCapData[byLoop],MODE_AUDIO);
			bIsExitAudAdp = TRUE;
		}
	}
	
	BOOL32 bIsExistDsSrc = m_tDoubleStreamSrc.IsNull() ? FALSE:TRUE;
	u16 wBiteRate= m_tConf.GetBitRate();
	if ( bIsExitVidAdp )
	{
		if ( bIsExistDsSrc )
		{
			wBiteRate = GetDoubleStreamVideoBitrate(m_tConf.GetBitRate(),TRUE);
		}
		RefreshBasParam4VidBrd(wBiteRate);
	}
	
	if ( bIsExitSecVidAdp )
	{
		wBiteRate = GetDoubleStreamVideoBitrate(m_tConf.GetBitRate(),FALSE);
		RefreshBasParam4DSBrd(wBiteRate);
	}
	
	if ( bIsExitAudAdp )
	{
		wBiteRate = GetAudioBitrate(m_tConf.GetSecAudioMediaType());
		RefreshBasParam4AudBrd(wBiteRate);
	}
	
	return TRUE;
}
/*====================================================================
函数名      ：ProcConfPollingByRemoveMt
功能        ：删除终端时处理会议轮询业务逻辑
算法实现    ：
引用全局变量：
输入参数说明：TMt tRemoveMt 删除的终端

返回值说明  ：void
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/09/06    4.6         周晶晶        创建
====================================================================*/
void CMcuVcInst::ProcConfPollingByRemoveMt( const TMt &tRemoveMt )
{
	if( POLL_STATE_NONE == m_tConf.m_tStatus.GetPollState() )
	{
		return;
	}
	
	if( IsMcu(tRemoveMt) )	
	{	
		TMtPollParam atMtPollNew[MAXNUM_CONF_MT];
		TMtPollParam tTmpMt;
		u8 byPos;
		u8 byNewNum= 0;
		BOOL32 bPollingMtInSMcu = IsMtInMcu( tRemoveMt,(TMt)m_tConf.m_tStatus.GetMtPollParam() );// ( m_tConf.m_tStatus.GetMtPollParam().GetMcuIdx() == wMcuIdx/*tMt.GetMtId()*/ ) ? TRUE : FALSE ;
		u8 byNextPos = bPollingMtInSMcu ? POLLING_POS_START : 0;     // 下一个要轮询的终端
		for( byPos = 0; byPos < m_tConfPollParam.GetPolledMtNum(); byPos++ )
		{
			tTmpMt = *(m_tConfPollParam.GetPollMtByIdx(byPos));
			if( !IsMtInMcu( tRemoveMt,(TMt)tTmpMt ) )//wMcuIdx/*tMt.GetMtId()*/ != tTmpMt.GetMcuIdx() )
			{
				atMtPollNew[byNewNum] = tTmpMt;
				if( byPos > m_tConfPollParam.GetCurrentIdx() && byNextPos == POLLING_POS_START )
				{
					//记录下一个被轮询的终端在新列表中的位置, zgc, 2007-04-07
					byNextPos = byNewNum; 
				}
				byNewNum ++;
			}
		}
		m_tConfPollParam.SetPollList( byNewNum, atMtPollNew );
		// 如果离线的下级MCU中有当前轮询的终端，则立即切换
		if ( bPollingMtInSMcu )
		{
			// 指定新的轮询位置, zgc, 2007-04-07
			if( byNextPos == POLLING_POS_START )
			{
				byNextPos = m_tConfPollParam.GetPolledMtNum();
			}
			m_tConfPollParam.SpecPollPos( byNextPos );
			SetTimer( MCUVC_POLLING_CHANGE_TIMER, 10 );
		}
		PollParamChangeNotify();
	}
	else
	{
		if( tRemoveMt == (TMt)(m_tConf.m_tStatus.GetMtPollParam()) )
		{
			SetTimer( MCUVC_POLLING_CHANGE_TIMER, 10 );
		}
	}	
}

/*====================================================================
函数名      ：ProcMMcuSpyMtByRemoveMt
功能        ：下级挂断本级上传通道终端
算法实现    ：
引用全局变量：
输入参数说明：TMt tRemoveMt 删除的终端

  返回值说明  ：void
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  13/05/27    4.7         杨怀志        创建
====================================================================*/
void CMcuVcInst::ProcMMcuSpyMtByRemoveMt( const TMt &tRemoveMt )
{
	if (tRemoveMt.IsNull() || m_tCascadeMMCU.IsNull())
	{
		return;
	}
	// 上级MCU上传通道成员可能是要挂断mcu的下级终端
	TConfMcInfo *ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(GetMcuIdxFromMcuId(m_tCascadeMMCU.GetMtId()));
	if( ptConfMcInfo != NULL && 
		( !ptConfMcInfo->m_tSpyMt.IsNull() ) )
	{
		TMt tMMcuSpyMt = ptConfMcInfo->m_tSpyMt;
		if( tMMcuSpyMt.GetMtId() == tRemoveMt.GetMtId()&&
			tMMcuSpyMt.GetMcuId() == tRemoveMt.GetMcuId())
		{
			StopSpyMtCascaseSwitch();
		}
	}

	return;
}

/*====================================================================
函数名      ：ProcVmpPollingByRemoveMt
功能        ：删除终端时处理Vmp单通道轮询业务逻辑
算法实现    ：
引用全局变量：
输入参数说明：TMt tRemoveMt 删除的终端

返回值说明  ：void
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
12/05/05    4.7         杨怀志        创建
====================================================================*/
void CMcuVcInst::ProcVmpPollingByRemoveMt( const TMt &tRemoveMt )
{
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp(GetTheOnlyVmpIdFromVmpList());
	if (g_cMcuVcApp.GetVMPMode(tVmpEqp) == CONF_VMPMODE_NONE ||
		POLL_STATE_NONE == m_tVmpPollParam.GetPollState() )
	{
		return;
	}
	
	if ( IsMcu(tRemoveMt) )	
	{	
		TMtPollParam atMtPollNew[MAXNUM_CONF_MT];
		TMtPollParam tTmpMt;
		u8 byPos;
		u8 byNewNum= 0;
		BOOL32 bPollingMtInSMcu = IsMtInMcu( tRemoveMt,(TMt)m_tVmpPollParam.GetMtPollParam() );
		u8 byNextPos = bPollingMtInSMcu ? POLLING_POS_START : 0;     // 下一个要轮询的终端
		for( byPos = 0; byPos < m_tVmpPollParam.GetPolledMtNum(); byPos++ )
		{
			tTmpMt = *(m_tVmpPollParam.GetPollMtByIdx(byPos));
			if( !IsMtInMcu( tRemoveMt,(TMt)tTmpMt ) )
			{
				atMtPollNew[byNewNum] = tTmpMt;
				if( byPos > m_tVmpPollParam.GetCurrentIdx() && byNextPos == POLLING_POS_START )
				{
					//记录下一个被轮询的终端在新列表中的位置, zgc, 2007-04-07
					byNextPos = byNewNum; 
				}
				byNewNum ++;
			}
		}
		m_tVmpPollParam.SetPollList( byNewNum, atMtPollNew );
		// 如果离线的下级MCU中有当前轮询的终端，则立即切换
		if ( bPollingMtInSMcu )
		{
			// 指定新的轮询位置, zgc, 2007-04-07
			if( byNextPos == POLLING_POS_START )
			{
				byNextPos = m_tVmpPollParam.GetPolledMtNum();
			}
			m_tVmpPollParam.SpecPollPos( byNextPos );
			SetTimer( MCUVC_VMPPOLLING_CHANGE_TIMER, 10 );
		}
	}
	else
	{
		if( tRemoveMt == (TMt)(m_tVmpPollParam.GetMtPollParam()) )
		{
			SetTimer( MCUVC_VMPPOLLING_CHANGE_TIMER, 10 );
		}
	}	
}


/*====================================================================
函数名      SetLastMultiSpyRollCallFinish
功能        ：点名与被点名人多回传时需要等上次点名成功再做下次点名，设置中间的状态
算法实现    ：
引用全局变量：
输入参数说明：BOOL32 true:本次等待完成，false，开始等待

  返回值说明  ：void
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  12/09/20    4.7         周翼亮        创建
====================================================================*/
void CMcuVcInst::SetLastMultiSpyRollCallFinish( const BOOL32 bFinish )
{
	  KillTimer(MCUVC_WAIT_LASTVMPROLLCALLFINISH_TIMER);
      if ( !bFinish )//开始等待
      {
		//1、settimer
		  SetTimer(MCUVC_WAIT_LASTVMPROLLCALLFINISH_TIMER,10000);//10s
		//2、设置标志位
		m_tConfInStatus.SetLastMutiSpyRollCallFinished(FALSE);
      }
	  else//等待完成
	  {
		  //1、killtimer
		  KillTimer(MCUVC_WAIT_LASTVMPROLLCALLFINISH_TIMER);
		  //2、恢复标志位
		 m_tConfInStatus.SetLastMutiSpyRollCallFinished(TRUE);
	  }
}

/*====================================================================
函数名      ProcWaitLastVmpRollCallFinishTimer
功能        ：点名与被点名人多回传时需要等上次点名完成超时timer
算法实现    ：
引用全局变量：
输入参数说明：CMessage

  返回值说明  ：void
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  12/09/20    4.7         周翼亮        创建
====================================================================*/
void CMcuVcInst::ProcWaitLastVmpRollCallFinishTimer(  )
{
	 StaticLog("[ProcWaitLastVmpRollCallFinishTimer]Recover Rollcall finish Mark\n")  ;
     SetLastMultiSpyRollCallFinish(TRUE);
}



/*====================================================================
函数名      ProcWaitMSConfDataTimer
功能        ：主备环境，主板给备板备会议数据超时，结束该会议
算法实现    ：
引用全局变量：
输入参数说明：

  返回值说明  ：void
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  12/09/20    4.7         周翼亮        创建
====================================================================*/
void CMcuVcInst::ProcWaitMSConfDataTimer(  )
{
	KillTimer(MCUVC_WAITMSCONFDATA_TIMER);
	if (!g_cMSSsnApp.IsDoubleLink())
	{
		StaticLog("[ProcWaitMSConfDataTimer]Not Doublelink evn!\n");
		return;
	}
	if ( STATE_SCHEDULED == CurState() || STATE_ONGOING == CurState() )
	{
		ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"[ProcWaitMSConfDataTimer] Ms conf data not complete, releaseconf InstID:%d\n",GetInsID());
		ReleaseConf(TRUE);
		SetWaitMsConfData( FALSE );
		NextState(STATE_IDLE);
	}
}

/*====================================================================
函数名         IsCanRlsBasChn
功能        ：根据源和目的信息判断是否可释放对应适配通道
算法实现    ：
引用全局变量：
输入参数说明：TMt tRlsSrc  当前要释放的源
			  const TMt &tSpySrc 当前要回传的新源
			  const TSimCapSet &tDstCap 当前要回传的能力
	
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::IsCanRlsBasChn(const TMt &tRlsSrc,  const TMt &tSpySrc, const TSimCapSet &tDstCap, u8 byRlsMode)
{
	if (tRlsSrc.IsNull() || tDstCap.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsCanRlsBasChn] tRlsSrc<McuId:%d, MtId:%d> or tDstCap is null!\n",
		   	     tRlsSrc.GetMcuId(), tRlsSrc.GetMtId());
		return FALSE;
	}

	if (byRlsMode != MODE_VIDEO && byRlsMode != MODE_AUDIO && byRlsMode != MODE_SECVIDEO)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsCanRlsBasChn] unexpected MediaMode:%d!\n", byRlsMode);
		return FALSE;
	}
	
	TMt tLocalSrc = GetLocalMtFromOtherMcuMt(tRlsSrc);
	
	ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS,  "[IsCanRlsBasChn] tLocalSrc<McuId:%d, MtId:%d>!\n",
								tLocalSrc.GetMcuId(), tLocalSrc.GetMtId());
	
	if (!IsNeedSpyAdpt(tRlsSrc, tDstCap, MODE_VIDEO))
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS,  "[IsCanRlsBasChn] !IsNeedSpyAdpt\n");
		return FALSE;
	}
	
	TBasOutInfo tRlsOutInfo;
	if (!FindBasChn2SpyForMt(tRlsSrc, tDstCap, byRlsMode,tRlsOutInfo))
	{
		return FALSE;
	}
	TBasOutInfo tOutInfo;
	TMtStatus tMtStatus;
	BOOL32 bRlsBas = TRUE;
	//遍历所有终端有没有同样收相同适配通道的码流
	TMt tTempSelSrc;
	u8 byOtherMode = MODE_NONE;
	if (MODE_VIDEO == byRlsMode)
	{
		byOtherMode = MODE_VIDEO2SECOND;
	}
	else if (MODE_VIDEO2SECOND == byRlsMode)
	{
		byOtherMode = MODE_VIDEO;
	}

	for (u8 byMtIdx = 1; byMtIdx < MAXNUM_CONF_MT; byMtIdx++)
	{
		if (!m_tConfAllMtInfo.MtJoinedConf(byMtIdx))
		{
			continue;
		}
		if (tLocalSrc.GetMtId() == byMtIdx)
		{
			continue;
		}
		
		tMtStatus.SetNull();
		m_ptMtTable->GetMtStatus(byMtIdx, &tMtStatus);
		tTempSelSrc = tMtStatus.GetSelectMt(byRlsMode);

		//[nizhijun 2012/04/10] 如果遍历到的终端是上级MCU，
		//且上级MCU的选看源(上级MCU有选看源，说明上传通道中有终端) 与 tSpySrc(多回传要求回传的源) 一样，那么参数还是可以调整的
		if ( !m_tCascadeMMCU.IsNull() && 
			 m_tCascadeMMCU.GetMtId() == byMtIdx &&
			 !tTempSelSrc.IsNull()&&
			 tTempSelSrc == tSpySrc
			)
		{
			ConfPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[IsCanRlsBasChn]tTempSelSrc:%d-%d is equal to tRlsSrc\n",tTempSelSrc.GetMcuId(), tTempSelSrc.GetMtId());
			continue;
		}

		if (tTempSelSrc == tRlsSrc &&
			IsNeedSelAdpt(tLocalSrc, m_ptMtTable->GetMt(byMtIdx), byRlsMode) &&
			FindBasChn2SelForMt(tRlsSrc, m_ptMtTable->GetMt(byMtIdx), byRlsMode, tOutInfo) &&
			tOutInfo.m_tBasEqp.GetEqpId() == tRlsOutInfo.m_tBasEqp.GetEqpId() && tOutInfo.m_byChnId == tRlsOutInfo.m_byChnId)
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[IsCanRlsBasChn] Find LocalMt.%d see Mt.%d through Bas<EqpId:%d, ChnId:%d>!\n",
				byMtIdx, tLocalSrc.GetMtId(), tRlsOutInfo.m_tBasEqp.GetEqpId(), tRlsOutInfo.m_byChnId);
			bRlsBas = FALSE;
			break;
		}

		if (MODE_NONE == byOtherMode)
		{
			continue;
		}

		tTempSelSrc.SetNull();
		tTempSelSrc = m_ptMtTable->GetMtSelMtByMode(byMtIdx, byOtherMode);
		
		if (tTempSelSrc == tRlsSrc &&
			IsNeedSelAdpt(tLocalSrc, m_ptMtTable->GetMt(byMtIdx), byRlsMode) &&
			FindBasChn2SelForMt(tRlsSrc, m_ptMtTable->GetMt(byMtIdx), byRlsMode, tOutInfo) &&
			tOutInfo.m_tBasEqp.GetEqpId() == tRlsOutInfo.m_tBasEqp.GetEqpId() && tOutInfo.m_byChnId == tRlsOutInfo.m_byChnId)
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[IsCanRlsBasChn] Find LocalMt.%d see Mt.%d through Bas<EqpId:%d, ChnId:%d>!\n",
				byMtIdx, tLocalSrc.GetMtId(), tRlsOutInfo.m_tBasEqp.GetEqpId(), tRlsOutInfo.m_byChnId);
			bRlsBas = FALSE;
			break;
		}
	}
	return bRlsBas;
}

/*====================================================================
函数名         AdjustSpyStreamFromAdp
功能        ：对回传源过适配的码流根据业务要求进行调整
算法实现    ：
引用全局变量：
输入参数说明：TMt tSpySrc  上传源
			  u8 byRes 需求的分辨率
			  TMsgHeadMsg tHeadMsg 消息头

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
2012/02/29	4.7			倪志俊		  重整
====================================================================*/
BOOL32 CMcuVcInst::AdjustSpyStreamFromAdp(TMt tSpySrc, u8 byRes, TMsgHeadMsg tHeadMsg)
{
	if (VIDEO_FORMAT_INVALID == byRes)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[AdjustSpyStreamFromAdp]  byRes is null!\n");
		return FALSE;
	}

	if (!IsSupportMultiSpy())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[AdjustSpyStreamFromAdp]  Is not SupportMultiSpy!\n");
		return FALSE;
	}

	TMt tOrgSrc    = tSpySrc;
	TMt tUnLocalMt = GetMtFromMultiCascadeMtInfo( tHeadMsg.m_tMsgDst, tSpySrc);
	TMt tLocalMt   = GetLocalMtFromOtherMcuMt(tUnLocalMt);
	BOOL32 bAdjustOK = FALSE;
	
	CSendSpy *ptSndSpy = NULL;
	TSimCapSet tDstCap;
	tDstCap.Clear();

	ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[AdjustSpyStreamFromAdp]  tSpySrc(mcuid-%d,mtid-%d) byRes:%d!\n",
		  tUnLocalMt.GetMcuId(), tUnLocalMt.GetMtId(),byRes);
	
	for (u8 bySpyIdx = 0; bySpyIdx < MAXNUM_CONF_SPY; bySpyIdx++)
	{
		ptSndSpy = m_cLocalSpyMana.GetSendSpy(bySpyIdx);
		if (NULL == ptSndSpy)
		{
			continue;
		}
		if (!(ptSndSpy->GetSpyMt() == tUnLocalMt))
		{
			continue;
		}
		
		tDstCap = ptSndSpy->GetSimCapset();
		
		if (IsNeedSpyAdpt(tLocalMt, tDstCap, MODE_VIDEO))
		{
			TBasOutInfo tOutInfo;
			tDstCap.SetVideoResolution(byRes);
			if( !FindBasChn2SpyForMt(tUnLocalMt, tDstCap, MODE_VIDEO, tOutInfo) )
			{
				if ( FindBasChnForAdjustSpyStream(tUnLocalMt,tDstCap,MODE_VIDEO,tOutInfo) )
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[AdjustSpyStreamFromAdp]  FindBasChnForAdjustSpyStream-%d-%d-%d  success!\n",
							tOutInfo.m_tBasEqp.GetEqpId(), tOutInfo.m_byChnId, tOutInfo.m_byOutIdx	
							);
					bAdjustOK = TRUE;
					ChangeAdapt(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId);
				}
				else
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[AdjustSpyStreamFromAdp]  FindBasChnForAdjustSpyStream  failed!\n");
				}
			}
			else
			{
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[AdjustSpyStreamFromAdp]  FindBasChn2SpyForMt  success!\n");
				bAdjustOK = TRUE;
				
				//[2011/08/25/zhangli]
				THDAdaptParam atParam[MAXNUM_BASOUTCHN];
				u8 byCurrOutNum = 0;
				//获取适配参数
				/*lint -save -e685*/
				if(g_cMcuVcApp.GetBasOutPutParam(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId, byCurrOutNum, atParam)
					&& tOutInfo.m_byOutIdx < byCurrOutNum)
				/*lint -restore*/
				{
					u16 wCurrWitch = 0;
					u16 wCurrHeight = 0;
					//找到通道的分辨率
					u8 byChnRes = GetResByWH(atParam[tOutInfo.m_byOutIdx].GetWidth(), atParam[tOutInfo.m_byOutIdx].GetHeight());
					GetWHByRes(byRes, wCurrWitch, wCurrHeight);
					
					 //要调的分辨率 不等于通道当前分辨率，修改；看此通道还有没有其他终端用，没有就改通道参数
					if (wCurrWitch * wCurrHeight != atParam[tOutInfo.m_byOutIdx].GetWidth() * atParam[tOutInfo.m_byOutIdx].GetHeight())
					{	
						//如果可以释放，分辨率调整为byRes
						if (IsCanRlsBasChn(tUnLocalMt, tUnLocalMt, tDstCap, MODE_VIDEO))
						{
							THDAdaptParam tParam = atParam[tOutInfo.m_byOutIdx];
							u16 wWidth  = 0;
							u16 wHeight = 0;
							//[2011/09/27]如果是非标分辨率，调成标准分辨率
							if (byRes != VIDEO_FORMAT_CIF && byRes != VIDEO_FORMAT_4CIF
								&& byRes != VIDEO_FORMAT_HD720 && byRes != VIDEO_FORMAT_HD1080)
							{
								byRes = GetDownStandRes(byRes);
							}
							GetWHByRes(byRes, wWidth, wHeight);
							tParam.SetResolution(wWidth, wHeight);
							RefreshBasParambyOutIdx(tOutInfo,tParam);
							ChangeAdapt(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId);
							ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[AdjustSpyStreamFromAdp] bas-%d-%d-%d  change param from:%d-%d to %d-%d!\n",
									tOutInfo.m_tBasEqp.GetEqpId(), tOutInfo.m_byChnId, tOutInfo.m_byOutIdx,	
									atParam[tOutInfo.m_byOutIdx].GetWidth(), atParam[tOutInfo.m_byOutIdx].GetHeight(),
									wWidth,wHeight
									);
						}
						else
						{
							ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[AdjustSpyStreamFromAdp] can't find rlsbaschn for RefreshBasParam!\n");
						}
					}
					else if (wCurrWitch * wCurrHeight == atParam[tOutInfo.m_byOutIdx].GetWidth() * atParam[tOutInfo.m_byOutIdx].GetHeight())
					{
						//相等，找分辨率 < byRes，看这些能否释放，如果能，释放
						ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[AdjustSpyStreamFromAdp] byRes = res of current channel,realse!\n");
						TSimCapSet tTempDstCap = tDstCap;
						TBasOutInfo tFindBasOutInfo;
						u8 byNextUpStandRes = 0;
						byNextUpStandRes = GetUpStandRes(byRes);
						while (VIDEO_FORMAT_INVALID != byNextUpStandRes)
						{
							tTempDstCap.SetVideoResolution(byNextUpStandRes);
							if ( FindBasChn2SpyForMt(tUnLocalMt, tTempDstCap, MODE_VIDEO, tFindBasOutInfo) )
							{
								//不是当前回传占用的bas，且没有其他终端使用
								if (tFindBasOutInfo.m_byChnId != tOutInfo.m_byChnId && IsCanRlsBasChn(tUnLocalMt, tUnLocalMt,tTempDstCap, MODE_VIDEO))
								{
									//释放该bas
									ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[AdjustSpyStreamFromAdp] realse eqp%dchnid&d!\n",
										tFindBasOutInfo.m_tBasEqp.GetEqpId(), tFindBasOutInfo.m_byChnId);
									StopSpyAdapt(tUnLocalMt, tTempDstCap, MODE_VIDEO);
								}
							}
							byNextUpStandRes = GetUpStandRes(byNextUpStandRes);
						}
					}
				}
			}
			
			if (bAdjustOK)
			{
				tOutInfo.m_tBasEqp.SetConfIdx(m_byConfIdx);
				g_cMpManager.StartSwitchToMmcu(tOutInfo.m_tBasEqp, tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx, 
												m_tCascadeMMCU, MODE_VIDEO, 
												SWITCH_MODE_SELECT, FALSE, TRUE, FALSE, ptSndSpy->GetSpyAddr().GetPort());
				
				TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
				//[nizhijun 2010/12/24] 通知上级改变后的RTCP信息
				if (tConfAttrb.IsResendLosePack())
				{			
					TTransportAddr tVidRtcpAddr, tAudRtcpAddr;
					tVidRtcpAddr.SetNull();
					tAudRtcpAddr.SetNull();
					GetSpyBasRtcpInfo(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId, tOutInfo.m_byFrontOutNum, tOutInfo.m_byOutIdx, tVidRtcpAddr);
					SendMMcuMtExtInfoNotif(tOrgSrc,tHeadMsg,MODE_VIDEO,tVidRtcpAddr,tAudRtcpAddr);
				}
			}
		}
	}
		
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[AdjustSpyStreamFromAdp] adjust finished, return:%d", bAdjustOK);
	return bAdjustOK;
}

/*====================================================================
函数名         AdjustSpyStreamFromAdpForMMcu
功能        ：对上传源过适配的码流根据业务要求进行调整
算法实现    ：
引用全局变量：
输入参数说明：TMt tSpySrc  上传源
u8 byRes 需求的分辨率
TMsgHeadMsg tHeadMsg 消息头

  返回值说明  ：
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  10/06/30    4.6         zhangli        创建
  2012/03/27  4.7         倪志俊		 修改
====================================================================*/
  BOOL32 CMcuVcInst::AdjustSpyStreamFromAdpForMMcu(TMt tSpySrc, u8 byRes, TMsgHeadMsg tHeadMsg)
  {
	  if (VIDEO_FORMAT_INVALID == byRes)
	  {
		  ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[AdjustSpyStreamFromAdpForMMcu]  byRes is null!\n");
		  return FALSE;
	  }
	  
	  TMt tUnLocalMt = GetMtFromMultiCascadeMtInfo( tHeadMsg.m_tMsgDst, tSpySrc);
	  
	  ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[AdjustSpyStreamFromAdpForMMcu]  tSpySrc(mcuid-%d,mtid-%d) byRes:%d!\n",
		  tUnLocalMt.GetMcuId(), tUnLocalMt.GetMtId(),byRes);
	  
	  BOOL32 bAdjustMcuOk = FALSE;
	  //多回传下，如果有终端在上传，调上传源分辨率也走这里逻辑
	  TConfMcInfo *ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(GetMcuIdxFromMcuId(m_tCascadeMMCU.GetMtId()));
	  if ((ptConfMcInfo != NULL && ptConfMcInfo->m_tSpyMt == tUnLocalMt) || !IsSupportMultiSpy())
	  {
		  if (IsNeedSelAdpt(tUnLocalMt, m_tCascadeMMCU, MODE_VIDEO))
		  {
			  TBasOutInfo tOutInfo;
			  TSimCapSet tDstCap = m_ptMtTable->GetDstSCS(m_tCascadeMMCU.GetMtId());
			  tDstCap.SetVideoResolution(byRes);
			  if (FindBasChn2SpyForMt(tUnLocalMt, tDstCap, MODE_VIDEO, tOutInfo))
			  {
				  bAdjustMcuOk = TRUE;
				  //[2011/08/25/zhangli]
				  THDAdaptParam atParam[MAXNUM_BASOUTCHN];
				  u8 byCurrOutNum = 0;
				  //获取适配参数
				  /*lint -save -e685*/
				  if(g_cMcuVcApp.GetBasOutPutParam(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId, byCurrOutNum, atParam)
					  && tOutInfo.m_byOutIdx < byCurrOutNum)
				  /*lint -restore*/
				  {
					  u16 wCurrWidth = 0;
					  u16 wCurrHeight = 0;
					  //找到通道的分辨率
					  u8 byChnRes = GetResByWH(atParam[tOutInfo.m_byOutIdx].GetWidth(), atParam[tOutInfo.m_byOutIdx].GetHeight());
					  GetWHByRes(byRes, wCurrWidth, wCurrHeight);
					  
					  //要调的分辨率 不等于通道当前分辨率，修改；看此通道还有没有其他终端用，没有就改通道参数
					  if (wCurrWidth * wCurrHeight != atParam[tOutInfo.m_byOutIdx].GetWidth() * atParam[tOutInfo.m_byOutIdx].GetHeight())
					  {
						  
						  //如果可以释放，分辨率修改为byRes
						  if (IsCanRlsBasChn(tUnLocalMt, tUnLocalMt,tDstCap, MODE_VIDEO))
						  {
							  THDAdaptParam tParam = atParam[tOutInfo.m_byOutIdx];
							  u16 wWidth  = 0;
							  u16 wHeight = 0;
							  //[2011/09/27]如果是非标分辨率，调成标准分辨率
							  if (byRes != VIDEO_FORMAT_CIF && byRes != VIDEO_FORMAT_4CIF
								  && byRes != VIDEO_FORMAT_HD720 && byRes != VIDEO_FORMAT_HD1080)
							  {
								  byRes = GetDownStandRes(byRes);
							  }
							  GetWHByRes(byRes, wWidth, wHeight);
							  tParam.SetResolution(wWidth, wHeight);
							  RefreshBasParambyOutIdx(tOutInfo,tParam);
							  ChangeAdapt(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId);
							  ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[AdjustSpyStreamFromAdpForMMcu] bas-%d-%d change res from:%d-%d to %d-%d!\n",
									tOutInfo.m_tBasEqp.GetEqpId(),tOutInfo.m_byChnId,
									atParam[tOutInfo.m_byOutIdx].GetWidth(), atParam[tOutInfo.m_byOutIdx].GetHeight(),
									wWidth,wHeight
									);
						  }
						  else
						  {
							  ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[AdjustSpyStreamFromAdpForMMcu] can't find rlsbaschn for RefreshBasParam!\n");
						  }
					  }
					  //单回传情况下，需要恢复的分辨率找到的通道不是原来调分辨率后使用的通道，此处用来释放调分辨率后所使用的通道
					  //场景：BAP4 A通道：H264 4CIF H264 CIF,画面合成调成H263 CIF时新占一个通道B，取消画面合成，恢复成4CIF时，找到通道A
					  //此时通过以下逻辑释放通道B
					  else if (wCurrWidth * wCurrHeight == atParam[tOutInfo.m_byOutIdx].GetWidth() * atParam[tOutInfo.m_byOutIdx].GetHeight())
					  {
						  //相等，找分辨率 < byRes，看这些能否释放，如果能，释放
						  ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[AdjustSpyStreamFromAdpForMMcu] byRes = res of current channel,realse!\n");
						  TSimCapSet tTempDstCap = tDstCap;
						  TBasOutInfo tFindBasOutInfo;
						  u8 byNextUpStandRes = 0;
						  byNextUpStandRes = GetUpStandRes(byRes);
						  while (VIDEO_FORMAT_INVALID != byNextUpStandRes)
						  {
							  tTempDstCap.SetVideoResolution(byNextUpStandRes);
							  if ( FindBasChn2SpyForMt(tUnLocalMt, tTempDstCap, MODE_VIDEO, tFindBasOutInfo) )
							  {
								  //不是当前回传占用的bas，且没有其他终端使用
								  if (tFindBasOutInfo.m_byChnId != tOutInfo.m_byChnId && IsCanRlsBasChn(tUnLocalMt, tUnLocalMt, tTempDstCap, MODE_VIDEO))
								  {
									  //释放该bas
									  ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[AdjustSpyStreamFromAdpForMMcu] realse eqp%dchnid&d!\n",
										  tFindBasOutInfo.m_tBasEqp.GetEqpId(), tFindBasOutInfo.m_byChnId);
									  StopSpyAdapt(tUnLocalMt, tTempDstCap, MODE_VIDEO);
								  }
							  }
							  byNextUpStandRes = GetUpStandRes(byNextUpStandRes);
						  }
					  }
				  }
			  }
			  else
			  {
				  if ( FindBasChnForAdjustSpyStream(tUnLocalMt,tDstCap,MODE_VIDEO,tOutInfo) )
				  {
					  ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[AdjustSpyStreamFromAdpForMMcu]  FindBasChnForAdjustSpyStream:%d-%d-%d success!\n",
								tOutInfo.m_tBasEqp.GetEqpId(), tOutInfo.m_byChnId, tOutInfo.m_byOutIdx
								);
					  ChangeAdapt(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId);
					  bAdjustMcuOk = TRUE;
				  }
				  else
				  {
					  ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[AdjustSpyStreamFromAdpForMMcu]  FindBasChnForAdjustSpyStream  failed!\n");
				  }
			  }

			  if (  TRUE == bAdjustMcuOk )
			  {
				  tOutInfo.m_tBasEqp.SetConfIdx(m_byConfIdx);
				  g_cMpManager.StartSwitchToMmcu(tOutInfo.m_tBasEqp, tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx, 
												 m_tCascadeMMCU, MODE_VIDEO, 
												 SWITCH_MODE_SELECT, FALSE, TRUE, FALSE
												);
			  }
		  }
	  }
	  
	  ConfPrint(LOG_LVL_DETAIL, MID_MCU_BAS, "[AdjustSpyStreamFromAdpForMMcu] adjust finished, return:%d\n", bAdjustMcuOk);
	  return bAdjustMcuOk;
  }

/*====================================================================
函数名         FindBasChnForAdjustSpyStream
功能        ： 根据源和目的能力找一个能给级联调分辨率强刷参数的通道
算法实现    ：
引用全局变量：
输入参数说明： tBasSrc, Bas源;
			   const TSimCapSet &tDstCap 目的能力
			   byMediaMode, 媒体模式
			    TBasOutInfo &tOutInfo  返回的通道
返回值说明  ： TRUE,成功; 否则,失败
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/2/29   4.7         倪志俊          创建
====================================================================*/
BOOL32	CMcuVcInst::FindBasChnForAdjustSpyStream(const TMt &tSpySrc, const TSimCapSet &tDstCap, u8 byMediaMode,TBasOutInfo &tOutInfo)
{	
	if ( byMediaMode == MODE_AUDIO )
	{
		return TRUE;
	}

	CBasChn *apcBasChn[MAXNUM_PERIEQP]={NULL};
	u8		byChnNum = 0;
	TVideoStreamCap	atOccpiedSimCapSet[MAX_CONF_BAS_ADAPT_NUM];
	TMt tTempSrcMt;
	if ( GetBasSelChnGrp(byChnNum,apcBasChn,byMediaMode) )
	{
		for ( u8 byIdx = 0; byIdx<byChnNum; byIdx++ )
		{
			if ( NULL == apcBasChn[byIdx] )
			{
				continue;
			}
			
			tTempSrcMt = apcBasChn[byIdx]->GetSrc();
			if (!tSpySrc.IsLocal() && IsMcu(tTempSrcMt) )
			{
				TMt tRealMt = GetSMcuViewMt(tTempSrcMt, TRUE);
				if ( !tRealMt.IsNull() )
				{
					tTempSrcMt = tRealMt;
				}
			}

			if ( tTempSrcMt == tSpySrc &&
				 apcBasChn[byIdx]->GetMediaMode() == byMediaMode
				)
			{
				TMt tLocalSrc = GetLocalMtFromOtherMcuMt(tSpySrc);
				TSimCapSet tSrcCap = m_ptMtTable->GetSrcSCS(tLocalSrc.GetMtId());
				u8 byRes = tDstCap.GetVideoResolution();
				if (byRes != VIDEO_FORMAT_CIF && byRes != VIDEO_FORMAT_4CIF
					&& byRes != VIDEO_FORMAT_HD720 && byRes != VIDEO_FORMAT_HD1080)
				{
					byRes = GetDownStandRes(byRes);
				}
				TSimCapSet tTempDstCap = tDstCap;
				tTempDstCap.SetVideoResolution(byRes);
				TNeedVidAdaptData	tBasNeeds;
				if ( GetBasNeedResDataByCap(tSrcCap, tTempDstCap,byMediaMode, tBasNeeds) )
				{
					THDAdaptParam tParam;
					u16 wWidth  = 0;
					u16 wHeight = 0;
					//当前通道剩余能力是否支持新的编码
					if ( apcBasChn[byIdx]->IsBasChnSupportNeeds(tBasNeeds,atOccpiedSimCapSet) &&
						tBasNeeds.m_byRealEncNum == 0
						)
					{
						u8		byFrontOutNum = 0;
						u8		byOutNum = 0;	
						if ( !g_cMcuVcApp.GetBasChnFrontOutPutNum(apcBasChn[byIdx]->GetBas(), apcBasChn[byIdx]->GetChnId(),byOutNum,byFrontOutNum) )
						{
							continue;
						}
						
						TBasChnCapData tChnCapData;
						TVideoStreamCap tTempVidStreamCap = tTempDstCap.GetVideoCap();
						tChnCapData.atBasChnCap[0].SetVidepCapSet(tTempVidStreamCap);
						AddBasSelChnParam(apcBasChn[byIdx]->GetBas(), apcBasChn[byIdx]->GetChnId(),tChnCapData);
						u8 byDstRes = tTempDstCap.GetVideoResolution();
						if ( byMediaMode == MODE_VIDEO )
						{
							if (MEDIA_TYPE_MP4 == tTempDstCap.GetVideoMediaType()&&
								VIDEO_FORMAT_16CIF == byDstRes
								)
							{
								byDstRes = VIDEO_FORMAT_4CIF;
							}
						}
						GetWHByRes(byDstRes, wWidth, wHeight);
						tParam.SetAudType(tTempDstCap.GetAudioMediaType());
						tParam.SetVidType(tTempDstCap.GetVideoMediaType());
						tParam.SetVidActiveType(GetActivePayload(m_tConf, tTempDstCap.GetVideoMediaType()));
						tParam.SetResolution(wWidth, wHeight);
						tParam.SetBitRate(tTempDstCap.GetVideoMaxBitRate());
						if (MEDIA_TYPE_H264 == tTempDstCap.GetVideoMediaType())
						{
							tParam.SetFrameRate(tTempDstCap.GetUserDefFrameRate());
							tParam.SetProfileType(tTempDstCap.GetVideoProfileType());
						}
						else
						{	
							tParam.SetFrameRate(tTempDstCap.GetVideoFrameRate());
						}
						tParam.SetProfileType( tTempDstCap.GetVideoProfileType() );	
						TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
						tParam.SetIsNeedByPrs(tConfAttrb.IsResendLosePack());
						//保存适配参数
						if( !SetBasSelChnParam( apcBasChn[byIdx]->GetBas(),apcBasChn[byIdx]->GetChnId(),byMediaMode,tParam ) ) 
						{
							ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[FindBasChnForAdjustSpyStream] SetBasAdaptParam failed!\n");
							return FALSE;
						}
						if ( FindBasChn2SpyForMt(tSpySrc,tTempDstCap,byMediaMode,tOutInfo) )
						{
							return TRUE;
						}
					}
					//不支持，则要考虑强刷参数
					else
					{
						TMtStatus tMtStatus;
						BOOL32 bIsExistMt = FALSE;	//是否有终端收相同适配通道的码流
						TBasOutInfo	tTempOutInfo;
						TMt	tTempSelSrc;
						for (u8 byMtIdx = 1; byMtIdx < MAXNUM_CONF_MT; byMtIdx++)
						{
							if (!m_tConfAllMtInfo.MtJoinedConf(byMtIdx))
							{
								continue;
							}
							if (tLocalSrc.GetMtId() == byMtIdx)
							{
								continue;
							}
							
							tMtStatus.SetNull();
							m_ptMtTable->GetMtStatus(byMtIdx, &tMtStatus);
							tTempSelSrc = tMtStatus.GetSelectMt(byMediaMode);
							//[nizhijun 2012/04/10] 如果遍历到的终端是上级MCU，
							//且上级MCU的选看源 与 tRlsSrc(多回传要求回传的源) 一样，那么参数还是可以调整的
							if ( !m_tCascadeMMCU.IsNull() && 
								m_tCascadeMMCU.GetMtId() == byMtIdx &&
								!tTempSelSrc.IsNull()
								)
							{
								if (!tSpySrc.IsLocal() && IsMcu(tTempSelSrc) )
								{
									TMt tRealMt = GetSMcuViewMt(tTempSelSrc, TRUE);
									if ( !tRealMt.IsNull() )
									{
										tTempSelSrc = tRealMt;
									}
								}
									
								if ( tTempSelSrc == tSpySrc )
								{
									ConfPrint(LOG_LVL_DETAIL,MID_MCU_BAS,"[FindBasChnForAdjustSpyStream]tTempSelSrc:%d-%d is equal to tSpySrc\n",tTempSelSrc.GetMcuId(), tTempSelSrc.GetMtId());
									continue;
								}
							}

							if (tTempSelSrc == tSpySrc &&
								IsNeedSelAdpt(tLocalSrc, m_ptMtTable->GetMt(byMtIdx), byMediaMode) &&
								FindBasChn2SelForMt(tSpySrc, m_ptMtTable->GetMt(byMtIdx), byMediaMode, tTempOutInfo) &&
								tTempOutInfo.m_tBasEqp.GetEqpId() == apcBasChn[byIdx]->GetBas().GetEqpId() && 
								tTempOutInfo.m_byChnId == apcBasChn[byIdx]->GetChnId()
								)
							{
								ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[FindBasChnForAdjustSpyStream] Find LocalMt.%d see Mt.%d through Bas<EqpId:%d, ChnId:%d>!\n",
									byMtIdx, tLocalSrc.GetMtId(), apcBasChn[byIdx]->GetBas().GetEqpId(), apcBasChn[byIdx]->GetChnId()
									);
								bIsExistMt = TRUE;
								break;
							}
						}
						
						if ( !bIsExistMt )
						{
							u8 byNextUpStandRes = 0;
							byNextUpStandRes = GetUpStandRes( tTempDstCap.GetVideoResolution() );
							while (VIDEO_FORMAT_INVALID != byNextUpStandRes)
							{
								tTempDstCap.SetVideoResolution(byNextUpStandRes);
								if (FindBasChn2SpyForMt(tSpySrc, tTempDstCap, MODE_VIDEO,tOutInfo))
								{
									THDAdaptParam atParam[MAXNUM_BASOUTCHN];
									if(g_cMcuVcApp.GetBasOutPutParam(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId, tOutInfo.m_byOutNum, atParam))
									{
										tParam = atParam[tOutInfo.m_byOutIdx];					
										u8 byRealRes = tDstCap.GetVideoResolution();
										//[2011/09/27]Bug00065621如果是非标分辨率，调成标准分辨率
										if ( byRealRes!= VIDEO_FORMAT_CIF && byRealRes != VIDEO_FORMAT_4CIF
											&& byRealRes != VIDEO_FORMAT_HD720 && byRealRes != VIDEO_FORMAT_HD1080)
										{
											byRealRes = GetDownStandRes(byRealRes);
										}
										GetWHByRes(byRealRes, wWidth, wHeight);
										tParam.SetResolution(wWidth, wHeight);
										RefreshBasParambyOutIdx(tOutInfo,tParam);
										return TRUE;
									}
								}
								byNextUpStandRes = GetUpStandRes(byNextUpStandRes);
							}

						}
					}
				}
			}
		}
	}

	return FALSE;

}

/*====================================================================
函数名         IsNeedAdjustSelParam
功能        ： 是否有一个可用的同源通道可以下参，给选看使用
算法实现    ：
引用全局变量：
输入参数说明： tBasSrc, Bas源;
			   const TSimCapSet &tDstCap 目的能力
			   byMediaMode, 媒体模式
			    TBasOutInfo &tOutInfo  返回的通道
返回值说明  ： TRUE,成功; 否则,失败
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/2/29   4.7         倪志俊          创建
====================================================================*/
BOOL32 CMcuVcInst::IsNeedAdjustSelParam(const TMt &tSrc,const TMt &tDst,TBasOutInfo &tOutInfo, u8 byMediaMode, CBasChn **pcBasChn, TBasChnCapData &tChnCapData)
{
	if ( byMediaMode == MODE_AUDIO )
	{
		return FALSE;
	}
	TMt tOrigSrc = tSrc;
	TMt tlocalDst = GetLocalMtFromOtherMcuMt(tDst);
	
	if ( tSrc.IsNull() ||tDst.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[IsNeedAdjustSelParam] tSrc or tDst is null!\n");
		return FALSE;
	}
	if (MODE_NONE == byMediaMode || MODE_BOTH == byMediaMode)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsNeedAdjustSelParam] byMediaMode<%d> is error!\n", byMediaMode);
		return FALSE;
	}
	
	TSimCapSet tDstSimCapSet;
	if ( byMediaMode == MODE_VIDEO )
	{
		tDstSimCapSet = m_ptMtTable->GetDstSCS(tlocalDst.GetMtId());
// 		TSimCapSet tSrcCap = m_ptMtTable->GetSrcSCS(tSrc.GetMtId());
// 		//当终端过适配建交换到上级mcu的上传端口时，如果上传端口为264格式就直接适配到cif,
// 		//因为如果上级开启画面合成且如果上传端口的格式是264高清格式，适配的码流直接建到上级画面合成会导致画面合成撑死,
// 		//所以策略改为都适配到264cif
// 		if( !m_tCascadeMMCU.IsNull() && tDst == m_tCascadeMMCU &&		
// 			tDstSimCapSet.GetVideoMediaType() == MEDIA_TYPE_H264 &&
// 			tSrcCap.GetVideoMediaType() != MEDIA_TYPE_H264 &&
// 			tDstSimCapSet.GetVideoResolution() != VIDEO_FORMAT_CIF )
// 		{
// 			tDstSimCapSet.SetVideoResolution( VIDEO_FORMAT_CIF );
// 		}
		
	}
	else if ( byMediaMode==MODE_SECVIDEO )
	{
		tDstSimCapSet = m_ptMtTable->GetDstDSSCS(tlocalDst.GetMtId());
	}
	else if (byMediaMode == MODE_VIDEO2SECOND)
	{
		tDstSimCapSet = m_ptMtTable->GetDstDSSCS(tlocalDst.GetMtId());
		byMediaMode = MODE_VIDEO;
	}
	else
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[IsNeedAdjustSelParam]byMediaMode:%d is illegal!\n", byMediaMode);
		return FALSE;
	}

	THDAdaptParam atParam[MAXNUM_BASOUTCHN];
	u8 byCurrOutNum = 0;
	if( g_cMcuVcApp.GetBasOutPutParam(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId, byCurrOutNum, atParam) )
	{
		if ( atParam[tOutInfo.m_byOutIdx].GetVidType() == tDstSimCapSet.GetVideoMediaType() &&
			 (atParam[tOutInfo.m_byOutIdx].GetProfileType() != tDstSimCapSet.GetVideoProfileType() ||
			  GetResByWH(atParam[tOutInfo.m_byOutIdx].GetWidth(), atParam[tOutInfo.m_byOutIdx].GetHeight()) != tDstSimCapSet.GetVideoResolution() 
			 )
		   )
		{
			//return GetBasChnForSel(tOrigSrc,tDstSimCapSet,byMediaMode,pcBasChn,tChnCapData,FALSE);
			//查找是否有可用的同源通道支持
			TMt tLocalSrc = GetLocalMtFromOtherMcuMt(tOrigSrc);	
			TSimCapSet tSrcCap = m_ptMtTable->GetSrcSCS(tLocalSrc.GetMtId());
			CBasChn *apcBasChn[MAXNUM_PERIEQP]={NULL};
			u8		byChnNum = 0;
			TVideoStreamCap	atOccpiedSimCapSet[MAX_CONF_BAS_ADAPT_NUM];
			if ( GetBasSelChnGrp(byChnNum,apcBasChn,byMediaMode) )
			{
				for ( u8 byIdx = 0; byIdx<byChnNum; byIdx++ )
				{
					if ( NULL == apcBasChn[byIdx] )
					{
						continue;
					}
					
					if ( apcBasChn[byIdx]->GetSrc() == tOrigSrc &&
						apcBasChn[byIdx]->GetMediaMode() == byMediaMode
						)
					{
						TNeedVidAdaptData	tBasNeeds;
						if ( GetBasNeedResDataByCap(tSrcCap, tDstSimCapSet,byMediaMode, tBasNeeds) )
						{
							TNeedVidAdaptData tTempBasNeeds;
							memcpy(&tTempBasNeeds,&tBasNeeds,sizeof(TNeedVidAdaptData));
							if ( apcBasChn[byIdx]->IsBasChnSupportNeeds(tTempBasNeeds,atOccpiedSimCapSet) )
							{
								if ( tTempBasNeeds.m_byRealEncNum != 0 )
								{
									continue;
								}
								
								tChnCapData.atBasChnCap[0].SetVidepCapSet(tBasNeeds.m_atSimCapSet[0]);
								*pcBasChn = apcBasChn[byIdx];
								return TRUE;
							}
						}
					}
				}
			}
		}
	}
	return FALSE;
}

/*====================================================================
函数名         GetBasDecPT
功能        ： 根据bas源和请求的媒体类型获取bas的解码类型
算法实现    ：
引用全局变量：
输入参数说明： tBasSrc, Bas源;
			   byMediaMode, 媒体模式
			   byVidBasDecPT, 视频或双流的解码类型
			   byAudBasDecPt, 音频的解码类型
返回值说明  ： TRUE,成功; 否则,失败
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/11    1.0          刘旭          创建
====================================================================*/
const BOOL32 CMcuVcInst::GetBasDecPT( const TMt& tBasSrc, const u8 byMode, u8& byVidBasDecPT, u8& byAudBasDecPt,TLogicalChannel &tSrcLgcChn)
{
	byVidBasDecPT =  byAudBasDecPt = MEDIA_TYPE_NULL;							// 重置返回值

	//适配通道源为终端
	if (TYPE_MT == tBasSrc.GetType())
	{
		u8 byMtId = tBasSrc.GetMtId();							// 源Id
		if( !tBasSrc.IsLocal() )								// 源非本级终端, 获取它在本级的id
		{
			byMtId = GetFstMcuIdFromMcuIdx( tBasSrc.GetMcuId() );
		}

		switch (byMode)
		{
		case MODE_AUDIO:
			{
				if (m_ptMtTable->GetMtLogicChnnl( byMtId, LOGCHL_AUDIO, &tSrcLgcChn, FALSE))
				{
					byAudBasDecPt = tSrcLgcChn.GetChannelType();
				}
				else
				{
					ConfPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[GetBasDecPT] GetMtLogicChnnl tBasSrc<MtId:%d, LgcMode:%d> failed!\n", tBasSrc.GetMtId(), LOGCHL_AUDIO);
				}
			}
			break;
		case MODE_VIDEO:
			{
				if (m_ptMtTable->GetMtLogicChnnl(byMtId/*tBasSrc*/, LOGCHL_VIDEO, &tSrcLgcChn, FALSE))
				{
					byVidBasDecPT = tSrcLgcChn.GetChannelType();				
					TLogicalChannel tAudSrcLgcChn;
					if (m_ptMtTable->GetMtLogicChnnl(byMtId/*tBasSrc*/, LOGCHL_AUDIO, &tAudSrcLgcChn, FALSE))
					{
						byAudBasDecPt = tAudSrcLgcChn.GetChannelType();
					}
					else
					{
						ConfPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[GetBasDecPT] GetMtLogicChnnl tBasSrc<MtId:%d, LgcMode:%d> failed!\n", tBasSrc.GetMtId(), LOGCHL_AUDIO);
					}
				}
				else
				{
					ConfPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[GetBasDecPT] GetMtLogicChnnl tBasSrc<MtId:%d, LgcMode:%d> failed!\n", tBasSrc.GetMtId(), LOGCHL_VIDEO);
				}
			}
			break;
		case MODE_SECVIDEO:
			{
				if (m_ptMtTable->GetMtLogicChnnl(byMtId/*tBasSrc*/, LOGCHL_SECVIDEO, &tSrcLgcChn, FALSE))
				{
					byVidBasDecPT = tSrcLgcChn.GetChannelType();
				}
				else
				{
					ConfPrint(LOG_LVL_WARNING, MID_MCU_BAS, "[GetBasDecPT] GetMtLogicChnnl tBasSrc<MtId:%d, LgcMode:%d> failed!\n", tBasSrc.GetMtId(), LOGCHL_SECVIDEO);
				}
			}
			break;
		default:
			break;
		}
	}
	//适配源为外设
	else if(TYPE_MCUPERI == tBasSrc.GetType())
	{
		if (EQP_TYPE_RECORDER == tBasSrc.GetEqpType())
		{
			switch (byMode)
			{
			case MODE_AUDIO:
				{
					byAudBasDecPt = m_tPlayEqpAttrib.GetAudioType();
					tSrcLgcChn.SetMediaType( byAudBasDecPt );
					tSrcLgcChn.SetAudioTrackNum( m_tPlayEqpAttrib.GetAudTrackNum() );
				}
				break;
			case MODE_VIDEO:
				{
					byVidBasDecPT	  = m_tPlayEqpAttrib.GetVideoType();
					byAudBasDecPt	  = m_tPlayEqpAttrib.GetAudioType();
					if (MEDIA_TYPE_NULL == byVidBasDecPT)
					{
						byVidBasDecPT = m_tConf.GetMainVideoMediaType();
					}
					if (MEDIA_TYPE_NULL == byAudBasDecPt)
					{
						byAudBasDecPt = m_tConf.GetMainAudioMediaType();
					}
					tSrcLgcChn.SetChannelType(byVidBasDecPT );
					u16 wWidth =  0 ;
					u16 wHeight = 0;
					m_tPlayFileMediaInfo.GetVideo( byVidBasDecPT, wWidth,  wHeight );
					u8 byRes = GetResByWH( wWidth, wHeight);
					tSrcLgcChn.SetVideoFormat(byRes);
					if( byVidBasDecPT == MEDIA_TYPE_H264 )
					{
						tSrcLgcChn.SetChanVidFPS(m_tConf.GetMainVidUsrDefFPS());
					}
					else
					{
						tSrcLgcChn.SetChanVidFPS( m_tConf.GetSecVidFrameRate() );
					}
				}
				break;
			case MODE_SECVIDEO:
				{
					byVidBasDecPT = m_tPlayEqpAttrib.GetDVideoType();
					if (MEDIA_TYPE_NULL == byVidBasDecPT)
					{
						byVidBasDecPT = m_tConf.GetDStreamMediaType();
					}

					tSrcLgcChn.SetChannelType(byVidBasDecPT );
					u16 wWidth =  0 ;
					u16 wHeight = 0;
					m_tPlayFileMediaInfo.GetDVideo( byVidBasDecPT, wWidth,  wHeight );
					u8 byRes = GetResByWH( wWidth, wHeight);
					tSrcLgcChn.SetVideoFormat(byRes);
					if( byVidBasDecPT == MEDIA_TYPE_H264 )
					{
						tSrcLgcChn.SetChanVidFPS(m_tConf.GetDStreamUsrDefFPS());
					}
					else
					{
						tSrcLgcChn.SetChanVidFPS( VIDEO_FPS_2997_6);
					}
				}
				break;
			default:
				break;
			}
		}
		else if (EQP_TYPE_VMP == tBasSrc.GetEqpType())
		{
			//[nizhijun 2012/06/29] 录像机适配录像，如果源是VMP，不走BAS，直接收VMP的相关码流。
			//适配录像，VMP广播，不走BAS逻辑，如果代码进入此处，说明存在错误
			ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[GetBasDecPT]error:when vmp brd and Adapt Rec!\n");
			return FALSE;
// 			if (MODE_VIDEO == byMode)
// 			{
// 				if (IsRecNeedAdapt())
// 				{
// 					// vmp适配录像时, 采用适配录像格式
// 					byVidBasDecPT = m_tRecAdaptParam.GetVideoMediaType();
// 					ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "[GetBasDecPT]byVidBasDecPT is %d when vmp brd and Adapt Rec\n", byVidBasDecPT);
// 					return TRUE;
// 				}
// 			}
		}
	}

	if ( byMode == MODE_AUDIO &&  byAudBasDecPt == MEDIA_TYPE_NULL)
	{
		return FALSE;
	}
	
	if ( ( byMode == MODE_VIDEO || byMode == MODE_SECVIDEO) &&  byVidBasDecPT == MEDIA_TYPE_NULL)
	{
		return FALSE;
	}

	return TRUE;
}

/*====================================================================
函数名         IsSelInDoubleMedia
功能        ： 是否满足双格式不过BAS的选看
算法实现    ：
引用全局变量：
输入参数说明：TMt &tSrc 选看源；TMt &tDst 选看目的；

  返回值说明  ： TRUE,满足; FALSE,不满足
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  2011/02/22   4.6         倪志俊          创建
  ====================================================================*/
BOOL32 CMcuVcInst::IsSelInDoubleMedia(const TMt &tSrc,const TMt &tDst)
{
	if (tSrc.IsNull() || tDst.IsNull())
	{
		ConfPrint( LOG_LVL_WARNING, MID_MCU_CONF, "[IsSelInDoubleMedia]tSrc is NULL or tDst is NULL!\n");
		return FALSE;
	}  
	if (TYPE_MCUPERI == tSrc.GetType() && EQP_TYPE_VMP == tSrc.GetEqpType())
	{
		ConfPrint( LOG_LVL_WARNING, MID_MCU_CONF, "[IsSelInDoubleMedia]vmp don't need adapt!\n");
		return FALSE;
	}
	  
	TMt			tTempSrc;
	TSimCapSet  tMVSrcCap;
	TMt			tTempDst;
	TSimCapSet  tMVDstCap;
	
	tTempSrc = GetLocalMtFromOtherMcuMt(tSrc);
	tMVSrcCap = m_ptMtTable->GetSrcSCS(tTempSrc.GetMtId());
	tTempDst = GetLocalMtFromOtherMcuMt(tDst);
	tMVDstCap = m_ptMtTable->GetDstSCS(tTempDst.GetMtId());
	  
	if( tMVDstCap.IsNull() || tMVSrcCap.IsNull() )
	{
		ConfPrint( LOG_LVL_WARNING, MID_MCU_CONF, "[IsSelInDoubleMedia]tMVDstCap is NULL or tMVSrcCap is NULL!\n");
		return FALSE;
	}
	
	if (tMVDstCap.GetVideoMediaType() != tMVSrcCap.GetVideoMediaType())
	{
		if (g_cMcuVcApp.IsSelInDoubleMediaConf())
		{
			ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[IsSelInDoubleMedia]tDst%d select tSrc%d SelInDoubleMedia\n",tTempDst.GetMtId(), tTempSrc.GetMtId());
			return TRUE;
		}
	}
	return FALSE;
}

/*====================================================================
函数名         IsBasChnForRec
功能        ： 判断是否用户自定义适配录像
算法实现    ：
引用全局变量：
输入参数说明： const TEqp& tBas,
				u8 byChnId
返回值说明  ： TRUE,需要; FALSE,不需要
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/11/23   4.7         倪志俊          创建
====================================================================*/
BOOL32 CMcuVcInst::IsBasChnForRecAdapt(const TEqp& tBas,u8 byChnId)
{
	if ( tBas.IsNull() )
	{
		return FALSE;
	}

	TRecBasChn tTempRecBas;
	tTempRecBas.m_tBas = tBas;
	tTempRecBas.m_byChnId = byChnId;
	u8 byTempMediaMode;
	if ( m_cRecAdaptMgr.IsExistMediaModeForRecAdpat(tTempRecBas,byTempMediaMode) )
	{
		return TRUE;
	}

	return FALSE;
}

/*====================================================================
函数名         IsRecNeedAdapt
功能        ： 判断是否用户自定义适配录像
算法实现    ：
引用全局变量：
输入参数说明： byMediaMode, 媒体模式,默认为MODE_VIDEO

返回值说明  ： TRUE,需要; FALSE,不需要
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/10/25    1.0          刘旭          创建
2013/02/20  4.7          倪志俊        修改
====================================================================*/
BOOL32 CMcuVcInst::IsRecNeedAdapt(u8 byMediaMode)
{
	if ( MODE_BOTH == byMediaMode )
	{
		if ( IsRecNeedAdapt(MODE_VIDEO) ||
			 IsRecNeedAdapt(MODE_SECVIDEO) ||
			 IsRecNeedAdapt(MODE_AUDIO)
			)
		{
			return TRUE;
		}
		
		return FALSE;
	}

	if (MODE_VIDEO == byMediaMode)
	{
		TVideoStreamCap tTempVidCap;
		if ( m_cRecAdaptMgr.GetRecVideoCapSet(byMediaMode,tTempVidCap) )
		{
#ifdef _8KI_
			return FALSE;
#else
			return TRUE;
#endif
		}
	}

	if (MODE_SECVIDEO == byMediaMode)
	{
		TVideoStreamCap tTempSecVidCap;
		if ( m_cRecAdaptMgr.GetRecVideoCapSet(byMediaMode,tTempSecVidCap) )
		{
#ifdef _8KI_
			return FALSE;
#else
			return TRUE;
#endif
		}
	}

	if (MODE_AUDIO == byMediaMode)
	{
		TAudioTypeDesc tAudCap;
		if ( m_cRecAdaptMgr.GetRecAudCapSet(tAudCap) )
		{
			return TRUE;
		}
	}

	return FALSE;
}

/*====================================================================
函数名         IsRecAdaptUseBas
功能        ：判断用户自定义适配录像是否需要适配器
算法实现    ：
引用全局变量：
输入参数说明： 

返回值说明  ： TRUE,需要; FALSE,不需要
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
20120629    4.7          倪志俊          创建
====================================================================*/
BOOL32 CMcuVcInst::IsRecAdaptUseBas()
{
	//[nizhijun 2012/06/29] 录像机适配录像，如果源是VMP，不走BAS，直接收VMP的相关码流。
	if (  IsRecNeedAdapt(MODE_VIDEO) && !g_cMcuVcApp.IsBrdstVMP(m_tVmpEqp) )
	{
		ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_REC,"[IsRecAdaptUseBas]rec adapt need use bas\n");
		return TRUE;
	}
	
	ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_REC,"[IsRecAdaptUseBas]rec adapt don't need use bas\n");
	return FALSE;
}

/*=============================================================================
函 数 名： InitRecAdptParamByMediaMode
功    能： 根据模式对自定义格式录像的各项参数进行初始化
算法实现： 
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2013/02/04  4.7          倪志俊				   创建
=============================================================================*/
/*lint -save -e527*/
BOOL32 CMcuVcInst::InitRecAdptParamByMediaMode(u8 byMediaMode) 
{
	switch ( byMediaMode )
	{
	case MODE_VIDEO:
		{
			if ( IsRecNeedAdapt(MODE_VIDEO) )
			{	
				// 与会议主能力相适应的解码能力
				s16 swMainDecAbility = GetDecAbility(m_tConf.GetCapSupport().GetMainSimCapSet());
				// 与会议辅能力相适应的解码能力
				s16 swSecDecAbility = GetDecAbility(m_tConf.GetCapSupport().GetSecondSimCapSet());
				
				// 会议所需最高的解码能力所对应的同时能力集
				TSimCapSet tHigherDecSim;			
				if (swMainDecAbility >= swSecDecAbility)			// 主能力所需解码能力大于辅能力所需解码能力?
				{
					tHigherDecSim = m_tConf.GetCapSupport().GetMainSimCapSet();
				}
				else
				{
					tHigherDecSim = m_tConf.GetCapSupport().GetSecondSimCapSet();
				}

				// 调整录像适配能力集
				AdjustRecAdptParam(MODE_VIDEO);
				
				TVideoStreamCap tVidCapSet;
				m_cRecAdaptMgr.GetRecVideoCapSet(MODE_VIDEO,tVidCapSet);

				TSimCapSet tMainSimCapSet;
				tMainSimCapSet.SetVideoCap(tVidCapSet);
				CBasChn *pcBasChnData=NULL;				//将要申请到的适配通道信息
				TBasChnCapData tBasCapData;
				if(!g_cMcuVcApp.GetIdleBasChn(tHigherDecSim, tMainSimCapSet, MODE_VIDEO, &pcBasChnData, &tBasCapData))
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_REC, "[InitRecAdptParamByMediaMode]Get idle Bas Chn for mainvid failed\n");
					return FALSE;
				}
				
				// 保存申请到的bas信息
				TRecBasChn tMainVidBasChn;
				tMainVidBasChn.m_tBas = pcBasChnData->GetBas();
				tMainVidBasChn.m_tBas.SetConfIdx(m_byConfIdx);
				tMainVidBasChn.m_byChnId = pcBasChnData->GetChnId();
				m_cRecAdaptMgr.AddRecBasChn( MODE_VIDEO,tMainVidBasChn);
				TEqp tTempBas = pcBasChnData->GetBas();
				tTempBas.SetConfIdx(m_byConfIdx);
				pcBasChnData->SetBas(tTempBas);
				AssignBasSelChn(pcBasChnData,tBasCapData,m_tConf.GetConfId());
				// 设置适配源
				SetBasChnSrc(tMainVidBasChn.m_tBas, tMainVidBasChn.m_byChnId, GetVidBrdSrc());
				// 设置通道媒体模式
				SetBasChnMode(tMainVidBasChn.m_tBas, tMainVidBasChn.m_byChnId,MODE_VIDEO);
				
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "[InitRecAdptParamByMediaMode]get baschn for mainvid,eqpid:%d, chnid:%d\n", 
						  tMainVidBasChn.m_tBas.GetEqpId(), tMainVidBasChn.m_byChnId
						  );
				
				
				
				// 设置适配参数
				THDAdaptParam tParam;
				
				// 获取并设置分辨率
				u16 wWidth  = 0;
				u16 wHeight = 0;
				GetWHByRes(tMainSimCapSet.GetVideoResolution(), wWidth, wHeight);
				tParam.SetResolution(wWidth, wHeight);
				
				// 设置音视频类型及动态类型
				tParam.SetAudType(tMainSimCapSet.GetAudioMediaType());
				tParam.SetVidType(tMainSimCapSet.GetVideoMediaType());
				tParam.SetVidActiveType(GetActivePayload(m_tConf, tMainSimCapSet.GetVideoMediaType()));
				tParam.SetProfileType(tMainSimCapSet.GetVideoProfileType());
				TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
                tParam.SetIsNeedByPrs(tConfAttrb.IsResendLosePack());
				
				// 低速录像，获取会议的最低码率
				u16 wBitRate = ( m_tRecPara.IsRecLowStream() ? m_tConf.GetSecBitRate() : m_tConf.GetBitRate());
				// 设置适配码率
				tParam.SetBitRate(wBitRate);
				
				// 设置帧率
				if (MEDIA_TYPE_H264 == tMainSimCapSet.GetVideoMediaType())
				{
					tParam.SetFrameRate(tMainSimCapSet.GetUserDefFrameRate());
				}
				else
				{	
					tParam.SetFrameRate(tMainSimCapSet.GetVideoFrameRate());
				}
				
				// Log输出
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, 
					"[InitRecAdptParamByMediaMode]main vid Adapt Rec param: VidType[%d, Active.%d], Res[%d, %d], BitRate.%d, FrmRate.%d, profile:%d\n",
					tParam.GetVidType(), 
					tParam.GetVidActiveType(),
					tParam.GetWidth(),
					tParam.GetHeight(),
					tParam.GetBitrate(),
					tParam.GetFrameRate(),
					tParam.GetProfileType()
					);
				
				//保存适配参数
				if ( !SetBasSelChnParam(tMainVidBasChn.m_tBas, tMainVidBasChn.m_byChnId, MODE_VIDEO,tParam) )
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_REC, "[InitRecAdptParamByMediaMode]main vid SetBasAdaptParam failed!\n");
					return FALSE;
				}
			} 
			else
			{
				return TRUE;
			}
		}
		break;
	case MODE_SECVIDEO:
		{
			if ( IsRecNeedAdapt(MODE_SECVIDEO) )
			{
				//获取双流所需编码能力
				TVideoStreamCap tSecVidCapSet;
				m_cRecAdaptMgr.GetRecVideoCapSet(MODE_SECVIDEO,tSecVidCapSet);
			
				//获取双流解码能力
				TVideoStreamCap tSecVidDecSim = m_tConf.GetCapSupport().GetDStreamCapSet().GetVideoStremCap();
				TSimCapSet tSecDecCapSet;
				tSecDecCapSet.SetVideoCap( tSecVidDecSim );
				
				TSimCapSet tSecSimCapSet;
				tSecSimCapSet.SetVideoCap(tSecVidCapSet);
				CBasChn *pcBasChnData=NULL;	
				TBasChnCapData tBasCapData;
				if(!g_cMcuVcApp.GetIdleBasChn(tSecDecCapSet, tSecSimCapSet, MODE_SECVIDEO, &pcBasChnData, &tBasCapData))
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_REC, "[InitRecAdptParamByMediaMode]Get idle Bas Chn for secvid failed\n");
					return FALSE;
				}
				
				// 保存申请到的bas信息
				TRecBasChn tSecVidBasChn;
				tSecVidBasChn.m_tBas = pcBasChnData->GetBas();
				tSecVidBasChn.m_tBas.SetConfIdx(m_byConfIdx);
				tSecVidBasChn.m_byChnId = pcBasChnData->GetChnId();
				m_cRecAdaptMgr.AddRecBasChn( MODE_SECVIDEO,tSecVidBasChn );
				TEqp tTempBas = pcBasChnData->GetBas();
				tTempBas.SetConfIdx(m_byConfIdx);
				pcBasChnData->SetBas(tTempBas);
				AssignBasSelChn(pcBasChnData,tBasCapData,m_tConf.GetConfId());
				// 设置适配源
				SetBasChnSrc(tSecVidBasChn.m_tBas, tSecVidBasChn.m_byChnId, m_tDoubleStreamSrc);
				// 设置通道媒体模式
				SetBasChnMode(tSecVidBasChn.m_tBas, tSecVidBasChn.m_byChnId,MODE_SECVIDEO);
				
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "[InitRecAdptParamByMediaMode]get baschn for secvid,eqpid:%d, chnid:%d\n", 
					tSecVidBasChn.m_tBas.GetEqpId(), tSecVidBasChn.m_byChnId
					);
				
				// 设置适配参数
				THDAdaptParam tParam;
				
				// 获取并设置分辨率
				u16 wWidth  = 0;
				u16 wHeight = 0;
				GetWHByRes(tSecSimCapSet.GetVideoResolution(), wWidth, wHeight);
				tParam.SetResolution(wWidth, wHeight);
				
				// 设置音视频类型及动态类型
				tParam.SetAudType(tSecSimCapSet.GetAudioMediaType());
				tParam.SetVidType(tSecSimCapSet.GetVideoMediaType());
				tParam.SetVidActiveType(GetActivePayload(m_tConf, tSecSimCapSet.GetVideoMediaType()));
				tParam.SetProfileType(tSecSimCapSet.GetVideoProfileType());
				TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
                tParam.SetIsNeedByPrs(tConfAttrb.IsResendLosePack());
				
				// 低速录像，获取会议的最低码率
				u16 wBitRate = ( m_tRecPara.IsRecLowStream() ? m_tConf.GetSecBitRate() : m_tConf.GetBitRate());
				// 设置适配码率
				tParam.SetBitRate(GetDoubleStreamVideoBitrate(wBitRate, FALSE));
				
				// 设置帧率
				if (MEDIA_TYPE_H264 == tSecSimCapSet.GetVideoMediaType())
				{
					tParam.SetFrameRate(tSecSimCapSet.GetUserDefFrameRate());
				}
				else
				{	
					tParam.SetFrameRate(tSecSimCapSet.GetVideoFrameRate());
				}
				
				// Log输出
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, 
					"[InitRecAdptParamByMediaMode]sec vid Adapt Rec param: VidType[%d, Active.%d], Res[%d, %d], BitRate.%d, FrmRate.%d profile:%d\n",
					tParam.GetVidType(), 
					tParam.GetVidActiveType(),
					tParam.GetWidth(),
					tParam.GetHeight(),
					tParam.GetBitrate(),
					tParam.GetFrameRate(),
					tParam.GetProfileType()
					);
				
				//保存适配参数
				if ( !SetBasSelChnParam(tSecVidBasChn.m_tBas, tSecVidBasChn.m_byChnId, MODE_SECVIDEO,tParam) )
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_REC, "[InitRecAdptParamByMediaMode]main vid SetBasAdaptParam failed!\n");
					return FALSE;
				}
			}
			else
			{
				return TRUE;
			}
		}
		break;
	case MODE_AUDIO:
		{
			if ( IsRecNeedAdapt(MODE_AUDIO) )
			{
				//音频适配录像走广播
// 				//获取音频解码能力
// 				TAudioTypeDesc tAudDecCap;
// 				tAudDecCap = m_tConfEx.GetMainAudioTypeDesc();
// 
// 				//获取双流所需编码能力
// 				TAudioTypeDesc tAudEncCap;
// 				m_cRecAdaptMgr.GetRecAudCapSet(tAudEncCap);
// 		
// 				
// 				//预占音频适配通道
// 				CBasChn *pcBasChnData=NULL;	
// 				TBasChnCapData tBasCapData;
// 				if( !g_cMcuVcApp.GetIdleAudBasChn(tAudDecCap, tAudEncCap, &pcBasChnData) )
// 				{
// 					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_REC, "[InitRecAdptParamByMediaMode]Get idle Bas Chn for audio failed\n");
// 					return FALSE;
// 				}
// 
// 				tBasCapData.atBasChnCap[0].SetAudCapSet( tAudEncCap);
// 
// 				// 保存申请到的bas信息
// 				TRecBasChn tAudBasChn;
// 				tAudBasChn.m_tBas = pcBasChnData->GetBas();
// 				tAudBasChn.m_tBas.SetConfIdx(m_byConfIdx);
// 				tAudBasChn.m_byChnId = pcBasChnData->GetChnId();
// 				m_cRecAdaptMgr.AddRecBasChn( MODE_AUDIO,tAudBasChn );
// 				AssignBasSelChn(pcBasChnData,tBasCapData,m_tConf.GetConfId());
// 				// 设置适配源
// 				SetBasChnSrc(tAudBasChn.m_tBas, tAudBasChn.m_byChnId, m_tDoubleStreamSrc);
// 				// 设置通道媒体模式
// 				SetBasChnMode(tAudBasChn.m_tBas, tAudBasChn.m_byChnId,MODE_AUDIO);
// 				
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "[InitRecAdptParamByMediaMode]get baschn for aud,eqpid:%d, chnid:%d\n", 
// 					tAudBasChn.m_tBas.GetEqpId(), tAudBasChn.m_byChnId
// 					);
// 		
// 				// 设置适配参数
// 				TAudAdaptParam tParam;
// 				tParam.SetAudCodeType( tAudEncCap.GetAudioMediaType() );
// 				tParam.SetAudActiveType( GetActivePayload(m_tConf,tAudEncCap.GetAudioMediaType()) );
// 				tParam.SetTrackNum( tAudEncCap.GetAudioTrackNum() );
// 				TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
//                 tParam.SetIsNeedByPrs(tConfAttrb.IsResendLosePack());
// 
// 				// Log输出
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, 
// 					"[InitRecAdptParamByMediaMode]audio Adapt Rec param: Type[%d, Active.%d], tracknum.%d, prs.%d \n",
// 					tParam.GetAudCodeType(),
// 					tParam.GetAudActiveType(),
// 					tParam.GetTrackNum(),
// 					tParam.IsNeedbyPrs()
// 					);
// 				
// 				//保存适配参数
// 				if ( !SetBasSelAudChnParam(tAudBasChn.m_tBas, tAudBasChn.m_byChnId,tParam) )
// 				{
// 					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_REC, "[InitRecAdptParamByMediaMode]aud SetBasSelAudChnParam failed!\n");
// 					return FALSE;
// 				}
// 			
				return TRUE;
			}
			else
			{
				return TRUE;
			}
		}
		break;
	default:
		ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[InitRecAdptParamByMediaMode]byMediaMode:%d is wrong!\n",byMediaMode);
		return FALSE;
		break;
	}

	return TRUE;
}
/*lint -restore*/

/*=============================================================================
函 数 名： InitRecAdptParam
功    能： 对自定义格式录像的各项参数进行初始化
算法实现： 目前只考虑视频格式和分辨率适配
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2010/10/26  4.6		     刘旭                  创建
2012/02/09  4.7          倪志俊				   修改
=============================================================================*/
BOOL32 CMcuVcInst::InitRecAdptParam() 
{
	if ( InitRecAdptParamByMediaMode(MODE_VIDEO) &&
		 InitRecAdptParamByMediaMode(MODE_SECVIDEO)&&
		 InitRecAdptParamByMediaMode(MODE_AUDIO)
		)
	{
		return TRUE;
	}

	ResetRecAdptParam();
	return FALSE;
}


/*=============================================================================
函 数 名： ResetRecAdptParam
功    能： 对自定义格式录像的各项参数进行重置
算法实现： 目前只考虑视频格式和分辨率适配
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2010/10/21  4.6		     刘旭                  创建
2011/02/09  4.7			 倪志俊					修改
=============================================================================*/
void CMcuVcInst::ResetRecAdptParam(u8 byMediaMode /*= MODE_BOTH*/) 
{
	if ( byMediaMode == MODE_BOTH )
	{
		ResetRecAdptParam(MODE_AUDIO);
		ResetRecAdptParam(MODE_VIDEO);
		ResetRecAdptParam(MODE_SECVIDEO);
		return;
	}

	TRecBasChn tTempBasChn;
	if ( m_cRecAdaptMgr.IsExistRecBasChn( byMediaMode,tTempBasChn)  &&
		 byMediaMode != MODE_AUDIO
		)
	{
		TMt tBasSrc = GetBasChnSrc(tTempBasChn.m_tBas, tTempBasChn.m_byChnId);
		
		// 停止适配及交换
		StopBasAdapt(tTempBasChn.m_tBas, tTempBasChn.m_byChnId);
		//释放资源
		g_cMcuVcApp.ReleaseBasChn(tTempBasChn.m_tBas, tTempBasChn.m_byChnId);
		//移除选看通道资源
		ReMoveBasSelChn(tTempBasChn.m_tBas, tTempBasChn.m_byChnId);
		//更新外设状态为ready
		g_cMcuVcApp.UpdateBasChnStatus(tTempBasChn.m_tBas, tTempBasChn.m_byChnId, BASCHN_STATE_READY);
	}

	// 清除管理对象中的数据
	m_cRecAdaptMgr.Clear(byMediaMode);
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "ResetRecAdptParam, Adapt Rec:%d-%d over!\n",tTempBasChn.m_tBas.GetEqpId(), tTempBasChn.m_byChnId);

	return ;
}

/*=============================================================================
函 数 名： AdjustRecAdptParam
功    能： 对自定义格式参数进行调整
算法实现： 目前只考虑视频格式和分辨率适配
全局变量： 
参    数： 
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2010/10/21  1.0		     刘旭                  创建
2013/02/20  4.7          倪志俊				   修改
=============================================================================*/
BOOL32 CMcuVcInst::AdjustRecAdptParam(u8 byMediaMode)
{
	if ( MODE_VIDEO == byMediaMode )
	{
		// 自定义能力集必须与会议配置的主的或者辅的视频格式能力集相适应
		const TSimCapSet *ptBaseCapSet = NULL;			// 基准能力集
		
		// 获取主能力集
		const TSimCapSet tMainCapSet = m_tConf.GetCapSupport().GetMainSimCapSet();
		// 获取辅能力集
		const TSimCapSet tSecCapSet = m_tConf.GetCapSupport().GetSecondSimCapSet();

		TVideoStreamCap tTempVidCap;
		m_cRecAdaptMgr.GetRecVideoCapSet(byMediaMode,tTempVidCap);
		
		// 将基准能力集设为自定义视频格式一致的主的或辅的能力集
		if ( tTempVidCap.GetMediaType() == tMainCapSet.GetVideoMediaType())
		{
			ptBaseCapSet = &tMainCapSet;
		}
		else if (tTempVidCap.GetMediaType() == tSecCapSet.GetVideoMediaType())
		{
			ptBaseCapSet = &tSecCapSet;
		}
		
		// 码率调整, 目前不支持码率自定义, 设为基准能力集的视频码率
		if (!ptBaseCapSet)
		{
			return FALSE;
		}
		
		tTempVidCap.SetMaxBitRate(ptBaseCapSet->GetVideoMaxBitRate());
		
		//[nizhijun 2012/03/27]对于非H264的去自定义帧率设置帧率，H264的直接使用界面设定的帧率
		if (MEDIA_TYPE_H264 != tTempVidCap.GetMediaType() )
		{
			tTempVidCap.SetFrameRate(ptBaseCapSet->GetVideoFrameRate());
		}
				
		// [特殊处理]如果用户设定了Mpeg-4, Auto, 则分辨率需要根据码率调整为CIF,2cif或4cif
		if (MEDIA_TYPE_MP4 == tTempVidCap.GetMediaType() && 
			VIDEO_FORMAT_AUTO == tTempVidCap.GetResolution() )
		{
			// 获取会议的最低码率
			u16 wBitrate = m_tConf.GetSecBitRate();
			if (0 == wBitrate)
			{
				wBitrate = m_tConf.GetBitRate();
			}
			
			if (wBitrate > MPEG4_MAX_BT_2CIF)
			{
				tTempVidCap.SetResolution(VIDEO_FORMAT_4CIF);
			}else if (wBitrate > MPEG4_MAX_BT_CIF)
			{
				tTempVidCap.SetResolution(VIDEO_FORMAT_2CIF);
			}else
			{
				tTempVidCap.SetResolution(VIDEO_FORMAT_CIF);
			}		
		}
		
		m_cRecAdaptMgr.SetRecVideoCapSet(byMediaMode, tTempVidCap);

		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_REC, "m_tRecAdaptParam: VidType = %d, Res = %d, VidBr = %d, VidFr = %d\n", 
			tTempVidCap.GetMediaType(),
			tTempVidCap.GetResolution(),
			tTempVidCap.GetMaxBitRate(),
			( MEDIA_TYPE_H264 == tTempVidCap.GetMediaType() ) ? tTempVidCap.GetUserDefFrameRate() :tTempVidCap.GetFrameRate());
	}

	return TRUE;
}

/*====================================================================
函数名      :  OnMtRecDStreamSrcChanged
功能        ： 双流通道源发生改变时,对正在进行终端的录像机通道进行处理
算法实现    ：
引用全局变量：
输入参数说明：[in]bStopBeforeStart, 双流源改变为另一个双流源时为true, 用于先停到录像机通道的交换
                                    其它场景为false
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/05/28    1.0         刘旭            创建
====================================================================*/
void CMcuVcInst::OnMtRecDStreamSrcChanged(const BOOL32 bIsStart)
{
	if (m_tDoubleStreamSrc.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_REC, "[OnMtRecDStreamSrcChanged] OnMtRecDStreamSrcChanged param error!\n");
		return;
	}
	// 获取真正的双流源通道
	//const u8 bySrcChnnl = (m_tDoubleStreamSrc == m_tPlayEqp) ? m_byPlayChnnl : 0;

	TPeriEqpStatus tRecStatus;					// 录像机设备的状态
	TRecChnnlStatus tRecChnnlStatus;			// 录像机通道的状态

	// 遍历所有录像机通道, 如果某个通道正在为此会议进行终端录像, 则建立从双流源到录像机的交换
	for ( u8 byEqpId = RECORDERID_MIN; byEqpId <= RECORDERID_MAX; ++byEqpId )
	{
		if (!g_cMcuVcApp.IsPeriEqpConnected( byEqpId ) || !g_cMcuVcApp.IsPeriEqpValid(byEqpId))
		{
			continue;
		}

		if (!g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tRecStatus))
		{
			continue;
		}

		if (tRecStatus.IsNull())
		{
			continue;
		}

		u8 byRecChnNum = tRecStatus.m_tStatus.tRecorder.GetRecChnnlNum();
		for(u8 byRecChnnl = 0; byRecChnnl < byRecChnNum; byRecChnnl++)
		{
			if(TRUE == tRecStatus.m_tStatus.tRecorder.GetChnnlStatus(byRecChnnl, TRecChnnlStatus::TYPE_RECORD, &tRecChnnlStatus))
			{
				// 此通道没有录像, 则跳过
				if (TRecChnnlStatus::STATE_RECORDING != tRecChnnlStatus.m_byState
					&& TRecChnnlStatus::STATE_RECPAUSE != tRecChnnlStatus.m_byState )
				{
					continue;
				}

				//如果此通道有终端(非会议录像)，且此终端是本会议的
				if (!tRecChnnlStatus.m_tSrc.IsNull() && tRecChnnlStatus.m_tSrc.GetConfIdx() == m_byConfIdx)
				{
					//[2011/07/16/zhanlgi]整理录像机拆建RTP/RTCP交换
					AdjustMtRecSrcStream(MODE_SECVIDEO, TEqp(tRecStatus), byRecChnnl, (TMt)tRecChnnlStatus.m_tSrc, bIsStart);
				}
			}
		}
	}
}


/*====================================================================
函数名         RefreshBasParamForLowBrUse
功能        ： 需要低速码流场景下的刷新适配参数(usage at present: low br record and low br multicast)
算法实现    ：
引用全局变量：
输入参数说明：

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::RefreshBasParamForLowBrUse()
{
	if (IsRecNeedAdapt(MODE_VIDEO))
	{
		return FALSE;
	}
	TEqp tBas;
	tBas.SetNull();
	u8   byChnId  = 0;
	u8   byOutNum = 0;
	u8   byOutIdx = 0;
    if (!GetLowBrUseBasOutPutInfo(tBas, byChnId, byOutNum, byOutIdx))
    {
		ConfPrint(LOG_LVL_ERROR, MID_MCU_REC, "[RefreshBasParamForLowBrUse] GetLowBrUseBasOutPutInfo failed!\n");
		return FALSE;
    }
	THDAdaptParam atParam[MAXNUM_BASOUTCHN];
	if(!g_cMcuVcApp.GetBasOutPutParam(tBas, byChnId, byOutNum,  atParam))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_REC, "[RefreshBasParamForLowBrUse]GetBasOutPutParam failed!\n");
		return FALSE;
	}
	//[2011/06/28/zhangli]如果当前输出参数比第二码率低，不能设置
	if (atParam[byOutIdx].GetBitrate() > m_tConf.GetSecBitRate())
	{
		//设置会议第二速率
		atParam[byOutIdx].SetBitRate(m_tConf.GetSecBitRate());
		TBasOutInfo tOutInfo;
		tOutInfo.m_tBasEqp = tBas;
		tOutInfo.m_byChnId = byChnId;
		tOutInfo.m_byOutIdx = byOutIdx;
		tOutInfo.m_byOutNum = byOutNum;
		RefreshBasParambyOutIdx(tOutInfo,atParam[byOutIdx]);
		//g_cMcuVcApp.SetBasAdaptParam(m_tConf, tBas, byChnId, atParam[byOutIdx], TRUE);
		ChangeAdapt(tBas, byChnId);
	}
	return TRUE;
}


/*====================================================================
函数名         GetLowBrUseBasOutPutInfo
功能        ： 获取低速适配的适配输出(usage at present: low br record and low br multicast)
算法实现    ：
引用全局变量：
输入参数说明：

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/06/30    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::GetLowBrUseBasOutPutInfo( TEqp &tBas, u8 &byChnId, u8 &byOutNum, u8 &byOutIdx )
{
	TVideoStreamCap  tTempSimCapSet;
	if ( !GetProximalGrp(tTempSimCapSet) )
	{
		ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[GetLowBrUseBasOutPutInfo]GetProximalGrp failed!\n");
		return FALSE;
	}
	
	TBasOutInfo tOutInfo;
	if ( FindBasChnByCapForVidBrd(tTempSimCapSet,MODE_VIDEO,tOutInfo,TRUE) )
	{
		tBas = tOutInfo.m_tBasEqp;
		byChnId = tOutInfo.m_byChnId;
		byOutNum = tOutInfo.m_byOutNum;
		byOutIdx = tOutInfo.m_byOutIdx;
		return TRUE;
	}
	return FALSE;
}
/*====================================================================
函数名         GetCurConfMixMtNum
功能        ： 获取当前会议下参与混音的终端数目（计算下级MCU和普通终端）
算法实现    ：
引用全局变量：
输入参数说明：

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/10/29    4.0         田志勇        创建
====================================================================*/
u16 CMcuVcInst::GetCurConfMixMtNum(u16 wMcuIdx)
{
	u16 wCurMcuMixNum = 0;
	u16 wSMcuIdx = INVALID_MCUIDX;
	if (wMcuIdx == INVALID_MCUIDX) //包含本地与下级所有混音终端
	{
		for (u8 byMtid = 1; byMtid <= MAXNUM_CONF_MT; byMtid++)
		{
			if (m_tConfAllMtInfo.MtInConf(byMtid))
			{
				if (m_ptMtTable->IsMtInMixing(byMtid) )
				{
					if (m_ptMtTable->GetMtType(byMtid) == MT_TYPE_MT)
					{
						wCurMcuMixNum++;
					}
					else if (m_ptMtTable->GetMtType(byMtid) == MT_TYPE_SMCU)
					{
						wSMcuIdx = GetMcuIdxFromMcuId(byMtid);
						if( wSMcuIdx != INVALID_MCUIDX )
						{
							wCurMcuMixNum += GetCurConfMixMtNum(wSMcuIdx);
						}
						wCurMcuMixNum++;
					}
				}
			}
		}
	}
	else//取得某一个下级MCU混音终端
	{		
		if ( !IsValidSubMcuId(wMcuIdx) )
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetCurConfMixMtNum] invalid mcuidx (wMcuIdx.%d)!\n",wMcuIdx);
			return 0;
		}

		u8 abyMcuId[MAX_CASCADEDEPTH-1];
		memset( &abyMcuId[0],0,sizeof(abyMcuId) );
		if( !m_tConfAllMcuInfo.GetMcuIdByIdx( wMcuIdx,&abyMcuId[0] ) )
		{
            ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetCurConfMixMtNum] Fail to GetMcuId (wMcuIdx.%d)!\n",wMcuIdx);
			return 0;
		}
		TConfMcInfo *ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(wMcuIdx);
		if( NULL == ptConfMcInfo )
		{
            ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetCurConfMixMtNum] Fail to GetMcInfo (wMcuIdx.%d)!\n",wMcuIdx);
			return 0;
		}

		for (u8 byMtid = 0; byMtid < MAXNUM_CONF_MT; byMtid++)
		{
			if (!ptConfMcInfo->m_atMtStatus[byMtid].IsNull() && ptConfMcInfo->m_atMtStatus[byMtid].IsInMixing())
			{
				if (ptConfMcInfo->m_atMtExt[byMtid].GetMtType() == MT_TYPE_MT)
				{
					wCurMcuMixNum++;
				}
				else if (ptConfMcInfo->m_atMtExt[byMtid].GetMtType() == MT_TYPE_SMCU)
				{
					if( 0 == abyMcuId[1] )
					{
						abyMcuId[1] = ptConfMcInfo->m_atMtExt[byMtid].GetMtId();
						wSMcuIdx = GetMcuIdxFromMcuId(&abyMcuId[0],2);
						if( INVALID_MCUIDX != wSMcuIdx )
						{
							wCurMcuMixNum += GetCurConfMixMtNum(wSMcuIdx);
						}
						else
						{
							wCurMcuMixNum++;
						}

						abyMcuId[1] = 0;
					}					
				}
			}
		}
	}
	return wCurMcuMixNum;
}
/*====================================================================
函数名         IsConfDbCapDbBitrateCapH264OrMp4
功能        ： 会议是否双速双格式，且主辅格式分别为H264或者MP4
算法实现    ：
引用全局变量：
输入参数说明：

返回值说明  ：TRUE--会议是双速双格式，且主辅格式分别为H264或者MP4
			  FALSE--会议不是双速双格式，且主辅格式分别为H264或者MP4
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/11/10    4.0         zhouyiliang        创建
====================================================================*/
BOOL32 CMcuVcInst::IsConfDbCapDbBitrateCapH264OrMp4( )
{
	BOOL32 bRet = FALSE;
	if ( 	m_tConf.GetSecBitRate() != 0 && m_tConf.GetSecVideoMediaType() != MEDIA_TYPE_NULL &&
			(
				( m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_MP4 && m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_H264 ) ||
				( m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H264 && m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_MP4 )
			) 
		)
	{
		bRet = TRUE;
	}
	return bRet;
}
/*====================================================================
函数名         ClearSMcuAllMtMixStatusToAuto
功能        ： 将某下级MCU下终端进混音器属性为自动
算法实现    ：
引用全局变量：
输入参数说明：

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/04    4.0         田志勇        创建
====================================================================*/
void CMcuVcInst::ClearSMcuAllMtMixStatusToAuto(u16 wMcuIdx)
{
	u16 wSMcuIdx = INVALID_MCUIDX;
	if (wMcuIdx == INVALID_MCUIDX)//包含本地与下级所有混音终端
	{
		for (u8 byMtid = 1; byMtid <= MAXNUM_CONF_MT; byMtid++)
		{
			if (m_tConfAllMtInfo.MtInConf(byMtid))
			{
				if (m_ptMtTable->IsMtInMixing(byMtid) )
				{
					if (m_ptMtTable->GetMtType(byMtid) == MT_TYPE_MT)
					{
						m_ptMtTable->SetMtInMixing(byMtid, FALSE, TRUE);
					}
					else if (m_ptMtTable->GetMtType(byMtid) == MT_TYPE_SMCU)
					{
						wSMcuIdx = GetMcuIdxFromMcuId(byMtid);
						if( INVALID_MCUIDX != wSMcuIdx )
						{
							ClearSMcuAllMtMixStatusToAuto(wSMcuIdx);
						}
						
					}
				}
			}
		}
	}
	else//取得某一个下级MCU混音终端
	{		
		if (wMcuIdx >= MAXNUM_CONFSUB_MCU)
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[GetCurConfMixMtNum] invalid mcuidx (wMcuIdx.%d)\n",wMcuIdx);
			return;
		}
		u8 abyMcuId[MAX_CASCADEDEPTH-1];
		memset( &abyMcuId[0],0,sizeof(abyMcuId) );
		if( !m_tConfAllMcuInfo.GetMcuIdByIdx( wMcuIdx,&abyMcuId[0] ) )
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER,"[GetCurConfMixMtNum] Fail to GetMcuId (wMcuIdx.%d)\n",wMcuIdx);
			return;
		}
		TConfMcInfo *ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(wMcuIdx);
		if( NULL == ptConfMcInfo )
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER,"[GetCurConfMixMtNum] Fail to GetMcInfo (wMcuIdx.%d)\n",wMcuIdx);
			return;
		}

		for (u8 byMtid = 0; byMtid < MAXNUM_CONF_MT; byMtid++)
		{
			if (ptConfMcInfo->m_atMtStatus[byMtid].IsInMixing())
			{
				if (ptConfMcInfo->m_atMtExt[byMtid].GetMtType() == MT_TYPE_MT)
				{
					ptConfMcInfo->m_atMtStatus[byMtid].SetIsAutoInMix(TRUE);
				}
				else if (ptConfMcInfo->m_atMtExt[byMtid].GetMtType() == MT_TYPE_SMCU)
				{
					if( 0 == abyMcuId[1] )
					{
						abyMcuId[1] = ptConfMcInfo->m_atMtExt[byMtid].GetMtId();
						wSMcuIdx = GetMcuIdxFromMcuId(&abyMcuId[0],2);
						if( INVALID_MCUIDX != wSMcuIdx )
						{
							ClearSMcuAllMtMixStatusToAuto( wSMcuIdx );
						}
					}					
				}
			}
		}
	}
	return;
}
/*====================================================================
    函数名      ：ChairmanAutoSpecMix
    功能        ：将会议切为自动定制混音，混音组中只包含主席及发言人
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    01/10/11    4.0         田志勇        创建
====================================================================*/
void CMcuVcInst::ChairmanAutoSpecMix()
{
	// 由主席触发定制混音，必须保证主席在线
	if (!HasJoinedChairman())
	{
		return;
	}

	// 已经在会议讨论，只做指定主席操作，继续听讨论的效果
	if (m_tConf.m_tStatus.IsAutoMixing())
	{
		return;
	}
	// 已经在定制混音，自动将主席加入定制混音混音
	else if (m_tConf.m_tStatus.IsSpecMixing())
	{
		TMt tChairman = m_tConf.GetChairman();
		tChairman = GetLocalMtFromOtherMcuMt(tChairman);
		if (!m_ptMtTable->IsMtInMixGrp(tChairman.GetMtId()))
		{
			AddSpecMixMember(&tChairman, 1, TRUE);
		}
		return;
	}
	// 已经在VAC, 自动切换为定制混音
	else if (m_tConf.m_tStatus.IsVACing())
	{
		// 停止VAC
		CServMsg cSrvMsg;
		u8 byMixerSubtype = UNKONW_MIXER;
		g_cMcuAgent.GetMixerSubTypeByEqpId(m_tMixEqp.GetEqpId(),byMixerSubtype);
		if (byMixerSubtype == EAPU_MIXER || byMixerSubtype == APU2_MIXER)
		{
			TPeriEqpStatus tPeriEqpStatus;
            SendMsgToEqp(m_tMixEqp.GetEqpId(),MCU_MIXER_STOPVAC_CMD,cSrvMsg);
            g_cMcuVcApp.GetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriEqpStatus);
            tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[0].m_byGrpState = TMixerGrpStatus::READY;
			tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpId = 0;
			tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byConfId = 0;
            g_cMcuVcApp.SetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriEqpStatus);
            m_tConf.m_tStatus.SetVACing(FALSE);
			
            //停止向混音器交换数据
            TMt            tMt;
            for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
            {
                memset(&tMt,0,sizeof(TMt));
                if (m_tConfAllMtInfo.MtJoinedConf(byMtId))            
                {
                    tMt = m_ptMtTable->GetMt( byMtId );
                    StopSwitchToPeriEqp(m_tMixEqp.GetEqpId(), 
                        (MAXPORTSPAN_MIXER_GROUP*m_byMixGrpId/PORTSPAN+GetMixChnPos(tMt)), FALSE, MODE_AUDIO );
                    m_ptMtTable->SetMtInMixGrp(byMtId, FALSE);
                }   
            }
            if (HasJoinedChairman())
            {
                SendMsgToMt( m_tConf.GetChairman().GetMtId(), MCU_MT_STOPVAC_NOTIF, cSrvMsg );
            }
            //通知主席及所有会控
            SendMsgToAllMcs(MCU_MCS_STOPVAC_NOTIF, cSrvMsg);
            //混音状态通知,通知主席及所有会控
            MixerStatusChange();            
            NotifyChairmanMixMode();
            if ( !m_tCascadeMMCU.IsNull() )
            {
                OnNtfMtStatusToMMcu(m_tCascadeMMCU.GetMtId());
            }
            cSrvMsg.SetMsgBody((u8 *)&tPeriEqpStatus, sizeof(tPeriEqpStatus));
            SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cSrvMsg);

            m_tVacLastSpeaker.SetNull();
            m_tMixEqp.SetNull();
			TMt tChairman;
			TMt tSpeaker;
			tChairman.SetNull();
			tSpeaker.SetNull();
			memset( m_abyMixMtId, 0, sizeof(m_abyMixMtId) );
			memset(m_atMixMt,0,sizeof(m_atMixMt));
			if (m_tConf.HasChairman())
			{
				tChairman = m_tConf.GetChairman();
				m_ptMtTable->SetMtInMixing(tChairman.GetMtId(), TRUE,TRUE);
			}
			if (m_tConf.HasSpeaker())
			{
				TMt tLocalSpeaker;
				tLocalSpeaker.SetNull();
				tSpeaker = m_tConf.GetSpeaker();
				if (!tSpeaker.IsLocal())
				{
					tLocalSpeaker = GetLocalMtFromOtherMcuMt(tSpeaker);
					CServMsg cMsg;
					TMcu tMcu;
					tMcu.SetNull();
					tMcu.SetMcuId( tLocalSpeaker.GetMtId() );
					cMsg.SetMsgBody((u8*)&tMcu, sizeof(TMcu));
					cMsg.CatMsgBody((u8*)&tSpeaker, sizeof(TMt));
					u8 bNotStopNoMix = 0;
					cMsg.CatMsgBody((u8*)&bNotStopNoMix, sizeof(bNotStopNoMix));
					u8 bNotForceRemove = 0;
					cMsg.CatMsgBody((u8*)&bNotForceRemove, sizeof(bNotForceRemove));
					OnAddRemoveMixToSMcu(&cMsg, TRUE);	
					//m_ptMtTable->SetMtInMixing(tLocalSpeaker.GetMtId(), TRUE,TRUE);
				}
				else
				{
					m_ptMtTable->SetMtInMixing(tSpeaker.GetMtId(), TRUE,TRUE);
				}
			}
			StartMixing(mcuPartMix);

			
		}
		else
		{
			m_tConf.m_tStatus.SetVACing(FALSE);
			m_tConf.m_tStatus.SetSpecMixing();
		
			SendMsgToAllMcs(MCU_MCS_STOPVAC_NOTIF, cSrvMsg);
			if (HasJoinedChairman())
			{
				SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_STOPVAC_NOTIF, cSrvMsg);
			}
			ConfModeChange();
			if (HasJoinedChairman())
			{
				NotifyChairmanMixMode();
				CServMsg cServMsgToChairMan;
				cServMsgToChairMan.SetMsgBody((u8 *)&m_tConf, sizeof(TConfInfo));
				SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_CONF_NOTIF, cServMsgToChairMan);
			}

			TMt tChairman;
			TMt tSpeaker;
			tChairman.SetNull();
			tSpeaker.SetNull();
			if (m_tConf.HasChairman())
			{
				tChairman = m_tConf.GetChairman();
				AddSpecMixMember(&tChairman, 1, TRUE);
			}
			if (m_tConf.HasSpeaker())
			{
				TMt tLocalSpeaker;
				tLocalSpeaker.SetNull();
				tSpeaker = m_tConf.GetSpeaker();
				if (!tSpeaker.IsLocal())
				{
					tLocalSpeaker = GetLocalMtFromOtherMcuMt(tSpeaker);
					CServMsg cMsg;
					TMcu tMcu;
					tMcu.SetNull();
					tMcu.SetMcuId( tLocalSpeaker.GetMtId() );
					cMsg.SetMsgBody((u8*)&tMcu, sizeof(TMcu));
					cMsg.CatMsgBody((u8*)&tSpeaker, sizeof(TMt));
					u8 bNotStopNoMix = 0;
					cMsg.CatMsgBody((u8*)&bNotStopNoMix, sizeof(bNotStopNoMix));
					u8 bNotForceRemove = 0;
					cMsg.CatMsgBody((u8*)&bNotForceRemove, sizeof(bNotForceRemove));
					OnAddRemoveMixToSMcu(&cMsg, TRUE);	
					//m_ptMtTable->SetMtInMixing(tLocalSpeaker.GetMtId(), TRUE);
				}
				else
				{
					m_ptMtTable->SetMtInMixing(tSpeaker.GetMtId(), TRUE,TRUE);
				}
			}

			TMt tMt;
			// 停止除主席和发言人外终端发送码流给混音器,并建立混音器到各终端的交换
			for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
			{
				tMt = m_ptMtTable->GetMt(byMtId);
				if (tMt.IsNull())
				{
					continue;
				}

				if (m_ptMtTable->IsMtInMixGrp(byMtId) &&
					!(tMt == tChairman || tMt == tSpeaker))
				{
					RemoveMixMember(&tMt);
					StopSwitchToPeriEqp(m_tMixEqp.GetEqpId(), 
										(MAXPORTSPAN_MIXER_GROUP*m_byMixGrpId/PORTSPAN+tMt.GetMtId()),
										FALSE, MODE_AUDIO);
				}
				if (m_tConfAllMtInfo.MtJoinedConf(byMtId))
				{
					BOOL32 bNMode = FALSE;
					if( !m_ptMtTable->IsMtInMixGrp(byMtId) )
					{
						bNMode = TRUE;
					}

					SwitchMixMember(&tMt, bNMode);
				}
		
			}

			// 通知混音器发送码流
			NotifyMixerSendToMt(TRUE);

			
		}
	}
	// 会议尚未开启混音器
	else
	{
		if (m_tConf.HasChairman())
		{
			TMt tChairman;
			tChairman.SetNull();
			tChairman = m_tConf.GetChairman();
			m_ptMtTable->SetMtInMixing(tChairman.GetMtId(), TRUE,TRUE);
		}
		if (m_tConf.HasSpeaker())
		{
			TMt tSpeaker;
			tSpeaker.SetNull();
			TMt tLocalSpeaker;
			tLocalSpeaker.SetNull();
			tSpeaker = m_tConf.GetSpeaker();
			if (!tSpeaker.IsLocal())
			{
				tLocalSpeaker = GetLocalMtFromOtherMcuMt(tSpeaker);
				CServMsg cMsg;
				TMcu tMcu;
				tMcu.SetNull();
				tMcu.SetMcuId( tLocalSpeaker.GetMtId() );
				cMsg.SetMsgBody((u8*)&tMcu, sizeof(TMcu));
				cMsg.CatMsgBody((u8*)&tSpeaker, sizeof(TMt));
				u8 bNotStopNoMix = 0;
				cMsg.CatMsgBody((u8*)&bNotStopNoMix, sizeof(bNotStopNoMix));
				u8 bNotForceRemove = 0;
				cMsg.CatMsgBody((u8*)&bNotForceRemove, sizeof(bNotForceRemove));
				OnAddRemoveMixToSMcu(&cMsg, TRUE);	
			}
			else
			{
				m_ptMtTable->SetMtInMixing(tSpeaker.GetMtId(), TRUE,TRUE);
			}
		}
		StartMixing(mcuPartMix);

		
	}

	ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "ChairmanAutoSpecMix() successed!\n");
}

/*====================================================================
    函数名      ：ChangeConfRestoreMixParam
    功能        ：修改混音器恢复参数
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    01/11/11    4.0         田志勇        创建
====================================================================*/
// void CMcuVcInst::ChangeConfRestoreMixParam()
// {
// 	TMixParam tMixParam = m_tConf.m_tStatus.GetMixerParam();
// 	if (m_tConf.GetConfSource() == VCS_CONF 
// 		&& m_tMixEqp.IsNull() 
// 		&& m_cVCSConfStatus.GetMtInTvWallCanMixing() 
// 		&& tMixParam.GetMode() == mcuNoMix 
// 		&& m_byLastMixMode != mcuNoMix 
// 		&& tMixParam.GetMemberNum() != 0)
// 	{
// 		TMt tLastVcMT = m_cVCSConfStatus.GetLstVCMT();
// 		TMt tCurVcMT  = m_cVCSConfStatus.GetCurVCMT();
// 		
// 		if (tLastVcMT.IsLocal())
// 		{
// 			if (tMixParam.IsMtInMember(tLastVcMT.GetMtId()))
// 			{
// 				tMixParam.DelMember(tLastVcMT.GetMtId());
// 			}
// 			if (tCurVcMT.IsLocal())
// 			{
// 				tMixParam.AddMember(tCurVcMT.GetMtId());
// 			}
// 		}
// 	}
// 
// 	m_tConf.m_tStatus.SetMixerParam(tMixParam);
// }


/*====================================================================
函数名		   NewMcuBasMgr
功能        ： 开辟bas管理空间
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::NewMcuBasMgr()
{
	if(!IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return TRUE;
	}
	m_pcMcuBasMgr = new CMcuBasMgr;
	return !IS_PTR_NULL(m_pcMcuBasMgr);
}
/*====================================================================
函数名		   DeletMcuBasMgr
功能        ： 销毁
算法实现    ：
引用全局变量：
输入参数说明： 

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
void CMcuSingleConfAllInfo::DeleteMcuBasMgr()
{
	if(!IS_PTR_NULL(m_pcMcuBasMgr))
	{
		MCU_SAFE_DELETE(m_pcMcuBasMgr);
	}
	return;
}

/*====================================================================
函数名		   GetBasMgrBuf
功能        ： 获取bas管理数据区(主备倒换)
算法实现    ：
引用全局变量：
输入参数说明： u8 * pbyBuf   获取数据
返回值说明  ： Buf 数据长度
			    
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
u32 CMcuSingleConfAllInfo::GetBasMgrBuf(u8 *pbyBuf)
{
	if (IS_PTR_NULL(pbyBuf))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[GetBasMgrBuf] pbyBuf is null!\n");
		return 0 ;
	}

	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return 0;
	}
	memcpy(pbyBuf, m_pcMcuBasMgr, sizeof(CMcuBasMgr));
    return sizeof(CMcuBasMgr);
}

/*====================================================================
函数名		   SetBasMgrBuf
功能        ： 设置bas管理数据区(主备倒换)
算法实现    ：
引用全局变量：
输入参数说明： u8 * pbyBuf   设置数据
返回值说明  ： Buf 数据长度
			    
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
u32 CMcuSingleConfAllInfo::SetBasMgrBuf(u8 *pbyBuf)
{
	if (IS_PTR_NULL(pbyBuf))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[SetBasMgrBuf] pbyBuf is null!\n");
		return 0 ;
	}

	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return 0;
	}
	memcpy(m_pcMcuBasMgr, pbyBuf, sizeof(CMcuBasMgr));
	m_pcMcuBasMgr->ResignBasChn();
	return sizeof(CMcuBasMgr);
}

/*====================================================================
函数名		   ClearBasMgr
功能        ： 清空bas管理数据区
算法实现    ：
引用全局变量：
输入参数说明： 
返回值说明  ： 			    
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
void CMcuSingleConfAllInfo::ClearBasMgr()
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return;
	}
	m_pcMcuBasMgr->Clear();
	return;
}
/*====================================================================
函数名		   AssignBasBrdChn
功能        ： 分配广播bas通道
算法实现    ：
引用全局变量：
输入参数说明：CBasChn **aptBasChn    广播预留的适配通道
			  u8	byChnNum		 适配通道数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
2011/12/20  4.7         倪志俊			修改
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::AssignBasBrdChn(CBasChn **aptBasChn,  TBasChnCapData *atBasChnCapData, u8 byChnNum, const CConfId &cConId)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}

	if (NULL == aptBasChn)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[AssignBasBrdChn]aptBasChn is NULL!\n");
		return FALSE;
	}

	for ( u8 byIdx = 0; byIdx< byChnNum; byIdx++ )
	{
		if ( aptBasChn[byIdx] == NULL )
		{
			continue;
		}
		TEqp tBas = aptBasChn[byIdx]->GetBas();
		tBas.SetConfIdx(m_byConfIdx);
		aptBasChn[byIdx]->SetBas(tBas);	
		LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[AssignBasBrdChn]bas:%d-chn:%d for conf:%d mode:%d\n",
				  aptBasChn[byIdx]->GetBas().GetEqpId(), aptBasChn[byIdx]->GetChnId(), m_byConfIdx, aptBasChn[byIdx]->GetMediaMode()
				  );
	}

	return m_pcMcuBasMgr->AssignBrdChn(aptBasChn, atBasChnCapData, byChnNum,cConId);
}


/*====================================================================
函数名		   ReMoveBasBrdChn
功能        ： 移除广播bas通道
算法实现    ：
引用全局变量：
输入参数说明：u8 byEqpId
			  u8 byChnId
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::ReMoveBasBrdChn(const TEqp &tEqp, u8 byChnId)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->ReMoveBrdChn(tEqp, byChnId);
}

/*====================================================================
函数名        SetBasBrdAdaptParam
功能        ：设置广播适配参数
算法实现    ：
引用全局变量：
输入参数说明：THDAdaptParam tParam  适配参数
			  u8 byMediaMode		媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
// BOOL32 CMcuSingleConfAllInfo::SetBasBrdAdaptParam(THDAdaptParam tParam, u8 byMediaMode)
// {
// 	if(IS_PTR_NULL(m_pcMcuBasMgr))
// 	{
// 		return FALSE;
// 	}
// 	return m_pcMcuBasMgr->SetBrdAdaptParam(m_tConf, tParam, byMediaMode);
// }

/*====================================================================
函数名      ClearBasBrdAdaptParam
功能        ：清空广播适配参数
算法实现    ：
引用全局变量：
输入参数说明：u8 byMediaMode  媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
// BOOL32 CMcuSingleConfAllInfo::ClearBasBrdAdaptParam(u8 byMediaMode)
// {
// 	if(IS_PTR_NULL(m_pcMcuBasMgr))
// 	{
// 		return FALSE;
// 	}
// 	return m_pcMcuBasMgr->ClearBrdAdaptParam(byMediaMode);
// }

/*====================================================================
函数名				GetBasBrdChnGrp
功能        : 获取对应媒体模式的广播通道
算法实现    ：
引用全局变量：
输入参数说明：u8		   &byNum	    对应模式通道数
			  TBasChnData *ptBasChn		对应模式通道
			  u8           byMediaMode  媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::GetBasBrdChnGrp(u8 &byNum, CBasChn **pcBasChn, u8 byMediaMode)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->GetBrdChnGrp(byNum, pcBasChn, byMediaMode);
}

/*====================================================================
函数名			GetBasAllBrdChn
功能        : 获取所有V播通道
算法实现    ：
引用全局变量：
输入参数说明：u8			&byNum  所有广播通道数
			  TBasChnData *ptBasChn 所有广播通道
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::GetBasAllBrdChn(u8 &byNum, CBasChn **pcBasChn)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->GetAllBrdChn(byNum, pcBasChn);
}
/*====================================================================
函数名			GetDiffBrdEqp
功能        : 获取所有V播通道
算法实现    ：
引用全局变量：
输入参数说明：u8 byMediaMode        媒体模式
			  u8 &byEqpNum          返回广播所占用的适配外设数
			  TEqp *ptBas           广播所占的bas
返回值说明  ：true or false
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::GetDiffBrdEqp(u8 byMediaMode, u8 &byEqpNum, TEqp *ptBas)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->GetDiffBrdEqp(byMediaMode, byEqpNum, ptBas);
}
/*====================================================================
函数名		   AssignBasSelChn
功能        ：分配选看bas通道
算法实现    ：
引用全局变量：
输入参数说明：TBasChnData tBasChn    选看预留的适配通道
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::AssignBasSelChn(CBasChn *pcBasChn, const  TBasChnCapData &tBasChnIdxParam, const CConfId &cConId)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	g_cMcuVcApp.OcuppyBasChn(&pcBasChn, 1);
	return m_pcMcuBasMgr->AssignSelChn(pcBasChn,tBasChnIdxParam,cConId);
}

/*====================================================================
函数名		   ReMoveBasSelChn
功能        ：移除选看bas通道
算法实现    ：
引用全局变量：
输入参数说明：u8 byEqpId
			  u8 byChnId
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::ReMoveBasSelChn(const TEqp &tEqp, u8 byChnId)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->ReMoveSelChn(tEqp, byChnId);
}


/*====================================================================
函数名		   AddBasSelChnParam
功能        ： 添加参数
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp BAS外设
			  u8 byChnId	   通道号
			  const TBasChnIdxParam &tBasChnIdxParam 参数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::AddBasSelChnParam(const TEqp &tEqp, u8 byChnId, const  TBasChnCapData &tBasChnCapData)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->AddBasSelChnParam(tEqp, byChnId,tBasChnCapData);
}

/*====================================================================
函数名        GetBasSelChnGrp
功能        : 获取对应媒体模式的广播通道
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::GetBasSelChnGrp(u8 &byNum, CBasChn **pcBasChn, u8 byMediaMode)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->GetSelChnGrp(byNum, pcBasChn, byMediaMode);
}

/*====================================================================
函数名        SetBasSelAudChnParam
功能        : 设置BAS选看通道参数
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/14  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::SetBasSelAudChnParam(const TEqp &tEqp, u8 byChnId, TAudAdaptParam &tBasParam)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->SetSelAudChnParam(tEqp, byChnId,  tBasParam);
}

/*====================================================================
函数名        SetBasSelChnParam
功能        : 设置BAS选看通道参数
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::SetBasSelChnParam(const TEqp &tEqp, u8 byChnId, u8 byMediaMode, THDAdaptParam &tBasParam)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	
	if (MODE_VIDEO2SECOND == byMediaMode)
	{
		byMediaMode = MODE_VIDEO;
	}

	return m_pcMcuBasMgr->SetSelChnParam(tEqp, byChnId, byMediaMode, tBasParam);
}

/*====================================================================
函数名        GetBasAllSelChn
功能        : 获得所有选看通道
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7			倪志俊		  创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::GetBasAllSelChn(u8 &byNum, CBasChn **pcBasChn)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->GetAllSelChn(byNum,pcBasChn);
}

/*====================================================================
函数名           GetBasGrpType
功能        :    获取通道的所属组
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8    byChnId		通道Id	
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
u8  CMcuSingleConfAllInfo::GetBasGrpType(const TEqp &tEqp, u8 byChnId)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return CHN_ADPMODE_NONE;
	}
	return m_pcMcuBasMgr->GetGrpType(tEqp, byChnId);
}

/*====================================================================
函数名				SetBasChnMode
功能        : 设置对应通道D媒体模式
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
			  u8   byMediaMode  媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::SetBasChnMode(const TEqp &tEqp, u8 byChnId, u8 byMediaMode)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	
	if (MODE_VIDEO2SECOND == byMediaMode)
	{
		byMediaMode = MODE_VIDEO;
	}

	return m_pcMcuBasMgr->SetChnMode(tEqp, byChnId, byMediaMode);
}

/*====================================================================
函数名				GetBasChnMode
功能        : 获取对应通道D媒体模式
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
u8  CMcuSingleConfAllInfo::GetBasChnMode(const TEqp &tEqp, u8 byChnId)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return MODE_NONE;
	}
	return m_pcMcuBasMgr->GetChnMode(tEqp, byChnId);
}

/*====================================================================
函数名				IsExistChnOnEqp
功能        : 是否存在BAS通道在该外设上
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2012/11.08   4.7         倪志俊         创建
====================================================================*/
BOOL32  CMcuSingleConfAllInfo::IsExistChnOnEqp(const TEqp &tEqp)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return MODE_NONE;
	}

	BOOL32 bIsChnExist = FALSE;
	u8 byChnNum = g_cMcuVcApp.GetBasInPutChnNum(tEqp);
	u8 byChnIdx =0 ;
	for (byChnIdx = 0; byChnIdx < byChnNum; byChnIdx++)
	{
		if ( MODE_VIDEO ==	GetBasChnMode(tEqp, byChnIdx) ||
			MODE_SECVIDEO == GetBasChnMode(tEqp, byChnIdx) ||
			MODE_AUDIO == GetBasChnMode(tEqp,byChnIdx)
			)
		{
			bIsChnExist = TRUE;
			break;
		}
	}

	return bIsChnExist;
}



/*====================================================================
函数名				SetBasChnSrc
功能        : 设置对应适配通道D源信息
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
			  TMt    tSrc		源信息
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::SetBasChnSrc(const TEqp &tEqp, u8 byChnId, TMt tSrc)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->SetChnSrc(tEqp, byChnId, tSrc);
}

/*====================================================================
函数名				GetBasChnSrc
功能        : 获取对应适配通道D源信息
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
TMt CMcuSingleConfAllInfo::GetBasChnSrc(const TEqp &tEqp, u8 byChnId)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		TMt tNullTMt;
		tNullTMt.SetNull();
		return tNullTMt;
	}
	return m_pcMcuBasMgr->GetChnSrc(tEqp, byChnId);
}

/*====================================================================
函数名      SetBasVcuTick
功能        : 设置tick
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
			  u32    dwTick     tick数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::SetBasVcuTick(const TEqp &tEqp, u8 byChnId, u32 dwTick)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->SetVcuTick(tEqp, byChnId, dwTick);
}

/*====================================================================
函数名      GetBasVcuTick
功能        : 获取tick
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/06/30    4.6         周嘉麟          创建
====================================================================*/
u32	CMcuSingleConfAllInfo::GetBasVcuTick(const TEqp &tEqp, u8 byChnId)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return 0;
	}
	return m_pcMcuBasMgr->GetVcuTick(tEqp, byChnId);
}	

/*====================================================================
函数名      GetBasPosition
功能        : 获取tick
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
u8  CMcuSingleConfAllInfo::GetBasPosition(const TEqp &tEqp, u8 byChnId)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return 0xff;
	}
	return m_pcMcuBasMgr->GetPosition(tEqp, byChnId);
}

/*====================================================================
函数名      PrintBas
功能        : 获取tick
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7         倪志俊          创建
====================================================================*/
void  CMcuSingleConfAllInfo::PrintBas()
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return ;
	}
	m_pcMcuBasMgr->Print();
	return;
}

/*====================================================================
函数名      StartBasChnAdapt
功能        : 开启某个通道的适配
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7         倪志俊          创建
====================================================================*/
BOOL32  CMcuSingleConfAllInfo::StartBasChnAdapt(const TEqp &tEqp, u8 byChnId, TBasAdaptParamExt &tBasParamExt)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->StartBasAdapt(tEqp,byChnId,tBasParamExt);
}

/*====================================================================
函数名      StopBasChnAdapt
功能        : 停止某个通道的适配
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7         倪志俊          创建
====================================================================*/
BOOL32  CMcuSingleConfAllInfo::StopBasChnAdapt(const TEqp &tEqp, u8 byChnId)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->StopBasAdapt(tEqp, byChnId);
}

/*====================================================================
函数名		  RefreshSpecialCapForBasBrd
功能        :特殊处理，对于单速双格式或者音频适配需要特殊处理
算法实现    ：
引用全局变量：
输入参数说明：TSimCapSet &tSimCapSet  需要设置的特殊能力集
			  u8 byMediaMode		  媒体类型
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7         倪志俊          创建
====================================================================*/
BOOL32	CMcuSingleConfAllInfo::RefreshSpecialCapForVidBrd(TConfInfo &tConfInfo,TVideoStreamCap &tSimCapSet, u8 byMediaMode)
{
	//1.会议通道管理对象判空
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->RefreshSpecialCapForVidBrd(tConfInfo,tSimCapSet,byMediaMode);
}

/*====================================================================
函数名		  RefreshSpecialCapForAudBrd
功能        :特殊处理，对于单速双格式或者音频适配需要特殊处理
算法实现    ：
引用全局变量：
输入参数说明：TConfInfoEx &tConfInfoEx   会议勾选
TAudioTypeDesc tAudSrcCap   源能力
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/13  4.7         倪志俊          创建
====================================================================*/
BOOL32	CMcuSingleConfAllInfo::RefreshSpecialCapForAudBrd(TConfInfo &tConfInfo,TConfInfoEx &tConfInfoEx, TAudioTypeDesc &tSrcAudCap)
{
	//1.会议通道管理对象判空
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->RefreshSpecialCapForAudBrd(tConfInfo,tConfInfoEx,tSrcAudCap);
}

/*====================================================================
函数名      RefreshBasBrdParam
功能        : 获取tick
算法实现    ：
引用全局变量：
输入参数说明：const TEqp &tEqp  外设信息
			  u8	 byChnId	通道ID
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7         倪志俊          创建
====================================================================*/
BOOL32	CMcuSingleConfAllInfo::RefreshBasBrdParam(u8 byMediaMode,u16 wBiteRate)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	
	//清空广播视频适配参数，TPeriEqpStatus中的参数清空
	m_pcMcuBasMgr->ClearBrdAdaptParam(byMediaMode);

	//刷参
	return	m_pcMcuBasMgr->RefreshBrdParam(m_tConf, byMediaMode,wBiteRate);

}

/*====================================================================
函数名      RefreshBasParambyOutIdx
功能        : 强制刷新BAS某路输出参数
算法实现    ：
引用全局变量：
输入参数说明：TBasOutInfo &tBasOutInfo	BAS输出相关信息
			  THDAdaptParam tBasParam	参数
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7         倪志俊          创建
====================================================================*/
BOOL32	CMcuSingleConfAllInfo::RefreshBasParambyOutIdx(TBasOutInfo &tBasOutInfo, THDAdaptParam tBasParam)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	
	return m_pcMcuBasMgr->RefreshBasParambyOut(tBasOutInfo,tBasParam);
}

/*=============================================================================
函 数 名： GetDoubleStreamVideoBitrate
功    能： 获取双流视频码率，默认第一路
算法实现： 
全局变量： 
参    数： 
返 回 值： u16  
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2006/3/23  4.0			许世林                  创建
=============================================================================*/
u16  CMcuSingleConfAllInfo::GetDoubleStreamVideoBitrate(u16 wDialBitrate, BOOL32 bFst /*= TRUE*/)
{ 
    u8 byDStreamScale = m_tConf.GetDStreamScale();    
	
	u16 wSndBitrate = 0;
	if( bFst )
	{
		wSndBitrate = (100-byDStreamScale)*wDialBitrate/100;
	}
	else
	{
		wSndBitrate = byDStreamScale*wDialBitrate/100; 
	}

    return wSndBitrate;
}

/*====================================================================
函数名      FindBasChnByCapForBrd
功能        : 
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7         倪志俊          创建
====================================================================*/
BOOL32	CMcuSingleConfAllInfo::FindBasChnByCapForVidBrd(TVideoStreamCap &tSimCapSet, u8 byMediaMode, TBasOutInfo &tOutInfo, BOOL32 bIsExactMatch /*= FALSE*/)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	
	if ( m_pcMcuBasMgr->FindBasChnByCapForVidBrd(tSimCapSet,byMediaMode,tOutInfo,bIsExactMatch) )
	{
		//mpu需要根据源再匹配一下分辨率,因为MPU会将适合源的码率调整到其他输出上
#if !defined(_8KE_) && !defined(_8KH_) && !defined(_8KI_)
		TPeriEqpStatus tBasStatus;
		if ( g_cMcuAgent.IsEqpBasHD(tOutInfo.m_tBasEqp.GetEqpId()) && 
			 g_cMcuVcApp.GetPeriEqpStatus(tOutInfo.m_tBasEqp.GetEqpId(), &tBasStatus) &&
			 ( tBasStatus.m_tStatus.tHdBas.GetEqpType() == TYPE_MPU ||  
			   tBasStatus.m_tStatus.tHdBas.GetEqpType() == TYPE_MPU_H
			  )
			)
		{
			TMt tVidSrc;
			u8 byChnnel = LOGCHL_VIDEO;
			if ( byMediaMode == MODE_VIDEO )
			{
				tVidSrc = GetLocalVidBrdSrc();
				byChnnel = LOGCHL_VIDEO;
			}
			else if ( byMediaMode == MODE_SECVIDEO )
			{
				tVidSrc = GetLocalMtFromOtherMcuMt(m_tDoubleStreamSrc);
				byChnnel = LOGCHL_SECVIDEO;
			}

			if ( !tVidSrc.IsNull() )
			{
				//1.获得源能力
				TVideoStreamCap tVidSrcCap;
				if (TYPE_MCUPERI == tVidSrc.GetType() && EQP_TYPE_RECORDER == tVidSrc.GetEqpType())
				{
					u16 wRawBiteRate = m_tConf.GetBitRate() + GetAudioBitrate( m_tConfEx.GetMainAudioTypeDesc().GetAudioMediaType() );
					u16 wRealBiteRate = wRawBiteRate - GetMaxAudioBiterate(m_tConfEx);
					u16 wRecWidth  = 0;
					u16 wRecHeight = 0;
					u8  byVidType  = 0;
					u8  byRecRes =0;
					if ( byMediaMode == MODE_VIDEO )
					{
						m_tPlayFileMediaInfo.GetVideo( byVidType, wRecWidth,  wRecHeight );
						byRecRes= GetResByWH( wRecWidth, wRecHeight);
						tVidSrcCap.SetMediaType( byVidType );
						tVidSrcCap.SetResolution( byRecRes );
						tVidSrcCap.SetMaxBitRate( wRealBiteRate );
						tVidSrcCap.SetH264ProfileAttrb( m_tPlayFileHpAttrib.GetFirstVideHpAttrib() );	
						if( byVidType == MEDIA_TYPE_H264 )
						{
							tVidSrcCap.SetUserDefFrameRate(m_tConf.GetMainVidUsrDefFPS());
						}
						else
						{
							tVidSrcCap.SetFrameRate( m_tConf.GetSecVidFrameRate() );
						}
					}
					else
					{
						m_tPlayFileMediaInfo.GetDVideo( byVidType, wRecWidth, wRecHeight );
						byRecRes= GetResByWH( wRecWidth, wRecHeight);
						tVidSrcCap.SetMediaType( byVidType );
						tVidSrcCap.SetResolution( byRecRes );
						tVidSrcCap.SetMaxBitRate( GetDoubleStreamVideoBitrate(wRealBiteRate, FALSE) );
						tVidSrcCap.SetH264ProfileAttrb( m_tPlayFileHpAttrib.GetSecVideHpAttrib() );	
						if( byVidType == MEDIA_TYPE_H264 )
						{
							tVidSrcCap.SetUserDefFrameRate(m_tConf.GetDStreamUsrDefFPS());
						}
						else
						{
							tVidSrcCap.SetFrameRate( m_tConf.GetDStreamFrameRate() );
						}
					}
				}
				else
				{
					TSimCapSet tSrcCap = m_ptMtTable->GetSrcSCS(tVidSrc.GetMtId());
					tVidSrcCap = tSrcCap.GetVideoCap();
				}

				//获得目的能力	
				THDAdaptParam atParam[MAXNUM_BASOUTCHN];
				u8			  byOutNum;
				BOOL32		  bIsNeedNewOut= FALSE;
				if(  g_cMcuVcApp.GetBasOutPutParam(tOutInfo.m_tBasEqp, tOutInfo.m_byChnId, byOutNum, atParam) &&
					atParam[tOutInfo.m_byOutIdx].GetVidType()!=MEDIA_TYPE_NULL
					)
				{
					TVideoStreamCap tVidDstCap;
					tVidDstCap.SetMediaType( atParam[tOutInfo.m_byOutIdx].GetVidType() );
					tVidDstCap.SetResolution( GetResByWH( atParam[tOutInfo.m_byOutIdx].GetWidth(),  atParam[tOutInfo.m_byOutIdx].GetHeight() ) );
					if ( atParam[tOutInfo.m_byOutIdx].GetVidType() != MEDIA_TYPE_H264 )
					{
						tVidDstCap.SetFrameRate(atParam[tOutInfo.m_byOutIdx].GetFrameRate());
					}
					else
					{
						tVidDstCap.SetUserDefFrameRate( atParam[tOutInfo.m_byOutIdx].GetFrameRate() );
					}
					tVidDstCap.SetMaxBitRate( atParam[tOutInfo.m_byOutIdx].GetBitrate() );
					if ( atParam[tOutInfo.m_byOutIdx].GetProfileType() == 1 )
					{
						tVidDstCap.SetH264ProfileAttrb(emHpAttrb);
					}
					else
					{
						tVidDstCap.SetH264ProfileAttrb(emBpAttrb);
					}

					if ( IsNeedAdjustCapBySrc(tVidSrcCap,tVidDstCap) )
					{
						TBasOutInfo tTempOutInfo;
						if ( m_pcMcuBasMgr->FindBasChnByCapForVidBrd(tVidDstCap,byMediaMode,tTempOutInfo,TRUE) )
						{
							tOutInfo.m_tBasEqp = tTempOutInfo.m_tBasEqp;
							tOutInfo.m_byChnId = tTempOutInfo.m_byChnId;
							tOutInfo.m_byOutIdx = tTempOutInfo.m_byOutIdx;
							tOutInfo.m_byOutNum = tTempOutInfo.m_byOutNum;
							tOutInfo.m_byFrontOutNum = tTempOutInfo.m_byFrontOutNum;
							return TRUE;
						}
					}
				}
			}
		}
#endif
		return TRUE;
	}
	return FALSE;

}

/*====================================================================
函数名      FindBasChnForAudBrd
功能        : 
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/13  4.7         倪志俊          创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::FindBasChnForAudBrd(TAudioTypeDesc &tAudCap,TBasOutInfo &tOutInfo)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	
	return m_pcMcuBasMgr->FindBasChnByCapForAudBrd(tAudCap,tOutInfo);
}

/*====================================================================
函数名      FindBasChnByVidCapForSel
功能        : 
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/12/22  4.7         倪志俊          创建
====================================================================*/
BOOL32	CMcuSingleConfAllInfo::FindBasChnByVidCapForSel(TMt &tSrc,TVideoStreamCap &tDstSimCapSet, u8 byMediaMode, TBasOutInfo &tOutInfo)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	return m_pcMcuBasMgr->FindBasChnByVidCapForSel(tSrc, tDstSimCapSet,byMediaMode,tOutInfo);
}

/*====================================================================
函数名      FindBasChnByAudCapForSel
功能        : 
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/14  4.7         倪志俊          创建
====================================================================*/
BOOL32	CMcuSingleConfAllInfo::FindBasChnByAudCapForSel(TMt &tSrc,TAudioTypeDesc &tDstAudCap, TBasOutInfo &tOutInfo)
{
	if(IS_PTR_NULL(m_pcMcuBasMgr))
	{
		return FALSE;
	}
	
	return m_pcMcuBasMgr->FindBasChnByAudCapForSel(tSrc, tDstAudCap,tOutInfo);

}

// BOOL32 CMcuSingleConfAllInfo::IsMtCountExtraPoint(u8 byMtId) const
// {
// 	if( byMtId == 0 || byMtId > MAXNUM_CONF_MT) return FALSE;
// 	return ( ( m_abyMtCountPoint[(byMtId-1) / 8] & ( 1 << ( (byMtId-1) % 8 ) ) ) != 0 );
// }
// 
// BOOL32 CMcuSingleConfAllInfo::AddMtExtraPoint(u8 byMtId)
// {
// 	if( byMtId == 0 || byMtId > MAXNUM_CONF_MT) return FALSE;
// 	m_abyMtCountPoint[(byMtId-1) / 8] |= 1 << ( (byMtId-1) % 8 );
// 	return TRUE;
// }
// 
// BOOL32 CMcuSingleConfAllInfo::DelMtExtraPoint(u8 byMtId)
// {
// 	if( byMtId == 0 || byMtId > MAXNUM_CONF_MT) return FALSE;
// 	m_abyMtCountPoint[(byMtId-1) / 8] &= 0 << ( (byMtId-1) % 8 );
// 	return TRUE;
// }

/*====================================================================
函数名         StartPrsForVmp
功能        ： 为vmp动态占用prs通道
算法实现    ：
引用全局变量：
输入参数说明：

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
void CMcuVcInst::StartPrsForVmp(TEqp tVmpEqp)
{
	u8 byVmpSubType = GetVmpSubType(tVmpEqp.GetEqpId());
	if (byVmpSubType == VMP)
	{
		u8 byPrsId    = 0;
		u8 byPrsChnId = 0;
		//Vmp双编码第二路出索引为1
		u8 byVmpOut   = 1;

		if (FindPrsChnForSrc(tVmpEqp, byVmpOut, MODE_VIDEO, byPrsId, byPrsChnId))
		{
			return;
		}

		if( g_cMcuVcApp.GetIdlePrsChls( 1, &byPrsId, &byPrsChnId))
		{
			if(ChangePrsSrc(byPrsId, byPrsChnId, MODE_VIDEO, tVmpEqp) &&
			   AssignPrsChn(byPrsId, byPrsChnId, MODE_VIDEO)
				)
			{
				SetPrsChnSrc(byPrsId, byPrsChnId, tVmpEqp, byVmpOut);
				OccupyPrsChnl(byPrsId, byPrsChnId);
			}
		}
		else
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_PRS, "[StartPrsForVmp:vmp] GetIdlePrsChls failed!\n");
		}
	}
	else if (MPU2_VMP_ENHACED == byVmpSubType ||
			 MPU2_VMP_BASIC == byVmpSubType)
	{
		TKDVVMPOutParam tVMPOutParam = g_cMcuVcApp.GetVMPOutParam(tVmpEqp);
		// MPU2时,根据后适配通道开启个数,依次开启
		u8 byMaxOutChnl = tVMPOutParam.GetVmpOutCount();
		//不重复占用
		u8 byPrsId = 0;
		u8 byPrsChnnlId = 0;
		for(u8 byVmpOut = 0; byVmpOut < byMaxOutChnl; byVmpOut++)
		{
			byPrsId = 0;
			byPrsChnnlId = 0;
			if (FindPrsChnForSrc(tVmpEqp, byVmpOut, MODE_VIDEO, byPrsId, byPrsChnnlId))
			{
				return;
			}
		}

		u8 abyPrsId[MAXNUM_PRS_CHNNL] = {0};
		u8 abyPrsChnId[MAXNUM_PRS_CHNNL] = {0};
		if( g_cMcuVcApp.GetIdlePrsChls( byMaxOutChnl, abyPrsId, abyPrsChnId))
		{
			for (u8 byLoop = 0; byLoop < byMaxOutChnl; byLoop++)
			{
				if(ChangePrsSrc(abyPrsId[byLoop], abyPrsChnId[byLoop], MODE_VIDEO,
					tVmpEqp, byLoop) &&
					AssignPrsChn(abyPrsId[byLoop], abyPrsChnId[byLoop], MODE_VIDEO)
					)
				{
					SetPrsChnSrc(abyPrsId[byLoop], abyPrsChnId[byLoop],
						tVmpEqp, byLoop);
					OccupyPrsChnl(abyPrsId[byLoop], abyPrsChnId[byLoop]);
				}
			}
		}
		else
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_PRS, "[StartMpuVmpBrd] GetIdlePrsChls ChnNum:%d failed!\n", byMaxOutChnl);
		}
	} 
	else
	{
		//不重复占用
		u8 byPrsId = 0;
		u8 byPrsChnnlId = 0;
		for(u8 byVmpOut = 0; byVmpOut < MAXNUM_MPU_OUTCHNNL; byVmpOut++)
		{
			byPrsId = 0;
			byPrsChnnlId = 0;
			if (FindPrsChnForSrc(tVmpEqp, byVmpOut, MODE_VIDEO, byPrsId, byPrsChnnlId))
			{
				return;
			}
		}
		
		//[2011/07/05/zhangli]整理以下代码
		//zhangli modify begin
		u8 byNeedPrsChn = 0;
		u8 abyVmpOutIdx[MAXNUM_MPU_OUTCHNNL] = {0};
		u8 byMainType = m_tConf.GetMainVideoMediaType();
		u8 byMainFormat = m_tConf.GetMainVideoFormat();
		u8 bySecType = m_tConf.GetSecVideoMediaType();
		u8 bySecFormat = m_tConf.GetSecVideoFormat();

		u8 byMainVmpOutIdx = ~0;
		u8 bySecVmpOutIdx = ~0;
		u8 by1080VmpOutIdx = ~0;
		u8 by720VmpOutIdx = ~0;
		u8 by4CifVmpOutIdx = ~0;
		u8 byCifVmpOutIdx = ~0;

		byMainVmpOutIdx = GetVmpOutChnnlByRes(tVmpEqp.GetEqpId(), byMainFormat, byMainType,m_tConf.GetMainVidUsrDefFPS(),m_tConf.GetProfileAttrb());
// 		//8000G-Vmp最多出720，如果是8000G，则重新按照720取
// #ifdef _8KE_
// 		if (MEDIA_TYPE_H264 == byMainType && VIDEO_FORMAT_HD1080 == byMainFormat)
// 		{
// 			byMainVmpOutIdx = GetVmpOutChnnlByRes(VIDEO_FORMAT_HD720, MEDIA_TYPE_H264);
// 		}
// #endif

		//辅格式other
		if (MEDIA_TYPE_NULL != bySecType)
		{
			bySecVmpOutIdx = GetVmpOutChnnlByRes(tVmpEqp.GetEqpId(), bySecFormat, bySecType);
		}

#ifdef _8KI_
		if( MEDIA_TYPE_H264 == byMainType )
		{
			u8 byFrameRate = m_tConf.GetMainVidUsrDefFPS();
			if( m_tConf.GetMainVidUsrDefFPS() >= 50 )
			{
				byFrameRate = m_tConf.GetMainVidUsrDefFPS() / 2;
			}

			if( IsMSSupportCapEx(VIDEO_FORMAT_HD1080,byFrameRate,emBpAttrb) )			
			{
				by1080VmpOutIdx = GetVmpOutChnnlByRes(tVmpEqp.GetEqpId(), VIDEO_FORMAT_HD1080, MEDIA_TYPE_H264,byFrameRate,emBpAttrb );
			}
			else if( IsMSSupportCapEx(VIDEO_FORMAT_HD1080,byFrameRate,emHpAttrb) )
			{
				by1080VmpOutIdx = GetVmpOutChnnlByRes(tVmpEqp.GetEqpId(), VIDEO_FORMAT_HD1080, MEDIA_TYPE_H264,byFrameRate,emHpAttrb );
			}

			if( IsMSSupportCapEx(VIDEO_FORMAT_HD720,byFrameRate,emBpAttrb) )			
			{
				by720VmpOutIdx = GetVmpOutChnnlByRes(tVmpEqp.GetEqpId(), VIDEO_FORMAT_HD720, MEDIA_TYPE_H264,byFrameRate,emBpAttrb );
			}
			else if( IsMSSupportCapEx(VIDEO_FORMAT_HD720,byFrameRate,emHpAttrb) )
			{
				by720VmpOutIdx = GetVmpOutChnnlByRes(tVmpEqp.GetEqpId(), VIDEO_FORMAT_HD720, MEDIA_TYPE_H264,byFrameRate,emHpAttrb );
			}
		}
		
#else
		
		//[2012/03/29 nizhijun]8KH特殊处理
#ifdef _8KH_
		if (IsMSSupportCapEx(VIDEO_FORMAT_HD720,30,emBpAttrb) || 
			IsMSSupportCapEx(VIDEO_FORMAT_HD720,25,emBpAttrb)
			)
		{
			by720VmpOutIdx = GetVmpOutChnnlByRes(tVmpEqp.GetEqpId(), VIDEO_FORMAT_HD720, MEDIA_TYPE_H264);
		}
#else
		if (IsMSSupportCapEx(VIDEO_FORMAT_HD720))
		{
			by720VmpOutIdx = GetVmpOutChnnlByRes(tVmpEqp.GetEqpId(), VIDEO_FORMAT_HD720, MEDIA_TYPE_H264);
		}
#endif

#endif
		if (IsMSSupportCapEx(VIDEO_FORMAT_4CIF))
		{
			by4CifVmpOutIdx = GetVmpOutChnnlByRes(tVmpEqp.GetEqpId(), VIDEO_FORMAT_4CIF, MEDIA_TYPE_H264);
		}
		if (IsMSSupportCapEx(VIDEO_FORMAT_CIF) )
		{
			byCifVmpOutIdx = GetVmpOutChnnlByRes(tVmpEqp.GetEqpId(), VIDEO_FORMAT_CIF, MEDIA_TYPE_H264);
		}
		
		for (u8 byIdx = 0; byIdx < MAXNUM_MPU_OUTCHNNL; byIdx++ )
		{
			if (byIdx == byMainVmpOutIdx)
			{
				abyVmpOutIdx[byNeedPrsChn] = byMainVmpOutIdx;
				byNeedPrsChn ++;
			}
			else if (byIdx == bySecVmpOutIdx)
			{
				abyVmpOutIdx[byNeedPrsChn] = bySecVmpOutIdx;
				byNeedPrsChn ++;
			}
			else if( byIdx == by1080VmpOutIdx )
			{
				abyVmpOutIdx[byNeedPrsChn] = by1080VmpOutIdx;
				byNeedPrsChn ++;
			}
			else if (byIdx == by720VmpOutIdx)
			{
				abyVmpOutIdx[byNeedPrsChn] = by720VmpOutIdx;
				byNeedPrsChn ++;
			}
			else if (byIdx == by4CifVmpOutIdx)
			{
				abyVmpOutIdx[byNeedPrsChn] = by4CifVmpOutIdx;
				byNeedPrsChn ++;
			}
			else if (byIdx == byCifVmpOutIdx)
			{
				abyVmpOutIdx[byNeedPrsChn] = byCifVmpOutIdx;
				byNeedPrsChn ++;
			}
		}
		//zhangli modify end

		u8 abyPrsId[MAXNUM_PRS_CHNNL] = {0};
		u8 abyPrsChnId[MAXNUM_PRS_CHNNL] = {0};
		if( g_cMcuVcApp.GetIdlePrsChls( byNeedPrsChn, abyPrsId, abyPrsChnId))
		{
			u8 byChnIdx = 0;
			for (u8 byLoop = 0; byLoop < byNeedPrsChn; byLoop++)
			{
				if(ChangePrsSrc(abyPrsId[byLoop], abyPrsChnId[byChnIdx], MODE_VIDEO,
											  tVmpEqp, abyVmpOutIdx[byLoop]) &&
				   AssignPrsChn(abyPrsId[byLoop], abyPrsChnId[byChnIdx], MODE_VIDEO)
						)
				{
					SetPrsChnSrc(abyPrsId[byLoop], abyPrsChnId[byChnIdx],
						tVmpEqp, abyVmpOutIdx[byLoop]);
					OccupyPrsChnl(abyPrsId[byLoop], abyPrsChnId[byChnIdx]);
					byChnIdx++;
				}			
			}
		}
		else
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_PRS, "[StartMpuVmpBrd] GetIdlePrsChls ChnNum:%d failed!\n", byNeedPrsChn);
		}
	}
	return;
}

/*====================================================================
函数名      ： StartPrsForMixer
功能        ： 为mixer动态占用prs通道
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
13/03/19    4.7         国大卫        创建
====================================================================*/
void CMcuVcInst::StartPrsForMixer(void)
{
	//适用于APU2
	u8 byMixerType = 0;
	g_cMcuAgent.GetMixerSubTypeByEqpId(m_tMixEqp.GetMtId(), byMixerType);
	TAudioTypeDesc atAudTypeDesc[MAXNUM_CONF_AUDIOTYPE];
	u8 byNeedChnlNum = m_tConfEx.GetAudioTypeDesc(atAudTypeDesc) - 1;

	u8 byLoop = 0;
	if (byMixerType == APU2_MIXER || byMixerType == MIXER_8KI)
	{
		u8 byPrsId = 0;
		u8 byPrsChnnlId = 0;

		for(byLoop = 0; byLoop < byNeedChnlNum; byLoop++)
		{
			byPrsId = 0;
			byPrsChnnlId = 0;
			if (FindPrsChnForSrc(m_tMixEqp, GetMixerNModeChn() + byLoop + 1, MODE_AUDIO, byPrsId, byPrsChnnlId))
			{
				return;
			}
		}
		
		u8 abyPrsId[MAXNUM_PRS_CHNNL] = {0};
		u8 abyPrsChnId[MAXNUM_PRS_CHNNL] = {0};
		if( g_cMcuVcApp.GetIdlePrsChls( byNeedChnlNum, abyPrsId, abyPrsChnId))
		{
			for (byLoop = 0; byLoop < byNeedChnlNum; byLoop++)
			{
				u8 bySrcOutChnl = GetMixerNModeChn() + byLoop + 1;
				if(ChangePrsSrc(abyPrsId[byLoop], abyPrsChnId[byLoop], MODE_AUDIO, m_tMixEqp, bySrcOutChnl) &&
					AssignPrsChn(abyPrsId[byLoop], abyPrsChnId[byLoop], MODE_AUDIO)
					)
				{
					SetPrsChnSrc(abyPrsId[byLoop], abyPrsChnId[byLoop], m_tMixEqp, bySrcOutChnl);
					OccupyPrsChnl(abyPrsId[byLoop], abyPrsChnId[byLoop]);
				}
			}
		}
		else
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_PRS, "[StartPrsForMixer] GetIdlePrsChls ChnlNum:%d Failed!\n", byNeedChnlNum);
		}
	}
}

/*====================================================================
函数名         StopPrsForVmp
功能        ： 将某下级MCU下终端进混音器属性为自动
算法实现    ：
引用全局变量：
输入参数说明：

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
void CMcuVcInst::StopPrsForVmp(TEqp tVmpEqp)
{
	u8 byPrsId    = 0;
	u8 byPrsChnId = 0;
	if (GetVmpSubType(tVmpEqp.GetEqpId()) == VMP)
	{
		//停止双编码第二路
		if (FindPrsChnForSrc(tVmpEqp, 1, MODE_VIDEO, byPrsId, byPrsChnId) &&
			IsPrsChnStart(byPrsId, byPrsChnId))
		{
			StopPrs(byPrsId, byPrsChnId, MODE_VIDEO);
			
			RlsPrsChnl(byPrsId, byPrsChnId);	
		}
	}
	else
	{
		u8 byMaxOutChnl = MAXNUM_MPU_OUTCHNNL;// MPU类型vmp有4路后适配
		u8 byVmpSubType = GetVmpSubType(tVmpEqp.GetEqpId());
		// MPU2类型vmp有9路后适配
		if (MPU2_VMP_ENHACED == byVmpSubType ||
			MPU2_VMP_BASIC == byVmpSubType)
		{
			TKDVVMPOutParam tVMPOutParam = g_cMcuVcApp.GetVMPOutParam(tVmpEqp);
			byMaxOutChnl = tVMPOutParam.GetVmpOutCount();//需根据后适配情况确定个数
		}
		for (u8 byVmpOutIdx = 0; byVmpOutIdx < byMaxOutChnl; byVmpOutIdx++)
		{
			byPrsId    = 0;
			byPrsChnId = 0;
			if (FindPrsChnForSrc(tVmpEqp, byVmpOutIdx, MODE_VIDEO, byPrsId, byPrsChnId) &&
				IsPrsChnStart(byPrsId, byPrsChnId))
			{
				StopPrs(byPrsId, byPrsChnId, MODE_VIDEO);
				
				RlsPrsChnl(byPrsId, byPrsChnId);			
			}
		}
	}
	return;
}

/*====================================================================
函数名      ： StopPrsForMixer
功能        ： mixer动态停止释放prs
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
13/03/19    4.7         国大卫        创建
====================================================================*/
void CMcuVcInst::StopPrsForMixer(void)
{
	u8 byPrsId    = 0;
	u8 byPrsChnId = 0;
	u8 byMixerType = 0;
	g_cMcuAgent.GetMixerSubTypeByEqpId(m_tMixEqp.GetMtId(), byMixerType);
	if (byMixerType == APU2_MIXER || byMixerType == MIXER_8KI)
	{
		u8 byMaxOutChnlNum = 0;
		if ( byMixerType == APU2_MIXER)
		{
			byMaxOutChnlNum = MAXNUM_CONF_AUDIOTYPE;
		}
		else
		{
			byMaxOutChnlNum = 3;
		}
		
		for (u8 byLoop = 0; byLoop < byMaxOutChnlNum; byLoop++)
		{
			byPrsId    = 0;
			byPrsChnId = 0;
			u8 bySrcOutChnl = GetMixerNModeChn() + byLoop + 1;
			if (FindPrsChnForSrc(m_tMixEqp, bySrcOutChnl, MODE_AUDIO, byPrsId, byPrsChnId) &&
				IsPrsChnStart(byPrsId, byPrsChnId))
			{
				StopPrs(byPrsId, byPrsChnId, MODE_AUDIO);
				RlsPrsChnl(byPrsId, byPrsChnId);			
			}
		}
	}
	return;
}

/*====================================================================
函数名         ShowPrsInfo
功能        ： 打印Prs动态占用信息
算法实现    ：
引用全局变量：
输入参数说明：

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
void CMcuVcInst::ShowPrsInfo()
{
	PrintPrs();
}

/*====================================================================
函数名         StopDstMtRtcpSwitchtoRealSrc
功能        ： 停止目的终端到其所对应prs通道的rtcp交换
算法实现    ：
引用全局变量：
输入参数说明：

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
void CMcuVcInst::StopPrsMemberRtcp(TMt tDstMt, u8 byMode)
{
	if(byMode != MODE_VIDEO &&
		byMode != MODE_AUDIO &&
		byMode != MODE_SECVIDEO)
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_PRS, "[StopDstMtRtcpSwitchtoRealSrc] unexpected Mode:%d!\n", byMode);
		return;
	}
	TMt tSrc;
	u8  byOutChn = 0;
	if(GetMtRealSrc(tDstMt.GetMtId(), byMode, tSrc, byOutChn))
	{
		u8 byPrsId    = 0;
		u8 byPrsChnId = 0;
		if(FindPrsChnForSrc(tSrc, byOutChn, byMode, byPrsId, byPrsChnId))
		{
			AddRemovePrsMember(tDstMt.GetMtId(), byPrsId, byPrsChnId, byMode, FALSE);
		}
	}
	return;
}

/*====================================================================
函数名         StopMtRtcpAllManytoOneSwitch
功能        ： 停止到源所有多对一规则
算法实现    ：
引用全局变量：
输入参数说明：

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
void CMcuVcInst::StopRtcpSwitchAlltoOne(const TMt &tRtcpDst, u8 byDstChn, u8 byMode)
{
	if (tRtcpDst.IsNull())
	{
		return;
	}

	if (MODE_VIDEO != byMode &&
		MODE_AUDIO != byMode &&
		MODE_SECVIDEO != byMode)
	{
		return;
	}

	TTransportAddr tRemoteAddr;
	if (!GetRemoteRtcpAddr(tRtcpDst, byDstChn, byMode, tRemoteAddr))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StopMtRtcpAllManytoOneSwitch] GetRemoteRtcpAddr failed!\n");
	}
	else
	{
		g_cMpManager.StopMultiToOneSwitch(m_byConfIdx, tRemoteAddr.GetIpAddr(), tRemoteAddr.GetPort());
	}
	return;
}
/*====================================================================
函数名         StartDSAdapt
功能        ： 开启双流适配
算法实现    ：
引用全局变量：
输入参数说明：TMt tSrc 双流源
              TMt tDst 目的终端

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
// BOOL32 CMcuVcInst::StartDSAdapt(TMt tSrc, TMt tDst)
// {
// 	ConfLog(FALSE, "[StartDSAdapt] Mt%d see DoubleSrc:Mt%d!\n", tDst.GetMtId(), tSrc.GetMtId());
// 
// 	if (tSrc.IsNull() || tDst.IsNull())
// 	{
// 		return FALSE;
// 	}
// 
// 	tSrc = GetLocalMtFromOtherMcuMt(tSrc);
//  	tDst = GetLocalMtFromOtherMcuMt(tDst);
// 
//     TLogicalChannel tDstLogicalChnl;
// 	if(!m_ptMtTable->GetMtLogicChnnl(tDst.GetMtId(), LOGCHL_SECVIDEO, &tDstLogicalChnl, TRUE))
// 	{	
// 		return FALSE;
// 	}
// 
// 	TSimCapSet tSrcCap = m_ptMtTable->GetSrcDSSCS(tSrc.GetMtId());		
// 	TSimCapSet tDstCap = m_ptMtTable->GetDstDSSCS(tDst.GetMtId());
// 
// 	if (tSrcCap.IsNull() || tDstCap.IsNull())
// 	{
// 		return FALSE;
// 	}
// 
// 	if (!IsNeedAdapt(tSrc, tDst, MODE_SECVIDEO))
// 	{
// 		return FALSE;
// 	}
// 	
// 	TEqp tBas;
// 	u8  byChnId = 0;
// 	u8  byOutNum = 0;
// 	u8  byOutIdx = 0;
// 	if (!FindBasChn2BrdForMt(tDst.GetMtId(), MODE_SECVIDEO,tBas, byChnId, byOutNum, byOutIdx, TRUE))
// 	{
// 		THDAdaptParam tParam;
// 		tParam.Reset();
// 		//格式
// 		tParam.SetVidType(tDstLogicalChnl.GetChannelType());
// 		tParam.SetVidActiveType(GetActivePayload(m_tConf, tDstLogicalChnl.GetChannelType()));
// 
// 		//分辨率
// 		u16 wHeight = 0;
// 		u16 wWidth  = 0;
// 		//双流保护到SXGA, 不出1080， FindBasChn2BrdForMt也有保护
// 		if (VIDEO_FORMAT_HD1080 == tDstLogicalChnl.GetVideoFormat())
// 		{
// 			tDstLogicalChnl.SetVideoFormat(VIDEO_FORMAT_SXGA);
// 		}
// 		GetWHByRes(tDstLogicalChnl.GetVideoFormat(), wWidth, wHeight);
// 		tParam.SetResolution(wWidth, wHeight);
// 		//帧率
// 		tParam.SetFrameRate(tDstLogicalChnl.GetChanVidFPS());
// 		//码率
// 		tParam.SetBitRate(tDstLogicalChnl.GetFlowControl());
// 
// 		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartDSAdapt] Try to SetBasBrdAdaptParam<MediaType:%d, Res:%d, BR:%d, FR:%d>!\n",
// 					tParam.GetVidType(), 
// 					GetResByWH(tParam.GetWidth(), tParam.GetHeight()), 
// 					tParam.GetBitrate(),
// 					tParam.GetFrameRate());
// 		
// 		//尝试下参数
// 		if(SetBasBrdAdaptParam(tParam, MODE_SECVIDEO))
// 		{
// 			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartDSAdapt] SetBasBrdAdaptParam succeed!\n");
// 
// 			if (!FindBasChn2BrdForMt(tDst.GetMtId(), MODE_SECVIDEO, tBas, byChnId, byOutNum, byOutIdx, TRUE))
// 			{
// 				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS,  "[StartDSAdapt] FindBasChn2BrdForMt failed!\n");
// 				return FALSE;
// 			}
// 			else
// 			{
// 			 	ChangeAdapt(tBas, byChnId);
// 
// 				if (BASCHN_STATE_RUNNING == g_cMcuVcApp.GetBasChnStatus(tBas, byChnId))
// 				{
// 					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartDSAdapt] start switch to mt%d from bas<EqpId:%d, ChnId:%d, OutIdx:%d>!\n",
// 									tDst.GetMtId(), tBas.GetEqpId(), byChnId, byOutIdx);
// 
// 					//建交换(参数刚设置，不需要再刷新参数)
// 					tBas.SetConfIdx(m_byConfIdx);
// 
// 					TSwitchGrp tSwitchGrp;
// 					tSwitchGrp.SetSrcChnl(byChnId * byOutNum + byOutIdx);
// 					tSwitchGrp.SetDstMtNum(1);
// 					tSwitchGrp.SetDstMt(&tDst);
// 					g_cMpManager.StartSwitchToAll(tBas, 1, &tSwitchGrp, MODE_SECVIDEO);
// 
// 					//Rtcp
// 					if (m_tConf.GetConfAttrb().IsResendLosePack())
// 					{
// 						u8 byPrsId = 0;
// 						u8 byPrsChnId = 0;
// 						if(FindPrsChnForSrc(tBas, byChnId * byOutNum + byOutIdx, MODE_SECVIDEO, byPrsId, byPrsChnId))
// 						{
// 							AddRemovePrsMember(tDst.GetMtId(), byPrsId, byPrsChnId, MODE_SECVIDEO, TRUE);
// 						}
// 					}	
// 				}		
// 				else
// 				{
// 					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartDSAdapt] Wait Bas<EqpId:%d, ChnId:%d, OutIdx:%d> Rsp to Start Switch to Mt:%d!\n", 
// 							tBas.GetEqpId(), byChnId, byOutIdx, tDst.GetMtId());
// 				}
// 			}
// 		}
// 		//尝试获取空闲适配通道
// 		else
// 		{
// 			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartDSAdapt] Try to GetIdleBasChn!\n");
// 
// 			TBasChnData tBasChn;
// 			if (!g_cMcuVcApp.GetIdleBasChn(tSrcCap, tDstCap, MODE_SECVIDEO, tBasChn))
// 			{
// 				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS,  "[StartDSAdapt] no idle bas for ds adapt!\n");
// 				return FALSE;
// 			}
// 
// 			//添加选看通道入选看组
// 			AssignBasBrdChn(&tBasChn, 1);
// 			//设置通道源信息
// 			SetBasChnSrc(tBasChn.GetBas(), tBasChn.GetChnId(), tSrc);
// 			//设置通道媒体模式
// 			SetBasChnMode(tBasChn.GetBas(), tBasChn.GetChnId(), MODE_SECVIDEO);
// 
// 			if(SetBasBrdAdaptParam(tParam, MODE_SECVIDEO) &&
// 			   FindBasChn2BrdForMt(tDst.GetMtId(), MODE_SECVIDEO,tBas, byChnId, byOutNum, byOutIdx, TRUE))
// 			{
// 				//开启双流适配
// 				ChangeAdapt(tBas, byChnId);
// 			}
// 			else
// 			{
// 				ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StartDSAdapt] SetBasBrdAdaptParam failed!\n");
// 			}
// 		}
// 	}
// 	else
// 	{
// 		//先刷新参数
// 		RefreshBrdBasParam(tDst.GetMtId(), MODE_SECVIDEO);
// 		//待适配通道开启（回ack）再建立交换
// 		if (BASCHN_STATE_RUNNING == g_cMcuVcApp.GetBasChnStatus(tBas, byChnId))
// 		{
// 			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS,  "[StartDSAdapt] start switch to mt from bas<EqpId:%d, ChnId:%d, OutIdx:%d>!\n",
// 				tBas.GetEqpId(), byChnId, byOutIdx);
// 				
// 			//从适配输出建立交换
// 			tBas.SetConfIdx(m_byConfIdx);
// 
// 			TSwitchGrp tSwitchGrp;
// 			tSwitchGrp.SetSrcChnl(byChnId * byOutNum + byOutIdx);
// 			tSwitchGrp.SetDstMtNum(1);
// 			tSwitchGrp.SetDstMt(&tDst);
// 			g_cMpManager.StartSwitchToAll(tBas, 1, &tSwitchGrp, MODE_SECVIDEO);
// 
// 			//Rtcp
// 			if (m_tConf.GetConfAttrb().IsResendLosePack())
// 			{
// 				u8 byPrsId = 0;
// 				u8 byPrsChnId = 0;
// 				if(FindPrsChnForSrc(tBas, byChnId * byOutNum + byOutIdx, MODE_SECVIDEO, byPrsId, byPrsChnId))
// 				{
// 					AddRemovePrsMember(tDst.GetMtId(), byPrsId, byPrsChnId, MODE_SECVIDEO, TRUE);
// 				}
// 			}	
// 		}
// 		else
// 		{
// 			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_BAS, "[StartDSAdapt] Wait Bas<EqpId:%d, ChnId:%d, OutIdx:%d> Rsp to Start Switch to Mt:%d!\n", 
// 							tBas.GetEqpId(), byChnId, byOutIdx, tDst.GetMtId());
// 		}
// 		
// 	}
// 	return TRUE;
// }

/*====================================================================
函数名         StartDSAdapt
功能        ： 停止源到目的双流适配
算法实现    ：
引用全局变量：
输入参数说明：TMt tSrc 双流源
              TMt tDst 目的终端

返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
// BOOL32 CMcuVcInst::StopDSAdapt(TMt tSrc, TMt tDst)
// {
// 	if (tSrc.IsNull() || tDst.IsNull())
// 	{
// 		return FALSE;
// 	}
// 	
// 	tSrc = GetLocalMtFromOtherMcuMt(tSrc);
// 	tDst = GetLocalMtFromOtherMcuMt(tDst);
// 	
//     TLogicalChannel tDstLogicalChnl;
// 	if(!m_ptMtTable->GetMtLogicChnnl(tDst.GetMtId(), LOGCHL_SECVIDEO, &tDstLogicalChnl, TRUE))
// 	{	
// 		return FALSE;
// 	}
// 
// 	if (!IsNeedAdapt(tSrc, tDst, MODE_SECVIDEO))
// 	{
// 		return FALSE;
// 	}
// 
// 	TEqp tRlsBas;
// 	tRlsBas.SetNull();
// 	u8 byRlsChnId  = 0;
// 	u8 byRlsOutNum = 0;
// 	u8 byRlsOutIdx = 0;
// 	//获取适配通道
// 	if (!FindBasChn2BrdForMt(tDst.GetMtId(), MODE_SECVIDEO, tRlsBas, byRlsChnId, byRlsOutNum, byRlsOutIdx))
// 	{
// 		ConfPrint(LOG_LVL_ERROR, MID_MCU_BAS, "[StopDSAdapt] FindBasChn2BrdForMt:%d failed!\n", tDst.GetMtId());
// 		return FALSE;
// 	}
// 
// 	TEqp tBas;
// 	tBas.SetNull();
// 	u8 byChnId  = 0;
// 	u8 byOutNum = 0;
// 	u8 byOutIdx = 0;
// 	BOOL32 bStopBas = TRUE;
// 	TLogicalChannel tDstLogicalChnnl;
// 	//遍历所有终端有没有同样收相同适配通道的码流
// 	for (u8 byMtIdx = 1; byMtIdx < MAXNUM_CONF_MT; byMtIdx++)
// 	{
// 		if (!m_tConfAllMtInfo.MtJoinedConf(byMtIdx))
// 		{
// 			continue;
// 		}
// 
// 		if (tSrc.GetMtId() == byMtIdx || tDst.GetMtId() == byMtIdx ||
// 			!m_ptMtTable->GetMtLogicChnnl(byMtIdx, LOGCHL_SECVIDEO, &tDstLogicalChnnl, TRUE))
// 		{
// 			continue;
// 		}
// 
// 		tBas.SetNull();
// 		byChnId  = 0;
// 		byOutNum = 0;
// 		byOutIdx = 0;
// 		if (IsNeedAdapt(tSrc, m_ptMtTable->GetMt(byMtIdx), MODE_SECVIDEO) &&
// 			FindBasChn2BrdForMt(byMtIdx, MODE_SECVIDEO, tBas, byChnId, byOutNum, byOutIdx, TRUE) &&
// 			tBas.GetEqpId() == tRlsBas.GetEqpId() && byChnId == byRlsChnId)
// 		{
// 			bStopBas = FALSE;
// 			break;
// 		}
// 	}
// 
// 	//释放适配器
// 	if (bStopBas)
// 	{
// 		//停止bas
// 		CServMsg cServMsg;
// 		cServMsg.SetChnIndex(byRlsChnId);
// 		cServMsg.SetConfId(m_tConf.GetConfId());
// #ifndef _8KE_
// 		if (g_cMcuAgent.IsEqpBasHD(tRlsBas.GetEqpId()))
// #endif
// 		{
// 			SendMsgToEqp(tRlsBas.GetEqpId(), MCU_HDBAS_STOPADAPT_REQ, cServMsg);
// 		}
// #ifndef _8KE_
// 		else
// 		{
// 			SendMsgToEqp(tRlsBas.GetEqpId(), MCU_BAS_STOPADAPT_REQ, cServMsg);
// 		}
// #endif
// 		//释放资源
// 		g_cMcuVcApp.ReleaseBasChn(tRlsBas, byRlsChnId);
// 		g_cMpManager.StopSwitchToPeriEqp(m_byConfIdx, tRlsBas.GetEqpId(), byRlsChnId, MODE_SECVIDEO);
// 		//移除选看通道资源
// 		ReMoveBasBrdChn(tRlsBas.GetEqpId(), byRlsChnId);
// 		//更新外设状态为ready
// 		g_cMcuVcApp.UpdateBasChnStatus(tRlsBas, byChnId, BASCHN_STATE_READY);
// 	}
// 	//zjl 20110510 Mp: StopSwitchToSubMt 接口重载替换 
// 	//g_cMpManager.StopSwitchToSubMt(tDst, MODE_SECVIDEO, TRUE);
// 	g_cMpManager.StopSwitchToSubMt(m_byConfIdx, 1, &tDst, MODE_SECVIDEO);
// 
// 	return TRUE;
// }

/*====================================================================
函数名         AssignPrsChn
功能        ： 单个分配占用Prs通道
算法实现    ：
引用全局变量：
输入参数说明：u8 byPrsId     单板Id
              u8 byPrsChnlId 通道Id
			  u8 byPrsMode   通道媒体模式
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::AssignPrsChn(u8 byPrsId, u8 byPrsChnlId, 
										   u8 byMediaMode, BOOL bBrdChn /* = FALSE */)
{
	if (MODE_VIDEO2SECOND == byMediaMode)
	{
		byMediaMode = MODE_SECVIDEO;
	}

	if (byPrsId < PRSID_MIN || byPrsId > PRSID_MAX ||
		(MODE_VIDEO != byMediaMode && 
		 MODE_AUDIO != byMediaMode &&
		 MODE_SECVIDEO != byMediaMode))
	{
		return FALSE;
	}
	return m_tConfPrsInfo.AssignPrsChnl(byPrsId, byPrsChnlId, byMediaMode, bBrdChn);
}

/*====================================================================
函数名         RemovePrsChn
功能        ： 移除单个prs通道
算法实现    ：
引用全局变量：
输入参数说明：u8 byPrsId     单板Id
              u8 byPrsChnlId 通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::RemovePrsChn(u8 byPrsId, u8 byPrsChnId)
{
	if (byPrsId < PRSID_MIN || byPrsId > PRSID_MAX)
	{
		return FALSE;
	}
	return m_tConfPrsInfo.RemovePrsChnl(byPrsId, byPrsChnId);
}

/*====================================================================
函数名         FindPrsChnForBrd
功能        ： 根据指定广播媒体模式获取预占的prs通道
算法实现    ：
引用全局变量：
输入参数说明：u8 byPrsId     单板Id
              u8 byPrsChnlId 通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::FindPrsChnForBrd(u8 byBrdMode, u8 &byPrsId, u8 &byPrsChnId)
{
	if (MODE_VIDEO2SECOND == byBrdMode)
	{
		byBrdMode = MODE_SECVIDEO;
	}
	if (MODE_VIDEO != byBrdMode &&
		MODE_SECVIDEO != byBrdMode &&
		MODE_AUDIO != byBrdMode)
	{
		return FALSE;
	}
	return m_tConfPrsInfo.FindPrsChnForBrd(byBrdMode, byPrsId, byPrsChnId);
}
/*====================================================================
函数名         FindPrsChnForSrc
功能        ： 为指定源寻找对应占用的prs通道
算法实现    ：
引用全局变量：
输入参数说明：
			  TMt tPrsSrc       指定源
			  u8 bySrcOutChnl	指定源输出通道
			  u8 byPrsId        单板Id
              u8 byPrsChnlId	通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::FindPrsChnForSrc(const TMt& tPrsSrc, u8 bySrcOutChnl, u8 byMode,
											   u8 &byPrsId, u8 &byPrsChnlId)
{
	if(tPrsSrc.IsNull())
	{
		return FALSE;
	}
	return m_tConfPrsInfo.FindPrsChnForSrc(tPrsSrc, bySrcOutChnl, byMode, byPrsId, byPrsChnlId);
}

/*====================================================================
函数名         SetPrsChnSrc
功能        ： 为指定Prs通道设置源信息
算法实现    ：
引用全局变量：
输入参数说明：
			  u8 byPrsId        单板Id
              u8 byPrsChnlId	通道Id
			  TMt tPrsSrc       指定源
			  u8 bySrcOutChnl	指定源输出通道
			  
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::SetPrsChnSrc(u8 byPrsId, u8 byPrsChnId, const TMt &tPrsSrc, u8 bySrcOutChn)
{
	if (byPrsId < PRSID_MIN || byPrsId > PRSID_MAX || tPrsSrc.IsNull())
	{
		return FALSE;
	}
	return m_tConfPrsInfo.SetPrsChnSrc(byPrsId, byPrsChnId, tPrsSrc, bySrcOutChn);
}
/*====================================================================
函数名         FindPrsChnlSrc
功能        ： 为指定prs通道寻找对应的源信息
算法实现    ：
引用全局变量：
输入参数说明：	 
			  u8 byPrsId        单板Id
              u8 byPrsChnlId	通道Id
			  u8 byMediaMode    媒体模式
			  TMt tPrsSrc       指定源
			  u8 bySrcOutChnl	指定源输出通道
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::FindPrsChnlSrc(u8 byPrsId, u8 byPrsChnlId, 
											 u8& byMediaMode, TMt& tPrsSrc, u8& bySrcOutChnl)
{
	if (byPrsId < PRSID_MIN || byPrsId > PRSID_MAX)
	{
		return FALSE;
	}
	return m_tConfPrsInfo.FindPrsChnlSrc(byPrsId, byPrsChnlId, byMediaMode, tPrsSrc, bySrcOutChnl);
}

/*====================================================================
函数名         GetPrsChnMediaMode
功能        ： 为指定prs通道寻找对应的源信息
算法实现    ：
引用全局变量：
输入参数说明：	 
			  u8 byPrsId        单板Id
              u8 byPrsChnlId	通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
u8 CMcuSingleConfAllInfo::GetPrsChnMediaMode(u8 byPrsId, u8 byPrsChnId)
{
	if (byPrsId < PRSID_MIN || byPrsId > PRSID_MAX)
	{
		return MODE_NONE;
	}
	return m_tConfPrsInfo.GetPrsChnMediaMode(byPrsId, byPrsChnId);
}

/*====================================================================
函数名         IsPrsChnStart
功能        ： 当前prs通道是否已开启
算法实现    ：
引用全局变量：
输入参数说明：	 
			  u8 byPrsId        单板Id
              u8 byPrsChnlId	通道Id
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::IsPrsChnStart(u8 byPrsId, u8 byPrsChnId)
{
	if (byPrsId < PRSID_MIN || byPrsId > PRSID_MAX)
	{
		return FALSE;
	}
	return m_tConfPrsInfo.IsPrsChnStart(byPrsId, byPrsChnId);
}

/*====================================================================
函数名         SetPrsChnStart
功能        ： 设置当前prs通道是否开启
算法实现    ：
引用全局变量：
输入参数说明：	 
			  u8 byPrsId        单板Id
              u8 byPrsChnlId	通道Id
			  BOOL32 bStart     是否开启
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::SetPrsChnStart(u8 byPrsId, u8 byPrsChnId, BOOL32 bStart)
{
	if (byPrsId < PRSID_MIN || byPrsId > PRSID_MAX)
	{
		return FALSE;
	}
	return m_tConfPrsInfo.SetPrsChnStart(byPrsId, byPrsChnId, bStart);
}
/*====================================================================
函数名         GetSpecPrsIdAllChnForConf
功能        ： 获取指定prs单板在当前会议使用的所有通道
算法实现    ：
引用全局变量：
输入参数说明：	 
			  u8 byPrsId        单板Id
              u8 *pbyPrsChnId	通道Id
			  
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
u8 CMcuSingleConfAllInfo::GetSpecPrsIdAllChnForConf(u8 byPrsId, u8 *pbyPrsChnId)
{
	if (byPrsId < PRSID_MIN || byPrsId > PRSID_MAX || NULL == pbyPrsChnId)
	{
		return 0;
	}
	return m_tConfPrsInfo.GetSpecPrsIdAllChnForConf(byPrsId, pbyPrsChnId);
}

/*====================================================================
函数名         GetConfAllPrsChn
功能        ： 获取当前会议占用的所有prs通道
算法实现    ：
引用全局变量：
输入参数说明：	 
			  u8 *pbyPrsId      单板Id
              u8 *pbyPrsChnId	通道Id
			  
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/03/18    4.0         周嘉麟        创建
====================================================================*/
u8 CMcuSingleConfAllInfo::GetConfAllPrsChn(u8 *pbyPrsId, u8 *pbyChnId)
{
	if (NULL == pbyPrsId || NULL == pbyChnId)
	{
		return 0;
	}
	return m_tConfPrsInfo.GetAllPrsChn(pbyPrsId, pbyChnId);
}

/*====================================================================
函数名		   GetPrsMgrBuf
功能        ： 获取Prs管理数据区(主备倒换)
算法实现    ：
引用全局变量：
输入参数说明： u8 * pbyBuf   获取数据
返回值说明  ： Buf 数据长度
			    
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
u32 CMcuSingleConfAllInfo::GetPrsMgrBuf(u8 *pbyBuf)
{
	if (IS_PTR_NULL(pbyBuf))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[GetPrsMgrBuf] pbyBuf is null!\n");
		return 0 ;
	}

	memcpy(pbyBuf, &m_tConfPrsInfo, sizeof(m_tConfPrsInfo));
    return sizeof(m_tConfPrsInfo);
}

/*====================================================================
函数名		   SetPrsMgrBuf
功能        ： 设置Prs管理数据区(主备倒换)
算法实现    ：
引用全局变量：
输入参数说明： u8 * pbyBuf   设置数据
返回值说明  ： Buf 数据长度
			    
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/01/19    4.6         周嘉麟          创建
====================================================================*/
u32 CMcuSingleConfAllInfo::SetPrsMgrBuf(u8 *pbyBuf)
{
	if (IS_PTR_NULL(pbyBuf))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[SetPrsMgrBuf] pbyBuf is null!\n");
		return 0 ;
	}

	memcpy(&m_tConfPrsInfo, pbyBuf, sizeof(m_tConfPrsInfo));
	return sizeof(m_tConfPrsInfo);
}

/*====================================================================
函数名         PrintPrs
功能        ： prs打印
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/04/19    4.0         周嘉麟        创建
====================================================================*/
void CMcuSingleConfAllInfo::PrintPrs()
{
	m_tConfPrsInfo.Print();
}

/*====================================================================
函数名         StartBrdPrs
功能        ： 开启广播prs
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/04/19    4.0         周嘉麟        创建
====================================================================*/
void CMcuVcInst::StartBrdPrs(u8 byMediaMode)
{
	if (MODE_VIDEO    != byMediaMode
		&& MODE_SECVIDEO != byMediaMode
		&& MODE_AUDIO    != byMediaMode
		&& MODE_VIDEO2SECOND != byMediaMode)
	{
		return;
	}

	TMt tPrsSrc = GetBrdSrc(byMediaMode);
	if (tPrsSrc.IsNull())
	{
		return;
	}

	u8 bySrcOutChn = 0;
	if (MODE_AUDIO == byMediaMode && m_tMixEqp == tPrsSrc)
	{	
		bySrcOutChn = GetMixerNModeChn();
	}
	
	u8 byPrsId = 0;
	u8 byPrsChnId = 0;

	if(!FindPrsChnForBrd(byMediaMode, byPrsId, byPrsChnId))
	{
		if (!g_cMcuVcApp.GetIdlePrsChls(1, &byPrsId, &byPrsChnId))
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_PRS, "[StartBrdPrs] GetIdlePrsChls failed!\n");
			return;
		}
		AssignPrsChn(byPrsId, byPrsChnId, byMediaMode, TRUE);
		OccupyPrsChnl(byPrsId, byPrsChnId);
	}
	//保存prs通道源信息
	SetPrsChnSrc(byPrsId, byPrsChnId, tPrsSrc, bySrcOutChn);
	//开启广播prs
	//[2011/11/03/zhangli]改变prs源失败的处理
	if (!ChangePrsSrc(byPrsId, byPrsChnId, byMediaMode, tPrsSrc, bySrcOutChn))
	{
		if (IsPrsChnStart(byPrsId, byPrsChnId))
		{
			StopPrs(byPrsId, byPrsChnId, byMediaMode);
		}
		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[StartBrdPrs] ChangePrsSrc failed and stop prs for prsId:%d,prsChnId:%d, mode:%d!\n",
			byPrsId, byPrsChnId, byMediaMode);
	}	
}


/*====================================================================
函数名         StopBrdPrs
功能        ： 停止广播prs
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/04/19    4.6         周嘉麟        创建
====================================================================*/
void CMcuVcInst::StopBrdPrs(u8 byMediaMode)
{
	if (MODE_VIDEO    != byMediaMode &&
		MODE_SECVIDEO != byMediaMode &&
		MODE_AUDIO    != byMediaMode)
	{
		return;
	}
	u8 byPrsId = 0;
	u8 byPrsChnId = 0;
	
	if(FindPrsChnForBrd(byMediaMode, byPrsId, byPrsChnId) &&
	   IsPrsChnStart(byPrsId, byPrsChnId))
	{
		StopPrs(byPrsId, byPrsChnId, byMediaMode);
	}
	return;
}

/*====================================================================
函数名         ShowToken
功能        ： 打印Token
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/04/19    4.6         周嘉麟        创建
====================================================================*/
void CMcuVcInst::ShowToken()
{
	StaticLog( "-----------Ds Token Info as follows----------\n");
	StaticLog("TokenMT:<Type:%d, McuId:%d, MtId:%d>\n",
							m_tH239TokenOwnerInfo.m_tH239TokenMt.GetType(),
							m_tH239TokenOwnerInfo.m_tH239TokenMt.GetMcuId(),
							m_tH239TokenOwnerInfo.m_tH239TokenMt.GetMtId());
	TMt tRealDsMt = GetConfRealDsMt();
	StaticLog("DoubleStream:<Type:%d, McuId:%d, MtId:%d> RealDsMt<McuId:%d, MtId:%d>\n", 
							m_tDoubleStreamSrc.GetType(),
							m_tDoubleStreamSrc.GetMcuId(),
							m_tDoubleStreamSrc.GetMtId(),tRealDsMt.GetMcuIdx(),tRealDsMt.GetMtId());
	return;
}

/*====================================================================
函数名         IsBrdPrsAssigned
功能        ： 广播PRS通道是否已分配
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/04/19    4.6         周嘉麟        创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::IsBrdPrsAssigned()
{
	u8 byPrsId = 0;
	u8 byPrsChnId = 0;

	return FindPrsChnForBrd(MODE_AUDIO, byPrsId, byPrsChnId) &&
		   FindPrsChnForBrd(MODE_VIDEO, byPrsId, byPrsChnId) &&
		   FindPrsChnForBrd(MODE_SECVIDEO, byPrsId, byPrsChnId);
}

/*====================================================================
函数名         IsMultiCastMt
功能        ： 判断终端是否组播终端
算法实现    ： 
引用全局变量：
输入参数说明： u8 MtId
返回值说明  ： BOOL32
----------------------------------------------------------------------
修改记录    ：
 日  期        版本        修改人        修改内容
2013/01/09     4.6         朱胜泽          创建
====================================================================*/
BOOL32 CMcuSingleConfAllInfo::IsMultiCastMt( u8 byMtId )
{
	
	if ( !m_tConf.GetConfAttrb().IsSatDCastMode())
	{
		return FALSE;
	}

    if ( m_tConfAllMtInfo.MtJoinedConf(byMtId) )
    {
        return g_cMcuVcApp.IsMultiCastMtIp( m_ptMtTable->GetIPAddr( byMtId ) );
    }
    else
    {
        LogPrint(LOG_LVL_WARNING, MID_MCU_MT, "[IsMultiCastMt]mt.%d not join conf!\n", byMtId);
        return FALSE;
    }
    
}

/*
 *	Mt主流和双流有一个在发就表示占了卫星回传
 */
BOOL32 CMcuSingleConfAllInfo::IsSatMtSend(const TMt &tMt )
{
	if ( tMt.IsNull()
		|| !tMt.IsLocal() //过滤非本级
		|| !IsMultiCastMt(tMt.GetMtId()))
	{
		return FALSE;
	}

	TLogicalChannel tSndChnnl;
	m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_VIDEO, &tSndChnnl, FALSE);
	if ( tSndChnnl.GetFlowControl() > 0 )
	{
		return TRUE;
	}

	m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_SECVIDEO, &tSndChnnl, FALSE);
	if ( tSndChnnl.GetFlowControl() > 0 )
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

/*====================================================================
函数名         GetMtListGroupBySmcu
功能        ： 将某会议下的一批与会终端按照直属MCU进行分组(新策略：按分支分组)
算法实现    ： 
引用全局变量：
输入参数说明： TMt * ptMtIn  输入与会终端列表
               u8  byMtNum         终端数目
               u8  &bySmcuNum      记录该批下级终端所属的直属下级MCU(非跨级)个数
			   u8  *pbyMtNum       各个MCU下终端数目
               TMt *ptMtOut        分组后输出终端列表
返回值说明  ： void
----------------------------------------------------------------------
修改记录    ：
 日  期        版本        修改人        修改内容
2011/06/28     4.6         田志勇          创建
====================================================================*/
void CMcuVcInst::GetMtListGroupBySmcu(TMt * ptMtIn,u8 byMtNum,u8 &bySmcuNum,u8 *pbyMtNum,  TMt * ptMtOut)
{
	if (ptMtIn == NULL || byMtNum == 0)
	{
		ConfPrint( LOG_LVL_ERROR, MID_MCU_MIXER, "[GetLocalSmcuMtList] Error ptMtIn == NULL || (ptMtIn + byMtNum) == NULL || byMtNum == 0,so return!\n" );
		return;
	}

	TMt *ptMtBegin = ptMtIn;
	TMt *ptMtEnd   = ptMtIn + byMtNum - 1;
	BOOL32 bIsHasNotLocal = FALSE;
	
	if ( !ptMtBegin->IsLocal() )
	{
		bIsHasNotLocal = TRUE;
	}

	TMt tMtSwitch;
	for( ; ptMtBegin <= ptMtEnd; ptMtBegin++ )
	{
		if( !ptMtBegin->IsLocal() )
		{
			bIsHasNotLocal = TRUE;

			for( ; ptMtEnd > ptMtBegin ; ptMtEnd-- )
			{
				ConfPrint( LOG_LVL_DETAIL, MID_MCU_MIXER, "[GetMtListGroupBySmcu]ptMtEnd[%d,%d].IsLocal=%d\n", ptMtEnd->GetMcuId(), 
					ptMtEnd->GetMtId(), ptMtEnd->IsLocal() );

				if ( ptMtEnd->IsLocal() )
				{
					tMtSwitch = *ptMtBegin;
					*ptMtBegin = *ptMtEnd;
					*ptMtEnd = tMtSwitch;
					break;
				}
			}
		}
	}
	
	if (!bIsHasNotLocal)
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[GetMtListGroupBySmcu] get nothing, return\n");
		return;
	}

	TMt aatmt[MAXNUM_SUB_MCU][MAXNUM_MIXING_MEMBER];
	u8 abyFstMcuId[MAXNUM_SUB_MCU] ;
	memset((u8*)abyFstMcuId,0xFF,sizeof(abyFstMcuId));
	bySmcuNum = 0;
	u8 byFstMcuId = 0xFF;

	for (u8 byMtIdx = 0; byMtIdx < byMtNum; byMtIdx++)
	{
		if (ptMtIn == NULL)
		{
			ConfPrint( LOG_LVL_WARNING, MID_MCU_MIXER, "[GetLocalSmcuMtList] Warning ptMtIn == NULL,so return!\n");
			return;
		}

		if (ptMtIn->IsLocal() || ptMtIn->IsNull()) 
		{
			ConfPrint( LOG_LVL_WARNING, MID_MCU_MIXER, "[GetLocalSmcuMtList]Warning ptMtIn->IsLocal(%d) || ptMtIn->IsNull(%d),so ingore the Mt and continue!\n", 
				ptMtIn->IsLocal(),ptMtIn->IsNull() );
			ptMtIn++;
			continue;
		}

		byFstMcuId = GetFstMcuIdFromMcuIdx(ptMtIn->GetMcuIdx());
		for (u8 byMcuIdx = 0;byMcuIdx < MAXNUM_SUB_MCU;byMcuIdx++)
		{
			if (abyFstMcuId[byMcuIdx] == byFstMcuId)  // 该终端所属MCU已存在
			{
				for (u8 byMtIdx2 = 0;byMtIdx2 < MAXNUM_MIXING_MEMBER;byMtIdx2++)
				{
					if (aatmt[byMcuIdx][byMtIdx2].IsNull())
					{
						aatmt[byMcuIdx][byMtIdx2] = *ptMtIn;
						if (pbyMtNum != NULL)
						{
							*(pbyMtNum + byMcuIdx) += 1;
						}
						break;
					}
				}
				break;
			}

			if (abyFstMcuId[byMcuIdx] == 0xFF)   // 第一次找到则直接插入
			{
				abyFstMcuId[byMcuIdx] = byFstMcuId;
				aatmt[byMcuIdx][0] = *ptMtIn;
				bySmcuNum++;
				if (pbyMtNum != NULL)
				{
					*(pbyMtNum + byMcuIdx) += 1;
				}
				break;
			}
		}
		ptMtIn++;
	}

	if (ptMtOut != NULL)
	{	
		for (u8 bySmcuIdx = 0;bySmcuIdx < bySmcuNum;bySmcuIdx++)
		{
			if (pbyMtNum != NULL)
			{
				memcpy(ptMtOut,&aatmt[bySmcuIdx][0],sizeof(TMt)*(*(pbyMtNum + bySmcuIdx)));
				ptMtOut += *(pbyMtNum + bySmcuIdx);
			}
		}
	}

	return;
}

/*====================================================================
函数名         NotifyMcsCriMacAddrInfo
功能        ： 
算法实现    ： 通知MCS所有接入功能单板Mac地址信息
引用全局变量：
输入参数说明： 
返回值说明  ： void
----------------------------------------------------------------------
修改记录    ：
 日  期        版本        修改人        修改内容
2012/05/17     4.7         chendaiwei         创建
====================================================================*/
void CMcuVcInst::NotifyMcsCriMacAddrInfo( void )
{
	CServMsg cMsg;
	g_cMcuVcApp.ConstructCriMacInfoMsg(cMsg);

	SendMsgToAllMcs(MCU_MCS_GETCRIMAC_NOTIF,cMsg);

	return;
}

/*====================================================================
函数名         NotifyMcsCriMacAddrInfo
功能        ： 
算法实现    ： 处理MCS获取所有接入功能单板Mac地址信息的请求
引用全局变量：
输入参数说明： 
返回值说明  ： void
----------------------------------------------------------------------
修改记录    ：
 日  期        版本        修改人        修改内容
2012/05/17     4.7         chendaiwei         创建
====================================================================*/
void CMcuVcInst::DaemonProcMcsMcuGetCriMacAddrInfoReq(  const CMessage * pcMsg ) 
{
	CServMsg cMsg(pcMsg->content,pcMsg->length);

	SendReplyBack(cMsg,pcMsg->event+1);
	ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_MCS,"send MCU_MCS_GETCRIMAC_ACK to Mcs!\n");

	NotifyMcsCriMacAddrInfo();
}
/*====================================================================
    函数名      ：ProcMcsMcuChangeMtSecVidSendCmd
    功能        ：处理VCS控制发言人发双流
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息 
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/06/2011              朱胜泽          创建
====================================================================*/
//[5/4/2011 zhushengze]VCS控制发言人发双流
void  CMcuVcInst::ProcMcsMcuChangeMtSecVidSendCmd( const CMessage * pcMsg )
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);

	//消息体TMt(目的终端) + u8(1:开启双流; 0:停止双流)
    TMt tDstMt = *(TMt*)cServMsg.GetMsgBody();
    u8  byIsSendDStream = *(u8*)(cServMsg.GetMsgBody() + sizeof(TMt) );
	ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MCS, "[ProcMcsMcuChangeMtSecVidSendCmd]Mt(%d,%d) byIsSendDStream(%d)!\n",
				tDstMt.GetMcuIdx(),tDstMt.GetMtId(),byIsSendDStream);
	if (m_tConf.GetConfSource() == VCS_CONF)
	{	
		//action abort when no chairman online
		TMt tChairMan = m_tConf.GetChairman();
		if( ( tChairMan.IsNull()  || 
			!m_tConfAllMtInfo.MtJoinedConf(tChairMan.GetMcuId(), tChairMan.GetMtId()) ) &&
			m_byCreateBy != CONF_CREATE_MT
			)
		{
			cServMsg.SetErrorCode(ERR_MCU_VCS_LOCMTOFFLINE);
			cServMsg.SetEventId(cServMsg.GetEventId() + 2);
			SendReplyBack(cServMsg, cServMsg.GetEventId());
			return;
		}
	}
	else
	{
		if (tDstMt.IsNull() || IsMcu(tDstMt) || !m_tConfAllMtInfo.MtJoinedConf(tDstMt) || 
				(CONF_DUALMODE_SPEAKERONLY == m_tConf.GetConfAttrb().GetDualMode() && 
					(
					 (IsMcu(m_tConf.GetSpeaker()) && !IsMtInMcu(m_tConf.GetSpeaker(),tDstMt)) || 
					 (!IsMcu(m_tConf.GetSpeaker()) && !(m_tConf.GetSpeaker() == tDstMt))
					)
				)
		   )
		{
			cServMsg.SetEventId(cServMsg.GetEventId() + 2);
			SendReplyBack(cServMsg, cServMsg.GetEventId());
			ConfPrint(LOG_LVL_WARNING, MID_MCU_MCS, "[ProcMcsMcuChangeMtSecVidSendCmd]IsMcu(%d) MtJoinedConf(%d) DualMode(%d) IsMcu(Speaker(%d)),So Return!\n",
				IsMcu(tDstMt),m_tConfAllMtInfo.MtJoinedConf(tDstMt),m_tConf.GetConfAttrb().GetDualMode(),IsMcu(m_tConf.GetSpeaker()));
			return;
		}
		if (tDstMt.IsLocal())
		{
			if (((m_tDoubleStreamSrc == tDstMt) && byIsSendDStream) || (!(m_tDoubleStreamSrc == tDstMt) && !byIsSendDStream))
			{
				cServMsg.SetEventId(cServMsg.GetEventId() + 2);
				SendReplyBack(cServMsg, cServMsg.GetEventId());
				ConfPrint(LOG_LVL_WARNING, MID_MCU_MCS, "[ProcMcsMcuChangeMtSecVidSendCmd]m_tDoubleStreamSrc(%d,%d),So Return!\n",
					m_tDoubleStreamSrc.GetMcuIdx(),m_tDoubleStreamSrc.GetMtId());
				return;
			}
		}
		else
		{
			TConfMcInfo *ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo( tDstMt.GetMcuIdx() );
			if(ptConfMcInfo == NULL)
			{
				cServMsg.SetEventId(cServMsg.GetEventId() + 2);
				SendReplyBack(cServMsg, cServMsg.GetEventId());
				ConfPrint(LOG_LVL_WARNING, MID_MCU_MCS, "[ProcMcsMcuChangeMtSecVidSendCmd]ptConfMcInfo == NULL,So Return!\n");
				return;
			}
			TMcMtStatus *ptMcMtStatus = ptConfMcInfo->GetMtStatus(tDstMt);
			if (ptMcMtStatus == NULL)
			{
				cServMsg.SetEventId(cServMsg.GetEventId() + 2);
				SendReplyBack(cServMsg, cServMsg.GetEventId());
				ConfPrint(LOG_LVL_WARNING, MID_MCU_MCS, "[ProcMcsMcuChangeMtSecVidSendCmd]ptMcMtStatus == NULL!\n");
				return;
			}
			if ((m_tDoubleStreamSrc.GetMtId() == GetLocalMtFromOtherMcuMt(tDstMt).GetMtId() && ptMcMtStatus->IsSndVideo2() && byIsSendDStream) ||
				(!ptMcMtStatus->IsSndVideo2() && !byIsSendDStream))
			{
				cServMsg.SetEventId(cServMsg.GetEventId() + 2);
				SendReplyBack(cServMsg, cServMsg.GetEventId());
				ConfPrint(LOG_LVL_WARNING, MID_MCU_MCS, "[ProcMcsMcuChangeMtSecVidSendCmd]m_tDoubleStreamSrc(%d,%d),So Return!\n",
					m_tDoubleStreamSrc.GetMcuIdx(),m_tDoubleStreamSrc.GetMtId());
				return;
			}
		}
	}

    CServMsg cMsg;
    cMsg.SetSrcSsnId(m_cVCSConfStatus.GetCurSrcSsnId());
    cMsg.SetConfIdx(m_byConfIdx);
    cMsg.SetConfId(m_tConf.GetConfId()) ;

    if (!tDstMt.IsLocal())
    {//非本地终端

        TMsgHeadMsg tHeadMsg;
        TMt tSMcu;
        tHeadMsg.m_tMsgDst = BuildMultiCascadeMtInfo(tDstMt, tSMcu);

        cMsg.SetEventId(MCU_MCU_CHANGEMTSECVIDSEND_CMD);
        cMsg.SetMsgBody((u8*)&tHeadMsg, sizeof(tHeadMsg));
        cMsg.CatMsgBody((u8*)&tSMcu, sizeof(TMt));
        cMsg.CatMsgBody((u8*)&byIsSendDStream, sizeof(u8));
        SendMsgToMt((u8)tSMcu.GetMcuId(), cMsg.GetEventId(), cMsg);
    }
    else
    {//本地终端

        if (!m_tConfAllMtInfo.MtJoinedConf( tDstMt.GetMtId()))
        {//终端未入会
            
            ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_VCS, 
                     "[ProcMcsMcuChangeMtSecVidSendCmd]MT:%d not joined conf !\n", tDstMt.GetMtId());
            return;
        }

        cMsg.SetEventId(MCU_MT_CHANGEMTSECVIDSEND_CMD);
        cMsg.SetMsgBody((u8*)&byIsSendDStream, sizeof(u8));
        BOOL32 bRet = SendMsgToMt(tDstMt.GetMtId(), cMsg.GetEventId(), cMsg);
        if (bRet != 1)
        {
            ConfPrint(LOG_LVL_ERROR, MID_MCU_MT, "MCU_MT_CHANGEMTSECVIDSEND_CMD send failed!\n");
        }
    }

    return;
}
/*====================================================================
    函数名      ：GetConfRealDsMt
    功能        ：获取全局双流源
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    07/31/2012             田志勇          创建
====================================================================*/
TMt CMcuVcInst::GetConfRealDsMt(void)
{
	TMt tRealDsMt;
	tRealDsMt = m_tDoubleStreamSrc;
	if(m_tDoubleStreamSrc.IsNull() || m_tDoubleStreamSrc == m_tCascadeMMCU)
	{
		return tRealDsMt;
	}

	if (IsMcu(m_tDoubleStreamSrc))
	{
		u16 wMcuIdx = GetMcuIdxFromMcuId(m_tDoubleStreamSrc.GetMtId());
		u8 abyMcuId[MAX_CASCADEDEPTH-1];
		memset( &abyMcuId[0],0,sizeof(abyMcuId) );
		if( !m_tConfAllMcuInfo.GetMcuIdByIdx( wMcuIdx,&abyMcuId[0] ) )
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetConfRealDsMt] Fail to GetMcuId (wMcuIdx.%d)!\n",wMcuIdx);
			return tRealDsMt;
		}
		TConfMcInfo *ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(wMcuIdx);
		if( NULL == ptConfMcInfo )
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetConfRealDsMt] Fail to GetMcInfo (wMcuIdx.%d)!\n",wMcuIdx);
			return tRealDsMt;
		}
		
		for (u8 byIdx = 0; byIdx < MAXNUM_CONF_MT; byIdx++)
		{
			if ( !ptConfMcInfo->m_atMtStatus[byIdx].IsNull() && 
				ptConfMcInfo->m_atMtStatus[byIdx].IsSndVideo2())
			{
				tRealDsMt = (TMt)(ptConfMcInfo->m_atMtStatus[byIdx]);
				if (ptConfMcInfo->m_atMtExt[byIdx].GetMtType() == MT_TYPE_MT)
				{
					break;
				} 
				else if(ptConfMcInfo->m_atMtExt[byIdx].GetMtType() == MT_TYPE_SMCU)
				{
					if( 0 == abyMcuId[1] )
					{
						abyMcuId[1] = ptConfMcInfo->m_atMtExt[byIdx].GetMtId();
						u16 wSMcuIdx = GetMcuIdxFromMcuId(&abyMcuId[0],2);
						if( INVALID_MCUIDX != wSMcuIdx )
						{
							TConfMcInfo *ptConfMcInfo1 = m_ptConfOtherMcTable->GetMcInfo(wSMcuIdx);
							if( NULL == ptConfMcInfo1 )
							{
								ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetConfRealDsMt] Fail to GetMcInfo (wMcuIdx.%d)!\n",wMcuIdx);
								return tRealDsMt;
							}
							for (u8 byIdx2 = 0; byIdx2 < MAXNUM_CONF_MT; byIdx2++)
							{
								if ( !ptConfMcInfo1->m_atMtStatus[byIdx2].IsNull() && 
									ptConfMcInfo1->m_atMtStatus[byIdx2].IsSndVideo2())
								{
									tRealDsMt = (TMt)(ptConfMcInfo1->m_atMtStatus[byIdx2]);
									return tRealDsMt;
								}
							}
						}
					}
				}
				else
				{
					ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[GetConfRealDsMt]MT(%d,%d) UNKNOWN MTTYPE(%d)!\n",
						tRealDsMt.GetMcuIdx(),tRealDsMt.GetMtId(),ptConfMcInfo->m_atMtExt[byIdx].GetMtType());
					break;
				}
			}
		}
	}
	return tRealDsMt;
}
/*====================================================================
    函数名      UpdateUploadMtMixingToMcs
    功能        ：更新上传通道中终端混音标志
				  //Bug00107418 单回传两级级联会议，在上级拖一下级的终
				  端到定制混音中，开始后通道内无终端IP显示,上级有混音器，
				  下级无混音器
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/09/2012             田志勇          创建
====================================================================*/
void CMcuVcInst::UpdateUploadMtMixingToMcs(TMt tLocalSmcuMt,CServMsg &cServMsg)
{
	if (!tLocalSmcuMt.IsLocal() || tLocalSmcuMt.IsNull() || !IsMcu(tLocalSmcuMt))
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[UpdateUploadMtMixingToMcs]tLocalSmcuMt(%d,%d) IsMcu(%d)!So Return!\n",
						tLocalSmcuMt.GetMcuIdx(),tLocalSmcuMt.GetMtId(),IsMcu(tLocalSmcuMt));
		return;
	}
	TMt tViewMt;
	TMtStatus tMtStatus;
	TConfMcInfo *ptMcInfo = NULL;
	TMcMtStatus *ptMcMtStatus = NULL;
	tViewMt = tLocalSmcuMt;
	BOOL32 bNeedSetMixing = FALSE;

	for ( ;!tViewMt.IsNull(); )
	{
		tViewMt = GetSMcuViewMt(tViewMt);
		if (!m_ptConfOtherMcTable->IsMtInMixing(tViewMt))
		{
			ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tViewMt.GetMcuId());
			if (ptMcInfo == NULL)
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[UpdateUploadMtMixingToMcs]ViewMt(%d,%d) ptMcInfo == NULL!So Return!\n",
						tViewMt.GetMcuIdx(),tViewMt.GetMtId());
				return;
			}
			ptMcMtStatus = ptMcInfo->GetMtStatus(tViewMt);
			if (ptMcMtStatus == NULL)
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[UpdateUploadMtMixingToMcs]ViewMt(%d,%d) ptMcMtStatus == NULL!So Return!\n",
						tViewMt.GetMcuIdx(),tViewMt.GetMtId());
				return;
			}
			tMtStatus = ptMcMtStatus->GetMtStatus();

			if (GetCurConfMixMtNum(tViewMt.GetMcuIdx()) == 0)
			{
				if(m_tConfAllMcuInfo.IsSMcuByMcuIdx(tViewMt.GetMcuIdx()))
				{
					if(m_ptMtTable->IsMtInMixing(tLocalSmcuMt.GetMtId()))
					{
						bNeedSetMixing = TRUE; //直属下级MCU无混音器，但直属下级MCU回传进上级混音
					}
				}
				else
				{
					TMt tTmpMt;
					TMt tMcuIdMt = GetMcuIdMtFromMcuIdxMt(tViewMt);
					u8 byMcuId = tMcuIdMt.GetMcuId();
					u16 wMcuIdx = GetMcuIdxFromMcuId( &byMcuId );
					tTmpMt.SetMcuIdx(wMcuIdx);
					tTmpMt.SetMtId(tMcuIdMt.GetMtId());
					if(m_ptConfOtherMcTable->IsMtInMixing(tTmpMt))
					{
						bNeedSetMixing = TRUE;//第三级MCU无混音器，但第三级MCU回传进第二级混音
					}
				}
			}

			if( bNeedSetMixing)
			{
				tMtStatus.SetInMixing(TRUE);
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[UpdateUploadMtMixingToMcs]tViewMt(%d,%d) SetMtInmixing!\n",
					tViewMt.GetMcuIdx(),tViewMt.GetMtId());
			}

			cServMsg.CatMsgBody( (u8*)&tMtStatus, sizeof( TMtStatus ) );
		}
	}
}
/*====================================================================
    函数名      IsNeedCheapMcsMtMixing
    功能        ：判断某个非本地终端是否需要欺骗MCS终端混音标志
				  //Bug00110105 MCU级联单回传,下级终端参与混音后挂断再上线状态显示错误
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/19/2012             田志勇          创建
====================================================================*/
BOOL32 CMcuVcInst::IsNeedCheapMcsMtMixing(TMt tUnLocalMt)
{
	if (tUnLocalMt.IsNull() || tUnLocalMt.IsLocal())
	{
		return FALSE;
	}
	TMt tTempMt =  GetLocalMtFromOtherMcuMt(tUnLocalMt);
	if (m_tConfAllMtInfo.MtJoinedConf( tUnLocalMt ) &&
		!m_ptConfOtherMcTable->IsMtInMixing(tUnLocalMt) &&
		m_ptMtTable->IsMtInMixing(tTempMt.GetMtId()))
	{
		tTempMt = GetSMcuViewMt(tTempMt);
		if (!tTempMt.IsNull())
		{
			if (tTempMt == tUnLocalMt)
			{
				if (GetCurConfMixMtNum(tTempMt.GetMcuIdx()) == 0)
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[IsNeedCheapMcsMtMixing]tTempMt(%d,%d) Need SetMtInmixing!\n",
						tTempMt.GetMcuIdx(),tTempMt.GetMtId());
					return TRUE;
				}
			} 
			else
			{
				if (IsMcu(tTempMt))
				{
					tTempMt = GetSMcuViewMt(tTempMt);
					if (tTempMt == tUnLocalMt)
					{
						if (GetCurConfMixMtNum(tTempMt.GetMcuIdx()) == 0)
						{
							ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[IsNeedCheapMcsMtMixing]tTempMt(%d,%d) Need SetMtInmixing!\n",
								tTempMt.GetMcuIdx(),tTempMt.GetMtId());
							return TRUE;
						}
					}
				}
			}
		}
	}
	return FALSE;
}

/*====================================================================
    函数名      ：IsPhoneMt
    功能        ：判断终端是不是电话端
    算法实现    ：用音频点数加外厂商属性判断，不支持下级终端
    引用全局变量：
    输入参数说明：
    返回值说明  ：TRUE / FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    12/13/2012           yanghuaizhi        创建
====================================================================*/
BOOL32 CMcuVcInst::IsPhoneMt(const TMt & tMt)
{
	// 空终端不做判断
	if (tMt.IsNull())
	{
		return FALSE;
	}

	// 判是否是下级电话终端
	if (!tMt.IsLocal())
	{
		TMtStatus tMtStatus;	
		if ( GetMtStatus( tMt,tMtStatus ) )
		{
			BOOL32 bLogicalChnlOpen = TRUE;
			if ( !tMtStatus.IsSendVideo() && tMtStatus.IsSendAudio()) //只有音频无视频，认为是电话终端
			{
				return TRUE;
			} 
		}
	}
	else if (m_ptMtTable->GetManuId( tMt.GetMtId() ) != MT_MANU_KDC && 
		m_ptMtTable->GetManuId( tMt.GetMtId() ) != MT_MANU_KDCMCU &&
		g_cMcuVcApp.IsOccupyAudAccessPoint(m_byConfIdx, tMt.GetMtId()))
	{
		return TRUE;
	}

	return FALSE;
}

/*====================================================================
    函数名      ：IsG400IPCMt
    功能        ：判断终端是不是IPC前端
    算法实现    ：用终端的IP去匹配eth0网卡的IP，如果相同则是，否则不是
				特别的，只针对linux有效
    引用全局变量：
    输入参数说明：
    返回值说明  ：TRUE / FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/31/2012              彭国锋          创建
====================================================================*/
BOOL32 CMcuVcInst::IsG400IPCMt(const TMt & tMt)
{
	if ( tMt.IsNull() || !tMt.IsLocal())
	{
		return FALSE;
	}
	LogPrint(LOG_LVL_DETAIL, MID_MCU_MT, "[IsG400IPCMt]Mt(%d) Manu(%d) ProductId(%s)\n",
			tMt.GetMtId(),m_ptMtTable->GetManuId(tMt.GetMtId()),m_ptMtTable->GetProductId(tMt.GetMtId()));

	if (m_ptMtTable->GetManuId(tMt.GetMtId()) == MT_MANU_KDC && strcmp(m_ptMtTable->GetProductId(tMt.GetMtId()), "KDC MCGATEWAY" )  == 0)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

/*====================================================================
    函数名      ：SetWaitMsConfData
    功能        ：设置是否等待主板发会议数据
    算法实现    ：				
    引用全局变量：
    输入参数说明：TRUE / FALSE 是否在等待
    返回值说明  ：void
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/20/2013    4.7.2          周晶晶        创建
====================================================================*/
void CMcuVcInst::SetWaitMsConfData( BOOL32 bIsWait )
{
	if( bIsWait )
	{
		m_byConfFlag |= 0x01;
	}
	else
	{
		m_byConfFlag &= 0xFE;
	}	
}

/*====================================================================
    函数名      ：IsWaitMsConfData
    功能        ：是否等待主板发会议数据
    算法实现    ：				
    引用全局变量：
    输入参数说明：
    返回值说明  ：TRUE / FALSE 是否在等待
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/20/2013    4.7.2          周晶晶        创建
====================================================================*/
BOOL32 CMcuVcInst::IsWaitMsConfData( void )
{
	return ( (m_byConfFlag & 0x01) == 1 );
}
	
/*====================================================================
    函数名      ：SetInOtherConf
    功能        ：设置简单级联会议时是否已经被其它会议呼入
    算法实现    ：				
    引用全局变量：
    输入参数说明：bIsInOtherConf 是否在等待，byOtherConfMtId对端在本端的mtid
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/20/2013    4.7.2          周晶晶        创建
====================================================================*/
void CMcuVcInst::SetInOtherConf( BOOL32 bIsInOtherConf,u8 byOtherConfMtId /* =0 */ )
{
	if( m_tConf.GetConfAttrb().IsSupportCascade() )
	{
		return;
	}
	
	if( bIsInOtherConf )
	{
		m_byOtherConfMtId = byOtherConfMtId;
		m_byConfFlag |= 0x02;
	}
	else
	{
		m_byOtherConfMtId = 0;
		m_byConfFlag &= 0xFD;
	}	
}

/*====================================================================
    函数名      ：IsInOtherConf
    功能        ：简单级联会议时是否已经被其它会议呼入
    算法实现    ：				
    引用全局变量：
    输入参数说明：
    返回值说明  ：TRUE / FALSE 是否已经被其它会议呼入
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/20/2013    4.7.2          周晶晶        创建
====================================================================*/
BOOL32 CMcuVcInst::IsInOtherConf( void )
{
	if( m_tConf.GetConfAttrb().IsSupportCascade() )
	{
		return FALSE;
	}
	return ( (m_byConfFlag & 0x02) != 0 );
}

/*====================================================================
    函数名      ：Starth460PinHoleNotify
    功能        ：通知转发板向外网终端打洞
    算法实现    ：				
    引用全局变量：
    输入参数说明：const u32 dwLocalAddr,本地IP
                  const u16 wLocalPort,本地端口
                  const u32 dwRemoteAddr,远端IP
                  const u16 wRemotePort,远端端口
                  const u8 byPinHoleType,打洞类型(RTP/RTCP)
                  const u8 byPayLoad,载荷
    返回值说明  ：void
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/09/2013  4.7.2     zhushengze        创建
====================================================================*/
void CMcuVcInst::Starth460PinHoleNotify( const u32 dwLocalAddr,
                                         const u16 wLocalPort,
                                         const u32 dwRemoteAddr,
                                         const u16 wRemotePort,
                                         const u8 byPinHoleType,
                                         const u8 byPayLoad)
{
    
    //根据IP地址查找交换MP编号
    u8 byMpId = g_cMcuVcApp.FindMp( dwLocalAddr );
    
    CServMsg cMsg;
    cMsg.SetConfIdx(m_byConfIdx);
    cMsg.SetDstDriId(byMpId);
    u32 dwLocalAddrIp = htonl(dwLocalAddr);
    cMsg.SetMsgBody((u8 *)&dwLocalAddrIp, sizeof(u32));
    cMsg.CatMsgBody((u8 *)&wLocalPort, sizeof(u16));
    u32 dwRemoteAddrIp = htonl(dwRemoteAddr);
    cMsg.CatMsgBody((u8 *)&dwRemoteAddrIp, sizeof(u32));
    cMsg.CatMsgBody((u8 *)&wRemotePort, sizeof(u16));
    cMsg.CatMsgBody((u8 *)&byPinHoleType, sizeof(u8));
    cMsg.CatMsgBody((u8 *)&byPayLoad, sizeof(u8));
    
    g_cMpSsnApp.SendMsgToMpSsn(byMpId, MCU_MP_PINHOLE_NOTIFY, (u8 *)&cMsg, cMsg.GetServMsgLen());
}

/*====================================================================
    函数名      ：StopH460PinHoleNotifyByMtId
    功能        ：通知转发板停止向终端打洞
    算法实现    ：				
    引用全局变量：
    输入参数说明：const u8 byMtId
    返回值说明  ：void
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/09/2013  4.7.2     zhushengze        创建
====================================================================*/
void CMcuVcInst::StopH460PinHoleNotifyByMtId( const u8 byMtId )
{

    H460StopHoleInfo tH460StopHoleInfo[32] = { 0 };
    u8 byIndex = 0;

    u16 wLocalPort = 0;
    u16 wRemotePort = 0;
    //如果打了洞要补洞
    if ( TRUE == m_ptMtTable->m_atMtData[byMtId - 1].m_bIsPinHole )
    {
        //音频前向rtcp补洞
        if ( m_ptMtTable->m_atMtData[byMtId - 1].m_tFwdChannel.m_tAudioChannel.IsOpened() )
        {
            tH460StopHoleInfo[byIndex].wLocalPort = m_ptMtTable->m_atMtData[byMtId - 1].m_tFwdChannel.m_tAudioChannel.m_tSndMediaCtrlChannel.GetPort();
            tH460StopHoleInfo[byIndex].dwRemoteIp = m_ptMtTable->m_atMtData[byMtId - 1].m_tFwdChannel.m_tAudioChannel.m_tRcvMediaCtrlChannel.m_dwIpAddr;
            tH460StopHoleInfo[byIndex].wRemotePort = m_ptMtTable->m_atMtData[byMtId - 1].m_tFwdChannel.m_tAudioChannel.m_tRcvMediaCtrlChannel.GetPort(); 
            byIndex++;

            LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_MT, "[StopH460PinHoleNotify]Del Audio forward rtcp hole LocPort:%d, Remote(0x%x:%d)\n",
                wLocalPort,
                m_ptMtTable->m_atMtData[byMtId - 1].m_tFwdChannel.m_tAudioChannel.m_tRcvMediaCtrlChannel.m_dwIpAddr,
                wRemotePort);                       
        }

        //音频后向rtcp、rtp补洞        
        if ( m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tAudioChannel.IsOpened() )
        {

            //rtcp
            tH460StopHoleInfo[byIndex].wLocalPort = m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tAudioChannel.m_tRcvMediaCtrlChannel.GetPort();
            tH460StopHoleInfo[byIndex].dwRemoteIp = m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tAudioChannel.m_tSndMediaCtrlChannel.m_dwIpAddr;
            tH460StopHoleInfo[byIndex].wRemotePort = m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tAudioChannel.m_tSndMediaCtrlChannel.GetPort(); 
            byIndex++;
            
            LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_MT, "[StopH460PinHoleNotify]Del Audio backward rtcp hole LocPort:%d, Remote(0x%x:%d)\n",
                wLocalPort,
                m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tAudioChannel.m_tSndMediaCtrlChannel.m_dwIpAddr,
                wRemotePort);   
            
            //rtp
            tH460StopHoleInfo[byIndex].wLocalPort = m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tAudioChannel.m_tRcvMediaChannel.GetPort();
            tH460StopHoleInfo[byIndex].dwRemoteIp = m_ptMtTable->m_atMtData[byMtId - 1].m_tAudRtpSndTransportAddr.m_dwIpAddr;
            tH460StopHoleInfo[byIndex].wRemotePort = m_ptMtTable->m_atMtData[byMtId - 1].m_tAudRtpSndTransportAddr.m_wPort; 
            byIndex++;

            LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_MT, "[StopH460PinHoleNotify]Del Audio backward rtp hole LocPort:%d, Remote(0x%x:%d)\n",
                m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tAudioChannel.m_tRcvMediaChannel.m_wPort,
                m_ptMtTable->m_atMtData[byMtId - 1].m_tAudRtpSndTransportAddr.m_dwIpAddr,
                m_ptMtTable->m_atMtData[byMtId - 1].m_tAudRtpSndTransportAddr.m_wPort); 
        }

        //视频前向rtcp补洞
        if ( m_ptMtTable->m_atMtData[byMtId - 1].m_tFwdChannel.m_tPrimaryVideoChannel.IsOpened() )
        {  
            tH460StopHoleInfo[byIndex].wLocalPort = m_ptMtTable->m_atMtData[byMtId - 1].m_tFwdChannel.m_tPrimaryVideoChannel.m_tSndMediaCtrlChannel.GetPort();
            tH460StopHoleInfo[byIndex].dwRemoteIp = m_ptMtTable->m_atMtData[byMtId - 1].m_tFwdChannel.m_tPrimaryVideoChannel.m_tRcvMediaCtrlChannel.m_dwIpAddr;
            tH460StopHoleInfo[byIndex].wRemotePort = m_ptMtTable->m_atMtData[byMtId - 1].m_tFwdChannel.m_tPrimaryVideoChannel.m_tRcvMediaCtrlChannel.GetPort(); 
            byIndex++;   
            
            LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_MT, "[StopH460PinHoleNotify]Del Video forward rtcp hole LocPort:%d, Remote(0x%x:%d)\n",
                wLocalPort,
                m_ptMtTable->m_atMtData[byMtId - 1].m_tFwdChannel.m_tPrimaryVideoChannel.m_tRcvMediaCtrlChannel.m_dwIpAddr,
                wRemotePort); 
        }
        
        //视频后向rtcp、rtp补洞        
        if ( m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tPrimaryVideoChannel.IsOpened() )
        {
            
            //rtcp
            tH460StopHoleInfo[byIndex].wLocalPort = m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tPrimaryVideoChannel.m_tRcvMediaCtrlChannel.GetPort();
            tH460StopHoleInfo[byIndex].dwRemoteIp = m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tPrimaryVideoChannel.m_tSndMediaCtrlChannel.m_dwIpAddr;
            tH460StopHoleInfo[byIndex].wRemotePort = m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tPrimaryVideoChannel.m_tSndMediaCtrlChannel.GetPort(); 
            byIndex++;
            
            LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_MT, "[StopH460PinHoleNotify]Del Video backward rtcp hole LocPort:%d, Remote(0x%x:%d)\n",
                wLocalPort,
                m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tPrimaryVideoChannel.m_tSndMediaCtrlChannel.m_dwIpAddr,
                wRemotePort);
            
            //rtp
            tH460StopHoleInfo[byIndex].wLocalPort = m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tPrimaryVideoChannel.m_tRcvMediaChannel.GetPort();
            tH460StopHoleInfo[byIndex].dwRemoteIp = m_ptMtTable->m_atMtData[byMtId - 1].m_tVidRtpSndTransportAddr.m_dwIpAddr;
            tH460StopHoleInfo[byIndex].wRemotePort = m_ptMtTable->m_atMtData[byMtId - 1].m_tVidRtpSndTransportAddr.m_wPort; 
            byIndex++;

            LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_MT, "[StopH460PinHoleNotify]Del Video backward rtp hole LocPort:%d, Remote(0x%x:%d)\n",
                wLocalPort,
                m_ptMtTable->m_atMtData[byMtId - 1].m_tVidRtpSndTransportAddr.m_dwIpAddr,
                m_ptMtTable->m_atMtData[byMtId - 1].m_tVidRtpSndTransportAddr.m_wPort);
        }

        //双流前向rtcp补洞
        if ( m_ptMtTable->m_atMtData[byMtId - 1].m_tFwdChannel.m_tSecondVideoChannel.IsOpened() )
        {  
            tH460StopHoleInfo[byIndex].wLocalPort = m_ptMtTable->m_atMtData[byMtId - 1].m_tFwdChannel.m_tSecondVideoChannel.m_tSndMediaCtrlChannel.GetPort();
            tH460StopHoleInfo[byIndex].dwRemoteIp = m_ptMtTable->m_atMtData[byMtId - 1].m_tFwdChannel.m_tSecondVideoChannel.m_tRcvMediaCtrlChannel.m_dwIpAddr;
            tH460StopHoleInfo[byIndex].wRemotePort = m_ptMtTable->m_atMtData[byMtId - 1].m_tFwdChannel.m_tSecondVideoChannel.m_tRcvMediaCtrlChannel.GetPort(); 
            byIndex++;

            LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_MT, "[StopH460PinHoleNotify]Del Sec forward rtp hole LocPort:%d, Remote(0x%x:%d)\n",
                wLocalPort,
                m_ptMtTable->m_atMtData[byMtId - 1].m_tFwdChannel.m_tSecondVideoChannel.m_tRcvMediaCtrlChannel.m_dwIpAddr,
                wRemotePort);
        }
        
        //双流后向rtcp、rtp补洞        
        if ( m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tSecondVideoChannel.IsOpened() )
        {
            
            //rtcp
            tH460StopHoleInfo[byIndex].wLocalPort = m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tSecondVideoChannel.m_tRcvMediaCtrlChannel.GetPort();
            tH460StopHoleInfo[byIndex].dwRemoteIp = m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tSecondVideoChannel.m_tSndMediaCtrlChannel.m_dwIpAddr;
            tH460StopHoleInfo[byIndex].wRemotePort = m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tSecondVideoChannel.m_tSndMediaCtrlChannel.GetPort(); 
            byIndex++;
 
            LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_MT, "[StopH460PinHoleNotify]Del Sec backward rtcp hole LocPort:%d, Remote(0x%x:%d)\n",
                wLocalPort,
                m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tSecondVideoChannel.m_tSndMediaCtrlChannel.m_dwIpAddr,
                wRemotePort);
            
            //rtp
            tH460StopHoleInfo[byIndex].wLocalPort = m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tSecondVideoChannel.m_tRcvMediaChannel.GetPort();
            tH460StopHoleInfo[byIndex].dwRemoteIp = m_ptMtTable->m_atMtData[byMtId - 1].m_tSecRtpSndTransportAddr.m_dwIpAddr;
            tH460StopHoleInfo[byIndex].wRemotePort = m_ptMtTable->m_atMtData[byMtId - 1].m_tSecRtpSndTransportAddr.m_wPort; 
            byIndex++;
 
            LogPrint( LOG_LVL_KEYSTATUS, MID_MCU_MT, "[StopH460PinHoleNotify]Del Sec backward rtp hole LocPort:%d, Remote(0x%x:%d)\n",
                m_ptMtTable->m_atMtData[byMtId - 1].m_tRvsChannel.m_tSecondVideoChannel.m_tRcvMediaChannel.m_wPort,
                m_ptMtTable->m_atMtData[byMtId - 1].m_tSecRtpSndTransportAddr.m_dwIpAddr,
                m_ptMtTable->m_atMtData[byMtId - 1].m_tSecRtpSndTransportAddr.m_wPort);
        }
        
        u8 byHoleNum = byIndex;
        if ( byIndex  > 0 )
        {
            //根据IP地址查找交换MP编号
            u8 byMpId = m_ptMtTable->GetMpId( byMtId );
            
            CServMsg cMsg;
            cMsg.SetConfIdx(m_byConfIdx);
            cMsg.SetDstDriId(byMpId);
            cMsg.SetMsgBody((u8 *)&byHoleNum, sizeof(u8));
            cMsg.CatMsgBody((u8 *)tH460StopHoleInfo, byIndex*sizeof(H460StopHoleInfo));
            g_cMpSsnApp.SendMsgToMpSsn(byMpId, MCU_MP_STOPPINHOLE_NOTIFY, (u8 *)&cMsg, cMsg.GetServMsgLen());
            LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT, "[StopH460PinHoleNotify]Del %d holes\n", byIndex);
        }

        m_ptMtTable->m_atMtData[byMtId - 1].m_bIsPinHole = FALSE;
    }
}

/*====================================================================
    函数名      ：StopH460PinHole
    功能        ：通知转发板停止外网地址打洞
    算法实现    ：				
    引用全局变量：
    输入参数说明：const u8 byMpId, 转发板ID
                  const u16 wLocalPort, 本地端口
                  const u32 dwRemoteAddr, 远端IP
                  const u16 wRemotePort, 远端端口
    返回值说明  ：void
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/09/2013  4.7.2     zhushengze        创建
====================================================================*/
void CMcuVcInst::StopH460PinHole( const u8 byMpId, 
                                  const u16 wLocalPort, 
                                  const u32 dwRemoteAddr,
                                  const u16 wRemotePort)
{


    CServMsg cMsg;
    cMsg.SetConfIdx(m_byConfIdx);
    cMsg.SetDstDriId(byMpId);
    u8 byHoleNum = 1;
    cMsg.SetMsgBody((u8 *)&byHoleNum, sizeof(u8));
    cMsg.CatMsgBody((u8 *)&wLocalPort, sizeof(wLocalPort));  
    u32 dwRemoteIp = htonl(dwRemoteAddr);
    cMsg.CatMsgBody((u8 *)&dwRemoteIp, sizeof(dwRemoteAddr)); 
    cMsg.CatMsgBody((u8 *)&wRemotePort, sizeof(wRemotePort));    
    g_cMpSsnApp.SendMsgToMpSsn(byMpId, MCU_MP_STOPPINHOLE_NOTIFY, (u8 *)&cMsg, cMsg.GetServMsgLen());

    LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_MT, "[StopH460PinHole]Del %d holes\n", byHoleNum);
}
//END FILE
